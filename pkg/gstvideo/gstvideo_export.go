// Code generated by girgen. DO NOT EDIT.

package gstvideo

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/go-gst/go-gst/pkg/gst"
	"github.com/go-gst/go-gst/pkg/gstbase"
)

// #include <stdlib.h>
// #include <gst/video/video.h>
import "C"

//export _gotk4_gstvideo1_VideoConvertSampleCallback
func _gotk4_gstvideo1_VideoConvertSampleCallback(arg1 *C.GstSample, arg2 *C.GError, arg3 C.gpointer) {
	var fn VideoConvertSampleCallback
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(VideoConvertSampleCallback)
	}

	var _sample *gst.Sample // out
	var _err error          // out

	_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_err = gerror.Take(unsafe.Pointer(arg2))

	fn(_sample, _err)
}

//export _gotk4_gstvideo1_ColorBalance_ConnectValueChanged
func _gotk4_gstvideo1_ColorBalance_ConnectValueChanged(arg0 C.gpointer, arg1 *C.GstColorBalanceChannel, arg2 C.gint, arg3 C.guintptr) {
	var f func(channel *ColorBalanceChannel, value int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(channel *ColorBalanceChannel, value int))
	}

	var _channel *ColorBalanceChannel // out
	var _value int                    // out

	_channel = wrapColorBalanceChannel(coreglib.Take(unsafe.Pointer(arg1)))
	_value = int(arg2)

	f(_channel, _value)
}

//export _gotk4_gstvideo1_ColorBalanceChannelClass_value_changed
func _gotk4_gstvideo1_ColorBalanceChannelClass_value_changed(arg0 *C.GstColorBalanceChannel, arg1 C.gint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ColorBalanceChannelOverrides](instance0)
	if overrides.ValueChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ColorBalanceChannelOverrides.ValueChanged, got none")
	}

	var _value int // out

	_value = int(arg1)

	overrides.ValueChanged(_value)
}

//export _gotk4_gstvideo1_ColorBalanceChannel_ConnectValueChanged
func _gotk4_gstvideo1_ColorBalanceChannel_ConnectValueChanged(arg0 C.gpointer, arg1 C.gint, arg2 C.guintptr) {
	var f func(value int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(value int))
	}

	var _value int // out

	_value = int(arg1)

	f(_value)
}

//export _gotk4_gstvideo1_VideoAggregatorClass_aggregate_frames
func _gotk4_gstvideo1_VideoAggregatorClass_aggregate_frames(arg0 *C.GstVideoAggregator, arg1 *C.GstBuffer) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoAggregatorOverrides](instance0)
	if overrides.AggregateFrames == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoAggregatorOverrides.AggregateFrames, got none")
	}

	var _outbuffer *gst.Buffer // out

	_outbuffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	flowReturn := overrides.AggregateFrames(_outbuffer)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstvideo1_VideoAggregatorClass_find_best_format
func _gotk4_gstvideo1_VideoAggregatorClass_find_best_format(arg0 *C.GstVideoAggregator, arg1 *C.GstCaps, arg2 *C.GstVideoInfo, arg3 *C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoAggregatorOverrides](instance0)
	if overrides.FindBestFormat == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoAggregatorOverrides.FindBestFormat, got none")
	}

	var _downstreamCaps *gst.Caps // out
	var _bestInfo *VideoInfo      // out

	_downstreamCaps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_bestInfo = (*VideoInfo)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	atLeastOneAlpha := overrides.FindBestFormat(_downstreamCaps, _bestInfo)

	var _ bool

	if atLeastOneAlpha {
		*arg3 = C.TRUE
	}
}

//export _gotk4_gstvideo1_VideoAggregatorClass_update_caps
func _gotk4_gstvideo1_VideoAggregatorClass_update_caps(arg0 *C.GstVideoAggregator, arg1 *C.GstCaps) (cret *C.GstCaps) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoAggregatorOverrides](instance0)
	if overrides.UpdateCaps == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoAggregatorOverrides.UpdateCaps, got none")
	}

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ret := overrides.UpdateCaps(_caps)

	var _ *gst.Caps

	cret = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(ret)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(ret)), nil)

	return cret
}

//export _gotk4_gstvideo1_VideoAggregatorConvertPadClass_create_conversion_info
func _gotk4_gstvideo1_VideoAggregatorConvertPadClass_create_conversion_info(arg0 *C.GstVideoAggregatorConvertPad, arg1 *C.GstVideoAggregator, arg2 *C.GstVideoInfo) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoAggregatorConvertPadOverrides](instance0)
	if overrides.CreateConversionInfo == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoAggregatorConvertPadOverrides.CreateConversionInfo, got none")
	}

	var _agg VideoAggregatorrer    // out
	var _conversionInfo *VideoInfo // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gstvideo.VideoAggregatorrer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(VideoAggregatorrer)
			return ok
		})
		rv, ok := casted.(VideoAggregatorrer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstvideo.VideoAggregatorrer")
		}
		_agg = rv
	}
	_conversionInfo = (*VideoInfo)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	overrides.CreateConversionInfo(_agg, _conversionInfo)
}

//export _gotk4_gstvideo1_VideoAggregatorPadClass_clean_frame
func _gotk4_gstvideo1_VideoAggregatorPadClass_clean_frame(arg0 *C.GstVideoAggregatorPad, arg1 *C.GstVideoAggregator, arg2 *C.GstVideoFrame) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoAggregatorPadOverrides](instance0)
	if overrides.CleanFrame == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoAggregatorPadOverrides.CleanFrame, got none")
	}

	var _videoaggregator VideoAggregatorrer // out
	var _preparedFrame *VideoFrame          // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gstvideo.VideoAggregatorrer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(VideoAggregatorrer)
			return ok
		})
		rv, ok := casted.(VideoAggregatorrer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstvideo.VideoAggregatorrer")
		}
		_videoaggregator = rv
	}
	_preparedFrame = (*VideoFrame)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	overrides.CleanFrame(_videoaggregator, _preparedFrame)
}

//export _gotk4_gstvideo1_VideoAggregatorPadClass_prepare_frame
func _gotk4_gstvideo1_VideoAggregatorPadClass_prepare_frame(arg0 *C.GstVideoAggregatorPad, arg1 *C.GstVideoAggregator, arg2 *C.GstBuffer, arg3 *C.GstVideoFrame) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoAggregatorPadOverrides](instance0)
	if overrides.PrepareFrame == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoAggregatorPadOverrides.PrepareFrame, got none")
	}

	var _videoaggregator VideoAggregatorrer // out
	var _buffer *gst.Buffer                 // out
	var _preparedFrame *VideoFrame          // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gstvideo.VideoAggregatorrer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(VideoAggregatorrer)
			return ok
		})
		rv, ok := casted.(VideoAggregatorrer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstvideo.VideoAggregatorrer")
		}
		_videoaggregator = rv
	}
	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_preparedFrame = (*VideoFrame)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	ok := overrides.PrepareFrame(_videoaggregator, _buffer, _preparedFrame)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoAggregatorPadClass_prepare_frame_finish
func _gotk4_gstvideo1_VideoAggregatorPadClass_prepare_frame_finish(arg0 *C.GstVideoAggregatorPad, arg1 *C.GstVideoAggregator, arg2 *C.GstVideoFrame) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoAggregatorPadOverrides](instance0)
	if overrides.PrepareFrameFinish == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoAggregatorPadOverrides.PrepareFrameFinish, got none")
	}

	var _videoaggregator VideoAggregatorrer // out
	var _preparedFrame *VideoFrame          // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gstvideo.VideoAggregatorrer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(VideoAggregatorrer)
			return ok
		})
		rv, ok := casted.(VideoAggregatorrer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstvideo.VideoAggregatorrer")
		}
		_videoaggregator = rv
	}
	_preparedFrame = (*VideoFrame)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	overrides.PrepareFrameFinish(_videoaggregator, _preparedFrame)
}

//export _gotk4_gstvideo1_VideoAggregatorPadClass_prepare_frame_start
func _gotk4_gstvideo1_VideoAggregatorPadClass_prepare_frame_start(arg0 *C.GstVideoAggregatorPad, arg1 *C.GstVideoAggregator, arg2 *C.GstBuffer, arg3 *C.GstVideoFrame) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoAggregatorPadOverrides](instance0)
	if overrides.PrepareFrameStart == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoAggregatorPadOverrides.PrepareFrameStart, got none")
	}

	var _videoaggregator VideoAggregatorrer // out
	var _buffer *gst.Buffer                 // out
	var _preparedFrame *VideoFrame          // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gstvideo.VideoAggregatorrer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(VideoAggregatorrer)
			return ok
		})
		rv, ok := casted.(VideoAggregatorrer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstvideo.VideoAggregatorrer")
		}
		_videoaggregator = rv
	}
	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_preparedFrame = (*VideoFrame)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	overrides.PrepareFrameStart(_videoaggregator, _buffer, _preparedFrame)
}

//export _gotk4_gstvideo1_VideoAggregatorPadClass_update_conversion_info
func _gotk4_gstvideo1_VideoAggregatorPadClass_update_conversion_info(arg0 *C.GstVideoAggregatorPad) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoAggregatorPadOverrides](instance0)
	if overrides.UpdateConversionInfo == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoAggregatorPadOverrides.UpdateConversionInfo, got none")
	}

	overrides.UpdateConversionInfo()
}

//export _gotk4_gstvideo1_VideoDecoderClass_close
func _gotk4_gstvideo1_VideoDecoderClass_close(arg0 *C.GstVideoDecoder) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoDecoderOverrides](instance0)
	if overrides.Close == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoDecoderOverrides.Close, got none")
	}

	ok := overrides.Close()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoDecoderClass_decide_allocation
func _gotk4_gstvideo1_VideoDecoderClass_decide_allocation(arg0 *C.GstVideoDecoder, arg1 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoDecoderOverrides](instance0)
	if overrides.DecideAllocation == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoDecoderOverrides.DecideAllocation, got none")
	}

	var _query *gst.Query // out

	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.DecideAllocation(_query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoDecoderClass_drain
func _gotk4_gstvideo1_VideoDecoderClass_drain(arg0 *C.GstVideoDecoder) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoDecoderOverrides](instance0)
	if overrides.Drain == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoDecoderOverrides.Drain, got none")
	}

	flowReturn := overrides.Drain()

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstvideo1_VideoDecoderClass_finish
func _gotk4_gstvideo1_VideoDecoderClass_finish(arg0 *C.GstVideoDecoder) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoDecoderOverrides](instance0)
	if overrides.Finish == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoDecoderOverrides.Finish, got none")
	}

	flowReturn := overrides.Finish()

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstvideo1_VideoDecoderClass_flush
func _gotk4_gstvideo1_VideoDecoderClass_flush(arg0 *C.GstVideoDecoder) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoDecoderOverrides](instance0)
	if overrides.Flush == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoDecoderOverrides.Flush, got none")
	}

	ok := overrides.Flush()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoDecoderClass_getcaps
func _gotk4_gstvideo1_VideoDecoderClass_getcaps(arg0 *C.GstVideoDecoder, arg1 *C.GstCaps) (cret *C.GstCaps) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoDecoderOverrides](instance0)
	if overrides.caps == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoDecoderOverrides.caps, got none")
	}

	var _filter *gst.Caps // out

	_filter = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	caps := overrides.caps(_filter)

	var _ *gst.Caps

	cret = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)

	return cret
}

//export _gotk4_gstvideo1_VideoDecoderClass_handle_frame
func _gotk4_gstvideo1_VideoDecoderClass_handle_frame(arg0 *C.GstVideoDecoder, arg1 *C.GstVideoCodecFrame) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoDecoderOverrides](instance0)
	if overrides.HandleFrame == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoDecoderOverrides.HandleFrame, got none")
	}

	var _frame *VideoCodecFrame // out

	_frame = (*VideoCodecFrame)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_frame)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_codec_frame_unref((*C.GstVideoCodecFrame)(intern.C))
		},
	)

	flowReturn := overrides.HandleFrame(_frame)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstvideo1_VideoDecoderClass_handle_missing_data
func _gotk4_gstvideo1_VideoDecoderClass_handle_missing_data(arg0 *C.GstVideoDecoder, arg1 C.GstClockTime, arg2 C.GstClockTime) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoDecoderOverrides](instance0)
	if overrides.HandleMissingData == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoDecoderOverrides.HandleMissingData, got none")
	}

	var _timestamp gst.ClockTime // out
	var _duration gst.ClockTime  // out

	_timestamp = gst.ClockTime(arg1)
	_duration = gst.ClockTime(arg2)

	ok := overrides.HandleMissingData(_timestamp, _duration)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoDecoderClass_negotiate
func _gotk4_gstvideo1_VideoDecoderClass_negotiate(arg0 *C.GstVideoDecoder) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoDecoderOverrides](instance0)
	if overrides.Negotiate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoDecoderOverrides.Negotiate, got none")
	}

	ok := overrides.Negotiate()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoDecoderClass_open
func _gotk4_gstvideo1_VideoDecoderClass_open(arg0 *C.GstVideoDecoder) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoDecoderOverrides](instance0)
	if overrides.Open == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoDecoderOverrides.Open, got none")
	}

	ok := overrides.Open()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoDecoderClass_parse
func _gotk4_gstvideo1_VideoDecoderClass_parse(arg0 *C.GstVideoDecoder, arg1 *C.GstVideoCodecFrame, arg2 *C.GstAdapter, arg3 C.gboolean) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoDecoderOverrides](instance0)
	if overrides.Parse == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoDecoderOverrides.Parse, got none")
	}

	var _frame *VideoCodecFrame   // out
	var _adapter *gstbase.Adapter // out
	var _atEos bool               // out

	_frame = (*VideoCodecFrame)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.gst_video_codec_frame_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_frame)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_codec_frame_unref((*C.GstVideoCodecFrame)(intern.C))
		},
	)
	{
		obj := coreglib.Take(unsafe.Pointer(arg2))
		_adapter = &gstbase.Adapter{
			Object: obj,
		}
	}
	if arg3 != 0 {
		_atEos = true
	}

	flowReturn := overrides.Parse(_frame, _adapter, _atEos)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstvideo1_VideoDecoderClass_propose_allocation
func _gotk4_gstvideo1_VideoDecoderClass_propose_allocation(arg0 *C.GstVideoDecoder, arg1 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoDecoderOverrides](instance0)
	if overrides.ProposeAllocation == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoDecoderOverrides.ProposeAllocation, got none")
	}

	var _query *gst.Query // out

	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.ProposeAllocation(_query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoDecoderClass_reset
func _gotk4_gstvideo1_VideoDecoderClass_reset(arg0 *C.GstVideoDecoder, arg1 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoDecoderOverrides](instance0)
	if overrides.Reset == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoDecoderOverrides.Reset, got none")
	}

	var _hard bool // out

	if arg1 != 0 {
		_hard = true
	}

	ok := overrides.Reset(_hard)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoDecoderClass_set_format
func _gotk4_gstvideo1_VideoDecoderClass_set_format(arg0 *C.GstVideoDecoder, arg1 *C.GstVideoCodecState) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoDecoderOverrides](instance0)
	if overrides.SetFormat == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoDecoderOverrides.SetFormat, got none")
	}

	var _state *VideoCodecState // out

	_state = (*VideoCodecState)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.gst_video_codec_state_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_state)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_codec_state_unref((*C.GstVideoCodecState)(intern.C))
		},
	)

	ok := overrides.SetFormat(_state)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoDecoderClass_sink_event
func _gotk4_gstvideo1_VideoDecoderClass_sink_event(arg0 *C.GstVideoDecoder, arg1 *C.GstEvent) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoDecoderOverrides](instance0)
	if overrides.SinkEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoDecoderOverrides.SinkEvent, got none")
	}

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SinkEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoDecoderClass_sink_query
func _gotk4_gstvideo1_VideoDecoderClass_sink_query(arg0 *C.GstVideoDecoder, arg1 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoDecoderOverrides](instance0)
	if overrides.SinkQuery == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoDecoderOverrides.SinkQuery, got none")
	}

	var _query *gst.Query // out

	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SinkQuery(_query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoDecoderClass_src_event
func _gotk4_gstvideo1_VideoDecoderClass_src_event(arg0 *C.GstVideoDecoder, arg1 *C.GstEvent) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoDecoderOverrides](instance0)
	if overrides.SrcEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoDecoderOverrides.SrcEvent, got none")
	}

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SrcEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoDecoderClass_src_query
func _gotk4_gstvideo1_VideoDecoderClass_src_query(arg0 *C.GstVideoDecoder, arg1 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoDecoderOverrides](instance0)
	if overrides.SrcQuery == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoDecoderOverrides.SrcQuery, got none")
	}

	var _query *gst.Query // out

	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SrcQuery(_query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoDecoderClass_start
func _gotk4_gstvideo1_VideoDecoderClass_start(arg0 *C.GstVideoDecoder) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoDecoderOverrides](instance0)
	if overrides.Start == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoDecoderOverrides.Start, got none")
	}

	ok := overrides.Start()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoDecoderClass_stop
func _gotk4_gstvideo1_VideoDecoderClass_stop(arg0 *C.GstVideoDecoder) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoDecoderOverrides](instance0)
	if overrides.Stop == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoDecoderOverrides.Stop, got none")
	}

	ok := overrides.Stop()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoDecoderClass_transform_meta
func _gotk4_gstvideo1_VideoDecoderClass_transform_meta(arg0 *C.GstVideoDecoder, arg1 *C.GstVideoCodecFrame, arg2 *C.GstMeta) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoDecoderOverrides](instance0)
	if overrides.TransformMeta == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoDecoderOverrides.TransformMeta, got none")
	}

	var _frame *VideoCodecFrame // out
	var _meta *gst.Meta         // out

	_frame = (*VideoCodecFrame)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.gst_video_codec_frame_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_frame)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_codec_frame_unref((*C.GstVideoCodecFrame)(intern.C))
		},
	)
	_meta = (*gst.Meta)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.TransformMeta(_frame, _meta)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoEncoderClass_close
func _gotk4_gstvideo1_VideoEncoderClass_close(arg0 *C.GstVideoEncoder) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoEncoderOverrides](instance0)
	if overrides.Close == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoEncoderOverrides.Close, got none")
	}

	ok := overrides.Close()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoEncoderClass_decide_allocation
func _gotk4_gstvideo1_VideoEncoderClass_decide_allocation(arg0 *C.GstVideoEncoder, arg1 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoEncoderOverrides](instance0)
	if overrides.DecideAllocation == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoEncoderOverrides.DecideAllocation, got none")
	}

	var _query *gst.Query // out

	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.DecideAllocation(_query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoEncoderClass_finish
func _gotk4_gstvideo1_VideoEncoderClass_finish(arg0 *C.GstVideoEncoder) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoEncoderOverrides](instance0)
	if overrides.Finish == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoEncoderOverrides.Finish, got none")
	}

	flowReturn := overrides.Finish()

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstvideo1_VideoEncoderClass_flush
func _gotk4_gstvideo1_VideoEncoderClass_flush(arg0 *C.GstVideoEncoder) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoEncoderOverrides](instance0)
	if overrides.Flush == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoEncoderOverrides.Flush, got none")
	}

	ok := overrides.Flush()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoEncoderClass_getcaps
func _gotk4_gstvideo1_VideoEncoderClass_getcaps(arg0 *C.GstVideoEncoder, arg1 *C.GstCaps) (cret *C.GstCaps) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoEncoderOverrides](instance0)
	if overrides.caps == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoEncoderOverrides.caps, got none")
	}

	var _filter *gst.Caps // out

	_filter = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	caps := overrides.caps(_filter)

	var _ *gst.Caps

	cret = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)

	return cret
}

//export _gotk4_gstvideo1_VideoEncoderClass_handle_frame
func _gotk4_gstvideo1_VideoEncoderClass_handle_frame(arg0 *C.GstVideoEncoder, arg1 *C.GstVideoCodecFrame) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoEncoderOverrides](instance0)
	if overrides.HandleFrame == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoEncoderOverrides.HandleFrame, got none")
	}

	var _frame *VideoCodecFrame // out

	_frame = (*VideoCodecFrame)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.gst_video_codec_frame_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_frame)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_codec_frame_unref((*C.GstVideoCodecFrame)(intern.C))
		},
	)

	flowReturn := overrides.HandleFrame(_frame)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstvideo1_VideoEncoderClass_negotiate
func _gotk4_gstvideo1_VideoEncoderClass_negotiate(arg0 *C.GstVideoEncoder) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoEncoderOverrides](instance0)
	if overrides.Negotiate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoEncoderOverrides.Negotiate, got none")
	}

	ok := overrides.Negotiate()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoEncoderClass_open
func _gotk4_gstvideo1_VideoEncoderClass_open(arg0 *C.GstVideoEncoder) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoEncoderOverrides](instance0)
	if overrides.Open == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoEncoderOverrides.Open, got none")
	}

	ok := overrides.Open()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoEncoderClass_pre_push
func _gotk4_gstvideo1_VideoEncoderClass_pre_push(arg0 *C.GstVideoEncoder, arg1 *C.GstVideoCodecFrame) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoEncoderOverrides](instance0)
	if overrides.PrePush == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoEncoderOverrides.PrePush, got none")
	}

	var _frame *VideoCodecFrame // out

	_frame = (*VideoCodecFrame)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.gst_video_codec_frame_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_frame)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_codec_frame_unref((*C.GstVideoCodecFrame)(intern.C))
		},
	)

	flowReturn := overrides.PrePush(_frame)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstvideo1_VideoEncoderClass_propose_allocation
func _gotk4_gstvideo1_VideoEncoderClass_propose_allocation(arg0 *C.GstVideoEncoder, arg1 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoEncoderOverrides](instance0)
	if overrides.ProposeAllocation == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoEncoderOverrides.ProposeAllocation, got none")
	}

	var _query *gst.Query // out

	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.ProposeAllocation(_query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoEncoderClass_reset
func _gotk4_gstvideo1_VideoEncoderClass_reset(arg0 *C.GstVideoEncoder, arg1 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoEncoderOverrides](instance0)
	if overrides.Reset == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoEncoderOverrides.Reset, got none")
	}

	var _hard bool // out

	if arg1 != 0 {
		_hard = true
	}

	ok := overrides.Reset(_hard)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoEncoderClass_set_format
func _gotk4_gstvideo1_VideoEncoderClass_set_format(arg0 *C.GstVideoEncoder, arg1 *C.GstVideoCodecState) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoEncoderOverrides](instance0)
	if overrides.SetFormat == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoEncoderOverrides.SetFormat, got none")
	}

	var _state *VideoCodecState // out

	_state = (*VideoCodecState)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.gst_video_codec_state_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_state)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_codec_state_unref((*C.GstVideoCodecState)(intern.C))
		},
	)

	ok := overrides.SetFormat(_state)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoEncoderClass_sink_event
func _gotk4_gstvideo1_VideoEncoderClass_sink_event(arg0 *C.GstVideoEncoder, arg1 *C.GstEvent) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoEncoderOverrides](instance0)
	if overrides.SinkEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoEncoderOverrides.SinkEvent, got none")
	}

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SinkEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoEncoderClass_sink_query
func _gotk4_gstvideo1_VideoEncoderClass_sink_query(arg0 *C.GstVideoEncoder, arg1 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoEncoderOverrides](instance0)
	if overrides.SinkQuery == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoEncoderOverrides.SinkQuery, got none")
	}

	var _query *gst.Query // out

	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SinkQuery(_query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoEncoderClass_src_event
func _gotk4_gstvideo1_VideoEncoderClass_src_event(arg0 *C.GstVideoEncoder, arg1 *C.GstEvent) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoEncoderOverrides](instance0)
	if overrides.SrcEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoEncoderOverrides.SrcEvent, got none")
	}

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SrcEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoEncoderClass_src_query
func _gotk4_gstvideo1_VideoEncoderClass_src_query(arg0 *C.GstVideoEncoder, arg1 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoEncoderOverrides](instance0)
	if overrides.SrcQuery == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoEncoderOverrides.SrcQuery, got none")
	}

	var _query *gst.Query // out

	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SrcQuery(_query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoEncoderClass_start
func _gotk4_gstvideo1_VideoEncoderClass_start(arg0 *C.GstVideoEncoder) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoEncoderOverrides](instance0)
	if overrides.Start == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoEncoderOverrides.Start, got none")
	}

	ok := overrides.Start()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoEncoderClass_stop
func _gotk4_gstvideo1_VideoEncoderClass_stop(arg0 *C.GstVideoEncoder) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoEncoderOverrides](instance0)
	if overrides.Stop == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoEncoderOverrides.Stop, got none")
	}

	ok := overrides.Stop()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoEncoderClass_transform_meta
func _gotk4_gstvideo1_VideoEncoderClass_transform_meta(arg0 *C.GstVideoEncoder, arg1 *C.GstVideoCodecFrame, arg2 *C.GstMeta) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoEncoderOverrides](instance0)
	if overrides.TransformMeta == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoEncoderOverrides.TransformMeta, got none")
	}

	var _frame *VideoCodecFrame // out
	var _meta *gst.Meta         // out

	_frame = (*VideoCodecFrame)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.gst_video_codec_frame_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_frame)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_video_codec_frame_unref((*C.GstVideoCodecFrame)(intern.C))
		},
	)
	_meta = (*gst.Meta)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.TransformMeta(_frame, _meta)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoFilterClass_set_info
func _gotk4_gstvideo1_VideoFilterClass_set_info(arg0 *C.GstVideoFilter, arg1 *C.GstCaps, arg2 *C.GstVideoInfo, arg3 *C.GstCaps, arg4 *C.GstVideoInfo) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoFilterOverrides](instance0)
	if overrides.SetInfo == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoFilterOverrides.SetInfo, got none")
	}

	var _incaps *gst.Caps   // out
	var _inInfo *VideoInfo  // out
	var _outcaps *gst.Caps  // out
	var _outInfo *VideoInfo // out

	_incaps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_inInfo = (*VideoInfo)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_outcaps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	_outInfo = (*VideoInfo)(gextras.NewStructNative(unsafe.Pointer(arg4)))

	ok := overrides.SetInfo(_incaps, _inInfo, _outcaps, _outInfo)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoFilterClass_transform_frame
func _gotk4_gstvideo1_VideoFilterClass_transform_frame(arg0 *C.GstVideoFilter, arg1 *C.GstVideoFrame, arg2 *C.GstVideoFrame) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoFilterOverrides](instance0)
	if overrides.TransformFrame == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoFilterOverrides.TransformFrame, got none")
	}

	var _inframe *VideoFrame  // out
	var _outframe *VideoFrame // out

	_inframe = (*VideoFrame)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_outframe = (*VideoFrame)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	flowReturn := overrides.TransformFrame(_inframe, _outframe)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstvideo1_VideoFilterClass_transform_frame_ip
func _gotk4_gstvideo1_VideoFilterClass_transform_frame_ip(arg0 *C.GstVideoFilter, arg1 *C.GstVideoFrame) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoFilterOverrides](instance0)
	if overrides.TransformFrameIP == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoFilterOverrides.TransformFrameIP, got none")
	}

	var _frame *VideoFrame // out

	_frame = (*VideoFrame)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	flowReturn := overrides.TransformFrameIP(_frame)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstvideo1_VideoSinkClass_set_info
func _gotk4_gstvideo1_VideoSinkClass_set_info(arg0 *C.GstVideoSink, arg1 *C.GstCaps, arg2 *C.GstVideoInfo) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoSinkOverrides](instance0)
	if overrides.SetInfo == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoSinkOverrides.SetInfo, got none")
	}

	var _caps *gst.Caps  // out
	var _info *VideoInfo // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_info = (*VideoInfo)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.SetInfo(_caps, _info)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstvideo1_VideoSinkClass_show_frame
func _gotk4_gstvideo1_VideoSinkClass_show_frame(arg0 *C.GstVideoSink, arg1 *C.GstBuffer) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[VideoSinkOverrides](instance0)
	if overrides.ShowFrame == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected VideoSinkOverrides.ShowFrame, got none")
	}

	var _buf *gst.Buffer // out

	_buf = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	flowReturn := overrides.ShowFrame(_buf)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}
