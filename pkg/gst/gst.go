// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"fmt"
	"runtime"
	_ "runtime/cgo"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gstreamer-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_gst1_TypeFindFunction(GstTypeFind*, gpointer);
// extern void _gotk4_gst1_TaskFunction(gpointer);
// extern void _gotk4_gst1_TagForEachFunc(GstTagList*, gchar*, gpointer);
// extern void _gotk4_gst1_Registry_ConnectPluginAdded(gpointer, GstPlugin*, guintptr);
// extern void _gotk4_gst1_Registry_ConnectFeatureAdded(gpointer, GstPluginFeature*, guintptr);
// extern void _gotk4_gst1_PromiseChangeFunc(GstPromise*, gpointer);
// extern void _gotk4_gst1_Pad_ConnectUnlinked(gpointer, GstPad*, guintptr);
// extern void _gotk4_gst1_Pad_ConnectLinked(gpointer, GstPad*, guintptr);
// extern void _gotk4_gst1_PadTemplate_ConnectPadCreated(gpointer, GstPad*, guintptr);
// extern void _gotk4_gst1_PadTemplateClass_pad_created(GstPadTemplate*, GstPad*);
// extern void _gotk4_gst1_PadClass_unlinked(GstPad*, GstPad*);
// extern void _gotk4_gst1_PadClass_linked(GstPad*, GstPad*);
// extern void _gotk4_gst1_IteratorForEachFunction(GValue*, gpointer);
// extern void _gotk4_gst1_Element_ConnectPadRemoved(gpointer, GstPad*, guintptr);
// extern void _gotk4_gst1_Element_ConnectPadAdded(gpointer, GstPad*, guintptr);
// extern void _gotk4_gst1_Element_ConnectNoMorePads(gpointer, guintptr);
// extern void _gotk4_gst1_ElementClass_state_changed(GstElement*, GstState, GstState, GstState);
// extern void _gotk4_gst1_ElementClass_set_context(GstElement*, GstContext*);
// extern void _gotk4_gst1_ElementClass_set_bus(GstElement*, GstBus*);
// extern void _gotk4_gst1_ElementClass_release_pad(GstElement*, GstPad*);
// extern void _gotk4_gst1_ElementClass_pad_removed(GstElement*, GstPad*);
// extern void _gotk4_gst1_ElementClass_pad_added(GstElement*, GstPad*);
// extern void _gotk4_gst1_ElementClass_no_more_pads(GstElement*);
// extern void _gotk4_gst1_ElementCallAsyncFunc(GstElement*, gpointer);
// extern void _gotk4_gst1_Device_ConnectRemoved(gpointer, guintptr);
// extern void _gotk4_gst1_DeviceProvider_ConnectProviderUnhidden(gpointer, gchar*, guintptr);
// extern void _gotk4_gst1_DeviceProvider_ConnectProviderHidden(gpointer, gchar*, guintptr);
// extern void _gotk4_gst1_DeviceProviderClass_stop(GstDeviceProvider*);
// extern void _gotk4_gst1_Clock_ConnectSynced(gpointer, gboolean, guintptr);
// extern void _gotk4_gst1_ClockClass_unschedule(GstClock*, GstClockEntry*);
// extern void _gotk4_gst1_ChildProxy_ConnectChildRemoved(gpointer, GObject*, gchar*, guintptr);
// extern void _gotk4_gst1_ChildProxy_ConnectChildAdded(gpointer, GObject*, gchar*, guintptr);
// extern void _gotk4_gst1_Bus_ConnectSyncMessage(gpointer, GstMessage*, guintptr);
// extern void _gotk4_gst1_Bus_ConnectMessage(gpointer, GstMessage*, guintptr);
// extern void _gotk4_gst1_BusClass_sync_message(GstBus*, GstMessage*);
// extern void _gotk4_gst1_BusClass_message(GstBus*, GstMessage*);
// extern void _gotk4_gst1_BufferPoolClass_reset_buffer(GstBufferPool*, GstBuffer*);
// extern void _gotk4_gst1_BufferPoolClass_release_buffer(GstBufferPool*, GstBuffer*);
// extern void _gotk4_gst1_BufferPoolClass_free_buffer(GstBufferPool*, GstBuffer*);
// extern void _gotk4_gst1_BufferPoolClass_flush_stop(GstBufferPool*);
// extern void _gotk4_gst1_BufferPoolClass_flush_start(GstBufferPool*);
// extern void _gotk4_gst1_Bin_ConnectElementRemoved(gpointer, GstElement*, guintptr);
// extern void _gotk4_gst1_Bin_ConnectElementAdded(gpointer, GstElement*, guintptr);
// extern void _gotk4_gst1_Bin_ConnectDeepElementRemoved(gpointer, GstBin*, GstElement*, guintptr);
// extern void _gotk4_gst1_Bin_ConnectDeepElementAdded(gpointer, GstBin*, GstElement*, guintptr);
// extern void _gotk4_gst1_BinClass_handle_message(GstBin*, GstMessage*);
// extern void _gotk4_gst1_BinClass_element_removed(GstBin*, GstElement*);
// extern void _gotk4_gst1_BinClass_element_added(GstBin*, GstElement*);
// extern void _gotk4_gst1_BinClass_deep_element_removed(GstBin*, GstBin*, GstElement*);
// extern void _gotk4_gst1_BinClass_deep_element_added(GstBin*, GstBin*, GstElement*);
// extern gint _gotk4_gst1_CompareDataFunc(gconstpointer, gconstpointer, gpointer);
// extern gint _gotk4_glib2_CompareDataFunc(gconstpointer, gconstpointer, gpointer);
// extern gchar** _gotk4_gst1_BufferPoolClass_get_options(GstBufferPool*);
// extern gboolean _gotk4_gst1_StructureMapFunc(GQuark, GValue*, gpointer);
// extern gboolean _gotk4_gst1_StructureForEachFunc(GQuark, GValue*, gpointer);
// extern gboolean _gotk4_gst1_StructureFilterMapFunc(GQuark, GValue*, gpointer);
// extern gboolean _gotk4_gst1_PluginInitFullFunc(GstPlugin*, gpointer);
// extern gboolean _gotk4_gst1_PluginFilter(GstPlugin*, gpointer);
// extern gboolean _gotk4_gst1_PluginFeatureFilter(GstPluginFeature*, gpointer);
// extern gboolean _gotk4_gst1_PadStickyEventsForEachFunction(GstPad*, GstEvent**, gpointer);
// extern gboolean _gotk4_gst1_PadForwardFunction(GstPad*, gpointer);
// extern gboolean _gotk4_gst1_IteratorFoldFunction(GValue*, GValue*, gpointer);
// extern gboolean _gotk4_gst1_ElementForEachPadFunc(GstElement*, GstPad*, gpointer);
// extern gboolean _gotk4_gst1_ElementClass_set_clock(GstElement*, GstClock*);
// extern gboolean _gotk4_gst1_ElementClass_send_event(GstElement*, GstEvent*);
// extern gboolean _gotk4_gst1_ElementClass_query(GstElement*, GstQuery*);
// extern gboolean _gotk4_gst1_ElementClass_post_message(GstElement*, GstMessage*);
// extern gboolean _gotk4_gst1_DeviceProviderClass_start(GstDeviceProvider*);
// extern gboolean _gotk4_gst1_DeviceClass_reconfigure_element(GstDevice*, GstElement*);
// extern gboolean _gotk4_gst1_CustomMetaTransformFunction(GstBuffer*, GstCustomMeta*, GstBuffer*, GQuark, gpointer, gpointer);
// extern gboolean _gotk4_gst1_ControlBindingClass_sync_values(GstControlBinding*, GstObject*, GstClockTime, GstClockTime);
// extern gboolean _gotk4_gst1_ControlBindingClass_get_g_value_array(GstControlBinding*, GstClockTime, GstClockTime, guint, GValue*);
// extern gboolean _gotk4_gst1_ClockCallback(GstClock*, GstClockTime, GstClockID, gpointer);
// extern gboolean _gotk4_gst1_CapsMapFunc(GstCapsFeatures*, GstStructure*, gpointer);
// extern gboolean _gotk4_gst1_CapsForEachFunc(GstCapsFeatures*, GstStructure*, gpointer);
// extern gboolean _gotk4_gst1_CapsFilterMapFunc(GstCapsFeatures*, GstStructure*, gpointer);
// extern gboolean _gotk4_gst1_BusFunc(GstBus*, GstMessage*, gpointer);
// extern gboolean _gotk4_gst1_BufferPoolClass_stop(GstBufferPool*);
// extern gboolean _gotk4_gst1_BufferPoolClass_start(GstBufferPool*);
// extern gboolean _gotk4_gst1_BufferPoolClass_set_config(GstBufferPool*, GstStructure*);
// extern gboolean _gotk4_gst1_BufferListFunc(GstBuffer**, guint, gpointer);
// extern gboolean _gotk4_gst1_BufferForEachMetaFunc(GstBuffer*, GstMeta**, gpointer);
// extern gboolean _gotk4_gst1_Bin_ConnectDoLatency(gpointer, guintptr);
// extern gboolean _gotk4_gst1_BinClass_remove_element(GstBin*, GstElement*);
// extern gboolean _gotk4_gst1_BinClass_do_latency(GstBin*);
// extern gboolean _gotk4_gst1_BinClass_add_element(GstBin*, GstElement*);
// extern GstStateChangeReturn _gotk4_gst1_ElementClass_set_state(GstElement*, GstState);
// extern GstStateChangeReturn _gotk4_gst1_ElementClass_get_state(GstElement*, GstState*, GstState*, GstClockTime);
// extern GstStateChangeReturn _gotk4_gst1_ElementClass_change_state(GstElement*, GstStateChange);
// extern GstPadProbeReturn _gotk4_gst1_PadProbeCallback(GstPad*, GstPadProbeInfo*, gpointer);
// extern GstMemory* _gotk4_gst1_AllocatorClass_alloc(GstAllocator*, gsize, GstAllocationParams*);
// extern GstFlowReturn _gotk4_gst1_BufferPoolClass_alloc_buffer(GstBufferPool*, GstBuffer**, GstBufferPoolAcquireParams*);
// extern GstFlowReturn _gotk4_gst1_BufferPoolClass_acquire_buffer(GstBufferPool*, GstBuffer**, GstBufferPoolAcquireParams*);
// extern GstElement* _gotk4_gst1_DeviceClass_create_element(GstDevice*, gchar*);
// extern GstClockTime _gotk4_gst1_ClockClass_get_resolution(GstClock*);
// extern GstClockTime _gotk4_gst1_ClockClass_get_internal_time(GstClock*);
// extern GstClockTime _gotk4_gst1_ClockClass_change_resolution(GstClock*, GstClockTime, GstClockTime);
// extern GstClockReturn _gotk4_gst1_ClockClass_wait_async(GstClock*, GstClockEntry*);
// extern GstClockReturn _gotk4_gst1_ClockClass_wait(GstClock*, GstClockEntry*, GstClockTimeDiff*);
// extern GstClock* _gotk4_gst1_ElementClass_provide_clock(GstElement*);
// extern GstBusSyncReply _gotk4_gst1_BusSyncHandler(GstBus*, GstMessage*, gpointer);
// extern GValue* _gotk4_gst1_ControlBindingClass_get_value(GstControlBinding*, GstClockTime);
// GObject* _gotk4_gst1_ChildProxy_virtual_get_child_by_index(void* fnptr, GstChildProxy* arg0, guint arg1) {
//   return ((GObject* (*)(GstChildProxy*, guint))(fnptr))(arg0, arg1);
// };
// GObject* _gotk4_gst1_ChildProxy_virtual_get_child_by_name(void* fnptr, GstChildProxy* arg0, gchar* arg1) {
//   return ((GObject* (*)(GstChildProxy*, gchar*))(fnptr))(arg0, arg1);
// };
// GValue* _gotk4_gst1_ControlBinding_virtual_get_value(void* fnptr, GstControlBinding* arg0, GstClockTime arg1) {
//   return ((GValue* (*)(GstControlBinding*, GstClockTime))(fnptr))(arg0, arg1);
// };
// GstClock* _gotk4_gst1_Element_virtual_provide_clock(void* fnptr, GstElement* arg0) {
//   return ((GstClock* (*)(GstElement*))(fnptr))(arg0);
// };
// GstClockReturn _gotk4_gst1_Clock_virtual_wait(void* fnptr, GstClock* arg0, GstClockEntry* arg1, GstClockTimeDiff* arg2) {
//   return ((GstClockReturn (*)(GstClock*, GstClockEntry*, GstClockTimeDiff*))(fnptr))(arg0, arg1, arg2);
// };
// GstClockReturn _gotk4_gst1_Clock_virtual_wait_async(void* fnptr, GstClock* arg0, GstClockEntry* arg1) {
//   return ((GstClockReturn (*)(GstClock*, GstClockEntry*))(fnptr))(arg0, arg1);
// };
// GstClockTime _gotk4_gst1_Clock_virtual_change_resolution(void* fnptr, GstClock* arg0, GstClockTime arg1, GstClockTime arg2) {
//   return ((GstClockTime (*)(GstClock*, GstClockTime, GstClockTime))(fnptr))(arg0, arg1, arg2);
// };
// GstClockTime _gotk4_gst1_Clock_virtual_get_internal_time(void* fnptr, GstClock* arg0) {
//   return ((GstClockTime (*)(GstClock*))(fnptr))(arg0);
// };
// GstClockTime _gotk4_gst1_Clock_virtual_get_resolution(void* fnptr, GstClock* arg0) {
//   return ((GstClockTime (*)(GstClock*))(fnptr))(arg0);
// };
// GstElement* _gotk4_gst1_Device_virtual_create_element(void* fnptr, GstDevice* arg0, gchar* arg1) {
//   return ((GstElement* (*)(GstDevice*, gchar*))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gst1_BufferPool_virtual_acquire_buffer(void* fnptr, GstBufferPool* arg0, GstBuffer** arg1, GstBufferPoolAcquireParams* arg2) {
//   return ((GstFlowReturn (*)(GstBufferPool*, GstBuffer**, GstBufferPoolAcquireParams*))(fnptr))(arg0, arg1, arg2);
// };
// GstFlowReturn _gotk4_gst1_BufferPool_virtual_alloc_buffer(void* fnptr, GstBufferPool* arg0, GstBuffer** arg1, GstBufferPoolAcquireParams* arg2) {
//   return ((GstFlowReturn (*)(GstBufferPool*, GstBuffer**, GstBufferPoolAcquireParams*))(fnptr))(arg0, arg1, arg2);
// };
// GstMemory* _gotk4_gst1_Allocator_virtual_alloc(void* fnptr, GstAllocator* arg0, gsize arg1, GstAllocationParams* arg2) {
//   return ((GstMemory* (*)(GstAllocator*, gsize, GstAllocationParams*))(fnptr))(arg0, arg1, arg2);
// };
// GstPad* _gotk4_gst1_Element_virtual_request_new_pad(void* fnptr, GstElement* arg0, GstPadTemplate* arg1, gchar* arg2, GstCaps* arg3) {
//   return ((GstPad* (*)(GstElement*, GstPadTemplate*, gchar*, GstCaps*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GstStateChangeReturn _gotk4_gst1_Element_virtual_change_state(void* fnptr, GstElement* arg0, GstStateChange arg1) {
//   return ((GstStateChangeReturn (*)(GstElement*, GstStateChange))(fnptr))(arg0, arg1);
// };
// GstStateChangeReturn _gotk4_gst1_Element_virtual_get_state(void* fnptr, GstElement* arg0, GstState* arg1, GstState* arg2, GstClockTime arg3) {
//   return ((GstStateChangeReturn (*)(GstElement*, GstState*, GstState*, GstClockTime))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GstStateChangeReturn _gotk4_gst1_Element_virtual_set_state(void* fnptr, GstElement* arg0, GstState arg1) {
//   return ((GstStateChangeReturn (*)(GstElement*, GstState))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gst1_Bin_virtual_add_element(void* fnptr, GstBin* arg0, GstElement* arg1) {
//   return ((gboolean (*)(GstBin*, GstElement*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gst1_Bin_virtual_do_latency(void* fnptr, GstBin* arg0) {
//   return ((gboolean (*)(GstBin*))(fnptr))(arg0);
// };
// gboolean _gotk4_gst1_Bin_virtual_remove_element(void* fnptr, GstBin* arg0, GstElement* arg1) {
//   return ((gboolean (*)(GstBin*, GstElement*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gst1_BufferPool_virtual_set_config(void* fnptr, GstBufferPool* arg0, GstStructure* arg1) {
//   return ((gboolean (*)(GstBufferPool*, GstStructure*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gst1_BufferPool_virtual_start(void* fnptr, GstBufferPool* arg0) {
//   return ((gboolean (*)(GstBufferPool*))(fnptr))(arg0);
// };
// gboolean _gotk4_gst1_BufferPool_virtual_stop(void* fnptr, GstBufferPool* arg0) {
//   return ((gboolean (*)(GstBufferPool*))(fnptr))(arg0);
// };
// gboolean _gotk4_gst1_ControlBinding_virtual_get_g_value_array(void* fnptr, GstControlBinding* arg0, GstClockTime arg1, GstClockTime arg2, guint arg3, GValue* arg4) {
//   return ((gboolean (*)(GstControlBinding*, GstClockTime, GstClockTime, guint, GValue*))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// gboolean _gotk4_gst1_ControlBinding_virtual_sync_values(void* fnptr, GstControlBinding* arg0, GstObject* arg1, GstClockTime arg2, GstClockTime arg3) {
//   return ((gboolean (*)(GstControlBinding*, GstObject*, GstClockTime, GstClockTime))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gst1_DeviceProvider_virtual_start(void* fnptr, GstDeviceProvider* arg0) {
//   return ((gboolean (*)(GstDeviceProvider*))(fnptr))(arg0);
// };
// gboolean _gotk4_gst1_Device_virtual_reconfigure_element(void* fnptr, GstDevice* arg0, GstElement* arg1) {
//   return ((gboolean (*)(GstDevice*, GstElement*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gst1_Element_virtual_post_message(void* fnptr, GstElement* arg0, GstMessage* arg1) {
//   return ((gboolean (*)(GstElement*, GstMessage*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gst1_Element_virtual_query(void* fnptr, GstElement* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstElement*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gst1_Element_virtual_send_event(void* fnptr, GstElement* arg0, GstEvent* arg1) {
//   return ((gboolean (*)(GstElement*, GstEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gst1_Element_virtual_set_clock(void* fnptr, GstElement* arg0, GstClock* arg1) {
//   return ((gboolean (*)(GstElement*, GstClock*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gst1_Preset_virtual_delete_preset(void* fnptr, GstPreset* arg0, gchar* arg1) {
//   return ((gboolean (*)(GstPreset*, gchar*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gst1_Preset_virtual_get_meta(void* fnptr, GstPreset* arg0, gchar* arg1, gchar* arg2, gchar** arg3) {
//   return ((gboolean (*)(GstPreset*, gchar*, gchar*, gchar**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gst1_Preset_virtual_load_preset(void* fnptr, GstPreset* arg0, gchar* arg1) {
//   return ((gboolean (*)(GstPreset*, gchar*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gst1_Preset_virtual_rename_preset(void* fnptr, GstPreset* arg0, gchar* arg1, gchar* arg2) {
//   return ((gboolean (*)(GstPreset*, gchar*, gchar*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gst1_Preset_virtual_save_preset(void* fnptr, GstPreset* arg0, gchar* arg1) {
//   return ((gboolean (*)(GstPreset*, gchar*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gst1_Preset_virtual_set_meta(void* fnptr, GstPreset* arg0, gchar* arg1, gchar* arg2, gchar* arg3) {
//   return ((gboolean (*)(GstPreset*, gchar*, gchar*, gchar*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gst1_URIHandler_virtual_set_uri(void* fnptr, GstURIHandler* arg0, gchar* arg1, GError** arg2) {
//   return ((gboolean (*)(GstURIHandler*, gchar*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gchar* _gotk4_gst1_URIHandler_virtual_get_uri(void* fnptr, GstURIHandler* arg0) {
//   return ((gchar* (*)(GstURIHandler*))(fnptr))(arg0);
// };
// gchar** _gotk4_gst1_BufferPool_virtual_get_options(void* fnptr, GstBufferPool* arg0) {
//   return ((gchar** (*)(GstBufferPool*))(fnptr))(arg0);
// };
// gchar** _gotk4_gst1_Preset_virtual_get_preset_names(void* fnptr, GstPreset* arg0) {
//   return ((gchar** (*)(GstPreset*))(fnptr))(arg0);
// };
// gchar** _gotk4_gst1_Preset_virtual_get_property_names(void* fnptr, GstPreset* arg0) {
//   return ((gchar** (*)(GstPreset*))(fnptr))(arg0);
// };
// guint _gotk4_gst1_ChildProxy_virtual_get_children_count(void* fnptr, GstChildProxy* arg0) {
//   return ((guint (*)(GstChildProxy*))(fnptr))(arg0);
// };
// void _gotk4_gst1_Bin_virtual_deep_element_added(void* fnptr, GstBin* arg0, GstBin* arg1, GstElement* arg2) {
//   ((void (*)(GstBin*, GstBin*, GstElement*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gst1_Bin_virtual_deep_element_removed(void* fnptr, GstBin* arg0, GstBin* arg1, GstElement* arg2) {
//   ((void (*)(GstBin*, GstBin*, GstElement*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gst1_Bin_virtual_element_added(void* fnptr, GstBin* arg0, GstElement* arg1) {
//   ((void (*)(GstBin*, GstElement*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_Bin_virtual_element_removed(void* fnptr, GstBin* arg0, GstElement* arg1) {
//   ((void (*)(GstBin*, GstElement*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_Bin_virtual_handle_message(void* fnptr, GstBin* arg0, GstMessage* arg1) {
//   ((void (*)(GstBin*, GstMessage*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_BufferPool_virtual_flush_start(void* fnptr, GstBufferPool* arg0) {
//   ((void (*)(GstBufferPool*))(fnptr))(arg0);
// };
// void _gotk4_gst1_BufferPool_virtual_flush_stop(void* fnptr, GstBufferPool* arg0) {
//   ((void (*)(GstBufferPool*))(fnptr))(arg0);
// };
// void _gotk4_gst1_BufferPool_virtual_free_buffer(void* fnptr, GstBufferPool* arg0, GstBuffer* arg1) {
//   ((void (*)(GstBufferPool*, GstBuffer*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_BufferPool_virtual_release_buffer(void* fnptr, GstBufferPool* arg0, GstBuffer* arg1) {
//   ((void (*)(GstBufferPool*, GstBuffer*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_BufferPool_virtual_reset_buffer(void* fnptr, GstBufferPool* arg0, GstBuffer* arg1) {
//   ((void (*)(GstBufferPool*, GstBuffer*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_Bus_virtual_message(void* fnptr, GstBus* arg0, GstMessage* arg1) {
//   ((void (*)(GstBus*, GstMessage*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_Bus_virtual_sync_message(void* fnptr, GstBus* arg0, GstMessage* arg1) {
//   ((void (*)(GstBus*, GstMessage*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_ChildProxy_virtual_child_added(void* fnptr, GstChildProxy* arg0, GObject* arg1, gchar* arg2) {
//   ((void (*)(GstChildProxy*, GObject*, gchar*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gst1_ChildProxy_virtual_child_removed(void* fnptr, GstChildProxy* arg0, GObject* arg1, gchar* arg2) {
//   ((void (*)(GstChildProxy*, GObject*, gchar*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gst1_Clock_virtual_unschedule(void* fnptr, GstClock* arg0, GstClockEntry* arg1) {
//   ((void (*)(GstClock*, GstClockEntry*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_DeviceProvider_virtual_stop(void* fnptr, GstDeviceProvider* arg0) {
//   ((void (*)(GstDeviceProvider*))(fnptr))(arg0);
// };
// void _gotk4_gst1_Element_virtual_no_more_pads(void* fnptr, GstElement* arg0) {
//   ((void (*)(GstElement*))(fnptr))(arg0);
// };
// void _gotk4_gst1_Element_virtual_pad_added(void* fnptr, GstElement* arg0, GstPad* arg1) {
//   ((void (*)(GstElement*, GstPad*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_Element_virtual_pad_removed(void* fnptr, GstElement* arg0, GstPad* arg1) {
//   ((void (*)(GstElement*, GstPad*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_Element_virtual_release_pad(void* fnptr, GstElement* arg0, GstPad* arg1) {
//   ((void (*)(GstElement*, GstPad*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_Element_virtual_set_bus(void* fnptr, GstElement* arg0, GstBus* arg1) {
//   ((void (*)(GstElement*, GstBus*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_Element_virtual_set_context(void* fnptr, GstElement* arg0, GstContext* arg1) {
//   ((void (*)(GstElement*, GstContext*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_Element_virtual_state_changed(void* fnptr, GstElement* arg0, GstState arg1, GstState arg2, GstState arg3) {
//   ((void (*)(GstElement*, GstState, GstState, GstState))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gst1_PadTemplate_virtual_pad_created(void* fnptr, GstPadTemplate* arg0, GstPad* arg1) {
//   ((void (*)(GstPadTemplate*, GstPad*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_Pad_virtual_linked(void* fnptr, GstPad* arg0, GstPad* arg1) {
//   ((void (*)(GstPad*, GstPad*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gst1_Pad_virtual_unlinked(void* fnptr, GstPad* arg0, GstPad* arg1) {
//   ((void (*)(GstPad*, GstPad*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeBufferingMode          = coreglib.Type(C.gst_buffering_mode_get_type())
	GTypeBusSyncReply           = coreglib.Type(C.gst_bus_sync_reply_get_type())
	GTypeCapsIntersectMode      = coreglib.Type(C.gst_caps_intersect_mode_get_type())
	GTypeClockEntryType         = coreglib.Type(C.gst_clock_entry_type_get_type())
	GTypeClockReturn            = coreglib.Type(C.gst_clock_return_get_type())
	GTypeClockType              = coreglib.Type(C.gst_clock_type_get_type())
	GTypeCoreError              = coreglib.Type(C.gst_core_error_get_type())
	GTypeDebugColorMode         = coreglib.Type(C.gst_debug_color_mode_get_type())
	GTypeDebugLevel             = coreglib.Type(C.gst_debug_level_get_type())
	GTypeEventType              = coreglib.Type(C.gst_event_type_get_type())
	GTypeFlowReturn             = coreglib.Type(C.gst_flow_return_get_type())
	GTypeFormat                 = coreglib.Type(C.gst_format_get_type())
	GTypeIteratorItem           = coreglib.Type(C.gst_iterator_item_get_type())
	GTypeIteratorResult         = coreglib.Type(C.gst_iterator_result_get_type())
	GTypeLibraryError           = coreglib.Type(C.gst_library_error_get_type())
	GTypePadDirection           = coreglib.Type(C.gst_pad_direction_get_type())
	GTypePadLinkReturn          = coreglib.Type(C.gst_pad_link_return_get_type())
	GTypePadMode                = coreglib.Type(C.gst_pad_mode_get_type())
	GTypePadPresence            = coreglib.Type(C.gst_pad_presence_get_type())
	GTypePadProbeReturn         = coreglib.Type(C.gst_pad_probe_return_get_type())
	GTypeParseError             = coreglib.Type(C.gst_parse_error_get_type())
	GTypePluginError            = coreglib.Type(C.gst_plugin_error_get_type())
	GTypeProgressType           = coreglib.Type(C.gst_progress_type_get_type())
	GTypePromiseResult          = coreglib.Type(C.gst_promise_result_get_type())
	GTypeQOSType                = coreglib.Type(C.gst_qos_type_get_type())
	GTypeQueryType              = coreglib.Type(C.gst_query_type_get_type())
	GTypeRank                   = coreglib.Type(C.gst_rank_get_type())
	GTypeResourceError          = coreglib.Type(C.gst_resource_error_get_type())
	GTypeSearchMode             = coreglib.Type(C.gst_search_mode_get_type())
	GTypeSeekType               = coreglib.Type(C.gst_seek_type_get_type())
	GTypeState                  = coreglib.Type(C.gst_state_get_type())
	GTypeStateChange            = coreglib.Type(C.gst_state_change_get_type())
	GTypeStateChangeReturn      = coreglib.Type(C.gst_state_change_return_get_type())
	GTypeStreamError            = coreglib.Type(C.gst_stream_error_get_type())
	GTypeStreamStatusType       = coreglib.Type(C.gst_stream_status_type_get_type())
	GTypeStructureChangeType    = coreglib.Type(C.gst_structure_change_type_get_type())
	GTypeTagFlag                = coreglib.Type(C.gst_tag_flag_get_type())
	GTypeTagMergeMode           = coreglib.Type(C.gst_tag_merge_mode_get_type())
	GTypeTagScope               = coreglib.Type(C.gst_tag_scope_get_type())
	GTypeTaskState              = coreglib.Type(C.gst_task_state_get_type())
	GTypeTocEntryType           = coreglib.Type(C.gst_toc_entry_type_get_type())
	GTypeTocLoopType            = coreglib.Type(C.gst_toc_loop_type_get_type())
	GTypeTocScope               = coreglib.Type(C.gst_toc_scope_get_type())
	GTypeTracerValueScope       = coreglib.Type(C.gst_tracer_value_scope_get_type())
	GTypeTypeFindProbability    = coreglib.Type(C.gst_type_find_probability_get_type())
	GTypeURIError               = coreglib.Type(C.gst_uri_error_get_type())
	GTypeURIType                = coreglib.Type(C.gst_uri_type_get_type())
	GTypeAllocatorFlags         = coreglib.Type(C.gst_allocator_flags_get_type())
	GTypeBinFlags               = coreglib.Type(C.gst_bin_flags_get_type())
	GTypeBufferCopyFlagsType    = coreglib.Type(C.gst_buffer_copy_flags_get_type())
	GTypeBufferFlags            = coreglib.Type(C.gst_buffer_flags_get_type())
	GTypeBufferPoolAcquireFlags = coreglib.Type(C.gst_buffer_pool_acquire_flags_get_type())
	GTypeBusFlags               = coreglib.Type(C.gst_bus_flags_get_type())
	GTypeCapsFlags              = coreglib.Type(C.gst_caps_flags_get_type())
	GTypeClockFlags             = coreglib.Type(C.gst_clock_flags_get_type())
	GTypeDebugColorFlags        = coreglib.Type(C.gst_debug_color_flags_get_type())
	GTypeDebugGraphDetails      = coreglib.Type(C.gst_debug_graph_details_get_type())
	GTypeElementFlags           = coreglib.Type(C.gst_element_flags_get_type())
	GTypeEventTypeFlags         = coreglib.Type(C.gst_event_type_flags_get_type())
	GTypeGapFlags               = coreglib.Type(C.gst_gap_flags_get_type())
	GTypeLockFlags              = coreglib.Type(C.gst_lock_flags_get_type())
	GTypeMapFlags               = coreglib.Type(C.gst_map_flags_get_type())
	GTypeMemoryFlags            = coreglib.Type(C.gst_memory_flags_get_type())
	GTypeMessageType            = coreglib.Type(C.gst_message_type_get_type())
	GTypeMetaFlags              = coreglib.Type(C.gst_meta_flags_get_type())
	GTypeMiniObjectFlags        = coreglib.Type(C.gst_mini_object_flags_get_type())
	GTypeObjectFlags            = coreglib.Type(C.gst_object_flags_get_type())
	GTypePadFlags               = coreglib.Type(C.gst_pad_flags_get_type())
	GTypePadLinkCheck           = coreglib.Type(C.gst_pad_link_check_get_type())
	GTypePadProbeType           = coreglib.Type(C.gst_pad_probe_type_get_type())
	GTypePadTemplateFlags       = coreglib.Type(C.gst_pad_template_flags_get_type())
	GTypeParseFlags             = coreglib.Type(C.gst_parse_flags_get_type())
	GTypePipelineFlags          = coreglib.Type(C.gst_pipeline_flags_get_type())
	GTypePluginAPIFlags         = coreglib.Type(C.gst_plugin_api_flags_get_type())
	GTypePluginDependencyFlags  = coreglib.Type(C.gst_plugin_dependency_flags_get_type())
	GTypePluginFlags            = coreglib.Type(C.gst_plugin_flags_get_type())
	GTypeQueryTypeFlags         = coreglib.Type(C.gst_query_type_flags_get_type())
	GTypeSchedulingFlags        = coreglib.Type(C.gst_scheduling_flags_get_type())
	GTypeSeekFlags              = coreglib.Type(C.gst_seek_flags_get_type())
	GTypeSegmentFlags           = coreglib.Type(C.gst_segment_flags_get_type())
	GTypeSerializeFlags         = coreglib.Type(C.gst_serialize_flags_get_type())
	GTypeStackTraceFlags        = coreglib.Type(C.gst_stack_trace_flags_get_type())
	GTypeStreamFlags            = coreglib.Type(C.gst_stream_flags_get_type())
	GTypeStreamType             = coreglib.Type(C.gst_stream_type_get_type())
	GTypeTracerValueFlags       = coreglib.Type(C.gst_tracer_value_flags_get_type())
	GTypeChildProxy             = coreglib.Type(C.gst_child_proxy_get_type())
	GTypePreset                 = coreglib.Type(C.gst_preset_get_type())
	GTypeTagSetter              = coreglib.Type(C.gst_tag_setter_get_type())
	GTypeTocSetter              = coreglib.Type(C.gst_toc_setter_get_type())
	GTypeURIHandler             = coreglib.Type(C.gst_uri_handler_get_type())
	GTypeAllocator              = coreglib.Type(C.gst_allocator_get_type())
	GTypeBin                    = coreglib.Type(C.gst_bin_get_type())
	GTypeBitmask                = coreglib.Type(C.gst_bitmask_get_type())
	GTypeBufferPool             = coreglib.Type(C.gst_buffer_pool_get_type())
	GTypeBus                    = coreglib.Type(C.gst_bus_get_type())
	GTypeClock                  = coreglib.Type(C.gst_clock_get_type())
	GTypeControlBinding         = coreglib.Type(C.gst_control_binding_get_type())
	GTypeControlSource          = coreglib.Type(C.gst_control_source_get_type())
	GTypeDevice                 = coreglib.Type(C.gst_device_get_type())
	GTypeDeviceMonitor          = coreglib.Type(C.gst_device_monitor_get_type())
	GTypeDeviceProvider         = coreglib.Type(C.gst_device_provider_get_type())
	GTypeDeviceProviderFactory  = coreglib.Type(C.gst_device_provider_factory_get_type())
	GTypeDoubleRange            = coreglib.Type(C.gst_double_range_get_type())
	GTypeDynamicTypeFactory     = coreglib.Type(C.gst_dynamic_type_factory_get_type())
	GTypeElement                = coreglib.Type(C.gst_element_get_type())
	GTypeElementFactory         = coreglib.Type(C.gst_element_factory_get_type())
	GTypeFlagSet                = coreglib.Type(C.gst_flagset_get_type())
	GTypeFraction               = coreglib.Type(C.gst_fraction_get_type())
	GTypeFractionRange          = coreglib.Type(C.gst_fraction_range_get_type())
	GTypeGhostPad               = coreglib.Type(C.gst_ghost_pad_get_type())
	GTypeInt64Range             = coreglib.Type(C.gst_int64_range_get_type())
	GTypeIntRange               = coreglib.Type(C.gst_int_range_get_type())
	GTypeGstObject              = coreglib.Type(C.gst_object_get_type())
	GTypePad                    = coreglib.Type(C.gst_pad_get_type())
	GTypePadTemplate            = coreglib.Type(C.gst_pad_template_get_type())
	GTypePipeline               = coreglib.Type(C.gst_pipeline_get_type())
	GTypePlugin                 = coreglib.Type(C.gst_plugin_get_type())
	GTypePluginFeature          = coreglib.Type(C.gst_plugin_feature_get_type())
	GTypeProxyPad               = coreglib.Type(C.gst_proxy_pad_get_type())
	GTypeRegistry               = coreglib.Type(C.gst_registry_get_type())
	GTypeStream                 = coreglib.Type(C.gst_stream_get_type())
	GTypeStreamCollection       = coreglib.Type(C.gst_stream_collection_get_type())
	GTypeSystemClock            = coreglib.Type(C.gst_system_clock_get_type())
	GTypeTask                   = coreglib.Type(C.gst_task_get_type())
	GTypeTracer                 = coreglib.Type(C.gst_tracer_get_type())
	GTypeTracerFactory          = coreglib.Type(C.gst_tracer_factory_get_type())
	GTypeTracerRecord           = coreglib.Type(C.gst_tracer_record_get_type())
	GTypeTypeFindFactory        = coreglib.Type(C.gst_type_find_factory_get_type())
	GTypeValueArray             = coreglib.Type(C.gst_value_array_get_type())
	GTypeValueList              = coreglib.Type(C.gst_value_list_get_type())
	GTypeAllocationParams       = coreglib.Type(C.gst_allocation_params_get_type())
	GTypeAtomicQueue            = coreglib.Type(C.gst_atomic_queue_get_type())
	GTypeBuffer                 = coreglib.Type(C.gst_buffer_get_type())
	GTypeBufferList             = coreglib.Type(C.gst_buffer_list_get_type())
	GTypeCaps                   = coreglib.Type(C.gst_caps_get_type())
	GTypeCapsFeatures           = coreglib.Type(C.gst_caps_features_get_type())
	GTypeContext                = coreglib.Type(C.gst_context_get_type())
	GTypeDateTime               = coreglib.Type(C.gst_date_time_get_type())
	GTypeEvent                  = coreglib.Type(C.gst_event_get_type())
	GTypeIterator               = coreglib.Type(C.gst_iterator_get_type())
	GTypeMemory                 = coreglib.Type(C.gst_memory_get_type())
	GTypeMessage                = coreglib.Type(C.gst_message_get_type())
	GTypeMiniObject             = coreglib.Type(C.gst_mini_object_get_type())
	GTypeParseContext           = coreglib.Type(C.gst_parse_context_get_type())
	GTypePromise                = coreglib.Type(C.gst_promise_get_type())
	GTypeQuery                  = coreglib.Type(C.gst_query_get_type())
	GTypeSample                 = coreglib.Type(C.gst_sample_get_type())
	GTypeSegment                = coreglib.Type(C.gst_segment_get_type())
	GTypeStaticCaps             = coreglib.Type(C.gst_static_caps_get_type())
	GTypeStaticPadTemplate      = coreglib.Type(C.gst_static_pad_template_get_type())
	GTypeStructure              = coreglib.Type(C.gst_structure_get_type())
	GTypeTagList                = coreglib.Type(C.gst_tag_list_get_type())
	GTypeToc                    = coreglib.Type(C.gst_toc_get_type())
	GTypeTocEntry               = coreglib.Type(C.gst_toc_entry_get_type())
	GTypeTypeFind               = coreglib.Type(C.gst_type_find_get_type())
	GTypeURI                    = coreglib.Type(C.gst_uri_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeBufferingMode, F: marshalBufferingMode},
		coreglib.TypeMarshaler{T: GTypeBusSyncReply, F: marshalBusSyncReply},
		coreglib.TypeMarshaler{T: GTypeCapsIntersectMode, F: marshalCapsIntersectMode},
		coreglib.TypeMarshaler{T: GTypeClockEntryType, F: marshalClockEntryType},
		coreglib.TypeMarshaler{T: GTypeClockReturn, F: marshalClockReturn},
		coreglib.TypeMarshaler{T: GTypeClockType, F: marshalClockType},
		coreglib.TypeMarshaler{T: GTypeCoreError, F: marshalCoreError},
		coreglib.TypeMarshaler{T: GTypeDebugColorMode, F: marshalDebugColorMode},
		coreglib.TypeMarshaler{T: GTypeDebugLevel, F: marshalDebugLevel},
		coreglib.TypeMarshaler{T: GTypeEventType, F: marshalEventType},
		coreglib.TypeMarshaler{T: GTypeFlowReturn, F: marshalFlowReturn},
		coreglib.TypeMarshaler{T: GTypeFormat, F: marshalFormat},
		coreglib.TypeMarshaler{T: GTypeIteratorItem, F: marshalIteratorItem},
		coreglib.TypeMarshaler{T: GTypeIteratorResult, F: marshalIteratorResult},
		coreglib.TypeMarshaler{T: GTypeLibraryError, F: marshalLibraryError},
		coreglib.TypeMarshaler{T: GTypePadDirection, F: marshalPadDirection},
		coreglib.TypeMarshaler{T: GTypePadLinkReturn, F: marshalPadLinkReturn},
		coreglib.TypeMarshaler{T: GTypePadMode, F: marshalPadMode},
		coreglib.TypeMarshaler{T: GTypePadPresence, F: marshalPadPresence},
		coreglib.TypeMarshaler{T: GTypePadProbeReturn, F: marshalPadProbeReturn},
		coreglib.TypeMarshaler{T: GTypeParseError, F: marshalParseError},
		coreglib.TypeMarshaler{T: GTypePluginError, F: marshalPluginError},
		coreglib.TypeMarshaler{T: GTypeProgressType, F: marshalProgressType},
		coreglib.TypeMarshaler{T: GTypePromiseResult, F: marshalPromiseResult},
		coreglib.TypeMarshaler{T: GTypeQOSType, F: marshalQOSType},
		coreglib.TypeMarshaler{T: GTypeQueryType, F: marshalQueryType},
		coreglib.TypeMarshaler{T: GTypeRank, F: marshalRank},
		coreglib.TypeMarshaler{T: GTypeResourceError, F: marshalResourceError},
		coreglib.TypeMarshaler{T: GTypeSearchMode, F: marshalSearchMode},
		coreglib.TypeMarshaler{T: GTypeSeekType, F: marshalSeekType},
		coreglib.TypeMarshaler{T: GTypeState, F: marshalState},
		coreglib.TypeMarshaler{T: GTypeStateChange, F: marshalStateChange},
		coreglib.TypeMarshaler{T: GTypeStateChangeReturn, F: marshalStateChangeReturn},
		coreglib.TypeMarshaler{T: GTypeStreamError, F: marshalStreamError},
		coreglib.TypeMarshaler{T: GTypeStreamStatusType, F: marshalStreamStatusType},
		coreglib.TypeMarshaler{T: GTypeStructureChangeType, F: marshalStructureChangeType},
		coreglib.TypeMarshaler{T: GTypeTagFlag, F: marshalTagFlag},
		coreglib.TypeMarshaler{T: GTypeTagMergeMode, F: marshalTagMergeMode},
		coreglib.TypeMarshaler{T: GTypeTagScope, F: marshalTagScope},
		coreglib.TypeMarshaler{T: GTypeTaskState, F: marshalTaskState},
		coreglib.TypeMarshaler{T: GTypeTocEntryType, F: marshalTocEntryType},
		coreglib.TypeMarshaler{T: GTypeTocLoopType, F: marshalTocLoopType},
		coreglib.TypeMarshaler{T: GTypeTocScope, F: marshalTocScope},
		coreglib.TypeMarshaler{T: GTypeTracerValueScope, F: marshalTracerValueScope},
		coreglib.TypeMarshaler{T: GTypeTypeFindProbability, F: marshalTypeFindProbability},
		coreglib.TypeMarshaler{T: GTypeURIError, F: marshalURIError},
		coreglib.TypeMarshaler{T: GTypeURIType, F: marshalURIType},
		coreglib.TypeMarshaler{T: GTypeAllocatorFlags, F: marshalAllocatorFlags},
		coreglib.TypeMarshaler{T: GTypeBinFlags, F: marshalBinFlags},
		coreglib.TypeMarshaler{T: GTypeBufferCopyFlagsType, F: marshalBufferCopyFlagsType},
		coreglib.TypeMarshaler{T: GTypeBufferFlags, F: marshalBufferFlags},
		coreglib.TypeMarshaler{T: GTypeBufferPoolAcquireFlags, F: marshalBufferPoolAcquireFlags},
		coreglib.TypeMarshaler{T: GTypeBusFlags, F: marshalBusFlags},
		coreglib.TypeMarshaler{T: GTypeCapsFlags, F: marshalCapsFlags},
		coreglib.TypeMarshaler{T: GTypeClockFlags, F: marshalClockFlags},
		coreglib.TypeMarshaler{T: GTypeDebugColorFlags, F: marshalDebugColorFlags},
		coreglib.TypeMarshaler{T: GTypeDebugGraphDetails, F: marshalDebugGraphDetails},
		coreglib.TypeMarshaler{T: GTypeElementFlags, F: marshalElementFlags},
		coreglib.TypeMarshaler{T: GTypeEventTypeFlags, F: marshalEventTypeFlags},
		coreglib.TypeMarshaler{T: GTypeGapFlags, F: marshalGapFlags},
		coreglib.TypeMarshaler{T: GTypeLockFlags, F: marshalLockFlags},
		coreglib.TypeMarshaler{T: GTypeMapFlags, F: marshalMapFlags},
		coreglib.TypeMarshaler{T: GTypeMemoryFlags, F: marshalMemoryFlags},
		coreglib.TypeMarshaler{T: GTypeMessageType, F: marshalMessageType},
		coreglib.TypeMarshaler{T: GTypeMetaFlags, F: marshalMetaFlags},
		coreglib.TypeMarshaler{T: GTypeMiniObjectFlags, F: marshalMiniObjectFlags},
		coreglib.TypeMarshaler{T: GTypeObjectFlags, F: marshalObjectFlags},
		coreglib.TypeMarshaler{T: GTypePadFlags, F: marshalPadFlags},
		coreglib.TypeMarshaler{T: GTypePadLinkCheck, F: marshalPadLinkCheck},
		coreglib.TypeMarshaler{T: GTypePadProbeType, F: marshalPadProbeType},
		coreglib.TypeMarshaler{T: GTypePadTemplateFlags, F: marshalPadTemplateFlags},
		coreglib.TypeMarshaler{T: GTypeParseFlags, F: marshalParseFlags},
		coreglib.TypeMarshaler{T: GTypePipelineFlags, F: marshalPipelineFlags},
		coreglib.TypeMarshaler{T: GTypePluginAPIFlags, F: marshalPluginAPIFlags},
		coreglib.TypeMarshaler{T: GTypePluginDependencyFlags, F: marshalPluginDependencyFlags},
		coreglib.TypeMarshaler{T: GTypePluginFlags, F: marshalPluginFlags},
		coreglib.TypeMarshaler{T: GTypeQueryTypeFlags, F: marshalQueryTypeFlags},
		coreglib.TypeMarshaler{T: GTypeSchedulingFlags, F: marshalSchedulingFlags},
		coreglib.TypeMarshaler{T: GTypeSeekFlags, F: marshalSeekFlags},
		coreglib.TypeMarshaler{T: GTypeSegmentFlags, F: marshalSegmentFlags},
		coreglib.TypeMarshaler{T: GTypeSerializeFlags, F: marshalSerializeFlags},
		coreglib.TypeMarshaler{T: GTypeStackTraceFlags, F: marshalStackTraceFlags},
		coreglib.TypeMarshaler{T: GTypeStreamFlags, F: marshalStreamFlags},
		coreglib.TypeMarshaler{T: GTypeStreamType, F: marshalStreamType},
		coreglib.TypeMarshaler{T: GTypeTracerValueFlags, F: marshalTracerValueFlags},
		coreglib.TypeMarshaler{T: GTypeChildProxy, F: marshalChildProxy},
		coreglib.TypeMarshaler{T: GTypePreset, F: marshalPreset},
		coreglib.TypeMarshaler{T: GTypeTagSetter, F: marshalTagSetter},
		coreglib.TypeMarshaler{T: GTypeTocSetter, F: marshalTocSetter},
		coreglib.TypeMarshaler{T: GTypeURIHandler, F: marshalURIHandler},
		coreglib.TypeMarshaler{T: GTypeAllocator, F: marshalAllocator},
		coreglib.TypeMarshaler{T: GTypeBin, F: marshalBin},
		coreglib.TypeMarshaler{T: GTypeBitmask, F: marshalBitmask},
		coreglib.TypeMarshaler{T: GTypeBufferPool, F: marshalBufferPool},
		coreglib.TypeMarshaler{T: GTypeBus, F: marshalBus},
		coreglib.TypeMarshaler{T: GTypeClock, F: marshalClock},
		coreglib.TypeMarshaler{T: GTypeControlBinding, F: marshalControlBinding},
		coreglib.TypeMarshaler{T: GTypeControlSource, F: marshalControlSource},
		coreglib.TypeMarshaler{T: GTypeDevice, F: marshalDevice},
		coreglib.TypeMarshaler{T: GTypeDeviceMonitor, F: marshalDeviceMonitor},
		coreglib.TypeMarshaler{T: GTypeDeviceProvider, F: marshalDeviceProvider},
		coreglib.TypeMarshaler{T: GTypeDeviceProviderFactory, F: marshalDeviceProviderFactory},
		coreglib.TypeMarshaler{T: GTypeDoubleRange, F: marshalDoubleRange},
		coreglib.TypeMarshaler{T: GTypeDynamicTypeFactory, F: marshalDynamicTypeFactory},
		coreglib.TypeMarshaler{T: GTypeElement, F: marshalElement},
		coreglib.TypeMarshaler{T: GTypeElementFactory, F: marshalElementFactory},
		coreglib.TypeMarshaler{T: GTypeFlagSet, F: marshalFlagSet},
		coreglib.TypeMarshaler{T: GTypeFraction, F: marshalFraction},
		coreglib.TypeMarshaler{T: GTypeFractionRange, F: marshalFractionRange},
		coreglib.TypeMarshaler{T: GTypeGhostPad, F: marshalGhostPad},
		coreglib.TypeMarshaler{T: GTypeInt64Range, F: marshalInt64Range},
		coreglib.TypeMarshaler{T: GTypeIntRange, F: marshalIntRange},
		coreglib.TypeMarshaler{T: GTypeGstObject, F: marshalGstObject},
		coreglib.TypeMarshaler{T: GTypePad, F: marshalPad},
		coreglib.TypeMarshaler{T: GTypePadTemplate, F: marshalPadTemplate},
		coreglib.TypeMarshaler{T: GTypePipeline, F: marshalPipeline},
		coreglib.TypeMarshaler{T: GTypePlugin, F: marshalPlugin},
		coreglib.TypeMarshaler{T: GTypePluginFeature, F: marshalPluginFeature},
		coreglib.TypeMarshaler{T: GTypeProxyPad, F: marshalProxyPad},
		coreglib.TypeMarshaler{T: GTypeRegistry, F: marshalRegistry},
		coreglib.TypeMarshaler{T: GTypeStream, F: marshalStream},
		coreglib.TypeMarshaler{T: GTypeStreamCollection, F: marshalStreamCollection},
		coreglib.TypeMarshaler{T: GTypeSystemClock, F: marshalSystemClock},
		coreglib.TypeMarshaler{T: GTypeTask, F: marshalTask},
		coreglib.TypeMarshaler{T: GTypeTracer, F: marshalTracer},
		coreglib.TypeMarshaler{T: GTypeTracerFactory, F: marshalTracerFactory},
		coreglib.TypeMarshaler{T: GTypeTracerRecord, F: marshalTracerRecord},
		coreglib.TypeMarshaler{T: GTypeTypeFindFactory, F: marshalTypeFindFactory},
		coreglib.TypeMarshaler{T: GTypeValueArray, F: marshalValueArray},
		coreglib.TypeMarshaler{T: GTypeValueList, F: marshalValueList},
		coreglib.TypeMarshaler{T: GTypeAllocationParams, F: marshalAllocationParams},
		coreglib.TypeMarshaler{T: GTypeAtomicQueue, F: marshalAtomicQueue},
		coreglib.TypeMarshaler{T: GTypeBuffer, F: marshalBuffer},
		coreglib.TypeMarshaler{T: GTypeBufferList, F: marshalBufferList},
		coreglib.TypeMarshaler{T: GTypeCaps, F: marshalCaps},
		coreglib.TypeMarshaler{T: GTypeCapsFeatures, F: marshalCapsFeatures},
		coreglib.TypeMarshaler{T: GTypeContext, F: marshalContext},
		coreglib.TypeMarshaler{T: GTypeDateTime, F: marshalDateTime},
		coreglib.TypeMarshaler{T: GTypeEvent, F: marshalEvent},
		coreglib.TypeMarshaler{T: GTypeIterator, F: marshalIterator},
		coreglib.TypeMarshaler{T: GTypeMemory, F: marshalMemory},
		coreglib.TypeMarshaler{T: GTypeMessage, F: marshalMessage},
		coreglib.TypeMarshaler{T: GTypeMiniObject, F: marshalMiniObject},
		coreglib.TypeMarshaler{T: GTypeParseContext, F: marshalParseContext},
		coreglib.TypeMarshaler{T: GTypePromise, F: marshalPromise},
		coreglib.TypeMarshaler{T: GTypeQuery, F: marshalQuery},
		coreglib.TypeMarshaler{T: GTypeSample, F: marshalSample},
		coreglib.TypeMarshaler{T: GTypeSegment, F: marshalSegment},
		coreglib.TypeMarshaler{T: GTypeStaticCaps, F: marshalStaticCaps},
		coreglib.TypeMarshaler{T: GTypeStaticPadTemplate, F: marshalStaticPadTemplate},
		coreglib.TypeMarshaler{T: GTypeStructure, F: marshalStructure},
		coreglib.TypeMarshaler{T: GTypeTagList, F: marshalTagList},
		coreglib.TypeMarshaler{T: GTypeToc, F: marshalToc},
		coreglib.TypeMarshaler{T: GTypeTocEntry, F: marshalTocEntry},
		coreglib.TypeMarshaler{T: GTypeTypeFind, F: marshalTypeFind},
		coreglib.TypeMarshaler{T: GTypeURI, F: marshalURI},
	})
}

// ALLOCATOR_SYSMEM: allocator name for the default system memory allocator.
const ALLOCATOR_SYSMEM = "SystemMemory"

// BUFFER_OFFSET_NONE: constant for no-offset return results.
const BUFFER_OFFSET_NONE = 18446744073709551615
const CAN_INLINE = 1
const CAPS_FEATURE_MEMORY_SYSTEM_MEMORY = "memory:SystemMemory"
const DEBUG_BG_MASK = 240
const DEBUG_FG_MASK = 15
const DEBUG_FORMAT_MASK = 65280
const ELEMENT_FACTORY_KLASS_DECODER = "Decoder"
const ELEMENT_FACTORY_KLASS_DECRYPTOR = "Decryptor"
const ELEMENT_FACTORY_KLASS_DEMUXER = "Demuxer"
const ELEMENT_FACTORY_KLASS_DEPAYLOADER = "Depayloader"
const ELEMENT_FACTORY_KLASS_ENCODER = "Encoder"
const ELEMENT_FACTORY_KLASS_ENCRYPTOR = "Encryptor"
const ELEMENT_FACTORY_KLASS_FORMATTER = "Formatter"

// ELEMENT_FACTORY_KLASS_HARDWARE elements interacting with hardware devices
// should specify this classifier in their metadata. You may need to put the
// element in "READY" state to test if the hardware is present in the system.
const ELEMENT_FACTORY_KLASS_HARDWARE = "Hardware"
const ELEMENT_FACTORY_KLASS_MEDIA_AUDIO = "Audio"
const ELEMENT_FACTORY_KLASS_MEDIA_IMAGE = "Image"
const ELEMENT_FACTORY_KLASS_MEDIA_METADATA = "Metadata"
const ELEMENT_FACTORY_KLASS_MEDIA_SUBTITLE = "Subtitle"
const ELEMENT_FACTORY_KLASS_MEDIA_VIDEO = "Video"
const ELEMENT_FACTORY_KLASS_MUXER = "Muxer"
const ELEMENT_FACTORY_KLASS_PARSER = "Parser"
const ELEMENT_FACTORY_KLASS_PAYLOADER = "Payloader"
const ELEMENT_FACTORY_KLASS_SINK = "Sink"
const ELEMENT_FACTORY_KLASS_SRC = "Source"

// ELEMENT_METADATA_AUTHOR: name and contact details of the author(s).
// Use \n to separate multiple author details. E.g: "Joe Bloggs &lt;joe.blogs at
// foo.com&gt;".
const ELEMENT_METADATA_AUTHOR = "author"

// ELEMENT_METADATA_DESCRIPTION: sentence describing the purpose of the element.
// E.g: "Write stream to a file".
const ELEMENT_METADATA_DESCRIPTION = "description"

// ELEMENT_METADATA_DOC_URI: set uri pointing to user documentation.
// Applications can use this to show help for e.g. effects to users.
const ELEMENT_METADATA_DOC_URI = "doc-uri"

// ELEMENT_METADATA_ICON_NAME elements that bridge to certain other products
// can include an icon of that used product. Application can show the icon in
// menus/selectors to help identifying specific elements.
const ELEMENT_METADATA_ICON_NAME = "icon-name"

// ELEMENT_METADATA_KLASS: string describing the type of element, as an
// unordered list separated with slashes ('/'). See draft-klass.txt of the
// design docs for more details and common types. E.g: "Sink/File".
const ELEMENT_METADATA_KLASS = "klass"

// ELEMENT_METADATA_LONGNAME: long English name of the element. E.g. "File
// Sink".
const ELEMENT_METADATA_LONGNAME = "long-name"

// ERROR_SYSTEM builds a string using errno describing the previously failed
// system call. To be used as the debug argument in T_ELEMENT_ERROR.
const ERROR_SYSTEM = "system error: %s"
const EVENT_NUM_SHIFT = 8

// FLAG_SET_MASK_EXACT: mask value with all bits set, for use as a GstFlagSet
// mask where all flag bits must match exactly.
const FLAG_SET_MASK_EXACT = 4294967295

// FORMAT_PERCENT_MAX: PERCENT format is between 0 and this value.
const FORMAT_PERCENT_MAX = 1000000

// FORMAT_PERCENT_SCALE: value used to scale down the reported PERCENT format
// value to its real value.
const FORMAT_PERCENT_SCALE = 10000

// FOURCC_FORMAT: can be used together with T_FOURCC_ARGS to properly output a
// #guint32 fourcc value in a printf\()-style text message.
//
//	printf ("fourcc: %" GST_FOURCC_FORMAT "\n", GST_FOURCC_ARGS (fcc));.
const FOURCC_FORMAT = "c%c%c%c"

// GROUP_ID_INVALID: value which is guaranteed to never be returned by
// gst_util_group_id_next().
//
// Can be used as a default value in variables used to store group_id.
const GROUP_ID_INVALID = 0

// LICENSE_UNKNOWN: to be used in GST_PLUGIN_DEFINE if unsure about the licence.
const LICENSE_UNKNOWN = "unknown"

// META_TAG_MEMORY_REFERENCE_STR: this metadata stays relevant until a deep copy
// is made.
const META_TAG_MEMORY_REFERENCE_STR = "memory-reference"

// META_TAG_MEMORY_STR: this metadata stays relevant as long as memory layout is
// unchanged. In hindsight, this tag should have been called "memory-layout".
const META_TAG_MEMORY_STR = "memory"

// PARAM_CONDITIONALLY_AVAILABLE: use this flag on GObject properties of
// GstObject to indicate that they might not be available depending on
// environment such as OS, device, etc, so such properties will be installed
// conditionally only if the GstObject is able to support it.
const PARAM_CONDITIONALLY_AVAILABLE = 16384

// PARAM_CONTROLLABLE: use this flag on GObject properties to signal they
// can make sense to be. controlled over time. This hint is used by the
// GstController.
const PARAM_CONTROLLABLE = 512

// PARAM_DOC_SHOW_DEFAULT: use this flag on GObject properties of GstObject to
// indicate that during gst-inspect and friends, the default value should be
// used as default instead of the current value.
const PARAM_DOC_SHOW_DEFAULT = 8192

// PARAM_MUTABLE_PAUSED: use this flag on GObject properties of GstElements to
// indicate that they can be changed when the element is in the PAUSED or lower
// state. This flag implies GST_PARAM_MUTABLE_READY.
const PARAM_MUTABLE_PAUSED = 2048

// PARAM_MUTABLE_PLAYING: use this flag on GObject properties of GstElements to
// indicate that they can be changed when the element is in the PLAYING or lower
// state. This flag implies GST_PARAM_MUTABLE_PAUSED.
const PARAM_MUTABLE_PLAYING = 4096

// PARAM_MUTABLE_READY: use this flag on GObject properties of GstElements to
// indicate that they can be changed when the element is in the READY or lower
// state.
const PARAM_MUTABLE_READY = 1024

// PARAM_USER_SHIFT bits based on GST_PARAM_USER_SHIFT can be used by 3rd party
// applications.
const PARAM_USER_SHIFT = 65536

// PROTECTION_SYSTEM_ID_CAPS_FIELD: field name in a GstCaps that is used to
// signal the UUID of the protection system.
const PROTECTION_SYSTEM_ID_CAPS_FIELD = "protection-system"

// PROTECTION_UNSPECIFIED_SYSTEM_ID: protection system value of the unspecified
// UUID. In some cases the system protection ID is not present in the contents
// or in their metadata, as encrypted WebM. This define is used to set the
// value of the "system_id" field in GstProtectionEvent, with this value,
// the application will use an external information to choose which protection
// system to use.
//
// Example: The matroskademux uses this value in the case of encrypted WebM,
// the application will choose the appropriate protection system based on the
// information received through EME API.
const PROTECTION_UNSPECIFIED_SYSTEM_ID = "unspecified-system-id"

// PTR_FORMAT: printf format type used to debug GStreamer types. You can
// use this in combination with GStreamer's debug logging system as well
// as the functions gst_info_vasprintf(), gst_info_strdup_vprintf() and
// gst_info_strdup_printf() to pretty-print the following types: Caps,
// Structure, CapsFeatures, TagList, DateTime, Buffer, BufferList, Message,
// Event, Query, Context, Pad, Object. All #GObject types will be printed as
// typename plus pointer, and everything else will simply be printed as pointer
// address.
//
// This can only be used on types whose size is >= sizeof(gpointer).
const PTR_FORMAT = "paA"
const QUERY_NUM_SHIFT = 8

// SEGMENT_FORMAT: printf format type used to debug GStreamer segments.
// You can use this in combination with GStreamer's debug logging system as
// well as the functions gst_info_vasprintf(), gst_info_strdup_vprintf() and
// gst_info_strdup_printf() to pretty-print Segment structures. This can only be
// used on pointers to GstSegment structures.
const SEGMENT_FORMAT = "paB"
const SEGMENT_INSTANT_FLAGS = 912

// SEQNUM_INVALID: value which is guaranteed to never be returned by
// gst_util_seqnum_next().
//
// Can be used as a default value in variables used to store seqnum.
const SEQNUM_INVALID = 0

// STIMEP_FORMAT: printf format type used to debug GStreamer signed time
// value pointers. You can use this in combination with GStreamer's
// debug logging system as well as the functions gst_info_vasprintf(),
// gst_info_strdup_vprintf() and gst_info_strdup_printf() to pretty-print signed
// time (pointers to ClockTimeDiff or #gint64).
const STIMEP_FORMAT = "paS"

// STIME_FORMAT: string that can be used in printf-like format strings to
// display a signed ClockTimeDiff or #gint64 value in h:m:s format. Use
// GST_TIME_ARGS() to construct the matching arguments.
//
// Example:
//
//	C printf("%" GST_STIME_FORMAT "\n", GST_STIME_ARGS(ts));.
const STIME_FORMAT = "c%"

// TAG_ALBUM: album containing this data (string)
//
// The album name as it should be displayed, e.g. 'The Jazz Guitar'.
const TAG_ALBUM = "album"

// TAG_ALBUM_ARTIST: artist of the entire album, as it should be displayed.
const TAG_ALBUM_ARTIST = "album-artist"

// TAG_ALBUM_ARTIST_SORTNAME: artist of the entire album, as it should be
// sorted.
const TAG_ALBUM_ARTIST_SORTNAME = "album-artist-sortname"

// TAG_ALBUM_GAIN: album gain in db (double).
const TAG_ALBUM_GAIN = "replaygain-album-gain"

// TAG_ALBUM_PEAK: peak of the album (double).
const TAG_ALBUM_PEAK = "replaygain-album-peak"

// TAG_ALBUM_SORTNAME: album containing this data, as used for sorting (string)
//
// The album name as it should be sorted, e.g. 'Jazz Guitar, The'.
const TAG_ALBUM_SORTNAME = "album-sortname"

// TAG_ALBUM_VOLUME_COUNT: count of discs inside collection this disc belongs to
// (unsigned integer).
const TAG_ALBUM_VOLUME_COUNT = "album-disc-count"

// TAG_ALBUM_VOLUME_NUMBER: disc number inside a collection (unsigned integer).
const TAG_ALBUM_VOLUME_NUMBER = "album-disc-number"

// TAG_APPLICATION_DATA: arbitrary application data (sample)
//
// Some formats allow applications to add their own arbitrary data into files.
// This data is application dependent.
const TAG_APPLICATION_DATA = "application-data"

// TAG_APPLICATION_NAME: name of the application used to create the media
// (string).
const TAG_APPLICATION_NAME = "application-name"

// TAG_ARTIST: person(s) responsible for the recording (string)
//
// The artist name as it should be displayed, e.g. 'Jimi Hendrix' or 'The Guitar
// Heroes'.
const TAG_ARTIST = "artist"

// TAG_ARTIST_SORTNAME: person(s) responsible for the recording, as used for
// sorting (string)
//
// The artist name as it should be sorted, e.g. 'Hendrix, Jimi' or 'Guitar
// Heroes, The'.
const TAG_ARTIST_SORTNAME = "artist-sortname"

// TAG_ATTACHMENT: generic file attachment (sample) (sample taglist should
// specify the content type and if possible set "filename" to the file name of
// the attachment).
const TAG_ATTACHMENT = "attachment"

// TAG_AUDIO_CODEC: codec the audio data is stored in (string).
const TAG_AUDIO_CODEC = "audio-codec"

// TAG_BEATS_PER_MINUTE: number of beats per minute in audio (double).
const TAG_BEATS_PER_MINUTE = "beats-per-minute"

// TAG_BITRATE: exact or average bitrate in bits/s (unsigned integer).
const TAG_BITRATE = "bitrate"

// TAG_CODEC: codec the data is stored in (string).
const TAG_CODEC = "codec"

// TAG_COMMENT: free text commenting the data (string).
const TAG_COMMENT = "comment"

// TAG_COMPOSER: person(s) who composed the recording (string).
const TAG_COMPOSER = "composer"

// TAG_COMPOSER_SORTNAME composer's name, used for sorting (string).
const TAG_COMPOSER_SORTNAME = "composer-sortname"

// TAG_CONDUCTOR: conductor/performer refinement (string).
const TAG_CONDUCTOR = "conductor"

// TAG_CONTACT: contact information (string).
const TAG_CONTACT = "contact"

// TAG_CONTAINER_FORMAT: container format the data is stored in (string).
const TAG_CONTAINER_FORMAT = "container-format"

// TAG_CONTAINER_SPECIFIC_TRACK_ID: unique identifier for the audio,
// video or text track this tag is associated with. The mappings
// for several container formats are defined in the [Sourcing
// In-band Media Resource Tracks from Media Containers into HTML
// specification](https://dev.w3.org/html5/html-sourcing-inband-tracks/).
const TAG_CONTAINER_SPECIFIC_TRACK_ID = "container-specific-track-id"

// TAG_COPYRIGHT: copyright notice of the data (string).
const TAG_COPYRIGHT = "copyright"

// TAG_COPYRIGHT_URI: URI to location where copyright details can be found
// (string).
const TAG_COPYRIGHT_URI = "copyright-uri"

// TAG_DATE: date the data was created (#GDate structure).
const TAG_DATE = "date"

// TAG_DATE_TIME: date and time the data was created (DateTime structure).
const TAG_DATE_TIME = "datetime"

// TAG_DESCRIPTION: short text describing the content of the data (string).
const TAG_DESCRIPTION = "description"

// TAG_DEVICE_MANUFACTURER: manufacturer of the device used to create the media
// (string).
const TAG_DEVICE_MANUFACTURER = "device-manufacturer"

// TAG_DEVICE_MODEL: model of the device used to create the media (string).
const TAG_DEVICE_MODEL = "device-model"

// TAG_DURATION: length in GStreamer time units (nanoseconds) (unsigned 64-bit
// integer).
const TAG_DURATION = "duration"

// TAG_ENCODED_BY: name of the person or organisation that encoded the file.
// May contain a copyright message if the person or organisation also holds the
// copyright (string)
//
// Note: do not use this field to describe the encoding application. Use
// T_TAG_APPLICATION_NAME or T_TAG_COMMENT for that.
const TAG_ENCODED_BY = "encoded-by"

// TAG_ENCODER: encoder used to encode this stream (string).
const TAG_ENCODER = "encoder"

// TAG_ENCODER_VERSION: version of the encoder used to encode this stream
// (unsigned integer).
const TAG_ENCODER_VERSION = "encoder-version"

// TAG_EXTENDED_COMMENT: key/value text commenting the data (string)
//
// Must be in the form of 'key=comment' or 'key[lc]=comment' where 'lc' is an
// ISO-639 language code.
//
// This tag is used for unknown Vorbis comment tags, unknown APE tags and
// certain ID3v2 comment fields.
const TAG_EXTENDED_COMMENT = "extended-comment"

// TAG_GENRE: genre this data belongs to (string).
const TAG_GENRE = "genre"

// TAG_GEO_LOCATION_CAPTURE_DIRECTION indicates the direction the device is
// pointing to when capturing a media. It is represented as degrees in floating
// point representation, 0 means the geographic north, and increases clockwise
// (double from 0 to 360)
//
// See also T_TAG_GEO_LOCATION_MOVEMENT_DIRECTION.
const TAG_GEO_LOCATION_CAPTURE_DIRECTION = "geo-location-capture-direction"

// TAG_GEO_LOCATION_CITY: city (english name) where the media has been produced
// (string).
const TAG_GEO_LOCATION_CITY = "geo-location-city"

// TAG_GEO_LOCATION_COUNTRY: country (english name) where the media has been
// produced (string).
const TAG_GEO_LOCATION_COUNTRY = "geo-location-country"

// TAG_GEO_LOCATION_ELEVATION: geo elevation of where the media has been
// recorded or produced in meters according to WGS84 (zero is average sea level)
// (double).
const TAG_GEO_LOCATION_ELEVATION = "geo-location-elevation"

// TAG_GEO_LOCATION_HORIZONTAL_ERROR represents the expected error on the
// horizontal positioning in meters (double).
const TAG_GEO_LOCATION_HORIZONTAL_ERROR = "geo-location-horizontal-error"

// TAG_GEO_LOCATION_LATITUDE: geo latitude location of where the media has been
// recorded or produced in degrees according to WGS84 (zero at the equator,
// negative values for southern latitudes) (double).
const TAG_GEO_LOCATION_LATITUDE = "geo-location-latitude"

// TAG_GEO_LOCATION_LONGITUDE: geo longitude location of where the media has
// been recorded or produced in degrees according to WGS84 (zero at the prime
// meridian in Greenwich/UK, negative values for western longitudes). (double).
const TAG_GEO_LOCATION_LONGITUDE = "geo-location-longitude"

// TAG_GEO_LOCATION_MOVEMENT_DIRECTION indicates the movement direction of the
// device performing the capture of a media. It is represented as degrees in
// floating point representation, 0 means the geographic north, and increases
// clockwise (double from 0 to 360)
//
// See also T_TAG_GEO_LOCATION_CAPTURE_DIRECTION.
const TAG_GEO_LOCATION_MOVEMENT_DIRECTION = "geo-location-movement-direction"

// TAG_GEO_LOCATION_MOVEMENT_SPEED: speed of the capturing device when
// performing the capture. Represented in m/s. (double)
//
// See also T_TAG_GEO_LOCATION_MOVEMENT_DIRECTION.
const TAG_GEO_LOCATION_MOVEMENT_SPEED = "geo-location-movement-speed"

// TAG_GEO_LOCATION_NAME: human readable descriptive location of where the media
// has been recorded or produced. (string).
const TAG_GEO_LOCATION_NAME = "geo-location-name"

// TAG_GEO_LOCATION_SUBLOCATION: location 'smaller' than
// GST_TAG_GEO_LOCATION_CITY that specifies better where the media has been
// produced. (e.g. the neighborhood) (string).
//
// This tag has been added as this is how it is handled/named in XMP's
// Iptc4xmpcore schema.
const TAG_GEO_LOCATION_SUBLOCATION = "geo-location-sublocation"

// TAG_GROUPING groups together media that are related and spans multiple
// tracks. An example are multiple pieces of a concerto. (string).
const TAG_GROUPING = "grouping"

// TAG_HOMEPAGE: homepage for this media (i.e. artist or movie homepage)
// (string).
const TAG_HOMEPAGE = "homepage"

// TAG_IMAGE: image (sample) (sample taglist should specify the content type and
// preferably also set "image-type" field as GstTagImageType).
const TAG_IMAGE = "image"

// TAG_IMAGE_ORIENTATION represents the 'Orientation' tag from EXIF. Defines how
// the image should be rotated and mirrored for display. (string)
//
// This tag has a predefined set of allowed values: "rotate-0" "rotate-90"
// "rotate-180" "rotate-270" "flip-rotate-0" "flip-rotate-90" "flip-rotate-180"
// "flip-rotate-270"
//
// The naming is adopted according to a possible transformation to perform on
// the image to fix its orientation, obviously equivalent operations will yield
// the same result.
//
// Rotations indicated by the values are in clockwise direction and 'flip' means
// an horizontal mirroring.
const TAG_IMAGE_ORIENTATION = "image-orientation"

// TAG_INTERPRETED_BY: information about the people behind a remix and similar
// interpretations of another existing piece (string).
const TAG_INTERPRETED_BY = "interpreted-by"

// TAG_ISRC: international Standard Recording Code - see
// http://www.ifpi.org/isrc/ (string).
const TAG_ISRC = "isrc"

// TAG_KEYWORDS: comma separated keywords describing the content (string).
const TAG_KEYWORDS = "keywords"

// TAG_LANGUAGE_CODE: ISO-639-2 or ISO-639-1 code for the language the content
// is in (string)
//
// There is utility API in libgsttag in gst-plugins-base to obtain a translated
// language name from the language code: gst_tag_get_language_name().
const TAG_LANGUAGE_CODE = "language-code"

// TAG_LANGUAGE_NAME: name of the language the content is in (string)
//
// Free-form name of the language the content is in, if a language code is
// not available. This tag should not be set in addition to a language code.
// It is undefined what language or locale the language name is in.
const TAG_LANGUAGE_NAME = "language-name"

// TAG_LICENSE: license of data (string).
const TAG_LICENSE = "license"

// TAG_LICENSE_URI: URI to location where license details can be found (string).
const TAG_LICENSE_URI = "license-uri"

// TAG_LOCATION: origin of media as a URI (location, where the original of the
// file or stream is hosted) (string).
const TAG_LOCATION = "location"

// TAG_LYRICS lyrics of the media (string).
const TAG_LYRICS = "lyrics"

// TAG_MAXIMUM_BITRATE: maximum bitrate in bits/s (unsigned integer).
const TAG_MAXIMUM_BITRATE = "maximum-bitrate"

// TAG_MIDI_BASE_NOTE: Midi note number
// (http://en.wikipedia.org/wiki/Note#Note_designation_in_accordance_with_octave_name)
// of the audio track. This is useful for sample instruments and in particular
// for multi-samples.
const TAG_MIDI_BASE_NOTE = "midi-base-note"

// TAG_MINIMUM_BITRATE: minimum bitrate in bits/s (unsigned integer).
const TAG_MINIMUM_BITRATE = "minimum-bitrate"

// TAG_NOMINAL_BITRATE: nominal bitrate in bits/s (unsigned integer). The actual
// bitrate might be different from this target bitrate.
const TAG_NOMINAL_BITRATE = "nominal-bitrate"

// TAG_ORGANIZATION: organization (string).
const TAG_ORGANIZATION = "organization"

// TAG_PERFORMER: person(s) performing (string).
const TAG_PERFORMER = "performer"

// TAG_PREVIEW_IMAGE: image that is meant for preview purposes, e.g. small
// icon-sized version (sample) (sample taglist should specify the content type).
const TAG_PREVIEW_IMAGE = "preview-image"

// TAG_PRIVATE_DATA: any private data that may be contained in tags (sample).
//
// It is represented by Sample in which Buffer contains the binary data and the
// sample's info Structure may contain any extra information that identifies the
// origin or meaning of the data.
//
// Private frames in ID3v2 tags ('PRIV' frames) will be represented using
// this tag, in which case the GstStructure will be named "ID3PrivateFrame"
// and contain a field named "owner" of type string which contains the
// owner-identification string from the tag.
const TAG_PRIVATE_DATA = "private-data"

// TAG_PUBLISHER: name of the label or publisher (string).
const TAG_PUBLISHER = "publisher"

// TAG_REFERENCE_LEVEL: reference level of track and album gain values (double).
const TAG_REFERENCE_LEVEL = "replaygain-reference-level"

// TAG_SERIAL: serial number of track (unsigned integer).
const TAG_SERIAL = "serial"

// TAG_SHOW_EPISODE_NUMBER: number of the episode within a season/show (unsigned
// integer).
const TAG_SHOW_EPISODE_NUMBER = "show-episode-number"

// TAG_SHOW_NAME: name of the show, used for displaying (string).
const TAG_SHOW_NAME = "show-name"

// TAG_SHOW_SEASON_NUMBER: number of the season of a show/series (unsigned
// integer).
const TAG_SHOW_SEASON_NUMBER = "show-season-number"

// TAG_SHOW_SORTNAME: name of the show, used for sorting (string).
const TAG_SHOW_SORTNAME = "show-sortname"

// TAG_SUBTITLE_CODEC: codec/format the subtitle data is stored in (string).
const TAG_SUBTITLE_CODEC = "subtitle-codec"

// TAG_TITLE: commonly used title (string)
//
// The title as it should be displayed, e.g. 'The Doll House'.
const TAG_TITLE = "title"

// TAG_TITLE_SORTNAME: commonly used title, as used for sorting (string)
//
// The title as it should be sorted, e.g. 'Doll House, The'.
const TAG_TITLE_SORTNAME = "title-sortname"

// TAG_TRACK_COUNT: count of tracks inside collection this track belongs to
// (unsigned integer).
const TAG_TRACK_COUNT = "track-count"

// TAG_TRACK_GAIN: track gain in db (double).
const TAG_TRACK_GAIN = "replaygain-track-gain"

// TAG_TRACK_NUMBER: track number inside a collection (unsigned integer).
const TAG_TRACK_NUMBER = "track-number"

// TAG_TRACK_PEAK: peak of the track (double).
const TAG_TRACK_PEAK = "replaygain-track-peak"

// TAG_USER_RATING: rating attributed by a person (likely the application user).
// The higher the value, the more the user likes this media (unsigned int from 0
// to 100).
const TAG_USER_RATING = "user-rating"

// TAG_VERSION: version of this data (string).
const TAG_VERSION = "version"

// TAG_VIDEO_CODEC: codec the video data is stored in (string).
const TAG_VIDEO_CODEC = "video-codec"

// TIMEP_FORMAT: printf format type used to debug GStreamer ClockTime pointers.
// You can use this in combination with GStreamer's debug logging system as
// well as the functions gst_info_vasprintf(), gst_info_strdup_vprintf() and
// gst_info_strdup_printf() to pretty-print ClockTime pointers. This can only be
// used on pointers to GstClockTime values.
const TIMEP_FORMAT = "paT"

// TIME_FORMAT: string that can be used in printf-like format strings to display
// a ClockTime value in h:m:s format. Use GST_TIME_ARGS() to construct the
// matching arguments.
//
// Example:
//
//	C printf("%" GST_TIME_FORMAT "\n", GST_TIME_ARGS(ts));.
const TIME_FORMAT = "u:%02u:%02u.%09u"

// TOC_REPEAT_COUNT_INFINITE: special value for the repeat_count set in
// gst_toc_entry_set_loop() or returned by gst_toc_entry_set_loop() to indicate
// infinite looping.
const TOC_REPEAT_COUNT_INFINITE = -1

// URI_NO_PORT: value for Uri<!-- -->.port to indicate no port number.
const URI_NO_PORT = 0

// VALUE_EQUAL indicates that the first value provided to a comparison function
// (gst_value_compare()) is equal to the second one.
const VALUE_EQUAL = 0

// VALUE_GREATER_THAN indicates that the first value provided to a comparison
// function (gst_value_compare()) is greater than the second one.
const VALUE_GREATER_THAN = 1

// VALUE_LESS_THAN indicates that the first value provided to a comparison
// function (gst_value_compare()) is lesser than the second one.
const VALUE_LESS_THAN = -1

// VALUE_UNORDERED indicates that the comparison function (gst_value_compare())
// can not determine a order for the two provided values.
const VALUE_UNORDERED = 2

// VERSION_MAJOR: major version of GStreamer at compile time:.
const VERSION_MAJOR = 1

// VERSION_MICRO: micro version of GStreamer at compile time:.
const VERSION_MICRO = 10

// VERSION_MINOR: minor version of GStreamer at compile time:.
const VERSION_MINOR = 24

// VERSION_NANO: nano version of GStreamer at compile time: Actual releases have
// 0, GIT versions have 1, prerelease versions have 2-...
const VERSION_NANO = 0

// ClockID: datatype to hold the handle to an outstanding sync or async clock
// callback.
type ClockID = unsafe.Pointer

// ClockTime: datatype to hold a time, measured in nanoseconds.
type ClockTime = uint64

// ClockTimeDiff: datatype to hold a time difference, measured in nanoseconds.
type ClockTimeDiff = int64

// ElementFactoryListType: type defining the type of an element factory.
type ElementFactoryListType = uint64

// BufferingMode: different types of buffering methods.
type BufferingMode C.gint

const (
	// BufferingStream: small amount of data is buffered.
	BufferingStream BufferingMode = iota
	// BufferingDownload: stream is being downloaded.
	BufferingDownload
	// BufferingTimeshift: stream is being downloaded in a ringbuffer.
	BufferingTimeshift
	// BufferingLive: stream is a live stream.
	BufferingLive
)

func marshalBufferingMode(p uintptr) (interface{}, error) {
	return BufferingMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for BufferingMode.
func (b BufferingMode) String() string {
	switch b {
	case BufferingStream:
		return "Stream"
	case BufferingDownload:
		return "Download"
	case BufferingTimeshift:
		return "Timeshift"
	case BufferingLive:
		return "Live"
	default:
		return fmt.Sprintf("BufferingMode(%d)", b)
	}
}

// BusSyncReply: result values for a GstBusSyncHandler.
type BusSyncReply C.gint

const (
	// BusDrop: drop the message.
	BusDrop BusSyncReply = iota
	// BusPass pass the message to the async queue.
	BusPass
	// BusAsync pass message to async queue, continue if message is handled.
	BusAsync
)

func marshalBusSyncReply(p uintptr) (interface{}, error) {
	return BusSyncReply(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for BusSyncReply.
func (b BusSyncReply) String() string {
	switch b {
	case BusDrop:
		return "Drop"
	case BusPass:
		return "Pass"
	case BusAsync:
		return "Async"
	default:
		return fmt.Sprintf("BusSyncReply(%d)", b)
	}
}

// CapsIntersectMode modes of caps intersection
//
// GST_CAPS_INTERSECT_ZIG_ZAG tries to preserve overall order of both caps by
// iterating on the caps' structures as the following matrix shows:
//
//	         caps1
//	      +-------------
//	      | 1  2  4  7
//	caps2 | 3  5  8 10
//	      | 6  9 11 12
//
// Used when there is no explicit precedence of one caps over the other. e.g.
// tee's sink pad getcaps function, it will probe its src pad peers' for their
// caps and intersect them with this mode.
//
// GST_CAPS_INTERSECT_FIRST is useful when an element wants to preserve another
// element's caps priority order when intersecting with its own caps. Example:
// If caps1 is [A, B, C] and caps2 is [E, B, D, A], the result would be [A, B],
// maintaining the first caps priority on the intersection.
type CapsIntersectMode C.gint

const (
	// CapsIntersectZigZag zig-zags over both caps.
	CapsIntersectZigZag CapsIntersectMode = iota
	// CapsIntersectFirst keeps the first caps order.
	CapsIntersectFirst
)

func marshalCapsIntersectMode(p uintptr) (interface{}, error) {
	return CapsIntersectMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CapsIntersectMode.
func (c CapsIntersectMode) String() string {
	switch c {
	case CapsIntersectZigZag:
		return "ZigZag"
	case CapsIntersectFirst:
		return "First"
	default:
		return fmt.Sprintf("CapsIntersectMode(%d)", c)
	}
}

// ClockEntryType: type of the clock entry.
type ClockEntryType C.gint

const (
	// ClockEntrySingle: single shot timeout.
	ClockEntrySingle ClockEntryType = iota
	// ClockEntryPeriodic: periodic timeout request.
	ClockEntryPeriodic
)

func marshalClockEntryType(p uintptr) (interface{}, error) {
	return ClockEntryType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ClockEntryType.
func (c ClockEntryType) String() string {
	switch c {
	case ClockEntrySingle:
		return "Single"
	case ClockEntryPeriodic:
		return "Periodic"
	default:
		return fmt.Sprintf("ClockEntryType(%d)", c)
	}
}

// ClockReturn: return value of a clock operation.
type ClockReturn C.gint

const (
	// ClockOK: operation succeeded.
	ClockOK ClockReturn = iota
	// ClockEarly: operation was scheduled too late.
	ClockEarly
	// ClockUnscheduled: clockID was unscheduled.
	ClockUnscheduled
	// ClockBusy: clockID is busy.
	ClockBusy
	// ClockBadtime: bad time was provided to a function.
	ClockBadtime
	// ClockError: error occurred.
	ClockError
	// ClockUnsupported: operation is not supported.
	ClockUnsupported
	// ClockDone: clockID is done waiting.
	ClockDone
)

func marshalClockReturn(p uintptr) (interface{}, error) {
	return ClockReturn(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ClockReturn.
func (c ClockReturn) String() string {
	switch c {
	case ClockOK:
		return "OK"
	case ClockEarly:
		return "Early"
	case ClockUnscheduled:
		return "Unscheduled"
	case ClockBusy:
		return "Busy"
	case ClockBadtime:
		return "Badtime"
	case ClockError:
		return "Error"
	case ClockUnsupported:
		return "Unsupported"
	case ClockDone:
		return "Done"
	default:
		return fmt.Sprintf("ClockReturn(%d)", c)
	}
}

// ClockType: different kind of clocks.
type ClockType C.gint

const (
	// ClockTypeRealtime: time since Epoch.
	ClockTypeRealtime ClockType = iota
	// ClockTypeMonotonic: monotonic time since some unspecified starting point.
	ClockTypeMonotonic
	// ClockTypeOther: some other time source is used (Since: 1.0.5).
	ClockTypeOther
	// ClockTypeTai: time since Epoch, but using International Atomic Time as
	// reference (Since: 1.18).
	ClockTypeTai
)

func marshalClockType(p uintptr) (interface{}, error) {
	return ClockType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ClockType.
func (c ClockType) String() string {
	switch c {
	case ClockTypeRealtime:
		return "Realtime"
	case ClockTypeMonotonic:
		return "Monotonic"
	case ClockTypeOther:
		return "Other"
	case ClockTypeTai:
		return "Tai"
	default:
		return fmt.Sprintf("ClockType(%d)", c)
	}
}

// CoreError: core errors are errors inside the core GStreamer library.
type CoreError C.gint

const (
	// CoreErrorFailed: general error which doesn't fit in any other category.
	// Make sure you add a custom message to the error call.
	CoreErrorFailed CoreError = 1
	// CoreErrorTooLaZY: do not use this except as a placeholder for deciding
	// where to go while developing code.
	CoreErrorTooLaZY CoreError = 2
	// CoreErrorNotImplemented: use this when you do not want to implement this
	// functionality yet.
	CoreErrorNotImplemented CoreError = 3
	// CoreErrorStateChange: used for state change errors.
	CoreErrorStateChange CoreError = 4
	// CoreErrorPad: used for pad-related errors.
	CoreErrorPad CoreError = 5
	// CoreErrorThread: used for thread-related errors.
	CoreErrorThread CoreError = 6
	// CoreErrorNegotiation: used for negotiation-related errors.
	CoreErrorNegotiation CoreError = 7
	// CoreErrorEvent: used for event-related errors.
	CoreErrorEvent CoreError = 8
	// CoreErrorSeek: used for seek-related errors.
	CoreErrorSeek CoreError = 9
	// CoreErrorCaps: used for caps-related errors.
	CoreErrorCaps CoreError = 10
	// CoreErrorTag: used for negotiation-related errors.
	CoreErrorTag CoreError = 11
	// CoreErrorMissingPlugin: used if a plugin is missing.
	CoreErrorMissingPlugin CoreError = 12
	// CoreErrorClock: used for clock related errors.
	CoreErrorClock CoreError = 13
	// CoreErrorDisabled: used if functionality has been disabled at compile
	// time.
	CoreErrorDisabled CoreError = 14
	// CoreErrorNumErrors: number of core error types.
	CoreErrorNumErrors CoreError = 15
)

func marshalCoreError(p uintptr) (interface{}, error) {
	return CoreError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CoreError.
func (c CoreError) String() string {
	switch c {
	case CoreErrorFailed:
		return "Failed"
	case CoreErrorTooLaZY:
		return "TooLaZY"
	case CoreErrorNotImplemented:
		return "NotImplemented"
	case CoreErrorStateChange:
		return "StateChange"
	case CoreErrorPad:
		return "Pad"
	case CoreErrorThread:
		return "Thread"
	case CoreErrorNegotiation:
		return "Negotiation"
	case CoreErrorEvent:
		return "Event"
	case CoreErrorSeek:
		return "Seek"
	case CoreErrorCaps:
		return "Caps"
	case CoreErrorTag:
		return "Tag"
	case CoreErrorMissingPlugin:
		return "MissingPlugin"
	case CoreErrorClock:
		return "Clock"
	case CoreErrorDisabled:
		return "Disabled"
	case CoreErrorNumErrors:
		return "NumErrors"
	default:
		return fmt.Sprintf("CoreError(%d)", c)
	}
}

func CoreErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gst_core_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

type DebugColorMode C.gint

const (
	// DebugColorModeOff: do not use colors in logs.
	DebugColorModeOff DebugColorMode = iota
	// DebugColorModeOn: paint logs in a platform-specific way.
	DebugColorModeOn
	// DebugColorModeUnix: paint logs with UNIX terminal color codes no matter
	// what platform GStreamer is running on.
	DebugColorModeUnix
)

func marshalDebugColorMode(p uintptr) (interface{}, error) {
	return DebugColorMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DebugColorMode.
func (d DebugColorMode) String() string {
	switch d {
	case DebugColorModeOff:
		return "Off"
	case DebugColorModeOn:
		return "On"
	case DebugColorModeUnix:
		return "Unix"
	default:
		return fmt.Sprintf("DebugColorMode(%d)", d)
	}
}

// DebugLevel: level defines the importance of a debugging message. The more
// important a message is, the greater the probability that the debugging system
// outputs it.
type DebugLevel C.gint

const (
	// LevelNone: no debugging level specified or desired. Used to deactivate
	// debugging output.
	LevelNone DebugLevel = 0
	// LevelError: error messages are to be used only when an error occurred
	// that stops the application from keeping working correctly. An examples
	// is gst_element_error, which outputs a message with this priority. It does
	// not mean that the application is terminating as with g_error.
	LevelError DebugLevel = 1
	// LevelWarning: warning messages are to inform about abnormal behaviour
	// that could lead to problems or weird behaviour later on. An example of
	// this would be clocking issues ("your computer is pretty slow") or broken
	// input data ("Can't synchronize to stream.").
	LevelWarning DebugLevel = 2
	// LevelFixme: fixme messages are messages that indicate that something in
	// the executed code path is not fully implemented or handled yet. Note that
	// this does not replace proper error handling in any way, the purpose of
	// this message is to make it easier to spot incomplete/unfinished pieces of
	// code when reading the debug log.
	LevelFixme DebugLevel = 3
	// LevelInfo: informational messages should be used to keep the developer
	// updated about what is happening. Examples where this should be used are
	// when a typefind function has successfully determined the type of the
	// stream or when an mp3 plugin detects the format to be used. ("This file
	// has mono sound.").
	LevelInfo DebugLevel = 4
	// LevelDebug: debugging messages should be used when something common
	// happens that is not the expected default behavior, or something that's
	// useful to know but doesn't happen all the time (ie. per loop iteration
	// or buffer processed or event handled). An example would be notifications
	// about state changes or receiving/sending of events.
	LevelDebug DebugLevel = 5
	// LevelLog: log messages are messages that are very common but might be
	// useful to know. As a rule of thumb a pipeline that is running as expected
	// should never output anything else but LOG messages whilst processing
	// data. Use this log level to log recurring information in chain functions
	// and loop functions, for example.
	LevelLog DebugLevel = 6
	// LevelTrace: tracing-related messages. Examples for this are
	// referencing/dereferencing of objects.
	LevelTrace DebugLevel = 7
	// LevelMemdump: memory dump messages are used to log (small) chunks of data
	// as memory dumps in the log. They will be displayed as hexdump with ASCII
	// characters.
	LevelMemdump DebugLevel = 9
	// LevelCount: number of defined debugging levels.
	LevelCount DebugLevel = 10
)

func marshalDebugLevel(p uintptr) (interface{}, error) {
	return DebugLevel(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DebugLevel.
func (d DebugLevel) String() string {
	switch d {
	case LevelNone:
		return "None"
	case LevelError:
		return "Error"
	case LevelWarning:
		return "Warning"
	case LevelFixme:
		return "Fixme"
	case LevelInfo:
		return "Info"
	case LevelDebug:
		return "Debug"
	case LevelLog:
		return "Log"
	case LevelTrace:
		return "Trace"
	case LevelMemdump:
		return "Memdump"
	case LevelCount:
		return "Count"
	default:
		return fmt.Sprintf("DebugLevel(%d)", d)
	}
}

// DebugLevelGetName: get the string representation of a debugging level.
//
// The function takes the following parameters:
//
//   - level to get the name for.
//
// The function returns the following values:
//
//   - utf8: name.
func DebugLevelGetName(level DebugLevel) string {
	var _arg1 C.GstDebugLevel // out
	var _cret *C.gchar        // in

	_arg1 = C.GstDebugLevel(level)

	_cret = C.gst_debug_level_get_name(_arg1)
	runtime.KeepAlive(level)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// EventType lists the standard event types that can be sent in a pipeline.
//
// The custom event types can be used for private messages between elements that
// can't be expressed using normal GStreamer buffer passing semantics. Custom
// events carry an arbitrary Structure. Specific custom events are distinguished
// by the name of the structure.
type EventType C.gint

const (
	// EventUnknown: unknown event.
	EventUnknown EventType = 0
	// EventFlushStart: start a flush operation. This event clears all data from
	// the pipeline and unblock all streaming threads.
	EventFlushStart EventType = 2563
	// EventFlushStop: stop a flush operation. This event resets the
	// running-time of the pipeline.
	EventFlushStop EventType = 5127
	// EventStreamStart: event to mark the start of a new stream. Sent before
	// any other serialized event and only sent at the start of a new stream,
	// not after flushing seeks.
	EventStreamStart EventType = 10254
	// EventCaps event. Notify the pad of a new media type.
	EventCaps EventType = 12814
	// EventSegment: new media segment follows in the dataflow. The segment
	// events contains information for clipping buffers and converting buffer
	// timestamps to running-time and stream-time.
	EventSegment EventType = 17934
	// EventStreamCollection: new StreamCollection is available (Since: 1.10).
	EventStreamCollection EventType = 19230
	// EventTag: new set of metadata tags has been found in the stream.
	EventTag EventType = 20510
	// EventBuffersize: notification of buffering requirements. Currently not
	// used yet.
	EventBuffersize EventType = 23054
	// EventSinkMessage: event that sinks turn into a message. Used to send
	// messages that should be emitted in sync with rendering.
	EventSinkMessage EventType = 25630
	// EventStreamGroupDone indicates that there is no more data for the stream
	// group ID in the message. Sent before EOS in some instances and should be
	// handled mostly the same. (Since: 1.10).
	EventStreamGroupDone EventType = 26894
	// EventEos: end-Of-Stream. No more data is to be expected to follow without
	// either a STREAM_START event, or a FLUSH_STOP and a SEGMENT event.
	EventEos EventType = 28174
	// EventToc: event which indicates that a new table of contents (TOC) was
	// found or updated.
	EventToc EventType = 30750
	// EventProtection: event which indicates that new or updated encryption
	// information has been found in the stream.
	EventProtection EventType = 33310
	// EventSegmentDone marks the end of a segment playback.
	EventSegmentDone EventType = 38406
	// EventGap marks a gap in the datastream.
	EventGap EventType = 40966
	// EventInstantRateChange: notify downstream that a playback rate override
	// should be applied as soon as possible. (Since: 1.18).
	EventInstantRateChange EventType = 46090
	// EventQos: quality message. Used to indicate to upstream elements that the
	// downstream elements should adjust their processing rate.
	EventQos EventType = 48641
	// EventSeek: request for a new playback position and rate.
	EventSeek EventType = 51201
	// EventNavigation: navigation events are usually used for communicating
	// user requests, such as mouse or keyboard movements, to upstream elements.
	EventNavigation EventType = 53761
	// EventLatency: notification of new latency adjustment. Sinks will use the
	// latency information to adjust their synchronisation.
	EventLatency EventType = 56321
	// EventStep: request for stepping through the media. Sinks will usually
	// execute the step operation.
	EventStep EventType = 58881
	// EventReconfigure: request for upstream renegotiating caps and
	// reconfiguring.
	EventReconfigure EventType = 61441
	// EventTocSelect: request for a new playback position based on TOC entry's
	// UID.
	EventTocSelect EventType = 64001
	// EventSelectStreams: request to select one or more streams (Since: 1.10).
	EventSelectStreams EventType = 66561
	// EventInstantRateSyncTime: sent by the pipeline to notify elements that
	// handle the instant-rate-change event about the running-time when the rate
	// multiplier should be applied (or was applied). (Since: 1.18).
	EventInstantRateSyncTime EventType = 66817
	// EventCustomUpstream: upstream custom event.
	EventCustomUpstream EventType = 69121
	// EventCustomDownstream: downstream custom event that travels in the data
	// flow.
	EventCustomDownstream EventType = 71686
	// EventCustomDownstreamOob: custom out-of-band downstream event.
	EventCustomDownstreamOob EventType = 74242
	// EventCustomDownstreamSticky: custom sticky downstream event.
	EventCustomDownstreamSticky EventType = 76830
	// EventCustomBoth: custom upstream or downstream event. In-band when
	// travelling downstream.
	EventCustomBoth EventType = 79367
	// EventCustomBothOob: custom upstream or downstream out-of-band event.
	EventCustomBothOob EventType = 81923
)

func marshalEventType(p uintptr) (interface{}, error) {
	return EventType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for EventType.
func (e EventType) String() string {
	switch e {
	case EventUnknown:
		return "Unknown"
	case EventFlushStart:
		return "FlushStart"
	case EventFlushStop:
		return "FlushStop"
	case EventStreamStart:
		return "StreamStart"
	case EventCaps:
		return "Caps"
	case EventSegment:
		return "Segment"
	case EventStreamCollection:
		return "StreamCollection"
	case EventTag:
		return "Tag"
	case EventBuffersize:
		return "Buffersize"
	case EventSinkMessage:
		return "SinkMessage"
	case EventStreamGroupDone:
		return "StreamGroupDone"
	case EventEos:
		return "Eos"
	case EventToc:
		return "Toc"
	case EventProtection:
		return "Protection"
	case EventSegmentDone:
		return "SegmentDone"
	case EventGap:
		return "Gap"
	case EventInstantRateChange:
		return "InstantRateChange"
	case EventQos:
		return "Qos"
	case EventSeek:
		return "Seek"
	case EventNavigation:
		return "Navigation"
	case EventLatency:
		return "Latency"
	case EventStep:
		return "Step"
	case EventReconfigure:
		return "Reconfigure"
	case EventTocSelect:
		return "TocSelect"
	case EventSelectStreams:
		return "SelectStreams"
	case EventInstantRateSyncTime:
		return "InstantRateSyncTime"
	case EventCustomUpstream:
		return "CustomUpstream"
	case EventCustomDownstream:
		return "CustomDownstream"
	case EventCustomDownstreamOob:
		return "CustomDownstreamOob"
	case EventCustomDownstreamSticky:
		return "CustomDownstreamSticky"
	case EventCustomBoth:
		return "CustomBoth"
	case EventCustomBothOob:
		return "CustomBothOob"
	default:
		return fmt.Sprintf("EventType(%d)", e)
	}
}

// EventTypeGetFlags gets the EventTypeFlags associated with type.
//
// The function takes the following parameters:
//
//   - typ: EventType.
//
// The function returns the following values:
//
//   - eventTypeFlags: EventTypeFlags.
func EventTypeGetFlags(typ EventType) EventTypeFlags {
	var _arg1 C.GstEventType      // out
	var _cret C.GstEventTypeFlags // in

	_arg1 = C.GstEventType(typ)

	_cret = C.gst_event_type_get_flags(_arg1)
	runtime.KeepAlive(typ)

	var _eventTypeFlags EventTypeFlags // out

	_eventTypeFlags = EventTypeFlags(_cret)

	return _eventTypeFlags
}

// EventTypeGetName: get a printable name for the given event type. Do not
// modify or free.
//
// The function takes the following parameters:
//
//   - typ: event type.
//
// The function returns the following values:
//
//   - utf8: reference to the static name of the event.
func EventTypeGetName(typ EventType) string {
	var _arg1 C.GstEventType // out
	var _cret *C.gchar       // in

	_arg1 = C.GstEventType(typ)

	_cret = C.gst_event_type_get_name(_arg1)
	runtime.KeepAlive(typ)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// EventTypeToQuark: get the unique quark for the given event type.
//
// The function takes the following parameters:
//
//   - typ: event type.
//
// The function returns the following values:
//
//   - quark associated with the event type.
func EventTypeToQuark(typ EventType) glib.Quark {
	var _arg1 C.GstEventType // out
	var _cret C.GQuark       // in

	_arg1 = C.GstEventType(typ)

	_cret = C.gst_event_type_to_quark(_arg1)
	runtime.KeepAlive(typ)

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// EventTypeToStickyOrdering converts the EventType to an unsigned integer that
// represents the ordering of sticky events when re-sending them. A lower value
// represents a higher-priority event.
//
// The function takes the following parameters:
//
//   - typ: EventType.
//
// The function returns the following values:
//
//   - guint: unsigned integer.
func EventTypeToStickyOrdering(typ EventType) uint {
	var _arg1 C.GstEventType // out
	var _cret C.guint        // in

	_arg1 = C.GstEventType(typ)

	_cret = C.gst_event_type_to_sticky_ordering(_arg1)
	runtime.KeepAlive(typ)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// FlowReturn: result of passing data to a pad.
//
// Note that the custom return values should not be exposed outside of the
// element scope.
type FlowReturn C.gint

const (
	// FlowCustomSuccess2: pre-defined custom success code.
	FlowCustomSuccess2 FlowReturn = 102
	// FlowCustomSuccess1: pre-defined custom success code (define your custom
	// success code to this to avoid compiler warnings).
	FlowCustomSuccess1 FlowReturn = 101
	// FlowCustomSuccess elements can use values starting from this (and higher)
	// to define custom success codes.
	FlowCustomSuccess FlowReturn = 100
	// FlowOK: data passing was ok.
	FlowOK FlowReturn = 0
	// FlowNotLinked: pad is not linked.
	FlowNotLinked FlowReturn = -1
	// FlowFlushing: pad is flushing.
	FlowFlushing FlowReturn = -2
	// FlowEos: pad is EOS.
	FlowEos FlowReturn = -3
	// FlowNotNegotiated: pad is not negotiated.
	FlowNotNegotiated FlowReturn = -4
	// FlowError: some (fatal) error occurred. Element generating this error
	// should post an error message using GST_ELEMENT_ERROR() with more details.
	FlowError FlowReturn = -5
	// FlowNotSupported: this operation is not supported.
	FlowNotSupported FlowReturn = -6
	// FlowCustomError elements can use values starting from this (and lower) to
	// define custom error codes.
	FlowCustomError FlowReturn = -100
	// FlowCustomError1: pre-defined custom error code (define your custom error
	// code to this to avoid compiler warnings).
	FlowCustomError1 FlowReturn = -101
	// FlowCustomError2: pre-defined custom error code.
	FlowCustomError2 FlowReturn = -102
)

func marshalFlowReturn(p uintptr) (interface{}, error) {
	return FlowReturn(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FlowReturn.
func (f FlowReturn) String() string {
	switch f {
	case FlowCustomSuccess2:
		return "CustomSuccess2"
	case FlowCustomSuccess1:
		return "CustomSuccess1"
	case FlowCustomSuccess:
		return "CustomSuccess"
	case FlowOK:
		return "OK"
	case FlowNotLinked:
		return "NotLinked"
	case FlowFlushing:
		return "Flushing"
	case FlowEos:
		return "Eos"
	case FlowNotNegotiated:
		return "NotNegotiated"
	case FlowError:
		return "Error"
	case FlowNotSupported:
		return "NotSupported"
	case FlowCustomError:
		return "CustomError"
	case FlowCustomError1:
		return "CustomError1"
	case FlowCustomError2:
		return "CustomError2"
	default:
		return fmt.Sprintf("FlowReturn(%d)", f)
	}
}

// Format: standard predefined formats.
type Format C.gint

const (
	// FormatUndefined: undefined format.
	FormatUndefined Format = iota
	// FormatDefault: default format of the pad/element. This can be samples
	// for raw audio, frames/fields for raw video (some, but not all, elements
	// support this; use GST_FORMAT_TIME if you don't have a good reason to
	// query for samples/frames).
	FormatDefault
	// FormatBytes: bytes.
	FormatBytes
	// FormatTime: time in nanoseconds.
	FormatTime
	// FormatBuffers buffers (few, if any, elements implement this as of May
	// 2009).
	FormatBuffers
	// FormatPercent: percentage of stream (few, if any, elements implement this
	// as of May 2009).
	FormatPercent
)

func marshalFormat(p uintptr) (interface{}, error) {
	return Format(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Format.
func (f Format) String() string {
	switch f {
	case FormatUndefined:
		return "Undefined"
	case FormatDefault:
		return "Default"
	case FormatBytes:
		return "Bytes"
	case FormatTime:
		return "Time"
	case FormatBuffers:
		return "Buffers"
	case FormatPercent:
		return "Percent"
	default:
		return fmt.Sprintf("Format(%d)", f)
	}
}

// FormatGetByNick: return the format registered with the given nick.
//
// The function takes the following parameters:
//
//   - nick of the format.
//
// The function returns the following values:
//
//   - format with nick or GST_FORMAT_UNDEFINED if the format was not
//     registered.
func FormatGetByNick(nick string) Format {
	var _arg1 *C.gchar    // out
	var _cret C.GstFormat // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_format_get_by_nick(_arg1)
	runtime.KeepAlive(nick)

	var _format Format // out

	_format = Format(_cret)

	return _format
}

// FormatGetDetails: get details about the given format.
//
// The function takes the following parameters:
//
//   - format to get details of.
//
// The function returns the following values:
//
//   - formatDefinition (optional) for format or NULL on failure.
//
//     MT safe.
func FormatGetDetails(format Format) *FormatDefinition {
	var _arg1 C.GstFormat            // out
	var _cret *C.GstFormatDefinition // in

	_arg1 = C.GstFormat(format)

	_cret = C.gst_format_get_details(_arg1)
	runtime.KeepAlive(format)

	var _formatDefinition *FormatDefinition // out

	if _cret != nil {
		_formatDefinition = (*FormatDefinition)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _formatDefinition
}

// FormatGetName: get a printable name for the given format. Do not modify or
// free.
//
// The function takes the following parameters:
//
//   - format: Format.
//
// The function returns the following values:
//
//   - utf8 (optional): reference to the static name of the format or NULL if
//     the format is unknown.
func FormatGetName(format Format) string {
	var _arg1 C.GstFormat // out
	var _cret *C.gchar    // in

	_arg1 = C.GstFormat(format)

	_cret = C.gst_format_get_name(_arg1)
	runtime.KeepAlive(format)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// FormatIterateDefinitions: iterate all the registered formats. The format
// definition is read only.
//
// The function returns the following values:
//
//   - iterator: gstIterator of FormatDefinition.
func FormatIterateDefinitions() *Iterator {
	var _cret *C.GstIterator // in

	_cret = C.gst_format_iterate_definitions()

	var _iterator *Iterator // out

	_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iterator)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_iterator_free((*C.GstIterator)(intern.C))
		},
	)

	return _iterator
}

// FormatRegister: create a new GstFormat based on the nick or return an already
// registered format with that nick.
//
// The function takes the following parameters:
//
//   - nick of the new format.
//   - description of the new format.
//
// The function returns the following values:
//
//   - format: new GstFormat or an already registered format with the same nick.
//
//     MT safe.
func FormatRegister(nick, description string) Format {
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _cret C.GstFormat // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(nick)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_format_register(_arg1, _arg2)
	runtime.KeepAlive(nick)
	runtime.KeepAlive(description)

	var _format Format // out

	_format = Format(_cret)

	return _format
}

// FormatToQuark: get the unique quark for the given format.
//
// The function takes the following parameters:
//
//   - format: Format.
//
// The function returns the following values:
//
//   - quark associated with the format or 0 if the format is unknown.
func FormatToQuark(format Format) glib.Quark {
	var _arg1 C.GstFormat // out
	var _cret C.GQuark    // in

	_arg1 = C.GstFormat(format)

	_cret = C.gst_format_to_quark(_arg1)
	runtime.KeepAlive(format)

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// IteratorItem: result of a IteratorItemFunction.
type IteratorItem C.gint

const (
	// IteratorItemSkip: skip this item.
	IteratorItemSkip IteratorItem = iota
	// IteratorItemPass: return item.
	IteratorItemPass
	// IteratorItemEnd: stop after this item.
	IteratorItemEnd
)

func marshalIteratorItem(p uintptr) (interface{}, error) {
	return IteratorItem(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for IteratorItem.
func (i IteratorItem) String() string {
	switch i {
	case IteratorItemSkip:
		return "Skip"
	case IteratorItemPass:
		return "Pass"
	case IteratorItemEnd:
		return "End"
	default:
		return fmt.Sprintf("IteratorItem(%d)", i)
	}
}

// IteratorResult: result of gst_iterator_next().
type IteratorResult C.gint

const (
	// IteratorDone: no more items in the iterator.
	IteratorDone IteratorResult = iota
	// IteratorOK: item was retrieved.
	IteratorOK
	// IteratorResync: datastructure changed while iterating.
	IteratorResync
	// IteratorError: error happened.
	IteratorError
)

func marshalIteratorResult(p uintptr) (interface{}, error) {
	return IteratorResult(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for IteratorResult.
func (i IteratorResult) String() string {
	switch i {
	case IteratorDone:
		return "Done"
	case IteratorOK:
		return "OK"
	case IteratorResync:
		return "Resync"
	case IteratorError:
		return "Error"
	default:
		return fmt.Sprintf("IteratorResult(%d)", i)
	}
}

// LibraryError: library errors are for errors from the library being used by
// elements (initializing, finalizing, settings, ...).
type LibraryError C.gint

const (
	// LibraryErrorFailed: general error which doesn't fit in any other
	// category. Make sure you add a custom message to the error call.
	LibraryErrorFailed LibraryError = 1
	// LibraryErrorTooLaZY: do not use this except as a placeholder for deciding
	// where to go while developing code.
	LibraryErrorTooLaZY LibraryError = 2
	// LibraryErrorInit: used when the library could not be opened.
	LibraryErrorInit LibraryError = 3
	// LibraryErrorShutdown: used when the library could not be closed.
	LibraryErrorShutdown LibraryError = 4
	// LibraryErrorSettings: used when the library doesn't accept settings.
	LibraryErrorSettings LibraryError = 5
	// LibraryErrorEncode: used when the library generated an encoding error.
	LibraryErrorEncode LibraryError = 6
	// LibraryErrorNumErrors: number of library error types.
	LibraryErrorNumErrors LibraryError = 7
)

func marshalLibraryError(p uintptr) (interface{}, error) {
	return LibraryError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for LibraryError.
func (l LibraryError) String() string {
	switch l {
	case LibraryErrorFailed:
		return "Failed"
	case LibraryErrorTooLaZY:
		return "TooLaZY"
	case LibraryErrorInit:
		return "Init"
	case LibraryErrorShutdown:
		return "Shutdown"
	case LibraryErrorSettings:
		return "Settings"
	case LibraryErrorEncode:
		return "Encode"
	case LibraryErrorNumErrors:
		return "NumErrors"
	default:
		return fmt.Sprintf("LibraryError(%d)", l)
	}
}

func LibraryErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gst_library_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// PadDirection: direction of a pad.
type PadDirection C.gint

const (
	// PadUnknown: direction is unknown.
	PadUnknown PadDirection = iota
	// PadSrc: pad is a source pad.
	PadSrc
	// PadSink: pad is a sink pad.
	PadSink
)

func marshalPadDirection(p uintptr) (interface{}, error) {
	return PadDirection(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PadDirection.
func (p PadDirection) String() string {
	switch p {
	case PadUnknown:
		return "Unknown"
	case PadSrc:
		return "Src"
	case PadSink:
		return "Sink"
	default:
		return fmt.Sprintf("PadDirection(%d)", p)
	}
}

// PadLinkReturn: result values from gst_pad_link and friends.
type PadLinkReturn C.gint

const (
	// PadLinkOK: link succeeded.
	PadLinkOK PadLinkReturn = 0
	// PadLinkWrongHierarchy pads have no common grandparent.
	PadLinkWrongHierarchy PadLinkReturn = -1
	// PadLinkWasLinked: pad was already linked.
	PadLinkWasLinked PadLinkReturn = -2
	// PadLinkWrongDirection pads have wrong direction.
	PadLinkWrongDirection PadLinkReturn = -3
	// PadLinkNoformat pads do not have common format.
	PadLinkNoformat PadLinkReturn = -4
	// PadLinkNosched pads cannot cooperate in scheduling.
	PadLinkNosched PadLinkReturn = -5
	// PadLinkRefused: refused for some reason.
	PadLinkRefused PadLinkReturn = -6
)

func marshalPadLinkReturn(p uintptr) (interface{}, error) {
	return PadLinkReturn(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PadLinkReturn.
func (p PadLinkReturn) String() string {
	switch p {
	case PadLinkOK:
		return "OK"
	case PadLinkWrongHierarchy:
		return "WrongHierarchy"
	case PadLinkWasLinked:
		return "WasLinked"
	case PadLinkWrongDirection:
		return "WrongDirection"
	case PadLinkNoformat:
		return "Noformat"
	case PadLinkNosched:
		return "Nosched"
	case PadLinkRefused:
		return "Refused"
	default:
		return fmt.Sprintf("PadLinkReturn(%d)", p)
	}
}

// PadMode status of a GstPad. After activating a pad, which usually happens
// when the parent element goes from READY to PAUSED, the GstPadMode defines if
// the pad operates in push or pull mode.
type PadMode C.gint

const (
	// PadModeNone: pad will not handle dataflow.
	PadModeNone PadMode = iota
	// PadModePush: pad handles dataflow in downstream push mode.
	PadModePush
	// PadModePull: pad handles dataflow in upstream pull mode.
	PadModePull
)

func marshalPadMode(p uintptr) (interface{}, error) {
	return PadMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PadMode.
func (p PadMode) String() string {
	switch p {
	case PadModeNone:
		return "None"
	case PadModePush:
		return "Push"
	case PadModePull:
		return "Pull"
	default:
		return fmt.Sprintf("PadMode(%d)", p)
	}
}

// PadModeGetName: return the name of a pad mode, for use in debug messages
// mostly.
//
// The function takes the following parameters:
//
//   - mode: pad mode.
//
// The function returns the following values:
//
//   - utf8: short mnemonic for pad mode mode.
func PadModeGetName(mode PadMode) string {
	var _arg1 C.GstPadMode // out
	var _cret *C.gchar     // in

	_arg1 = C.GstPadMode(mode)

	_cret = C.gst_pad_mode_get_name(_arg1)
	runtime.KeepAlive(mode)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// PadPresence indicates when this pad will become available.
type PadPresence C.gint

const (
	// PadAlways: pad is always available.
	PadAlways PadPresence = iota
	// PadSometimes: pad will become available depending on the media stream.
	PadSometimes
	// PadRequest: pad is only available on request with
	// gst_element_request_pad().
	PadRequest
)

func marshalPadPresence(p uintptr) (interface{}, error) {
	return PadPresence(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PadPresence.
func (p PadPresence) String() string {
	switch p {
	case PadAlways:
		return "Always"
	case PadSometimes:
		return "Sometimes"
	case PadRequest:
		return "Request"
	default:
		return fmt.Sprintf("PadPresence(%d)", p)
	}
}

// PadProbeReturn: different return values for the PadProbeCallback.
type PadProbeReturn C.gint

const (
	// PadProbeDrop: drop data in data probes. For push mode this means that the
	// data item is not sent downstream. For pull mode, it means that the data
	// item is not passed upstream. In both cases, no other probes are called
	// for this item and GST_FLOW_OK or TRUE is returned to the caller.
	PadProbeDrop PadProbeReturn = iota
	// PadProbeOK: normal probe return value. This leaves the probe in place,
	// and defers decisions about dropping or passing data to other probes,
	// if any. If there are no other probes, the default behaviour for the probe
	// type applies ('block' for blocking probes, and 'pass' for non-blocking
	// probes).
	PadProbeOK
	// PadProbeRemove: remove this probe, passing the data. For blocking
	// probes this will cause data flow to unblock, unless there are also other
	// blocking probes installed.
	PadProbeRemove
	// PadProbePass pass the data item in the block probe and block on the next
	// item. Note, that if there are multiple pad probes installed and any probe
	// returns PASS, the data will be passed.
	PadProbePass
	// PadProbeHandled: data has been handled in the probe and will not be
	// forwarded further. For events and buffers this is the same behaviour
	// as GST_PAD_PROBE_DROP (except that in this case you need to unref the
	// buffer or event yourself). For queries it will also return TRUE to the
	// caller. The probe can also modify the FlowReturn value by using the
	// T_PAD_PROBE_INFO_FLOW_RETURN() accessor. Note that the resulting query
	// must contain valid entries. Since: 1.6.
	PadProbeHandled
)

func marshalPadProbeReturn(p uintptr) (interface{}, error) {
	return PadProbeReturn(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PadProbeReturn.
func (p PadProbeReturn) String() string {
	switch p {
	case PadProbeDrop:
		return "Drop"
	case PadProbeOK:
		return "OK"
	case PadProbeRemove:
		return "Remove"
	case PadProbePass:
		return "Pass"
	case PadProbeHandled:
		return "Handled"
	default:
		return fmt.Sprintf("PadProbeReturn(%d)", p)
	}
}

// ParseError: different parsing errors that can occur.
type ParseError C.gint

const (
	// ParseErrorSyntax: syntax error occurred.
	ParseErrorSyntax ParseError = iota
	// ParseErrorNoSuchElement: description contained an unknown element.
	ParseErrorNoSuchElement
	// ParseErrorNoSuchProperty: element did not have a specified property.
	ParseErrorNoSuchProperty
	// ParseErrorLink: there was an error linking two pads.
	ParseErrorLink
	// ParseErrorCouldNotSetProperty: there was an error setting a property.
	ParseErrorCouldNotSetProperty
	// ParseErrorEmptyBin: empty bin was specified.
	ParseErrorEmptyBin
	// ParseErrorEmpty: empty description was specified.
	ParseErrorEmpty
	// ParseErrorDelayedLink: delayed link did not get resolved.
	ParseErrorDelayedLink
)

func marshalParseError(p uintptr) (interface{}, error) {
	return ParseError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ParseError.
func (p ParseError) String() string {
	switch p {
	case ParseErrorSyntax:
		return "Syntax"
	case ParseErrorNoSuchElement:
		return "NoSuchElement"
	case ParseErrorNoSuchProperty:
		return "NoSuchProperty"
	case ParseErrorLink:
		return "Link"
	case ParseErrorCouldNotSetProperty:
		return "CouldNotSetProperty"
	case ParseErrorEmptyBin:
		return "EmptyBin"
	case ParseErrorEmpty:
		return "Empty"
	case ParseErrorDelayedLink:
		return "DelayedLink"
	default:
		return fmt.Sprintf("ParseError(%d)", p)
	}
}

// ParseErrorQuark: get the error quark used by the parsing subsystem.
//
// The function returns the following values:
//
//   - quark of the parse errors.
func ParseErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gst_parse_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// PluginError: plugin loading errors.
type PluginError C.gint

const (
	// PluginErrorModule: plugin could not be loaded.
	PluginErrorModule PluginError = iota
	// PluginErrorDependencies: plugin has unresolved dependencies.
	PluginErrorDependencies
	// PluginErrorNameMismatch: plugin has already be loaded from a different
	// file.
	PluginErrorNameMismatch
)

func marshalPluginError(p uintptr) (interface{}, error) {
	return PluginError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PluginError.
func (p PluginError) String() string {
	switch p {
	case PluginErrorModule:
		return "Module"
	case PluginErrorDependencies:
		return "Dependencies"
	case PluginErrorNameMismatch:
		return "NameMismatch"
	default:
		return fmt.Sprintf("PluginError(%d)", p)
	}
}

// PluginErrorQuark: get the error quark.
//
// The function returns the following values:
//
//   - quark: error quark used in GError messages.
func PluginErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gst_plugin_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// ProgressType: type of a GST_MESSAGE_PROGRESS. The progress messages inform
// the application of the status of asynchronous tasks.
type ProgressType C.gint

const (
	// ProgressTypeStart: new task started.
	ProgressTypeStart ProgressType = iota
	// ProgressTypeContinue: task completed and a new one continues.
	ProgressTypeContinue
	// ProgressTypeComplete: task completed.
	ProgressTypeComplete
	// ProgressTypeCanceled: task was canceled.
	ProgressTypeCanceled
	// ProgressTypeError: task caused an error. An error message is also posted
	// on the bus.
	ProgressTypeError
)

func marshalProgressType(p uintptr) (interface{}, error) {
	return ProgressType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ProgressType.
func (p ProgressType) String() string {
	switch p {
	case ProgressTypeStart:
		return "Start"
	case ProgressTypeContinue:
		return "Continue"
	case ProgressTypeComplete:
		return "Complete"
	case ProgressTypeCanceled:
		return "Canceled"
	case ProgressTypeError:
		return "Error"
	default:
		return fmt.Sprintf("ProgressType(%d)", p)
	}
}

// PromiseResult: result of a Promise.
type PromiseResult C.gint

const (
	// PromiseResultPending: initial state. Waiting for transition to any other
	// state.
	PromiseResultPending PromiseResult = iota
	// PromiseResultInterrupted: interrupted by the consumer as it doesn't want
	// the value anymore.
	PromiseResultInterrupted
	// PromiseResultReplied: producer marked a reply.
	PromiseResultReplied
	// PromiseResultExpired: promise expired (the carrying object lost all refs)
	// and the promise will never be fulfilled.
	PromiseResultExpired
)

func marshalPromiseResult(p uintptr) (interface{}, error) {
	return PromiseResult(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PromiseResult.
func (p PromiseResult) String() string {
	switch p {
	case PromiseResultPending:
		return "Pending"
	case PromiseResultInterrupted:
		return "Interrupted"
	case PromiseResultReplied:
		return "Replied"
	case PromiseResultExpired:
		return "Expired"
	default:
		return fmt.Sprintf("PromiseResult(%d)", p)
	}
}

// QOSType: different types of QoS events that can be given to the
// gst_event_new_qos() method.
type QOSType C.gint

const (
	// QosTypeOverflow: qoS event type that is produced when upstream elements
	// are producing data too quickly and the element can't keep up processing
	// the data. Upstream should reduce their production rate. This type is also
	// used when buffers arrive early or in time.
	QosTypeOverflow QOSType = iota
	// QosTypeUnderflow: qoS event type that is produced when upstream elements
	// are producing data too slowly and need to speed up their production rate.
	QosTypeUnderflow
	// QosTypeThrottle: qoS event type that is produced when the application
	// enabled throttling to limit the data rate.
	QosTypeThrottle
)

func marshalQOSType(p uintptr) (interface{}, error) {
	return QOSType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for QOSType.
func (q QOSType) String() string {
	switch q {
	case QosTypeOverflow:
		return "Overflow"
	case QosTypeUnderflow:
		return "Underflow"
	case QosTypeThrottle:
		return "Throttle"
	default:
		return fmt.Sprintf("QOSType(%d)", q)
	}
}

// QueryType: standard predefined Query types.
type QueryType C.gint

const (
	// QueryUnknown: unknown query type.
	QueryUnknown QueryType = 0
	// QueryPosition: current position in stream.
	QueryPosition QueryType = 2563
	// QueryDuration: total duration of the stream.
	QueryDuration QueryType = 5123
	// QueryLatency: latency of stream.
	QueryLatency QueryType = 7683
	// QueryJitter: current jitter of stream.
	QueryJitter QueryType = 10243
	// QueryRate: current rate of the stream.
	QueryRate QueryType = 12803
	// QuerySeeking: seeking capabilities.
	QuerySeeking QueryType = 15363
	// QuerySegment: segment start/stop positions.
	QuerySegment QueryType = 17923
	// QueryConvert: convert values between formats.
	QueryConvert QueryType = 20483
	// QueryFormats: query supported formats for convert.
	QueryFormats QueryType = 23043
	// QueryBuffering: query available media for efficient seeking.
	QueryBuffering QueryType = 28163
	// QueryCustom: custom application or element defined query.
	QueryCustom QueryType = 30723
	// QueryURI: query the URI of the source or sink.
	QueryURI QueryType = 33283
	// QueryAllocation: buffer allocation properties.
	QueryAllocation QueryType = 35846
	// QueryScheduling: scheduling properties.
	QueryScheduling QueryType = 38401
	// QueryAcceptCaps: accept caps query.
	QueryAcceptCaps QueryType = 40963
	// QueryCaps caps query.
	QueryCaps QueryType = 43523
	// QueryDrain: wait till all serialized data is consumed downstream.
	QueryDrain QueryType = 46086
	// QueryContext: query the pipeline-local context from downstream or
	// upstream (since 1.2).
	QueryContext QueryType = 48643
	// QueryBitrate: bitrate query (since 1.16).
	QueryBitrate QueryType = 51202
	// QuerySelectable: query stream selection capability.
	QuerySelectable QueryType = 53763
)

func marshalQueryType(p uintptr) (interface{}, error) {
	return QueryType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for QueryType.
func (q QueryType) String() string {
	switch q {
	case QueryUnknown:
		return "Unknown"
	case QueryPosition:
		return "Position"
	case QueryDuration:
		return "Duration"
	case QueryLatency:
		return "Latency"
	case QueryJitter:
		return "Jitter"
	case QueryRate:
		return "Rate"
	case QuerySeeking:
		return "Seeking"
	case QuerySegment:
		return "Segment"
	case QueryConvert:
		return "Convert"
	case QueryFormats:
		return "Formats"
	case QueryBuffering:
		return "Buffering"
	case QueryCustom:
		return "Custom"
	case QueryURI:
		return "URI"
	case QueryAllocation:
		return "Allocation"
	case QueryScheduling:
		return "Scheduling"
	case QueryAcceptCaps:
		return "AcceptCaps"
	case QueryCaps:
		return "Caps"
	case QueryDrain:
		return "Drain"
	case QueryContext:
		return "Context"
	case QueryBitrate:
		return "Bitrate"
	case QuerySelectable:
		return "Selectable"
	default:
		return fmt.Sprintf("QueryType(%d)", q)
	}
}

// QueryTypeGetFlags gets the QueryTypeFlags associated with type.
//
// The function takes the following parameters:
//
//   - typ: QueryType.
//
// The function returns the following values:
//
//   - queryTypeFlags: QueryTypeFlags.
func QueryTypeGetFlags(typ QueryType) QueryTypeFlags {
	var _arg1 C.GstQueryType      // out
	var _cret C.GstQueryTypeFlags // in

	_arg1 = C.GstQueryType(typ)

	_cret = C.gst_query_type_get_flags(_arg1)
	runtime.KeepAlive(typ)

	var _queryTypeFlags QueryTypeFlags // out

	_queryTypeFlags = QueryTypeFlags(_cret)

	return _queryTypeFlags
}

// QueryTypeGetName: get a printable name for the given query type. Do not
// modify or free.
//
// The function takes the following parameters:
//
//   - typ: query type.
//
// The function returns the following values:
//
//   - utf8: reference to the static name of the query.
func QueryTypeGetName(typ QueryType) string {
	var _arg1 C.GstQueryType // out
	var _cret *C.gchar       // in

	_arg1 = C.GstQueryType(typ)

	_cret = C.gst_query_type_get_name(_arg1)
	runtime.KeepAlive(typ)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// QueryTypeToQuark: get the unique quark for the given query type.
//
// The function takes the following parameters:
//
//   - typ: query type.
//
// The function returns the following values:
//
//   - quark associated with the query type.
func QueryTypeToQuark(typ QueryType) glib.Quark {
	var _arg1 C.GstQueryType // out
	var _cret C.GQuark       // in

	_arg1 = C.GstQueryType(typ)

	_cret = C.gst_query_type_to_quark(_arg1)
	runtime.KeepAlive(typ)

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// Rank: element priority ranks. Defines the order in which the autoplugger (or
// similar rank-picking mechanisms, such as e.g. gst_element_make_from_uri())
// will choose this element over an alternative one with the same function.
//
// These constants serve as a rough guidance for defining the rank of
// a PluginFeature. Any value is valid, including values bigger than
// GST_RANK_PRIMARY.
type Rank C.gint

const (
	// RankNone will be chosen last or not at all.
	RankNone Rank = 0
	// RankMarginal: unlikely to be chosen.
	RankMarginal Rank = 64
	// RankSecondary: likely to be chosen.
	RankSecondary Rank = 128
	// RankPrimary will be chosen first.
	RankPrimary Rank = 256
)

func marshalRank(p uintptr) (interface{}, error) {
	return Rank(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Rank.
func (r Rank) String() string {
	switch r {
	case RankNone:
		return "None"
	case RankMarginal:
		return "Marginal"
	case RankSecondary:
		return "Secondary"
	case RankPrimary:
		return "Primary"
	default:
		return fmt.Sprintf("Rank(%d)", r)
	}
}

// ResourceError: resource errors are for any resource used by an element:
// memory, files, network connections, process space, ... They're typically used
// by source and sink elements.
type ResourceError C.gint

const (
	// ResourceErrorFailed: general error which doesn't fit in any other
	// category. Make sure you add a custom message to the error call.
	ResourceErrorFailed ResourceError = 1
	// ResourceErrorTooLaZY: do not use this except as a placeholder for
	// deciding where to go while developing code.
	ResourceErrorTooLaZY ResourceError = 2
	// ResourceErrorNotFound: used when the resource could not be found.
	ResourceErrorNotFound ResourceError = 3
	// ResourceErrorBusy: used when resource is busy.
	ResourceErrorBusy ResourceError = 4
	// ResourceErrorOpenRead: used when resource fails to open for reading.
	ResourceErrorOpenRead ResourceError = 5
	// ResourceErrorOpenWrite: used when resource fails to open for writing.
	ResourceErrorOpenWrite ResourceError = 6
	// ResourceErrorOpenReadWrite: used when resource cannot be opened for both
	// reading and writing, or either (but unspecified which).
	ResourceErrorOpenReadWrite ResourceError = 7
	// ResourceErrorClose: used when the resource can't be closed.
	ResourceErrorClose ResourceError = 8
	// ResourceErrorRead: used when the resource can't be read from.
	ResourceErrorRead ResourceError = 9
	// ResourceErrorWrite: used when the resource can't be written to.
	ResourceErrorWrite ResourceError = 10
	// ResourceErrorSeek: used when a seek on the resource fails.
	ResourceErrorSeek ResourceError = 11
	// ResourceErrorSync: used when a synchronize on the resource fails.
	ResourceErrorSync ResourceError = 12
	// ResourceErrorSettings: used when settings can't be manipulated on.
	ResourceErrorSettings ResourceError = 13
	// ResourceErrorNoSpaceLeft: used when the resource has no space left.
	ResourceErrorNoSpaceLeft ResourceError = 14
	// ResourceErrorNotAuthorized: used when the resource can't be opened due to
	// missing authorization. (Since: 1.2.4).
	ResourceErrorNotAuthorized ResourceError = 15
	// ResourceErrorNumErrors: number of resource error types.
	ResourceErrorNumErrors ResourceError = 16
)

func marshalResourceError(p uintptr) (interface{}, error) {
	return ResourceError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ResourceError.
func (r ResourceError) String() string {
	switch r {
	case ResourceErrorFailed:
		return "Failed"
	case ResourceErrorTooLaZY:
		return "TooLaZY"
	case ResourceErrorNotFound:
		return "NotFound"
	case ResourceErrorBusy:
		return "Busy"
	case ResourceErrorOpenRead:
		return "OpenRead"
	case ResourceErrorOpenWrite:
		return "OpenWrite"
	case ResourceErrorOpenReadWrite:
		return "OpenReadWrite"
	case ResourceErrorClose:
		return "Close"
	case ResourceErrorRead:
		return "Read"
	case ResourceErrorWrite:
		return "Write"
	case ResourceErrorSeek:
		return "Seek"
	case ResourceErrorSync:
		return "Sync"
	case ResourceErrorSettings:
		return "Settings"
	case ResourceErrorNoSpaceLeft:
		return "NoSpaceLeft"
	case ResourceErrorNotAuthorized:
		return "NotAuthorized"
	case ResourceErrorNumErrors:
		return "NumErrors"
	default:
		return fmt.Sprintf("ResourceError(%d)", r)
	}
}

func ResourceErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gst_resource_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// SearchMode: different search modes.
type SearchMode C.gint

const (
	// SearchModeExact: only search for exact matches.
	SearchModeExact SearchMode = iota
	// SearchModeBefore: search for an exact match or the element just before.
	SearchModeBefore
	// SearchModeAfter: search for an exact match or the element just after.
	SearchModeAfter
)

func marshalSearchMode(p uintptr) (interface{}, error) {
	return SearchMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SearchMode.
func (s SearchMode) String() string {
	switch s {
	case SearchModeExact:
		return "Exact"
	case SearchModeBefore:
		return "Before"
	case SearchModeAfter:
		return "After"
	default:
		return fmt.Sprintf("SearchMode(%d)", s)
	}
}

// SeekType: different types of seek events. When constructing a seek event with
// gst_event_new_seek() or when doing gst_segment_do_seek ().
type SeekType C.gint

const (
	// SeekTypeNone: no change in position is required.
	SeekTypeNone SeekType = iota
	// SeekTypeSet: absolute position is requested.
	SeekTypeSet
	// SeekTypeEnd: relative position to duration is requested.
	SeekTypeEnd
)

func marshalSeekType(p uintptr) (interface{}, error) {
	return SeekType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SeekType.
func (s SeekType) String() string {
	switch s {
	case SeekTypeNone:
		return "None"
	case SeekTypeSet:
		return "Set"
	case SeekTypeEnd:
		return "End"
	default:
		return fmt.Sprintf("SeekType(%d)", s)
	}
}

// State: possible states an element can be in. States can be changed using
// gst_element_set_state() and checked using gst_element_get_state().
type State C.gint

const (
	// StateVoidPending: no pending state.
	StateVoidPending State = iota
	// StateNull: NULL state or initial state of an element.
	StateNull
	// StateReady: element is ready to go to PAUSED.
	StateReady
	// StatePaused: element is PAUSED, it is ready to accept and process data.
	// Sink elements however only accept one buffer and then block.
	StatePaused
	// StatePlaying: element is PLAYING, the Clock is running and the data is
	// flowing.
	StatePlaying
)

func marshalState(p uintptr) (interface{}, error) {
	return State(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for State.
func (s State) String() string {
	switch s {
	case StateVoidPending:
		return "VoidPending"
	case StateNull:
		return "Null"
	case StateReady:
		return "Ready"
	case StatePaused:
		return "Paused"
	case StatePlaying:
		return "Playing"
	default:
		return fmt.Sprintf("State(%d)", s)
	}
}

// StateChange: these are the different state changes an element goes through.
// GST_STATE_NULL &rArr; GST_STATE_PLAYING is called an upwards state change and
// GST_STATE_PLAYING &rArr; GST_STATE_NULL a downwards state change.
type StateChange C.gint

const (
	// StateChangeNullToReady: state change from NULL to READY. * The element
	// must check if the resources it needs are available. Device sinks and
	// -sources typically try to probe the device to constrain their caps.
	// * The element opens the device (in case feature need to be probed).
	StateChangeNullToReady StateChange = 10
	// StateChangeReadyToPaused: state change from READY to PAUSED.
	// * The element pads are activated in order to receive data in PAUSED.
	// Streaming threads are started. * Some elements might need to return
	// GST_STATE_CHANGE_ASYNC and complete the state change when they
	// have enough information. It is a requirement for sinks to return
	// GST_STATE_CHANGE_ASYNC and complete the state change when they receive
	// the first buffer or GST_EVENT_EOS (preroll). Sinks also block the
	// dataflow when in PAUSED. * A pipeline resets the running_time to 0. *
	// Live sources return GST_STATE_CHANGE_NO_PREROLL and don't generate data.
	StateChangeReadyToPaused StateChange = 19
	// StateChangePausedToPlaying: state change from PAUSED to PLAYING.
	// * Most elements ignore this state change. * The pipeline selects a Clock
	// and distributes this to all the children before setting them to PLAYING.
	// This means that it is only allowed to synchronize on the Clock in the
	// PLAYING state. * The pipeline uses the Clock and the running_time to
	// calculate the base_time. The base_time is distributed to all children
	// when performing the state change. * Sink elements stop blocking on
	// the preroll buffer or event and start rendering the data. * Sinks can
	// post GST_MESSAGE_EOS in the PLAYING state. It is not allowed to post
	// GST_MESSAGE_EOS when not in the PLAYING state. * While streaming in
	// PAUSED or PLAYING elements can create and remove sometimes pads. * Live
	// sources start generating data and return GST_STATE_CHANGE_SUCCESS.
	StateChangePausedToPlaying StateChange = 28
	// StateChangePlayingToPaused: state change from PLAYING to PAUSED.
	// * Most elements ignore this state change. * The pipeline calculates
	// the running_time based on the last selected Clock and the base_time.
	// It stores this information to continue playback when going back to the
	// PLAYING state. * Sinks unblock any Clock wait calls. * When a sink does
	// not have a pending buffer to play, it returns T_STATE_CHANGE_ASYNC from
	// this state change and completes the state change when it receives a
	// new buffer or an GST_EVENT_EOS. * Any queued GST_MESSAGE_EOS items are
	// removed since they will be reposted when going back to the PLAYING state.
	// The EOS messages are queued in Bin containers. * Live sources stop
	// generating data and return GST_STATE_CHANGE_NO_PREROLL.
	StateChangePlayingToPaused StateChange = 35
	// StateChangePausedToReady: state change from PAUSED to READY.
	// * Sinks unblock any waits in the preroll. * Elements unblock any waits
	// on devices * Chain or get_range functions return GST_FLOW_FLUSHING.
	// * The element pads are deactivated so that streaming becomes impossible
	// and all streaming threads are stopped. * The sink forgets all negotiated
	// formats * Elements remove all sometimes pads.
	StateChangePausedToReady StateChange = 26
	// StateChangeReadyToNull: state change from READY to NULL. * Elements close
	// devices * Elements reset any internal state.
	StateChangeReadyToNull StateChange = 17
	// StateChangeNullToNull: state change from NULL to NULL. (Since: 1.14).
	StateChangeNullToNull StateChange = 9
	// StateChangeReadyToReady: state change from READY to READY, This might
	// happen when going to PAUSED asynchronously failed, in that case elements
	// should make sure they are in a proper, coherent READY state. (Since:
	// 1.14).
	StateChangeReadyToReady StateChange = 18
	// StateChangePausedToPaused: state change from PAUSED to PAUSED. This might
	// happen when elements were in PLAYING state and 'lost state', they should
	// make sure to go back to real 'PAUSED' state (prerolling for example).
	// (Since: 1.14).
	StateChangePausedToPaused StateChange = 27
	// StateChangePlayingToPlaying: state change from PLAYING to PLAYING.
	// (Since: 1.14).
	StateChangePlayingToPlaying StateChange = 36
)

func marshalStateChange(p uintptr) (interface{}, error) {
	return StateChange(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for StateChange.
func (s StateChange) String() string {
	switch s {
	case StateChangeNullToReady:
		return "NullToReady"
	case StateChangeReadyToPaused:
		return "ReadyToPaused"
	case StateChangePausedToPlaying:
		return "PausedToPlaying"
	case StateChangePlayingToPaused:
		return "PlayingToPaused"
	case StateChangePausedToReady:
		return "PausedToReady"
	case StateChangeReadyToNull:
		return "ReadyToNull"
	case StateChangeNullToNull:
		return "NullToNull"
	case StateChangeReadyToReady:
		return "ReadyToReady"
	case StateChangePausedToPaused:
		return "PausedToPaused"
	case StateChangePlayingToPlaying:
		return "PlayingToPlaying"
	default:
		return fmt.Sprintf("StateChange(%d)", s)
	}
}

// StateChangeGetName gets a string representing the given state transition.
//
// The function takes the following parameters:
//
//   - transition to get the name of.
//
// The function returns the following values:
//
//   - utf8: string with the name of the state result.
func StateChangeGetName(transition StateChange) string {
	var _arg1 C.GstStateChange // out
	var _cret *C.gchar         // in

	_arg1 = C.GstStateChange(transition)

	_cret = C.gst_state_change_get_name(_arg1)
	runtime.KeepAlive(transition)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// StateChangeReturn: possible return values from a state change function such
// as gst_element_set_state(). Only GST_STATE_CHANGE_FAILURE is a real failure.
type StateChangeReturn C.gint

const (
	// StateChangeFailure: state change failed.
	StateChangeFailure StateChangeReturn = iota
	// StateChangeSuccess: state change succeeded.
	StateChangeSuccess
	// StateChangeAsync: state change will happen asynchronously.
	StateChangeAsync
	// StateChangeNoPreroll: state change succeeded but the element cannot
	// produce data in GST_STATE_PAUSED. This typically happens with live
	// sources.
	StateChangeNoPreroll
)

func marshalStateChangeReturn(p uintptr) (interface{}, error) {
	return StateChangeReturn(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for StateChangeReturn.
func (s StateChangeReturn) String() string {
	switch s {
	case StateChangeFailure:
		return "Failure"
	case StateChangeSuccess:
		return "Success"
	case StateChangeAsync:
		return "Async"
	case StateChangeNoPreroll:
		return "NoPreroll"
	default:
		return fmt.Sprintf("StateChangeReturn(%d)", s)
	}
}

// StreamError: stream errors are for anything related to the stream being
// processed: format errors, media type errors, ... They're typically used by
// decoders, demuxers, converters, ...
type StreamError C.gint

const (
	// StreamErrorFailed: general error which doesn't fit in any other category.
	// Make sure you add a custom message to the error call.
	StreamErrorFailed StreamError = 1
	// StreamErrorTooLaZY: do not use this except as a placeholder for deciding
	// where to go while developing code.
	StreamErrorTooLaZY StreamError = 2
	// StreamErrorNotImplemented: use this when you do not want to implement
	// this functionality yet.
	StreamErrorNotImplemented StreamError = 3
	// StreamErrorTypeNotFound: used when the element doesn't know the stream's
	// type.
	StreamErrorTypeNotFound StreamError = 4
	// StreamErrorWrongType: used when the element doesn't handle this type of
	// stream.
	StreamErrorWrongType StreamError = 5
	// StreamErrorCodecNotFound: used when there's no codec to handle the
	// stream's type.
	StreamErrorCodecNotFound StreamError = 6
	// StreamErrorDecode: used when decoding fails.
	StreamErrorDecode StreamError = 7
	// StreamErrorEncode: used when encoding fails.
	StreamErrorEncode StreamError = 8
	// StreamErrorDemux: used when demuxing fails.
	StreamErrorDemux StreamError = 9
	// StreamErrorMux: used when muxing fails.
	StreamErrorMux StreamError = 10
	// StreamErrorFormat: used when the stream is of the wrong format (for
	// example, wrong caps).
	StreamErrorFormat StreamError = 11
	// StreamErrorDecrypt: used when the stream is encrypted and can't be
	// decrypted because this is not supported by the element.
	StreamErrorDecrypt StreamError = 12
	// StreamErrorDecryptNokey: used when the stream is encrypted and can't be
	// decrypted because no suitable key is available.
	StreamErrorDecryptNokey StreamError = 13
	// StreamErrorNumErrors: number of stream error types.
	StreamErrorNumErrors StreamError = 14
)

func marshalStreamError(p uintptr) (interface{}, error) {
	return StreamError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for StreamError.
func (s StreamError) String() string {
	switch s {
	case StreamErrorFailed:
		return "Failed"
	case StreamErrorTooLaZY:
		return "TooLaZY"
	case StreamErrorNotImplemented:
		return "NotImplemented"
	case StreamErrorTypeNotFound:
		return "TypeNotFound"
	case StreamErrorWrongType:
		return "WrongType"
	case StreamErrorCodecNotFound:
		return "CodecNotFound"
	case StreamErrorDecode:
		return "Decode"
	case StreamErrorEncode:
		return "Encode"
	case StreamErrorDemux:
		return "Demux"
	case StreamErrorMux:
		return "Mux"
	case StreamErrorFormat:
		return "Format"
	case StreamErrorDecrypt:
		return "Decrypt"
	case StreamErrorDecryptNokey:
		return "DecryptNokey"
	case StreamErrorNumErrors:
		return "NumErrors"
	default:
		return fmt.Sprintf("StreamError(%d)", s)
	}
}

func StreamErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gst_stream_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// StreamStatusType: type of a GST_MESSAGE_STREAM_STATUS. The stream status
// messages inform the application of new streaming threads and their status.
type StreamStatusType C.gint

const (
	// StreamStatusTypeCreate: new thread need to be created.
	StreamStatusTypeCreate StreamStatusType = 0
	// StreamStatusTypeEnter: thread entered its loop function.
	StreamStatusTypeEnter StreamStatusType = 1
	// StreamStatusTypeLeave: thread left its loop function.
	StreamStatusTypeLeave StreamStatusType = 2
	// StreamStatusTypeDestroy: thread is destroyed.
	StreamStatusTypeDestroy StreamStatusType = 3
	// StreamStatusTypeStart: thread is started.
	StreamStatusTypeStart StreamStatusType = 8
	// StreamStatusTypePause: thread is paused.
	StreamStatusTypePause StreamStatusType = 9
	// StreamStatusTypeStop: thread is stopped.
	StreamStatusTypeStop StreamStatusType = 10
)

func marshalStreamStatusType(p uintptr) (interface{}, error) {
	return StreamStatusType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for StreamStatusType.
func (s StreamStatusType) String() string {
	switch s {
	case StreamStatusTypeCreate:
		return "Create"
	case StreamStatusTypeEnter:
		return "Enter"
	case StreamStatusTypeLeave:
		return "Leave"
	case StreamStatusTypeDestroy:
		return "Destroy"
	case StreamStatusTypeStart:
		return "Start"
	case StreamStatusTypePause:
		return "Pause"
	case StreamStatusTypeStop:
		return "Stop"
	default:
		return fmt.Sprintf("StreamStatusType(%d)", s)
	}
}

// StructureChangeType: type of a GST_MESSAGE_STRUCTURE_CHANGE.
type StructureChangeType C.gint

const (
	// StructureChangeTypePadLink: pad linking is starting or done.
	StructureChangeTypePadLink StructureChangeType = iota
	// StructureChangeTypePadUnlink: pad unlinking is starting or done.
	StructureChangeTypePadUnlink
)

func marshalStructureChangeType(p uintptr) (interface{}, error) {
	return StructureChangeType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for StructureChangeType.
func (s StructureChangeType) String() string {
	switch s {
	case StructureChangeTypePadLink:
		return "Link"
	case StructureChangeTypePadUnlink:
		return "Unlink"
	default:
		return fmt.Sprintf("StructureChangeType(%d)", s)
	}
}

// TagFlag: extra tag flags used when registering tags.
type TagFlag C.gint

const (
	// TagFlagUndefined: undefined flag.
	TagFlagUndefined TagFlag = iota
	// TagFlagMeta: tag is meta data.
	TagFlagMeta
	// TagFlagEncoded: tag is encoded.
	TagFlagEncoded
	// TagFlagDecoded: tag is decoded.
	TagFlagDecoded
	// TagFlagCount: number of tag flags.
	TagFlagCount
)

func marshalTagFlag(p uintptr) (interface{}, error) {
	return TagFlag(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TagFlag.
func (t TagFlag) String() string {
	switch t {
	case TagFlagUndefined:
		return "Undefined"
	case TagFlagMeta:
		return "Meta"
	case TagFlagEncoded:
		return "Encoded"
	case TagFlagDecoded:
		return "Decoded"
	case TagFlagCount:
		return "Count"
	default:
		return fmt.Sprintf("TagFlag(%d)", t)
	}
}

// TagMergeMode: different tag merging modes are basically replace, overwrite
// and append, but they can be seen from two directions. Given two taglists:
// (A) the tags already in the element and (B) the ones that are supplied to the
// element ( e.g. via gst_tag_setter_merge_tags() / gst_tag_setter_add_tags() or
// a GST_EVENT_TAG), how are these tags merged? In the table below this is shown
// for the cases that a tag exists in the list (A) or does not exists (!A) and
// combinations thereof.
//
// | merge mode | A + B | A + !B | !A + B | !A + !B | | ----------- | ----- |
// ------ | ------ | ------- | | REPLACE_ALL | B | ø | B | ø | | REPLACE | B | A
// | B | ø | | APPEND | A, B | A | B | ø | | PREPEND | B, A | A | B | ø | | KEEP
// | A | A | B | ø | | KEEP_ALL | A | A | ø | ø |.
type TagMergeMode C.gint

const (
	// TagMergeUndefined: undefined merge mode.
	TagMergeUndefined TagMergeMode = iota
	// TagMergeReplaceAll: replace all tags (clear list and append).
	TagMergeReplaceAll
	// TagMergeReplace: replace tags.
	TagMergeReplace
	// TagMergeAppend: append tags.
	TagMergeAppend
	// TagMergePrepend: prepend tags.
	TagMergePrepend
	// TagMergeKeep: keep existing tags.
	TagMergeKeep
	// TagMergeKeepAll: keep all existing tags.
	TagMergeKeepAll
	// TagMergeCount: number of merge modes.
	TagMergeCount
)

func marshalTagMergeMode(p uintptr) (interface{}, error) {
	return TagMergeMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TagMergeMode.
func (t TagMergeMode) String() string {
	switch t {
	case TagMergeUndefined:
		return "Undefined"
	case TagMergeReplaceAll:
		return "ReplaceAll"
	case TagMergeReplace:
		return "Replace"
	case TagMergeAppend:
		return "Append"
	case TagMergePrepend:
		return "Prepend"
	case TagMergeKeep:
		return "Keep"
	case TagMergeKeepAll:
		return "KeepAll"
	case TagMergeCount:
		return "Count"
	default:
		return fmt.Sprintf("TagMergeMode(%d)", t)
	}
}

// TagScope specifies if a taglist applies to the complete medium or only to one
// single stream.
type TagScope C.gint

const (
	// TagScopeStream tags specific to this single stream.
	TagScopeStream TagScope = iota
	// TagScopeGlobal: global tags for the complete medium.
	TagScopeGlobal
)

func marshalTagScope(p uintptr) (interface{}, error) {
	return TagScope(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TagScope.
func (t TagScope) String() string {
	switch t {
	case TagScopeStream:
		return "Stream"
	case TagScopeGlobal:
		return "Global"
	default:
		return fmt.Sprintf("TagScope(%d)", t)
	}
}

// TaskState: different states a task can be in.
type TaskState C.gint

const (
	// TaskStarted: task is started and running.
	TaskStarted TaskState = iota
	// TaskStopped: task is stopped.
	TaskStopped
	// TaskPaused: task is paused.
	TaskPaused
)

func marshalTaskState(p uintptr) (interface{}, error) {
	return TaskState(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TaskState.
func (t TaskState) String() string {
	switch t {
	case TaskStarted:
		return "Started"
	case TaskStopped:
		return "Stopped"
	case TaskPaused:
		return "Paused"
	default:
		return fmt.Sprintf("TaskState(%d)", t)
	}
}

// TocEntryType: different types of TOC entries (see TocEntry).
//
// There are two types of TOC entries: alternatives or parts in a sequence.
type TocEntryType C.gint

const (
	// TocEntryTypeAngle: entry is an angle (i.e. an alternative).
	TocEntryTypeAngle TocEntryType = -3
	// TocEntryTypeVersion: entry is a version (i.e. alternative).
	TocEntryTypeVersion TocEntryType = -2
	// TocEntryTypeEdition: entry is an edition (i.e. alternative).
	TocEntryTypeEdition TocEntryType = -1
	// TocEntryTypeInvalid: invalid entry type value.
	TocEntryTypeInvalid TocEntryType = 0
	// TocEntryTypeTitle: entry is a title (i.e. a part of a sequence).
	TocEntryTypeTitle TocEntryType = 1
	// TocEntryTypeTrack: entry is a track (i.e. a part of a sequence).
	TocEntryTypeTrack TocEntryType = 2
	// TocEntryTypeChapter: entry is a chapter (i.e. a part of a sequence).
	TocEntryTypeChapter TocEntryType = 3
)

func marshalTocEntryType(p uintptr) (interface{}, error) {
	return TocEntryType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TocEntryType.
func (t TocEntryType) String() string {
	switch t {
	case TocEntryTypeAngle:
		return "Angle"
	case TocEntryTypeVersion:
		return "Version"
	case TocEntryTypeEdition:
		return "Edition"
	case TocEntryTypeInvalid:
		return "Invalid"
	case TocEntryTypeTitle:
		return "Title"
	case TocEntryTypeTrack:
		return "Track"
	case TocEntryTypeChapter:
		return "Chapter"
	default:
		return fmt.Sprintf("TocEntryType(%d)", t)
	}
}

// TocEntryTypeGetNick converts type to a string representation.
//
// The function takes the following parameters:
//
//   - typ: TocEntryType.
//
// The function returns the following values:
//
//   - utf8 returns a human-readable string for type. This string is only for
//     debugging purpose and should not be displayed in a user interface.
func TocEntryTypeGetNick(typ TocEntryType) string {
	var _arg1 C.GstTocEntryType // out
	var _cret *C.gchar          // in

	_arg1 = C.GstTocEntryType(typ)

	_cret = C.gst_toc_entry_type_get_nick(_arg1)
	runtime.KeepAlive(typ)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TocLoopType: how a TocEntry should be repeated. By default, entries are
// played a single time.
type TocLoopType C.gint

const (
	// TocLoopNone: single forward playback.
	TocLoopNone TocLoopType = iota
	// TocLoopForward: repeat forward.
	TocLoopForward
	// TocLoopReverse: repeat backward.
	TocLoopReverse
	// TocLoopPingPong: repeat forward and backward.
	TocLoopPingPong
)

func marshalTocLoopType(p uintptr) (interface{}, error) {
	return TocLoopType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TocLoopType.
func (t TocLoopType) String() string {
	switch t {
	case TocLoopNone:
		return "None"
	case TocLoopForward:
		return "Forward"
	case TocLoopReverse:
		return "Reverse"
	case TocLoopPingPong:
		return "PingPong"
	default:
		return fmt.Sprintf("TocLoopType(%d)", t)
	}
}

// TocScope: scope of a TOC.
type TocScope C.gint

const (
	// TocScopeGlobal: global TOC representing all selectable options (this is
	// what applications are usually interested in).
	TocScopeGlobal TocScope = 1
	// TocScopeCurrent: TOC for the currently active/selected stream (this is
	// a TOC representing the current stream from start to EOS, and is what
	// a TOC writer / muxer is usually interested in; it will usually be a
	// subset of the global TOC, e.g. just the chapters of the current title,
	// or the chapters selected for playback from the current title).
	TocScopeCurrent TocScope = 2
)

func marshalTocScope(p uintptr) (interface{}, error) {
	return TocScope(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TocScope.
func (t TocScope) String() string {
	switch t {
	case TocScopeGlobal:
		return "Global"
	case TocScopeCurrent:
		return "Current"
	default:
		return fmt.Sprintf("TocScope(%d)", t)
	}
}

// TracerValueScope: tracing record will contain fields that contain a measured
// value or extra meta-data. One such meta data are values that tell where a
// measurement was taken. This enumerating declares to which scope such a meta
// data field relates to. If it is e.g. GST_TRACER_VALUE_SCOPE_PAD, then each of
// the log events may contain values for different Pads.
type TracerValueScope C.gint

const (
	// TracerValueScopeProcess: value is related to the process.
	TracerValueScopeProcess TracerValueScope = iota
	// TracerValueScopeThread: value is related to a thread.
	TracerValueScopeThread
	// TracerValueScopeElement: value is related to an Element.
	TracerValueScopeElement
	// TracerValueScopePad: value is related to a Pad.
	TracerValueScopePad
)

func marshalTracerValueScope(p uintptr) (interface{}, error) {
	return TracerValueScope(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TracerValueScope.
func (t TracerValueScope) String() string {
	switch t {
	case TracerValueScopeProcess:
		return "Process"
	case TracerValueScopeThread:
		return "Thread"
	case TracerValueScopeElement:
		return "Element"
	case TracerValueScopePad:
		return "Pad"
	default:
		return fmt.Sprintf("TracerValueScope(%d)", t)
	}
}

// TypeFindProbability: probability of the typefind function. Higher values have
// more certainty in doing a reliable typefind.
type TypeFindProbability C.gint

const (
	// TypeFindNone: type undetected.
	TypeFindNone TypeFindProbability = 0
	// TypeFindMinimum: unlikely typefind.
	TypeFindMinimum TypeFindProbability = 1
	// TypeFindPossible: possible type detected.
	TypeFindPossible TypeFindProbability = 50
	// TypeFindLikely: likely a type was detected.
	TypeFindLikely TypeFindProbability = 80
	// TypeFindNearlyCertain: nearly certain that a type was detected.
	TypeFindNearlyCertain TypeFindProbability = 99
	// TypeFindMaximum: very certain a type was detected.
	TypeFindMaximum TypeFindProbability = 100
)

func marshalTypeFindProbability(p uintptr) (interface{}, error) {
	return TypeFindProbability(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TypeFindProbability.
func (t TypeFindProbability) String() string {
	switch t {
	case TypeFindNone:
		return "None"
	case TypeFindMinimum:
		return "Minimum"
	case TypeFindPossible:
		return "Possible"
	case TypeFindLikely:
		return "Likely"
	case TypeFindNearlyCertain:
		return "NearlyCertain"
	case TypeFindMaximum:
		return "Maximum"
	default:
		return fmt.Sprintf("TypeFindProbability(%d)", t)
	}
}

// URIError: different URI-related errors that can occur.
type URIError C.gint

const (
	// URIErrorUnsupportedProtocol: protocol is not supported.
	URIErrorUnsupportedProtocol URIError = iota
	// URIErrorBadURI: there was a problem with the URI.
	URIErrorBadURI
	// URIErrorBadState: could not set or change the URI because the URI handler
	// was in a state where that is not possible or not permitted.
	URIErrorBadState
	// URIErrorBadReference: there was a problem with the entity that the URI
	// references.
	URIErrorBadReference
)

func marshalURIError(p uintptr) (interface{}, error) {
	return URIError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for URIError.
func (u URIError) String() string {
	switch u {
	case URIErrorUnsupportedProtocol:
		return "UnsupportedProtocol"
	case URIErrorBadURI:
		return "BadURI"
	case URIErrorBadState:
		return "BadState"
	case URIErrorBadReference:
		return "BadReference"
	default:
		return fmt.Sprintf("URIError(%d)", u)
	}
}

func URIErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gst_uri_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// URIType: different types of URI direction.
type URIType C.gint

const (
	// URIUnknown: URI direction is unknown.
	URIUnknown URIType = iota
	// URISink: URI is a consumer.
	URISink
	// URISrc: URI is a producer.
	URISrc
)

func marshalURIType(p uintptr) (interface{}, error) {
	return URIType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for URIType.
func (u URIType) String() string {
	switch u {
	case URIUnknown:
		return "Unknown"
	case URISink:
		return "Sink"
	case URISrc:
		return "Src"
	default:
		return fmt.Sprintf("URIType(%d)", u)
	}
}

// AllocatorFlags flags for allocators.
type AllocatorFlags C.guint

const (
	// AllocatorFlagCustomAlloc: allocator has a custom alloc function.
	// Only elements designed to work with this allocator should be using it,
	// other elements should ignore it from allocation propositions. This
	// implies GST_ALLOCATOR_FLAG_NO_COPY.
	AllocatorFlagCustomAlloc AllocatorFlags = 0b10000
	// AllocatorFlagNoCopy: when copying a Memory allocated with this allocator,
	// the copy will instead be allocated using the default allocator. Use this
	// when allocating a new memory is an heavy opperation that should only be
	// done with a BufferPool for example.
	AllocatorFlagNoCopy AllocatorFlags = 0b100000
	// AllocatorFlagLast: first flag that can be used for custom purposes.
	AllocatorFlagLast AllocatorFlags = 0b100000000000000000000
)

func marshalAllocatorFlags(p uintptr) (interface{}, error) {
	return AllocatorFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for AllocatorFlags.
func (a AllocatorFlags) String() string {
	if a == 0 {
		return "AllocatorFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(62)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case AllocatorFlagCustomAlloc:
			builder.WriteString("CustomAlloc|")
		case AllocatorFlagNoCopy:
			builder.WriteString("NoCopy|")
		case AllocatorFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("AllocatorFlags(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a AllocatorFlags) Has(other AllocatorFlags) bool {
	return (a & other) == other
}

// BinFlags are a set of flags specific to bins. Most are set/used internally.
// They can be checked using the GST_OBJECT_FLAG_IS_SET() macro, and (un)set
// using GST_OBJECT_FLAG_SET() and GST_OBJECT_FLAG_UNSET().
type BinFlags C.guint

const (
	// BinFlagNoResync: don't resync a state change when elements are added or
	// linked in the bin.
	BinFlagNoResync BinFlags = 0b100000000000000
	// BinFlagStreamsAware indicates whether the bin can handle elements that
	// add/remove source pads at any point in time without first posting a
	// no-more-pads signal.
	BinFlagStreamsAware BinFlags = 0b1000000000000000
	// BinFlagLast: last enum in the series of flags for bins. Derived classes
	// can use this as first value in a list of flags.
	BinFlagLast BinFlags = 0b10000000000000000000
)

func marshalBinFlags(p uintptr) (interface{}, error) {
	return BinFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for BinFlags.
func (b BinFlags) String() string {
	if b == 0 {
		return "BinFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(47)

	for b != 0 {
		next := b & (b - 1)
		bit := b - next

		switch bit {
		case BinFlagNoResync:
			builder.WriteString("NoResync|")
		case BinFlagStreamsAware:
			builder.WriteString("StreamsAware|")
		case BinFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("BinFlags(0b%b)|", bit))
		}

		b = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if b contains other.
func (b BinFlags) Has(other BinFlags) bool {
	return (b & other) == other
}

// BufferCopyFlagsType: set of flags that can be provided to the
// gst_buffer_copy_into() function to specify which items should be copied.
//
// This type has been renamed from BufferCopyFlags.
type BufferCopyFlagsType C.guint

const (
	// BufferCopyNone: copy nothing.
	BufferCopyNone BufferCopyFlagsType = 0b0
	// BufferCopyFlags: flag indicating that buffer flags should be copied.
	BufferCopyFlags BufferCopyFlagsType = 0b1
	// BufferCopyTimestamps: flag indicating that buffer pts, dts, duration,
	// offset and offset_end should be copied.
	BufferCopyTimestamps BufferCopyFlagsType = 0b10
	// BufferCopyMeta: flag indicating that buffer meta should be copied.
	BufferCopyMeta BufferCopyFlagsType = 0b100
	// BufferCopyMemory: flag indicating that buffer memory should be reffed
	// and appended to already existing memory. Unless the memory is marked as
	// NO_SHARE, no actual copy of the memory is made but it is simply reffed.
	// Add GST_BUFFER_COPY_DEEP to force a real copy.
	BufferCopyMemory BufferCopyFlagsType = 0b1000
	// BufferCopyMerge: flag indicating that buffer memory should be merged.
	BufferCopyMerge BufferCopyFlagsType = 0b10000
	// BufferCopyDeep: flag indicating that memory should always be copied
	// instead of reffed.
	BufferCopyDeep BufferCopyFlagsType = 0b100000
)

func marshalBufferCopyFlagsType(p uintptr) (interface{}, error) {
	return BufferCopyFlagsType(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for BufferCopyFlagsType.
func (b BufferCopyFlagsType) String() string {
	if b == 0 {
		return "BufferCopyFlagsType(0)"
	}

	var builder strings.Builder
	builder.Grow(114)

	for b != 0 {
		next := b & (b - 1)
		bit := b - next

		switch bit {
		case BufferCopyNone:
			builder.WriteString("None|")
		case BufferCopyFlags:
			builder.WriteString("Flags|")
		case BufferCopyTimestamps:
			builder.WriteString("Timestamps|")
		case BufferCopyMeta:
			builder.WriteString("Meta|")
		case BufferCopyMemory:
			builder.WriteString("Memory|")
		case BufferCopyMerge:
			builder.WriteString("Merge|")
		case BufferCopyDeep:
			builder.WriteString("Deep|")
		default:
			builder.WriteString(fmt.Sprintf("BufferCopyFlagsType(0b%b)|", bit))
		}

		b = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if b contains other.
func (b BufferCopyFlagsType) Has(other BufferCopyFlagsType) bool {
	return (b & other) == other
}

// BufferFlags: set of buffer flags used to describe properties of a Buffer.
type BufferFlags C.guint

const (
	// BufferFlagLive: buffer is live data and should be discarded in the PAUSED
	// state.
	BufferFlagLive BufferFlags = 0b10000
	// BufferFlagDecodeOnly: buffer contains data that should be dropped because
	// it will be clipped against the segment boundaries or because it does not
	// contain data that should be shown to the user.
	BufferFlagDecodeOnly BufferFlags = 0b100000
	// BufferFlagDiscont: buffer marks a data discontinuity in the stream.
	// This typically occurs after a seek or a dropped buffer from a live or
	// network source.
	BufferFlagDiscont BufferFlags = 0b1000000
	// BufferFlagResync: buffer timestamps might have a discontinuity and this
	// buffer is a good point to resynchronize.
	BufferFlagResync BufferFlags = 0b10000000
	// BufferFlagCorrupted: buffer data is corrupted.
	BufferFlagCorrupted BufferFlags = 0b100000000
	// BufferFlagMarker: buffer contains a media specific marker. for video
	// this is the end of a frame boundary, for audio this is the start of a
	// talkspurt. for RTP packets this matches the marker flag in the RTP packet
	// header.
	BufferFlagMarker BufferFlags = 0b1000000000
	// BufferFlagHeader: buffer contains header information that is needed to
	// decode the following data.
	BufferFlagHeader BufferFlags = 0b10000000000
	// BufferFlagGap: buffer has been created to fill a gap in the stream and
	// contains media neutral data (elements can switch to optimized code path
	// that ignores the buffer content).
	BufferFlagGap BufferFlags = 0b100000000000
	// BufferFlagDroppable: buffer can be dropped without breaking the stream,
	// for example to reduce bandwidth.
	BufferFlagDroppable BufferFlags = 0b1000000000000
	// BufferFlagDeltaUnit: unit cannot be decoded independently.
	BufferFlagDeltaUnit BufferFlags = 0b10000000000000
	// BufferFlagTagMemory: flag is set when memory of the buffer is
	// added/removed.
	BufferFlagTagMemory BufferFlags = 0b100000000000000
	// BufferFlagSyncAfter elements which write to disk or permanent storage
	// should ensure the data is synced after writing the contents of this
	// buffer.
	BufferFlagSyncAfter BufferFlags = 0b1000000000000000
	// BufferFlagNonDroppable: this buffer is important and should not be
	// dropped.
	//
	// This can be used to mark important buffers, e.g. to flag RTP packets
	// carrying keyframes or codec setup data for RTP Forward Error Correction
	// purposes, or to prevent still video frames from being dropped by elements
	// due to QoS.
	BufferFlagNonDroppable BufferFlags = 0b10000000000000000
	// BufferFlagLast: additional media specific flags can be added starting
	// from this flag.
	BufferFlagLast BufferFlags = 0b100000000000000000000
)

func marshalBufferFlags(p uintptr) (interface{}, error) {
	return BufferFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for BufferFlags.
func (b BufferFlags) String() string {
	if b == 0 {
		return "BufferFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for b != 0 {
		next := b & (b - 1)
		bit := b - next

		switch bit {
		case BufferFlagLive:
			builder.WriteString("Live|")
		case BufferFlagDecodeOnly:
			builder.WriteString("DecodeOnly|")
		case BufferFlagDiscont:
			builder.WriteString("Discont|")
		case BufferFlagResync:
			builder.WriteString("Resync|")
		case BufferFlagCorrupted:
			builder.WriteString("Corrupted|")
		case BufferFlagMarker:
			builder.WriteString("Marker|")
		case BufferFlagHeader:
			builder.WriteString("Header|")
		case BufferFlagGap:
			builder.WriteString("Gap|")
		case BufferFlagDroppable:
			builder.WriteString("Droppable|")
		case BufferFlagDeltaUnit:
			builder.WriteString("DeltaUnit|")
		case BufferFlagTagMemory:
			builder.WriteString("TagMemory|")
		case BufferFlagSyncAfter:
			builder.WriteString("SyncAfter|")
		case BufferFlagNonDroppable:
			builder.WriteString("NonDroppable|")
		case BufferFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("BufferFlags(0b%b)|", bit))
		}

		b = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if b contains other.
func (b BufferFlags) Has(other BufferFlags) bool {
	return (b & other) == other
}

// BufferPoolAcquireFlags: additional flags to control the allocation of a
// buffer.
type BufferPoolAcquireFlags C.guint

const (
	// BufferPoolAcquireFlagNone: no flags.
	BufferPoolAcquireFlagNone BufferPoolAcquireFlags = 0b0
	// BufferPoolAcquireFlagKeyUnit: buffer is keyframe.
	BufferPoolAcquireFlagKeyUnit BufferPoolAcquireFlags = 0b1
	// BufferPoolAcquireFlagDontwait: when the bufferpool is empty,
	// acquire_buffer will by default block until a buffer is released into the
	// pool again. Setting this flag makes acquire_buffer return T_FLOW_EOS
	// instead of blocking.
	BufferPoolAcquireFlagDontwait BufferPoolAcquireFlags = 0b10
	// BufferPoolAcquireFlagDiscont: buffer is discont.
	BufferPoolAcquireFlagDiscont BufferPoolAcquireFlags = 0b100
	// BufferPoolAcquireFlagLast: last flag, subclasses can use private flags
	// starting from this value.
	BufferPoolAcquireFlagLast BufferPoolAcquireFlags = 0b10000000000000000
)

func marshalBufferPoolAcquireFlags(p uintptr) (interface{}, error) {
	return BufferPoolAcquireFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for BufferPoolAcquireFlags.
func (b BufferPoolAcquireFlags) String() string {
	if b == 0 {
		return "BufferPoolAcquireFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(139)

	for b != 0 {
		next := b & (b - 1)
		bit := b - next

		switch bit {
		case BufferPoolAcquireFlagNone:
			builder.WriteString("None|")
		case BufferPoolAcquireFlagKeyUnit:
			builder.WriteString("KeyUnit|")
		case BufferPoolAcquireFlagDontwait:
			builder.WriteString("Dontwait|")
		case BufferPoolAcquireFlagDiscont:
			builder.WriteString("Discont|")
		case BufferPoolAcquireFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("BufferPoolAcquireFlags(0b%b)|", bit))
		}

		b = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if b contains other.
func (b BufferPoolAcquireFlags) Has(other BufferPoolAcquireFlags) bool {
	return (b & other) == other
}

// BusFlags: standard flags that a bus may have.
type BusFlags C.guint

const (
	// BusFlushing bus is currently dropping all messages.
	BusFlushing BusFlags = 0b10000
	// BusFlagLast: offset to define more flags.
	BusFlagLast BusFlags = 0b100000
)

func marshalBusFlags(p uintptr) (interface{}, error) {
	return BusFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for BusFlags.
func (b BusFlags) String() string {
	if b == 0 {
		return "BusFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(23)

	for b != 0 {
		next := b & (b - 1)
		bit := b - next

		switch bit {
		case BusFlushing:
			builder.WriteString("Flushing|")
		case BusFlagLast:
			builder.WriteString("FlagLast|")
		default:
			builder.WriteString(fmt.Sprintf("BusFlags(0b%b)|", bit))
		}

		b = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if b contains other.
func (b BusFlags) Has(other BusFlags) bool {
	return (b & other) == other
}

// CapsFlags: extra flags for a caps.
type CapsFlags C.guint

const (
	// CapsFlagAny caps has no specific content, but can contain anything.
	CapsFlagAny CapsFlags = 0b10000
)

func marshalCapsFlags(p uintptr) (interface{}, error) {
	return CapsFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for CapsFlags.
func (c CapsFlags) String() string {
	if c == 0 {
		return "CapsFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(11)

	for c != 0 {
		next := c & (c - 1)
		bit := c - next

		switch bit {
		case CapsFlagAny:
			builder.WriteString("Any|")
		default:
			builder.WriteString(fmt.Sprintf("CapsFlags(0b%b)|", bit))
		}

		c = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if c contains other.
func (c CapsFlags) Has(other CapsFlags) bool {
	return (c & other) == other
}

// ClockFlags capabilities of this clock.
type ClockFlags C.guint

const (
	// ClockFlagCanDoSingleSync: clock can do a single sync timeout request.
	ClockFlagCanDoSingleSync ClockFlags = 0b10000
	// ClockFlagCanDoSingleAsync: clock can do a single async timeout request.
	ClockFlagCanDoSingleAsync ClockFlags = 0b100000
	// ClockFlagCanDoPeriodicSync: clock can do sync periodic timeout requests.
	ClockFlagCanDoPeriodicSync ClockFlags = 0b1000000
	// ClockFlagCanDoPeriodicAsync: clock can do async periodic timeout
	// callbacks.
	ClockFlagCanDoPeriodicAsync ClockFlags = 0b10000000
	// ClockFlagCanSetResolution clock's resolution can be changed.
	ClockFlagCanSetResolution ClockFlags = 0b100000000
	// ClockFlagCanSetMaster: clock can be slaved to a master clock.
	ClockFlagCanSetMaster ClockFlags = 0b1000000000
	// ClockFlagNeedsStartupSync: clock needs to be synced before it can be
	// used.
	ClockFlagNeedsStartupSync ClockFlags = 0b10000000000
	// ClockFlagLast subclasses can add additional flags starting from this
	// flag.
	ClockFlagLast ClockFlags = 0b1000000000000
)

func marshalClockFlags(p uintptr) (interface{}, error) {
	return ClockFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ClockFlags.
func (c ClockFlags) String() string {
	if c == 0 {
		return "ClockFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(193)

	for c != 0 {
		next := c & (c - 1)
		bit := c - next

		switch bit {
		case ClockFlagCanDoSingleSync:
			builder.WriteString("CanDoSingleSync|")
		case ClockFlagCanDoSingleAsync:
			builder.WriteString("CanDoSingleAsync|")
		case ClockFlagCanDoPeriodicSync:
			builder.WriteString("CanDoPeriodicSync|")
		case ClockFlagCanDoPeriodicAsync:
			builder.WriteString("CanDoPeriodicAsync|")
		case ClockFlagCanSetResolution:
			builder.WriteString("CanSetResolution|")
		case ClockFlagCanSetMaster:
			builder.WriteString("CanSetMaster|")
		case ClockFlagNeedsStartupSync:
			builder.WriteString("NeedsStartupSync|")
		case ClockFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("ClockFlags(0b%b)|", bit))
		}

		c = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if c contains other.
func (c ClockFlags) Has(other ClockFlags) bool {
	return (c & other) == other
}

// DebugColorFlags: these are some terminal style flags you can use when
// creating your debugging categories to make them stand out in debugging
// output.
type DebugColorFlags C.guint

const (
	// DebugFgBlack: use black as foreground color.
	DebugFgBlack DebugColorFlags = 0b0
	// DebugFgRed: use red as foreground color.
	DebugFgRed DebugColorFlags = 0b1
	// DebugFgGreen: use green as foreground color.
	DebugFgGreen DebugColorFlags = 0b10
	// DebugFgYellow: use yellow as foreground color.
	DebugFgYellow DebugColorFlags = 0b11
	// DebugFgBlue: use blue as foreground color.
	DebugFgBlue DebugColorFlags = 0b100
	// DebugFgMagenta: use magenta as foreground color.
	DebugFgMagenta DebugColorFlags = 0b101
	// DebugFgCyan: use cyan as foreground color.
	DebugFgCyan DebugColorFlags = 0b110
	// DebugFgWhite: use white as foreground color.
	DebugFgWhite DebugColorFlags = 0b111
	// DebugBgBlack: use black as background color.
	DebugBgBlack DebugColorFlags = 0b0
	// DebugBgRed: use red as background color.
	DebugBgRed DebugColorFlags = 0b10000
	// DebugBgGreen: use green as background color.
	DebugBgGreen DebugColorFlags = 0b100000
	// DebugBgYellow: use yellow as background color.
	DebugBgYellow DebugColorFlags = 0b110000
	// DebugBgBlue: use blue as background color.
	DebugBgBlue DebugColorFlags = 0b1000000
	// DebugBgMagenta: use magenta as background color.
	DebugBgMagenta DebugColorFlags = 0b1010000
	// DebugBgCyan: use cyan as background color.
	DebugBgCyan DebugColorFlags = 0b1100000
	// DebugBgWhite: use white as background color.
	DebugBgWhite DebugColorFlags = 0b1110000
	// DebugBold: make the output bold.
	DebugBold DebugColorFlags = 0b100000000
	// DebugUnderline: underline the output.
	DebugUnderline DebugColorFlags = 0b1000000000
)

func marshalDebugColorFlags(p uintptr) (interface{}, error) {
	return DebugColorFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DebugColorFlags.
func (d DebugColorFlags) String() string {
	if d == 0 {
		return "DebugColorFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(230)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DebugFgBlack:
			builder.WriteString("FgBlack|")
		case DebugFgRed:
			builder.WriteString("FgRed|")
		case DebugFgGreen:
			builder.WriteString("FgGreen|")
		case DebugFgYellow:
			builder.WriteString("FgYellow|")
		case DebugFgBlue:
			builder.WriteString("FgBlue|")
		case DebugFgMagenta:
			builder.WriteString("FgMagenta|")
		case DebugFgCyan:
			builder.WriteString("FgCyan|")
		case DebugFgWhite:
			builder.WriteString("FgWhite|")
		case DebugBgRed:
			builder.WriteString("BgRed|")
		case DebugBgGreen:
			builder.WriteString("BgGreen|")
		case DebugBgYellow:
			builder.WriteString("BgYellow|")
		case DebugBgBlue:
			builder.WriteString("BgBlue|")
		case DebugBgMagenta:
			builder.WriteString("BgMagenta|")
		case DebugBgCyan:
			builder.WriteString("BgCyan|")
		case DebugBgWhite:
			builder.WriteString("BgWhite|")
		case DebugBold:
			builder.WriteString("Bold|")
		case DebugUnderline:
			builder.WriteString("Underline|")
		default:
			builder.WriteString(fmt.Sprintf("DebugColorFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DebugColorFlags) Has(other DebugColorFlags) bool {
	return (d & other) == other
}

// DebugGraphDetails: available details for pipeline graphs produced by
// GST_DEBUG_BIN_TO_DOT_FILE() and GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS().
type DebugGraphDetails C.guint

const (
	// DebugGraphShowMediaType: show caps-name on edges.
	DebugGraphShowMediaType DebugGraphDetails = 0b1
	// DebugGraphShowCapsDetails: show caps-details on edges.
	DebugGraphShowCapsDetails DebugGraphDetails = 0b10
	// DebugGraphShowNonDefaultParams: show modified parameters on elements.
	DebugGraphShowNonDefaultParams DebugGraphDetails = 0b100
	// DebugGraphShowStates: show element states.
	DebugGraphShowStates DebugGraphDetails = 0b1000
	// DebugGraphShowFullParams: show full element parameter values even if they
	// are very long.
	DebugGraphShowFullParams DebugGraphDetails = 0b10000
	// DebugGraphShowAll: show all the typical details that one might want.
	DebugGraphShowAll DebugGraphDetails = 0b1111
	// DebugGraphShowVerbose: show all details regardless of how large or
	// verbose they make the resulting output.
	DebugGraphShowVerbose DebugGraphDetails = 0b11111111111111111111111111111111
)

func marshalDebugGraphDetails(p uintptr) (interface{}, error) {
	return DebugGraphDetails(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DebugGraphDetails.
func (d DebugGraphDetails) String() string {
	if d == 0 {
		return "DebugGraphDetails(0)"
	}

	var builder strings.Builder
	builder.Grow(166)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DebugGraphShowMediaType:
			builder.WriteString("MediaType|")
		case DebugGraphShowCapsDetails:
			builder.WriteString("CapsDetails|")
		case DebugGraphShowNonDefaultParams:
			builder.WriteString("NonDefaultParams|")
		case DebugGraphShowStates:
			builder.WriteString("States|")
		case DebugGraphShowFullParams:
			builder.WriteString("FullParams|")
		case DebugGraphShowAll:
			builder.WriteString("All|")
		case DebugGraphShowVerbose:
			builder.WriteString("Verbose|")
		default:
			builder.WriteString(fmt.Sprintf("DebugGraphDetails(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DebugGraphDetails) Has(other DebugGraphDetails) bool {
	return (d & other) == other
}

// ElementFlags: standard flags that an element may have.
type ElementFlags C.guint

const (
	// ElementFlagLockedState: ignore state changes from parent.
	ElementFlagLockedState ElementFlags = 0b10000
	// ElementFlagSink: element is a sink.
	ElementFlagSink ElementFlags = 0b100000
	// ElementFlagSource: element is a source.
	ElementFlagSource ElementFlags = 0b1000000
	// ElementFlagProvideClock: element can provide a clock.
	ElementFlagProvideClock ElementFlags = 0b10000000
	// ElementFlagRequireClock: element requires a clock.
	ElementFlagRequireClock ElementFlags = 0b100000000
	// ElementFlagIndexable: element can use an index.
	ElementFlagIndexable ElementFlags = 0b1000000000
	// ElementFlagLast: offset to define more flags.
	ElementFlagLast ElementFlags = 0b100000000000000
)

func marshalElementFlags(p uintptr) (interface{}, error) {
	return ElementFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ElementFlags.
func (e ElementFlags) String() string {
	if e == 0 {
		return "ElementFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(141)

	for e != 0 {
		next := e & (e - 1)
		bit := e - next

		switch bit {
		case ElementFlagLockedState:
			builder.WriteString("LockedState|")
		case ElementFlagSink:
			builder.WriteString("Sink|")
		case ElementFlagSource:
			builder.WriteString("Source|")
		case ElementFlagProvideClock:
			builder.WriteString("ProvideClock|")
		case ElementFlagRequireClock:
			builder.WriteString("RequireClock|")
		case ElementFlagIndexable:
			builder.WriteString("Indexable|")
		case ElementFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("ElementFlags(0b%b)|", bit))
		}

		e = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if e contains other.
func (e ElementFlags) Has(other ElementFlags) bool {
	return (e & other) == other
}

// EventTypeFlags indicate the aspects of the different EventType values.
// You can get the type flags of a EventType with the gst_event_type_get_flags()
// function.
type EventTypeFlags C.guint

const (
	// EventTypeUpstream: set if the event can travel upstream.
	EventTypeUpstream EventTypeFlags = 0b1
	// EventTypeDownstream: set if the event can travel downstream.
	EventTypeDownstream EventTypeFlags = 0b10
	// EventTypeSerialized: set if the event should be serialized with data
	// flow.
	EventTypeSerialized EventTypeFlags = 0b100
	// EventTypeSticky: set if the event is sticky on the pads.
	EventTypeSticky EventTypeFlags = 0b1000
	// EventTypeStickyMulti: multiple sticky events can be on a pad, each
	// identified by the event name.
	EventTypeStickyMulti EventTypeFlags = 0b10000
)

func marshalEventTypeFlags(p uintptr) (interface{}, error) {
	return EventTypeFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for EventTypeFlags.
func (e EventTypeFlags) String() string {
	if e == 0 {
		return "EventTypeFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(94)

	for e != 0 {
		next := e & (e - 1)
		bit := e - next

		switch bit {
		case EventTypeUpstream:
			builder.WriteString("Upstream|")
		case EventTypeDownstream:
			builder.WriteString("Downstream|")
		case EventTypeSerialized:
			builder.WriteString("Serialized|")
		case EventTypeSticky:
			builder.WriteString("Sticky|")
		case EventTypeStickyMulti:
			builder.WriteString("StickyMulti|")
		default:
			builder.WriteString(fmt.Sprintf("EventTypeFlags(0b%b)|", bit))
		}

		e = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if e contains other.
func (e EventTypeFlags) Has(other EventTypeFlags) bool {
	return (e & other) == other
}

// GapFlags: different flags that can be set on T_EVENT_GAP events. See
// gst_event_set_gap_flags() for details.
type GapFlags C.guint

const (
	// GapFlagMissingData signals missing data, for example because of packet
	// loss.
	GapFlagMissingData GapFlags = 0b1
)

func marshalGapFlags(p uintptr) (interface{}, error) {
	return GapFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for GapFlags.
func (g GapFlags) String() string {
	if g == 0 {
		return "GapFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(18)

	for g != 0 {
		next := g & (g - 1)
		bit := g - next

		switch bit {
		case GapFlagMissingData:
			builder.WriteString("Data|")
		default:
			builder.WriteString(fmt.Sprintf("GapFlags(0b%b)|", bit))
		}

		g = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if g contains other.
func (g GapFlags) Has(other GapFlags) bool {
	return (g & other) == other
}

// LockFlags flags used when locking miniobjects.
type LockFlags C.guint

const (
	// LockFlagRead: lock for read access.
	LockFlagRead LockFlags = 0b1
	// LockFlagWrite: lock for write access.
	LockFlagWrite LockFlags = 0b10
	// LockFlagExclusive: lock for exclusive access.
	LockFlagExclusive LockFlags = 0b100
	// LockFlagLast: first flag that can be used for custom purposes.
	LockFlagLast LockFlags = 0b100000000
)

func marshalLockFlags(p uintptr) (interface{}, error) {
	return LockFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for LockFlags.
func (l LockFlags) String() string {
	if l == 0 {
		return "LockFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(57)

	for l != 0 {
		next := l & (l - 1)
		bit := l - next

		switch bit {
		case LockFlagRead:
			builder.WriteString("Read|")
		case LockFlagWrite:
			builder.WriteString("Write|")
		case LockFlagExclusive:
			builder.WriteString("Exclusive|")
		case LockFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("LockFlags(0b%b)|", bit))
		}

		l = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if l contains other.
func (l LockFlags) Has(other LockFlags) bool {
	return (l & other) == other
}

// MapFlags flags used when mapping memory.
type MapFlags C.guint

const (
	// MapRead: map for read access.
	MapRead MapFlags = 0b1
	// MapWrite: map for write access.
	MapWrite MapFlags = 0b10
	// MapFlagLast: first flag that can be used for custom purposes.
	MapFlagLast MapFlags = 0b10000000000000000
)

func marshalMapFlags(p uintptr) (interface{}, error) {
	return MapFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for MapFlags.
func (m MapFlags) String() string {
	if m == 0 {
		return "MapFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(28)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case MapRead:
			builder.WriteString("Read|")
		case MapWrite:
			builder.WriteString("Write|")
		case MapFlagLast:
			builder.WriteString("FlagLast|")
		default:
			builder.WriteString(fmt.Sprintf("MapFlags(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m MapFlags) Has(other MapFlags) bool {
	return (m & other) == other
}

// MemoryFlags flags for wrapped memory.
type MemoryFlags C.guint

const (
	// MemoryFlagReadonly: memory is readonly. It is not allowed to map the
	// memory with T_MAP_WRITE.
	MemoryFlagReadonly MemoryFlags = 0b10
	// MemoryFlagNoShare: memory must not be shared. Copies will have to be made
	// when this memory needs to be shared between buffers. (DEPRECATED: do not
	// use in new code, instead you should create a custom GstAllocator for
	// memory pooling instead of relying on the GstBuffer they were originally
	// attached to.).
	MemoryFlagNoShare MemoryFlags = 0b10000
	// MemoryFlagZeroPrefixed: memory prefix is filled with 0 bytes.
	MemoryFlagZeroPrefixed MemoryFlags = 0b100000
	// MemoryFlagZeroPadded: memory padding is filled with 0 bytes.
	MemoryFlagZeroPadded MemoryFlags = 0b1000000
	// MemoryFlagPhysicallyContiguous: memory is physically contiguous. (Since:
	// 1.2).
	MemoryFlagPhysicallyContiguous MemoryFlags = 0b10000000
	// MemoryFlagNotMappable: memory can't be mapped via gst_memory_map()
	// without any preconditions. (Since: 1.2).
	MemoryFlagNotMappable MemoryFlags = 0b100000000
	// MemoryFlagLast: first flag that can be used for custom purposes.
	MemoryFlagLast MemoryFlags = 0b100000000000000000000
)

func marshalMemoryFlags(p uintptr) (interface{}, error) {
	return MemoryFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for MemoryFlags.
func (m MemoryFlags) String() string {
	if m == 0 {
		return "MemoryFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(148)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case MemoryFlagReadonly:
			builder.WriteString("Readonly|")
		case MemoryFlagNoShare:
			builder.WriteString("NoShare|")
		case MemoryFlagZeroPrefixed:
			builder.WriteString("ZeroPrefixed|")
		case MemoryFlagZeroPadded:
			builder.WriteString("ZeroPadded|")
		case MemoryFlagPhysicallyContiguous:
			builder.WriteString("PhysicallyContiguous|")
		case MemoryFlagNotMappable:
			builder.WriteString("NotMappable|")
		case MemoryFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("MemoryFlags(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m MemoryFlags) Has(other MemoryFlags) bool {
	return (m & other) == other
}

// MessageType: different message types that are available.
type MessageType C.guint

const (
	// MessageUnknown: undefined message.
	MessageUnknown MessageType = 0b0
	// MessageEos: end-of-stream reached in a pipeline. The application will
	// only receive this message in the PLAYING state and every time it sets a
	// pipeline to PLAYING that is in the EOS state. The application can perform
	// a flushing seek in the pipeline, which will undo the EOS state again.
	MessageEos MessageType = 0b1
	// MessageError: error occurred. When the application receives an error
	// message it should stop playback of the pipeline and not assume that more
	// data will be played. It is possible to specify a redirection url to
	// the error messages by setting a redirect-location field into the error
	// message, application or high level bins might use the information as
	// required.
	MessageError MessageType = 0b10
	// MessageWarning: warning occurred.
	MessageWarning MessageType = 0b100
	// MessageInfo: info message occurred.
	MessageInfo MessageType = 0b1000
	// MessageTag: tag was found.
	MessageTag MessageType = 0b10000
	// MessageBuffering: pipeline is buffering. When the application receives
	// a buffering message in the PLAYING state for a non-live pipeline it must
	// PAUSE the pipeline until the buffering completes, when the percentage
	// field in the message is 100%. For live pipelines, no action must be
	// performed and the buffering percentage can be used to inform the user
	// about the progress.
	MessageBuffering MessageType = 0b100000
	// MessageStateChanged: state change happened.
	MessageStateChanged MessageType = 0b1000000
	// MessageStateDirty: element changed state in a streaming thread. This
	// message is deprecated.
	MessageStateDirty MessageType = 0b10000000
	// MessageStepDone: stepping operation finished.
	MessageStepDone MessageType = 0b100000000
	// MessageClockProvide: element notifies its capability of providing
	// a clock. This message is used internally and never forwarded to the
	// application.
	MessageClockProvide MessageType = 0b1000000000
	// MessageClockLost: current clock as selected by the pipeline became
	// unusable. The pipeline will select a new clock on the next PLAYING state
	// change. The application should set the pipeline to PAUSED and back to
	// PLAYING when this message is received.
	MessageClockLost MessageType = 0b10000000000
	// MessageNewClock: new clock was selected in the pipeline.
	MessageNewClock MessageType = 0b100000000000
	// MessageStructureChange: structure of the pipeline changed. This message
	// is used internally and never forwarded to the application.
	MessageStructureChange MessageType = 0b1000000000000
	// MessageStreamStatus status about a stream, emitted when it starts, stops,
	// errors, etc..
	MessageStreamStatus MessageType = 0b10000000000000
	// MessageApplication: message posted by the application, possibly via an
	// application-specific element.
	MessageApplication MessageType = 0b100000000000000
	// MessageElement: element-specific message, see the specific element's
	// documentation.
	MessageElement MessageType = 0b1000000000000000
	// MessageSegmentStart: pipeline started playback of a segment. This message
	// is used internally and never forwarded to the application.
	MessageSegmentStart MessageType = 0b10000000000000000
	// MessageSegmentDone: pipeline completed playback of a segment. This
	// message is forwarded to the application after all elements that posted
	// GST_MESSAGE_SEGMENT_START posted a GST_MESSAGE_SEGMENT_DONE message.
	MessageSegmentDone MessageType = 0b100000000000000000
	// MessageDurationChanged: duration of a pipeline changed. The application
	// can get the new duration with a duration query.
	MessageDurationChanged MessageType = 0b1000000000000000000
	// MessageLatency: posted by elements when their latency changes. The
	// application should recalculate and distribute a new latency.
	MessageLatency MessageType = 0b10000000000000000000
	// MessageAsyncStart: posted by elements when they start an ASYNC
	// StateChange. This message is not forwarded to the application but is used
	// internally.
	MessageAsyncStart MessageType = 0b100000000000000000000
	// MessageAsyncDone: posted by elements when they complete an ASYNC
	// StateChange. The application will only receive this message from the
	// toplevel pipeline.
	MessageAsyncDone MessageType = 0b1000000000000000000000
	// MessageRequestState: posted by elements when they want the pipeline to
	// change state. This message is a suggestion to the application which can
	// decide to perform the state change on (part of) the pipeline.
	MessageRequestState MessageType = 0b10000000000000000000000
	// MessageStepStart: stepping operation was started.
	MessageStepStart MessageType = 0b100000000000000000000000
	// MessageQos: buffer was dropped or an element changed its processing
	// strategy for Quality of Service reasons.
	MessageQos MessageType = 0b1000000000000000000000000
	// MessageProgress progress message.
	MessageProgress MessageType = 0b10000000000000000000000000
	// MessageToc: new table of contents (TOC) was found or previously found TOC
	// was updated.
	MessageToc MessageType = 0b100000000000000000000000000
	// MessageResetTime: message to request resetting the pipeline's running
	// time from the pipeline. This is an internal message which applications
	// will likely never receive.
	MessageResetTime MessageType = 0b1000000000000000000000000000
	// MessageStreamStart: message indicating start of a new stream. Useful e.g.
	// when using playbin in gapless playback mode, to get notified when the
	// next title actually starts playing (which will be some time after the URI
	// for the next title has been set).
	MessageStreamStart MessageType = 0b10000000000000000000000000000
	// MessageNeedContext: message indicating that an element wants a specific
	// context (Since: 1.2).
	MessageNeedContext MessageType = 0b100000000000000000000000000000
	// MessageHaveContext: message indicating that an element created a context
	// (Since: 1.2).
	MessageHaveContext MessageType = 0b1000000000000000000000000000000
	// MessageExtended: message is an extended message type (see below). These
	// extended message IDs can't be used directly with mask-based API like
	// gst_bus_poll() or gst_bus_timed_pop_filtered(), but you can still filter
	// for GST_MESSAGE_EXTENDED and then check the result for the specific type.
	// (Since: 1.4).
	MessageExtended MessageType = 0b10000000000000000000000000000000
	// MessageDeviceAdded: message indicating a Device was added to a
	// DeviceProvider (Since: 1.4).
	MessageDeviceAdded MessageType = 0b10000000000000000000000000000001
	// MessageDeviceRemoved: message indicating a Device was removed from a
	// DeviceProvider (Since: 1.4).
	MessageDeviceRemoved MessageType = 0b10000000000000000000000000000010
	// MessagePropertyNotify: message indicating a #GObject property has changed
	// (Since: 1.10).
	MessagePropertyNotify MessageType = 0b10000000000000000000000000000011
	// MessageStreamCollection: message indicating a new StreamCollection is
	// available (Since: 1.10).
	MessageStreamCollection MessageType = 0b10000000000000000000000000000100
	// MessageStreamsSelected: message indicating the active selection of
	// Streams has changed (Since: 1.10).
	MessageStreamsSelected MessageType = 0b10000000000000000000000000000101
	// MessageRedirect: message indicating to request the application to try to
	// play the given URL(s). Useful if for example a HTTP 302/303 response is
	// received with a non-HTTP URL inside. (Since: 1.10).
	MessageRedirect MessageType = 0b10000000000000000000000000000110
	// MessageDeviceChanged: message indicating a Device was changed a
	// DeviceProvider (Since: 1.16).
	MessageDeviceChanged MessageType = 0b10000000000000000000000000000111
	// MessageInstantRateRequest: message sent by elements to request the
	// running time from the pipeline when an instant rate change should be
	// applied (which may be in the past when the answer arrives). (Since:
	// 1.18).
	MessageInstantRateRequest MessageType = 0b10000000000000000000000000001000
	// MessageAny: mask for all of the above messages.
	MessageAny MessageType = 0b11111111111111111111111111111111
)

func marshalMessageType(p uintptr) (interface{}, error) {
	return MessageType(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for MessageType.
func (m MessageType) String() string {
	if m == 0 {
		return "MessageType(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case MessageUnknown:
			builder.WriteString("Unknown|")
		case MessageEos:
			builder.WriteString("Eos|")
		case MessageError:
			builder.WriteString("Error|")
		case MessageWarning:
			builder.WriteString("Warning|")
		case MessageInfo:
			builder.WriteString("Info|")
		case MessageTag:
			builder.WriteString("Tag|")
		case MessageBuffering:
			builder.WriteString("Buffering|")
		case MessageStateChanged:
			builder.WriteString("StateChanged|")
		case MessageStateDirty:
			builder.WriteString("StateDirty|")
		case MessageStepDone:
			builder.WriteString("StepDone|")
		case MessageClockProvide:
			builder.WriteString("ClockProvide|")
		case MessageClockLost:
			builder.WriteString("ClockLost|")
		case MessageNewClock:
			builder.WriteString("NewClock|")
		case MessageStructureChange:
			builder.WriteString("StructureChange|")
		case MessageStreamStatus:
			builder.WriteString("StreamStatus|")
		case MessageApplication:
			builder.WriteString("Application|")
		case MessageElement:
			builder.WriteString("Element|")
		case MessageSegmentStart:
			builder.WriteString("SegmentStart|")
		case MessageSegmentDone:
			builder.WriteString("SegmentDone|")
		case MessageDurationChanged:
			builder.WriteString("DurationChanged|")
		case MessageLatency:
			builder.WriteString("Latency|")
		case MessageAsyncStart:
			builder.WriteString("AsyncStart|")
		case MessageAsyncDone:
			builder.WriteString("AsyncDone|")
		case MessageRequestState:
			builder.WriteString("RequestState|")
		case MessageStepStart:
			builder.WriteString("StepStart|")
		case MessageQos:
			builder.WriteString("Qos|")
		case MessageProgress:
			builder.WriteString("Progress|")
		case MessageToc:
			builder.WriteString("Toc|")
		case MessageResetTime:
			builder.WriteString("ResetTime|")
		case MessageStreamStart:
			builder.WriteString("StreamStart|")
		case MessageNeedContext:
			builder.WriteString("NeedContext|")
		case MessageHaveContext:
			builder.WriteString("HaveContext|")
		case MessageExtended:
			builder.WriteString("Extended|")
		case MessageDeviceAdded:
			builder.WriteString("DeviceAdded|")
		case MessageDeviceRemoved:
			builder.WriteString("DeviceRemoved|")
		case MessagePropertyNotify:
			builder.WriteString("PropertyNotify|")
		case MessageStreamCollection:
			builder.WriteString("StreamCollection|")
		case MessageStreamsSelected:
			builder.WriteString("StreamsSelected|")
		case MessageRedirect:
			builder.WriteString("Redirect|")
		case MessageDeviceChanged:
			builder.WriteString("DeviceChanged|")
		case MessageInstantRateRequest:
			builder.WriteString("InstantRateRequest|")
		case MessageAny:
			builder.WriteString("Any|")
		default:
			builder.WriteString(fmt.Sprintf("MessageType(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m MessageType) Has(other MessageType) bool {
	return (m & other) == other
}

// MessageTypeGetName: get a printable name for the given message type. Do not
// modify or free.
//
// The function takes the following parameters:
//
//   - typ: message type.
//
// The function returns the following values:
//
//   - utf8: reference to the static name of the message.
func MessageTypeGetName(typ MessageType) string {
	var _arg1 C.GstMessageType // out
	var _cret *C.gchar         // in

	_arg1 = C.GstMessageType(typ)

	_cret = C.gst_message_type_get_name(_arg1)
	runtime.KeepAlive(typ)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// MessageTypeToQuark: get the unique quark for the given message type.
//
// The function takes the following parameters:
//
//   - typ: message type.
//
// The function returns the following values:
//
//   - quark associated with the message type.
func MessageTypeToQuark(typ MessageType) glib.Quark {
	var _arg1 C.GstMessageType // out
	var _cret C.GQuark         // in

	_arg1 = C.GstMessageType(typ)

	_cret = C.gst_message_type_to_quark(_arg1)
	runtime.KeepAlive(typ)

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// MetaFlags: extra metadata flags.
type MetaFlags C.guint

const (
	// MetaFlagNone: no flags.
	MetaFlagNone MetaFlags = 0b0
	// MetaFlagReadonly: metadata should not be modified.
	MetaFlagReadonly MetaFlags = 0b1
	// MetaFlagPooled: metadata is managed by a bufferpool.
	MetaFlagPooled MetaFlags = 0b10
	// MetaFlagLocked: metadata should not be removed.
	MetaFlagLocked MetaFlags = 0b100
	// MetaFlagLast: additional flags can be added starting from this flag.
	MetaFlagLast MetaFlags = 0b10000000000000000
)

func marshalMetaFlags(p uintptr) (interface{}, error) {
	return MetaFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for MetaFlags.
func (m MetaFlags) String() string {
	if m == 0 {
		return "MetaFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(72)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case MetaFlagNone:
			builder.WriteString("None|")
		case MetaFlagReadonly:
			builder.WriteString("Readonly|")
		case MetaFlagPooled:
			builder.WriteString("Pooled|")
		case MetaFlagLocked:
			builder.WriteString("Locked|")
		case MetaFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("MetaFlags(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m MetaFlags) Has(other MetaFlags) bool {
	return (m & other) == other
}

// MiniObjectFlags flags for the mini object.
type MiniObjectFlags C.guint

const (
	// MiniObjectFlagLockable: object can be locked and unlocked with
	// gst_mini_object_lock() and gst_mini_object_unlock().
	MiniObjectFlagLockable MiniObjectFlags = 0b1
	// MiniObjectFlagLockReadonly: object is permanently locked in READONLY
	// mode. Only read locks can be performed on the object.
	MiniObjectFlagLockReadonly MiniObjectFlags = 0b10
	// MiniObjectFlagMayBeLeaked: object is expected to stay alive even after
	// gst_deinit() has been called and so should be ignored by leak detection
	// tools. (Since: 1.10).
	MiniObjectFlagMayBeLeaked MiniObjectFlags = 0b100
	// MiniObjectFlagLast: first flag that can be used by subclasses.
	MiniObjectFlagLast MiniObjectFlags = 0b10000
)

func marshalMiniObjectFlags(p uintptr) (interface{}, error) {
	return MiniObjectFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for MiniObjectFlags.
func (m MiniObjectFlags) String() string {
	if m == 0 {
		return "MiniObjectFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(94)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case MiniObjectFlagLockable:
			builder.WriteString("Lockable|")
		case MiniObjectFlagLockReadonly:
			builder.WriteString("LockReadonly|")
		case MiniObjectFlagMayBeLeaked:
			builder.WriteString("MayBeLeaked|")
		case MiniObjectFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("MiniObjectFlags(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m MiniObjectFlags) Has(other MiniObjectFlags) bool {
	return (m & other) == other
}

// ObjectFlags: standard flags that an gstobject may have.
type ObjectFlags C.guint

const (
	// ObjectFlagMayBeLeaked: object is expected to stay alive even after
	// gst_deinit() has been called and so should be ignored by leak detection
	// tools. (Since: 1.10).
	ObjectFlagMayBeLeaked ObjectFlags = 0b1
	// ObjectFlagConstructed: flag that's set when the object has been
	// constructed. This can be used by API such as base class setters to
	// differentiate between the case where they're called from a subclass's
	// instance init function (and where the object isn't fully constructed yet,
	// and so one shouldn't do anything but set values in the instance
	// structure), and the case where the object is constructed.
	ObjectFlagConstructed ObjectFlags = 0b10
	// ObjectFlagLast subclasses can add additional flags starting from this
	// flag.
	ObjectFlagLast ObjectFlags = 0b10000
)

func marshalObjectFlags(p uintptr) (interface{}, error) {
	return ObjectFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ObjectFlags.
func (o ObjectFlags) String() string {
	if o == 0 {
		return "ObjectFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(58)

	for o != 0 {
		next := o & (o - 1)
		bit := o - next

		switch bit {
		case ObjectFlagMayBeLeaked:
			builder.WriteString("MayBeLeaked|")
		case ObjectFlagConstructed:
			builder.WriteString("Constructed|")
		case ObjectFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("ObjectFlags(0b%b)|", bit))
		}

		o = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if o contains other.
func (o ObjectFlags) Has(other ObjectFlags) bool {
	return (o & other) == other
}

// PadFlags: pad state flags.
type PadFlags C.guint

const (
	// PadFlagBlocked is dataflow on a pad blocked.
	PadFlagBlocked PadFlags = 0b10000
	// PadFlagFlushing is pad flushing.
	PadFlagFlushing PadFlags = 0b100000
	// PadFlagEos is pad in EOS state.
	PadFlagEos PadFlags = 0b1000000
	// PadFlagBlocking is pad currently blocking on a buffer or event.
	PadFlagBlocking PadFlags = 0b10000000
	// PadFlagNeedParent: ensure that there is a parent object before calling
	// into the pad callbacks.
	PadFlagNeedParent PadFlags = 0b100000000
	// PadFlagNeedReconfigure: pad should be reconfigured/renegotiated. The flag
	// has to be unset manually after reconfiguration happened.
	PadFlagNeedReconfigure PadFlags = 0b1000000000
	// PadFlagPendingEvents: pad has pending events.
	PadFlagPendingEvents PadFlags = 0b10000000000
	// PadFlagFixedCaps: pad is using fixed caps. This means that once the caps
	// are set on the pad, the default caps query function will only return
	// those caps.
	PadFlagFixedCaps PadFlags = 0b100000000000
	// PadFlagProxyCaps: default event and query handler will forward all events
	// and queries to the internally linked pads instead of discarding them.
	PadFlagProxyCaps PadFlags = 0b1000000000000
	// PadFlagProxyAllocation: default query handler will forward allocation
	// queries to the internally linked pads instead of discarding them.
	PadFlagProxyAllocation PadFlags = 0b10000000000000
	// PadFlagProxyScheduling: default query handler will forward scheduling
	// queries to the internally linked pads instead of discarding them.
	PadFlagProxyScheduling PadFlags = 0b100000000000000
	// PadFlagAcceptIntersect: default accept-caps handler will check it the
	// caps intersect the query-caps result instead of checking for a subset.
	// This is interesting for parsers that can accept incompletely specified
	// caps.
	PadFlagAcceptIntersect PadFlags = 0b1000000000000000
	// PadFlagAcceptTemplate: default accept-caps handler will use the template
	// pad caps instead of query caps to compare with the accept caps. Use this
	// in combination with GST_PAD_FLAG_ACCEPT_INTERSECT. (Since: 1.6).
	PadFlagAcceptTemplate PadFlags = 0b10000000000000000
	// PadFlagLast: offset to define more flags.
	PadFlagLast PadFlags = 0b100000000000000000000
)

func marshalPadFlags(p uintptr) (interface{}, error) {
	return PadFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PadFlags.
func (p PadFlags) String() string {
	if p == 0 {
		return "PadFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PadFlagBlocked:
			builder.WriteString("Blocked|")
		case PadFlagFlushing:
			builder.WriteString("Flushing|")
		case PadFlagEos:
			builder.WriteString("Eos|")
		case PadFlagBlocking:
			builder.WriteString("Blocking|")
		case PadFlagNeedParent:
			builder.WriteString("NeedParent|")
		case PadFlagNeedReconfigure:
			builder.WriteString("NeedReconfigure|")
		case PadFlagPendingEvents:
			builder.WriteString("PendingEvents|")
		case PadFlagFixedCaps:
			builder.WriteString("FixedCaps|")
		case PadFlagProxyCaps:
			builder.WriteString("ProxyCaps|")
		case PadFlagProxyAllocation:
			builder.WriteString("ProxyAllocation|")
		case PadFlagProxyScheduling:
			builder.WriteString("ProxyScheduling|")
		case PadFlagAcceptIntersect:
			builder.WriteString("AcceptIntersect|")
		case PadFlagAcceptTemplate:
			builder.WriteString("AcceptTemplate|")
		case PadFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("PadFlags(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PadFlags) Has(other PadFlags) bool {
	return (p & other) == other
}

// PadLinkCheck: amount of checking to be done when linking pads.
// GST_PAD_LINK_CHECK_CAPS and GST_PAD_LINK_CHECK_TEMPLATE_CAPS are mutually
// exclusive. If both are specified, expensive but safe GST_PAD_LINK_CHECK_CAPS
// are performed.
//
// > Only disable some of the checks if you are 100% certain you know the link >
// will not fail because of hierarchy/caps compatibility failures. If uncertain,
// > use the default checks (GST_PAD_LINK_CHECK_DEFAULT) or the regular methods
// > for linking the pads.
type PadLinkCheck C.guint

const (
	// PadLinkCheckNothing: don't check hierarchy or caps compatibility.
	PadLinkCheckNothing PadLinkCheck = 0b0
	// PadLinkCheckHierarchy: check the pads have same parents/grandparents.
	// Could be omitted if it is already known that the two elements that own
	// the pads are in the same bin.
	PadLinkCheckHierarchy PadLinkCheck = 0b1
	// PadLinkCheckTemplateCaps: check if the pads are compatible by using
	// their template caps. This is much faster than GST_PAD_LINK_CHECK_CAPS,
	// but would be unsafe e.g. if one pad has GST_CAPS_ANY.
	PadLinkCheckTemplateCaps PadLinkCheck = 0b10
	// PadLinkCheckCaps: check if the pads are compatible by comparing the caps
	// returned by gst_pad_query_caps().
	PadLinkCheckCaps PadLinkCheck = 0b100
	// PadLinkCheckNoReconfigure disables pushing a reconfigure event when pads
	// are linked.
	PadLinkCheckNoReconfigure PadLinkCheck = 0b1000
	// PadLinkCheckDefault: default checks done when linking pads (i.e. the ones
	// used by gst_pad_link()).
	PadLinkCheckDefault PadLinkCheck = 0b101
)

func marshalPadLinkCheck(p uintptr) (interface{}, error) {
	return PadLinkCheck(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PadLinkCheck.
func (p PadLinkCheck) String() string {
	if p == 0 {
		return "PadLinkCheck(0)"
	}

	var builder strings.Builder
	builder.Grow(129)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PadLinkCheckNothing:
			builder.WriteString("Nothing|")
		case PadLinkCheckHierarchy:
			builder.WriteString("Hierarchy|")
		case PadLinkCheckTemplateCaps:
			builder.WriteString("TemplateCaps|")
		case PadLinkCheckCaps:
			builder.WriteString("Caps|")
		case PadLinkCheckNoReconfigure:
			builder.WriteString("NoReconfigure|")
		case PadLinkCheckDefault:
			builder.WriteString("Default|")
		default:
			builder.WriteString(fmt.Sprintf("PadLinkCheck(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PadLinkCheck) Has(other PadLinkCheck) bool {
	return (p & other) == other
}

// PadProbeType: different probing types that can occur. When either one of
// GST_PAD_PROBE_TYPE_IDLE or GST_PAD_PROBE_TYPE_BLOCK is used, the probe will
// be a blocking probe.
type PadProbeType C.guint

const (
	// PadProbeTypeInvalid: invalid probe type.
	PadProbeTypeInvalid PadProbeType = 0b0
	// PadProbeTypeIdle: probe idle pads and block while the callback is called.
	PadProbeTypeIdle PadProbeType = 0b1
	// PadProbeTypeBlock: probe and block pads.
	PadProbeTypeBlock PadProbeType = 0b10
	// PadProbeTypeBuffer: probe buffers.
	PadProbeTypeBuffer PadProbeType = 0b10000
	// PadProbeTypeBufferList: probe buffer lists.
	PadProbeTypeBufferList PadProbeType = 0b100000
	// PadProbeTypeEventDownstream: probe downstream events.
	PadProbeTypeEventDownstream PadProbeType = 0b1000000
	// PadProbeTypeEventUpstream: probe upstream events.
	PadProbeTypeEventUpstream PadProbeType = 0b10000000
	// PadProbeTypeEventFlush: probe flush events.
	// This probe has to be explicitly enabled and is not
	// included in the @GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM or
	// @GST_PAD_PROBE_TYPE_EVENT_UPSTREAM probe types.
	PadProbeTypeEventFlush PadProbeType = 0b100000000
	// PadProbeTypeQueryDownstream: probe downstream queries.
	PadProbeTypeQueryDownstream PadProbeType = 0b1000000000
	// PadProbeTypeQueryUpstream: probe upstream queries.
	PadProbeTypeQueryUpstream PadProbeType = 0b10000000000
	// PadProbeTypePush: probe push.
	PadProbeTypePush PadProbeType = 0b1000000000000
	// PadProbeTypePull: probe pull.
	PadProbeTypePull PadProbeType = 0b10000000000000
	// PadProbeTypeBlocking: probe and block at the next opportunity, at data
	// flow or when idle.
	PadProbeTypeBlocking PadProbeType = 0b11
	// PadProbeTypeDataDownstream: probe downstream data (buffers, buffer lists,
	// and events).
	PadProbeTypeDataDownstream PadProbeType = 0b1110000
	// PadProbeTypeDataUpstream: probe upstream data (events).
	PadProbeTypeDataUpstream PadProbeType = 0b10000000
	// PadProbeTypeDataBoth: probe upstream and downstream data (buffers,
	// buffer lists, and events).
	PadProbeTypeDataBoth PadProbeType = 0b11110000
	// PadProbeTypeBlockDownstream: probe and block downstream data (buffers,
	// buffer lists, and events).
	PadProbeTypeBlockDownstream PadProbeType = 0b1110010
	// PadProbeTypeBlockUpstream: probe and block upstream data (events).
	PadProbeTypeBlockUpstream PadProbeType = 0b10000010
	// PadProbeTypeEventBoth: probe upstream and downstream events.
	PadProbeTypeEventBoth PadProbeType = 0b11000000
	// PadProbeTypeQueryBoth: probe upstream and downstream queries.
	PadProbeTypeQueryBoth PadProbeType = 0b11000000000
	// PadProbeTypeAllBoth: probe upstream events and queries and downstream
	// buffers, buffer lists, events and queries.
	PadProbeTypeAllBoth PadProbeType = 0b11011110000
	// PadProbeTypeScheduling: probe push and pull.
	PadProbeTypeScheduling PadProbeType = 0b11000000000000
)

func marshalPadProbeType(p uintptr) (interface{}, error) {
	return PadProbeType(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PadProbeType.
func (p PadProbeType) String() string {
	if p == 0 {
		return "PadProbeType(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PadProbeTypeInvalid:
			builder.WriteString("Invalid|")
		case PadProbeTypeIdle:
			builder.WriteString("Idle|")
		case PadProbeTypeBlock:
			builder.WriteString("Block|")
		case PadProbeTypeBuffer:
			builder.WriteString("Buffer|")
		case PadProbeTypeBufferList:
			builder.WriteString("BufferList|")
		case PadProbeTypeEventDownstream:
			builder.WriteString("EventDownstream|")
		case PadProbeTypeEventUpstream:
			builder.WriteString("EventUpstream|")
		case PadProbeTypeEventFlush:
			builder.WriteString("EventFlush|")
		case PadProbeTypeQueryDownstream:
			builder.WriteString("QueryDownstream|")
		case PadProbeTypeQueryUpstream:
			builder.WriteString("QueryUpstream|")
		case PadProbeTypePush:
			builder.WriteString("Push|")
		case PadProbeTypePull:
			builder.WriteString("Pull|")
		case PadProbeTypeBlocking:
			builder.WriteString("Blocking|")
		case PadProbeTypeDataDownstream:
			builder.WriteString("DataDownstream|")
		case PadProbeTypeDataBoth:
			builder.WriteString("DataBoth|")
		case PadProbeTypeBlockDownstream:
			builder.WriteString("BlockDownstream|")
		case PadProbeTypeBlockUpstream:
			builder.WriteString("BlockUpstream|")
		case PadProbeTypeEventBoth:
			builder.WriteString("EventBoth|")
		case PadProbeTypeQueryBoth:
			builder.WriteString("QueryBoth|")
		case PadProbeTypeAllBoth:
			builder.WriteString("AllBoth|")
		case PadProbeTypeScheduling:
			builder.WriteString("Scheduling|")
		default:
			builder.WriteString(fmt.Sprintf("PadProbeType(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PadProbeType) Has(other PadProbeType) bool {
	return (p & other) == other
}

// PadTemplateFlags flags for the padtemplate.
type PadTemplateFlags C.guint

const (
	// PadTemplateFlagLast: first flag that can be used by subclasses.
	PadTemplateFlagLast PadTemplateFlags = 0b100000000
)

func marshalPadTemplateFlags(p uintptr) (interface{}, error) {
	return PadTemplateFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PadTemplateFlags.
func (p PadTemplateFlags) String() string {
	if p == 0 {
		return "PadTemplateFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(19)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PadTemplateFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("PadTemplateFlags(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PadTemplateFlags) Has(other PadTemplateFlags) bool {
	return (p & other) == other
}

// ParseFlags: parsing options.
type ParseFlags C.guint

const (
	// ParseFlagNone: do not use any special parsing options.
	ParseFlagNone ParseFlags = 0b0
	// ParseFlagFatalErrors always return NULL when an error occurs (default
	// behaviour is to return partially constructed bins or elements in some
	// cases).
	ParseFlagFatalErrors ParseFlags = 0b1
	// ParseFlagNoSingleElementBins: if a bin only has a single element,
	// just return the element.
	ParseFlagNoSingleElementBins ParseFlags = 0b10
	// ParseFlagPlaceInBin: if more than one toplevel element is described by
	// the pipeline description string, put them in a Bin instead of a Pipeline.
	// (Since: 1.10).
	ParseFlagPlaceInBin ParseFlags = 0b100
)

func marshalParseFlags(p uintptr) (interface{}, error) {
	return ParseFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ParseFlags.
func (p ParseFlags) String() string {
	if p == 0 {
		return "ParseFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(83)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case ParseFlagNone:
			builder.WriteString("None|")
		case ParseFlagFatalErrors:
			builder.WriteString("FatalErrors|")
		case ParseFlagNoSingleElementBins:
			builder.WriteString("NoSingleElementBins|")
		case ParseFlagPlaceInBin:
			builder.WriteString("PlaceInBin|")
		default:
			builder.WriteString(fmt.Sprintf("ParseFlags(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p ParseFlags) Has(other ParseFlags) bool {
	return (p & other) == other
}

// PipelineFlags: pipeline flags.
type PipelineFlags C.guint

const (
	// PipelineFlagFixedClock: pipeline works with a fixed clock.
	PipelineFlagFixedClock PipelineFlags = 0b10000000000000000000
	// PipelineFlagLast: offset to define more flags.
	PipelineFlagLast PipelineFlags = 0b100000000000000000000000
)

func marshalPipelineFlags(p uintptr) (interface{}, error) {
	return PipelineFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PipelineFlags.
func (p PipelineFlags) String() string {
	if p == 0 {
		return "PipelineFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(39)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PipelineFlagFixedClock:
			builder.WriteString("FixedClock|")
		case PipelineFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("PipelineFlags(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PipelineFlags) Has(other PipelineFlags) bool {
	return (p & other) == other
}

type PluginAPIFlags C.guint

const (
	// PluginApiFlagIgnoreEnumMembers: ignore enum members when generating the
	// plugins cache. This is useful if the members of the enum are generated
	// dynamically, in order not to expose incorrect documentation to the end
	// user.
	PluginApiFlagIgnoreEnumMembers PluginAPIFlags = 0b1
)

func marshalPluginAPIFlags(p uintptr) (interface{}, error) {
	return PluginAPIFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PluginAPIFlags.
func (p PluginAPIFlags) String() string {
	if p == 0 {
		return "PluginAPIFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(30)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PluginApiFlagIgnoreEnumMembers:
			builder.WriteString("Members|")
		default:
			builder.WriteString(fmt.Sprintf("PluginAPIFlags(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PluginAPIFlags) Has(other PluginAPIFlags) bool {
	return (p & other) == other
}

// PluginDependencyFlags flags used in connection with
// gst_plugin_add_dependency().
type PluginDependencyFlags C.guint

const (
	// PluginDependencyFlagNone: no special flags.
	PluginDependencyFlagNone PluginDependencyFlags = 0b0
	// PluginDependencyFlagRecurse: recurse into subdirectories.
	PluginDependencyFlagRecurse PluginDependencyFlags = 0b1
	// PluginDependencyFlagPathsAreDefaultOnly: use paths argument only if none
	// of the environment variables is set.
	PluginDependencyFlagPathsAreDefaultOnly PluginDependencyFlags = 0b10
	// PluginDependencyFlagFileNameIsSuffix: interpret filename argument as
	// filter suffix and check all matching files in the directory.
	PluginDependencyFlagFileNameIsSuffix PluginDependencyFlags = 0b100
	// PluginDependencyFlagFileNameIsPrefix: interpret filename argument as
	// filter prefix and check all matching files in the directory. Since: 1.8.
	PluginDependencyFlagFileNameIsPrefix PluginDependencyFlags = 0b1000
	// PluginDependencyFlagPathsAreRelativeToExe: interpret non-absolute paths
	// as relative to the main executable directory. Since 1.14.
	PluginDependencyFlagPathsAreRelativeToExe PluginDependencyFlags = 0b10000
)

func marshalPluginDependencyFlags(p uintptr) (interface{}, error) {
	return PluginDependencyFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PluginDependencyFlags.
func (p PluginDependencyFlags) String() string {
	if p == 0 {
		return "PluginDependencyFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(208)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PluginDependencyFlagNone:
			builder.WriteString("None|")
		case PluginDependencyFlagRecurse:
			builder.WriteString("Recurse|")
		case PluginDependencyFlagPathsAreDefaultOnly:
			builder.WriteString("PathsAreDefaultOnly|")
		case PluginDependencyFlagFileNameIsSuffix:
			builder.WriteString("FileNameIsSuffix|")
		case PluginDependencyFlagFileNameIsPrefix:
			builder.WriteString("FileNameIsPrefix|")
		case PluginDependencyFlagPathsAreRelativeToExe:
			builder.WriteString("PathsAreRelativeToExe|")
		default:
			builder.WriteString(fmt.Sprintf("PluginDependencyFlags(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PluginDependencyFlags) Has(other PluginDependencyFlags) bool {
	return (p & other) == other
}

// PluginFlags: plugin loading state.
type PluginFlags C.guint

const (
	// PluginFlagCached: temporarily loaded plugins.
	PluginFlagCached PluginFlags = 0b10000
	// PluginFlagBlacklisted: plugin won't be scanned (again).
	PluginFlagBlacklisted PluginFlags = 0b100000
)

func marshalPluginFlags(p uintptr) (interface{}, error) {
	return PluginFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PluginFlags.
func (p PluginFlags) String() string {
	if p == 0 {
		return "PluginFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(38)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PluginFlagCached:
			builder.WriteString("Cached|")
		case PluginFlagBlacklisted:
			builder.WriteString("Blacklisted|")
		default:
			builder.WriteString(fmt.Sprintf("PluginFlags(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PluginFlags) Has(other PluginFlags) bool {
	return (p & other) == other
}

// QueryTypeFlags indicate the aspects of the different QueryType values.
// You can get the type flags of a QueryType with the gst_query_type_get_flags()
// function.
type QueryTypeFlags C.guint

const (
	// QueryTypeUpstream: set if the query can travel upstream.
	QueryTypeUpstream QueryTypeFlags = 0b1
	// QueryTypeDownstream: set if the query can travel downstream.
	QueryTypeDownstream QueryTypeFlags = 0b10
	// QueryTypeSerialized: set if the query should be serialized with data
	// flow.
	QueryTypeSerialized QueryTypeFlags = 0b100
)

func marshalQueryTypeFlags(p uintptr) (interface{}, error) {
	return QueryTypeFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for QueryTypeFlags.
func (q QueryTypeFlags) String() string {
	if q == 0 {
		return "QueryTypeFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(57)

	for q != 0 {
		next := q & (q - 1)
		bit := q - next

		switch bit {
		case QueryTypeUpstream:
			builder.WriteString("Upstream|")
		case QueryTypeDownstream:
			builder.WriteString("Downstream|")
		case QueryTypeSerialized:
			builder.WriteString("Serialized|")
		default:
			builder.WriteString(fmt.Sprintf("QueryTypeFlags(0b%b)|", bit))
		}

		q = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if q contains other.
func (q QueryTypeFlags) Has(other QueryTypeFlags) bool {
	return (q & other) == other
}

// SchedulingFlags: different scheduling flags.
type SchedulingFlags C.guint

const (
	// SchedulingFlagSeekable: if seeking is possible.
	SchedulingFlagSeekable SchedulingFlags = 0b1
	// SchedulingFlagSequential: if sequential access is recommended.
	SchedulingFlagSequential SchedulingFlags = 0b10
	// SchedulingFlagBandwidthLimited: if bandwidth is limited and buffering
	// possible (since 1.2).
	SchedulingFlagBandwidthLimited SchedulingFlags = 0b100
)

func marshalSchedulingFlags(p uintptr) (interface{}, error) {
	return SchedulingFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for SchedulingFlags.
func (s SchedulingFlags) String() string {
	if s == 0 {
		return "SchedulingFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(78)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case SchedulingFlagSeekable:
			builder.WriteString("Seekable|")
		case SchedulingFlagSequential:
			builder.WriteString("Sequential|")
		case SchedulingFlagBandwidthLimited:
			builder.WriteString("BandwidthLimited|")
		default:
			builder.WriteString(fmt.Sprintf("SchedulingFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s SchedulingFlags) Has(other SchedulingFlags) bool {
	return (s & other) == other
}

// SeekFlags flags to be used with gst_element_seek() or gst_event_new_seek().
// All flags can be used together.
//
// A non flushing seek might take some time to perform as the currently playing
// data in the pipeline will not be cleared.
//
// An accurate seek might be slower for formats that don't have any indexes
// or timestamp markers in the stream. Specifying this flag might require a
// complete scan of the file in those cases.
//
// When performing a segment seek: after the playback of the segment completes,
// no EOS will be emitted by the element that performed the seek, but a
// GST_MESSAGE_SEGMENT_DONE message will be posted on the bus by the element.
// When this message is posted, it is possible to send a new seek event to
// continue playback. With this seek method it is possible to perform seamless
// looping or simple linear editing.
//
// When only changing the playback rate and not the direction, the
// GST_SEEK_FLAG_INSTANT_RATE_CHANGE flag can be used for a non-flushing
// seek to signal that the rate change should be applied immediately.
// This requires special support in the seek handlers (e.g. demuxers) and any
// elements synchronizing to the clock, and in general can't work in all cases
// (for example UDP streaming where the delivery rate is controlled by a remote
// server). The instant-rate-change mode supports changing the trickmode-related
// GST_SEEK_ flags, but can't be used in conjunction with other seek flags
// that affect the new playback position - as the playback position will not be
// changing.
//
// When doing fast forward (rate > 1.0) or fast reverse (rate < -1.0) trickmode
// playback, the GST_SEEK_FLAG_TRICKMODE flag can be used to instruct decoders
// and demuxers to adjust the playback rate by skipping frames. This can improve
// performance and decrease CPU usage because not all frames need to be decoded.
//
// Beyond that, the GST_SEEK_FLAG_TRICKMODE_KEY_UNITS flag can be
// used to request that decoders skip all frames except key units, and
// GST_SEEK_FLAG_TRICKMODE_NO_AUDIO flags can be used to request that audio
// decoders do no decoding at all, and simple output silence.
//
// The GST_SEEK_FLAG_SNAP_BEFORE flag can be used to snap to the previous
// relevant location, and the GST_SEEK_FLAG_SNAP_AFTER flag can be used to
// select the next relevant location. If GST_SEEK_FLAG_KEY_UNIT is specified,
// the relevant location is a keyframe. If both flags are specified,
// the nearest of these locations will be selected. If none are specified,
// the implementation is free to select whichever it wants.
//
// The before and after here are in running time, so when playing backwards,
// the next location refers to the one that will played in next, and not the one
// that is located after in the actual source stream.
//
// Also see part-seeking.txt in the GStreamer design documentation for more
// details on the meaning of these flags and the behaviour expected of elements
// that handle them.
type SeekFlags C.guint

const (
	// SeekFlagNone: no flag.
	SeekFlagNone SeekFlags = 0b0
	// SeekFlagFlush: flush pipeline.
	SeekFlagFlush SeekFlags = 0b1
	// SeekFlagAccurate: accurate position is requested, this might be
	// considerably slower for some formats.
	SeekFlagAccurate SeekFlags = 0b10
	// SeekFlagKeyUnit: seek to the nearest keyframe. This might be faster but
	// less accurate.
	SeekFlagKeyUnit SeekFlags = 0b100
	// SeekFlagSegment: perform a segment seek.
	SeekFlagSegment SeekFlags = 0b1000
	// SeekFlagTrickmode: when doing fast forward or fast reverse playback,
	// allow elements to skip frames instead of generating all frames. (Since:
	// 1.6).
	SeekFlagTrickmode SeekFlags = 0b10000
	// SeekFlagSkip: deprecated backward compatibility flag, replaced by
	// GST_SEEK_FLAG_TRICKMODE.
	SeekFlagSkip SeekFlags = 0b10000
	// SeekFlagSnapBefore: go to a location before the requested position, if
	// GST_SEEK_FLAG_KEY_UNIT this means the keyframe at or before the requested
	// position the one at or before the seek target.
	SeekFlagSnapBefore SeekFlags = 0b100000
	// SeekFlagSnapAfter: go to a location after the requested position, if
	// GST_SEEK_FLAG_KEY_UNIT this means the keyframe at of after the requested
	// position.
	SeekFlagSnapAfter SeekFlags = 0b1000000
	// SeekFlagSnapNearest: go to a position near the requested position, if
	// GST_SEEK_FLAG_KEY_UNIT this means the keyframe closest to the requested
	// position, if both keyframes are at an equal distance, behaves like
	// GST_SEEK_FLAG_SNAP_BEFORE.
	SeekFlagSnapNearest SeekFlags = 0b1100000
	// SeekFlagTrickmodeKeyUnits: when doing fast forward or fast reverse
	// playback, request that elements only decode keyframes and skip all other
	// content, for formats that have keyframes. (Since: 1.6).
	SeekFlagTrickmodeKeyUnits SeekFlags = 0b10000000
	// SeekFlagTrickmodeNoAudio: when doing fast forward or fast reverse
	// playback, request that audio decoder elements skip decoding and output
	// only gap events or silence. (Since: 1.6).
	SeekFlagTrickmodeNoAudio SeekFlags = 0b100000000
	// SeekFlagTrickmodeForwardPredicted: when doing fast forward or fast
	// reverse playback, request that elements only decode keyframes and forward
	// predicted frames and skip all other content (for example B-Frames),
	// for formats that have keyframes and forward predicted frames. (Since:
	// 1.18).
	SeekFlagTrickmodeForwardPredicted SeekFlags = 0b1000000000
	// SeekFlagInstantRateChange signals that a rate change should be applied
	// immediately. Only valid if start/stop position are GST_CLOCK_TIME_NONE,
	// the playback direction does not change and the seek is not flushing.
	// (Since: 1.18).
	SeekFlagInstantRateChange SeekFlags = 0b10000000000
)

func marshalSeekFlags(p uintptr) (interface{}, error) {
	return SeekFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for SeekFlags.
func (s SeekFlags) String() string {
	if s == 0 {
		return "SeekFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case SeekFlagNone:
			builder.WriteString("None|")
		case SeekFlagFlush:
			builder.WriteString("Flush|")
		case SeekFlagAccurate:
			builder.WriteString("Accurate|")
		case SeekFlagKeyUnit:
			builder.WriteString("KeyUnit|")
		case SeekFlagSegment:
			builder.WriteString("Segment|")
		case SeekFlagTrickmode:
			builder.WriteString("Trickmode|")
		case SeekFlagSnapBefore:
			builder.WriteString("SnapBefore|")
		case SeekFlagSnapAfter:
			builder.WriteString("SnapAfter|")
		case SeekFlagSnapNearest:
			builder.WriteString("SnapNearest|")
		case SeekFlagTrickmodeKeyUnits:
			builder.WriteString("TrickmodeKeyUnits|")
		case SeekFlagTrickmodeNoAudio:
			builder.WriteString("TrickmodeNoAudio|")
		case SeekFlagTrickmodeForwardPredicted:
			builder.WriteString("TrickmodeForwardPredicted|")
		case SeekFlagInstantRateChange:
			builder.WriteString("InstantRateChange|")
		default:
			builder.WriteString(fmt.Sprintf("SeekFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s SeekFlags) Has(other SeekFlags) bool {
	return (s & other) == other
}

// SegmentFlags flags for the GstSegment structure. Currently mapped to the
// corresponding values of the seek flags.
type SegmentFlags C.guint

const (
	// SegmentFlagNone: no flags.
	SegmentFlagNone SegmentFlags = 0b0
	// SegmentFlagReset: reset the pipeline running_time to the segment
	// running_time.
	SegmentFlagReset SegmentFlags = 0b1
	// SegmentFlagTrickmode: perform skip playback (Since: 1.6).
	SegmentFlagTrickmode SegmentFlags = 0b10000
	// SegmentFlagSkip: deprecated backward compatibility flag, replaced by
	// GST_SEGMENT_FLAG_TRICKMODE.
	SegmentFlagSkip SegmentFlags = 0b10000
	// SegmentFlagSegment: send SEGMENT_DONE instead of EOS.
	SegmentFlagSegment SegmentFlags = 0b1000
	// SegmentFlagTrickmodeKeyUnits: decode only keyframes, where possible
	// (Since: 1.6).
	SegmentFlagTrickmodeKeyUnits SegmentFlags = 0b10000000
	// SegmentFlagTrickmodeForwardPredicted: decode only keyframes or forward
	// predicted frames, where possible (Since: 1.18).
	SegmentFlagTrickmodeForwardPredicted SegmentFlags = 0b1000000000
	// SegmentFlagTrickmodeNoAudio: do not decode any audio, where possible
	// (Since: 1.6).
	SegmentFlagTrickmodeNoAudio SegmentFlags = 0b100000000
)

func marshalSegmentFlags(p uintptr) (interface{}, error) {
	return SegmentFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for SegmentFlags.
func (s SegmentFlags) String() string {
	if s == 0 {
		return "SegmentFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(182)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case SegmentFlagNone:
			builder.WriteString("None|")
		case SegmentFlagReset:
			builder.WriteString("Reset|")
		case SegmentFlagTrickmode:
			builder.WriteString("Trickmode|")
		case SegmentFlagSegment:
			builder.WriteString("Segment|")
		case SegmentFlagTrickmodeKeyUnits:
			builder.WriteString("TrickmodeKeyUnits|")
		case SegmentFlagTrickmodeForwardPredicted:
			builder.WriteString("TrickmodeForwardPredicted|")
		case SegmentFlagTrickmodeNoAudio:
			builder.WriteString("TrickmodeNoAudio|")
		default:
			builder.WriteString(fmt.Sprintf("SegmentFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s SegmentFlags) Has(other SegmentFlags) bool {
	return (s & other) == other
}

type SerializeFlags C.guint

const (
	// SerializeFlagNone: no special flags specified.
	SerializeFlagNone SerializeFlags = 0b0
	// SerializeFlagBackwardCompat: serialize using the old format for nested
	// structures.
	SerializeFlagBackwardCompat SerializeFlags = 0b1
	// SerializeFlagStrict: serialization fails if a value cannot be serialized
	// instead of using placeholder "NULL" value (e.g. pointers, objects).
	SerializeFlagStrict SerializeFlags = 0b10
)

func marshalSerializeFlags(p uintptr) (interface{}, error) {
	return SerializeFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for SerializeFlags.
func (s SerializeFlags) String() string {
	if s == 0 {
		return "SerializeFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(65)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case SerializeFlagNone:
			builder.WriteString("None|")
		case SerializeFlagBackwardCompat:
			builder.WriteString("BackwardCompat|")
		case SerializeFlagStrict:
			builder.WriteString("Strict|")
		default:
			builder.WriteString(fmt.Sprintf("SerializeFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s SerializeFlags) Has(other SerializeFlags) bool {
	return (s & other) == other
}

type StackTraceFlags C.guint

const (
	// StackTraceShowNone: try to retrieve the minimum information available,
	// which may be none on some platforms (Since: 1.18).
	StackTraceShowNone StackTraceFlags = 0b0
	// StackTraceShowFull: try to retrieve as much information as possible,
	// including source information when getting the stack trace.
	StackTraceShowFull StackTraceFlags = 0b1
)

func marshalStackTraceFlags(p uintptr) (interface{}, error) {
	return StackTraceFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for StackTraceFlags.
func (s StackTraceFlags) String() string {
	if s == 0 {
		return "StackTraceFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(37)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case StackTraceShowNone:
			builder.WriteString("None|")
		case StackTraceShowFull:
			builder.WriteString("Full|")
		default:
			builder.WriteString(fmt.Sprintf("StackTraceFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s StackTraceFlags) Has(other StackTraceFlags) bool {
	return (s & other) == other
}

type StreamFlags C.guint

const (
	// StreamFlagNone: this stream has no special attributes.
	StreamFlagNone StreamFlags = 0b0
	// StreamFlagSparse: this stream is a sparse stream (e.g. a subtitle
	// stream), data may flow only in irregular intervals with large gaps in
	// between.
	StreamFlagSparse StreamFlags = 0b1
	// StreamFlagSelect: this stream should be selected by default. This flag
	// may be used by demuxers to signal that a stream should be selected by
	// default in a playback scenario.
	StreamFlagSelect StreamFlags = 0b10
	// StreamFlagUnselect: this stream should not be selected by default.
	// This flag may be used by demuxers to signal that a stream should not
	// be selected by default in a playback scenario, but only if explicitly
	// selected by the user (e.g. an audio track for the hard of hearing or a
	// director's commentary track).
	StreamFlagUnselect StreamFlags = 0b100
)

func marshalStreamFlags(p uintptr) (interface{}, error) {
	return StreamFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for StreamFlags.
func (s StreamFlags) String() string {
	if s == 0 {
		return "StreamFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(67)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case StreamFlagNone:
			builder.WriteString("None|")
		case StreamFlagSparse:
			builder.WriteString("Sparse|")
		case StreamFlagSelect:
			builder.WriteString("Select|")
		case StreamFlagUnselect:
			builder.WriteString("Unselect|")
		default:
			builder.WriteString(fmt.Sprintf("StreamFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s StreamFlags) Has(other StreamFlags) bool {
	return (s & other) == other
}

// StreamType describes a high level classification set for flows of data in
// Stream objects.
//
// Note that this is a flag, and therefore users should not assume it will be a
// single value. Do not use the equality operator for checking whether a stream
// is of a certain type.
type StreamType C.guint

const (
	// StreamTypeUnknown: stream is of unknown (unclassified) type.
	StreamTypeUnknown StreamType = 0b1
	// StreamTypeAudio: stream is of audio data.
	StreamTypeAudio StreamType = 0b10
	// StreamTypeVideo: stream carries video data.
	StreamTypeVideo StreamType = 0b100
	// StreamTypeContainer: stream is a muxed container type.
	StreamTypeContainer StreamType = 0b1000
	// StreamTypeText: stream contains subtitle / subpicture data.
	StreamTypeText StreamType = 0b10000
)

func marshalStreamType(p uintptr) (interface{}, error) {
	return StreamType(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for StreamType.
func (s StreamType) String() string {
	if s == 0 {
		return "StreamType(0)"
	}

	var builder strings.Builder
	builder.Grow(84)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case StreamTypeUnknown:
			builder.WriteString("Unknown|")
		case StreamTypeAudio:
			builder.WriteString("Audio|")
		case StreamTypeVideo:
			builder.WriteString("Video|")
		case StreamTypeContainer:
			builder.WriteString("Container|")
		case StreamTypeText:
			builder.WriteString("Text|")
		default:
			builder.WriteString(fmt.Sprintf("StreamType(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s StreamType) Has(other StreamType) bool {
	return (s & other) == other
}

// StreamTypeGetName: get a descriptive string for a given StreamType.
//
// The function takes the following parameters:
//
//   - stype: StreamType.
//
// The function returns the following values:
//
//   - utf8: string describing the stream type.
func StreamTypeGetName(stype StreamType) string {
	var _arg1 C.GstStreamType // out
	var _cret *C.gchar        // in

	_arg1 = C.GstStreamType(stype)

	_cret = C.gst_stream_type_get_name(_arg1)
	runtime.KeepAlive(stype)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TracerValueFlags: flag that describe the value. These flags help applications
// processing the logs to understand the values.
type TracerValueFlags C.guint

const (
	// TracerValueFlagsNone: no flags.
	TracerValueFlagsNone TracerValueFlags = 0b0
	// TracerValueFlagsOptional: value is optional. When using this flag one
	// need to have an additional boolean arg before this value in the var-args
	// list passed to gst_tracer_record_log().
	TracerValueFlagsOptional TracerValueFlags = 0b1
	// TracerValueFlagsAggregated: value is a combined figure, since the start
	// of tracing. Examples are averages or timestamps.
	TracerValueFlagsAggregated TracerValueFlags = 0b10
)

func marshalTracerValueFlags(p uintptr) (interface{}, error) {
	return TracerValueFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TracerValueFlags.
func (t TracerValueFlags) String() string {
	if t == 0 {
		return "TracerValueFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(72)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TracerValueFlagsNone:
			builder.WriteString("None|")
		case TracerValueFlagsOptional:
			builder.WriteString("Optional|")
		case TracerValueFlagsAggregated:
			builder.WriteString("Aggregated|")
		default:
			builder.WriteString(fmt.Sprintf("TracerValueFlags(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TracerValueFlags) Has(other TracerValueFlags) bool {
	return (t & other) == other
}

// BufferForEachMetaFunc: function that will be called from
// gst_buffer_foreach_meta(). The meta field will point to a the reference of
// the meta.
//
// buffer should not be modified from this callback.
//
// When this function returns TRUE, the next meta will be returned. When FALSE
// is returned, gst_buffer_foreach_meta() will return.
//
// When meta is set to NULL, the item will be removed from the buffer.
type BufferForEachMetaFunc func(buffer *Buffer) (meta *Meta, ok bool)

// BufferListFunc: function that will be called from gst_buffer_list_foreach().
// The buffer field will point to a the reference of the buffer at idx.
//
// When this function returns TRUE, the next buffer will be returned. When FALSE
// is returned, gst_buffer_list_foreach() will return.
//
// When buffer is set to NULL, the item will be removed from the bufferlist.
// When buffer has been made writable, the new buffer reference can be assigned
// to buffer. This function is responsible for unreffing the old buffer when
// removing or modifying.
type BufferListFunc func(idx uint) (buffer *Buffer, ok bool)

// BusFunc specifies the type of function passed to gst_bus_add_watch() or
// gst_bus_add_watch_full(), which is called from the mainloop when a message is
// available on the bus.
//
// The message passed to the function will be unreffed after execution of this
// function so it should not be freed in the function.
//
// Note that this function is used as a Func which means that returning FALSE
// will remove the #GSource from the mainloop.
type BusFunc func(bus *Bus, message *Message) (ok bool)

// BusSyncHandler: handler will be invoked synchronously, when a new message
// has been injected into the bus. This function is mostly used internally.
// Only one sync handler can be attached to a given bus.
//
// If the handler returns GST_BUS_DROP, it should unref the message, else the
// message should not be unreffed by the sync handler.
type BusSyncHandler func(bus *Bus, message *Message) (busSyncReply BusSyncReply)

// CapsFilterMapFunc: function that will be called in
// gst_caps_filter_and_map_in_place(). The function may modify features and
// structure, and both will be removed from the caps if FALSE is returned.
type CapsFilterMapFunc func(features *CapsFeatures, structure *Structure) (ok bool)

// CapsForEachFunc: function that will be called in gst_caps_foreach().
// The function may not modify features or structure.
type CapsForEachFunc func(features *CapsFeatures, structure *Structure) (ok bool)

// CapsMapFunc: function that will be called in gst_caps_map_in_place().
// The function may modify features and structure.
type CapsMapFunc func(features *CapsFeatures, structure *Structure) (ok bool)

// ClockCallback: function prototype of the callback.
type ClockCallback func(clock Clocker, time ClockTime, id ClockID) (ok bool)

// CustomMetaTransformFunction: function called for each meta in buffer as a
// result of performing a transformation that yields transbuf. Additional type
// specific transform data is passed to the function as data.
//
// Implementations should check the type of the transform and parse additional
// type specific fields in data that should be used to update the metadata on
// transbuf.
type CustomMetaTransformFunction func(transbuf *Buffer, meta *CustomMeta, buffer *Buffer, typ glib.Quark, data unsafe.Pointer) (ok bool)

// ElementCallAsyncFunc: callback prototype used in #gst_element_call_async.
type ElementCallAsyncFunc func(element Elementer)

// ElementForEachPadFunc: function called for each pad when using
// gst_element_foreach_sink_pad(), gst_element_foreach_src_pad(), or
// gst_element_foreach_pad().
type ElementForEachPadFunc func(element Elementer, pad *Pad) (ok bool)

// IteratorFoldFunction: function to be passed to gst_iterator_fold().
type IteratorFoldFunction func(item, ret *coreglib.Value) (ok bool)

// IteratorForEachFunction: function that is called by gst_iterator_foreach()
// for every element.
type IteratorForEachFunction func(item *coreglib.Value)

// MiniObjectNotify function can be added to a mini object as a callback that
// gets triggered when gst_mini_object_unref() drops the last ref and obj is
// about to be freed.
type MiniObjectNotify func(obj *MiniObject)

// PadForwardFunction: forward function is called for all internally linked
// pads, see gst_pad_forward().
type PadForwardFunction func(pad *Pad) (ok bool)

// PadProbeCallback: callback used by gst_pad_add_probe(). Gets called to notify
// about the current blocking type.
//
// The callback is allowed to modify the data pointer in info.
type PadProbeCallback func(pad *Pad, info *PadProbeInfo) (padProbeReturn PadProbeReturn)

// PadStickyEventsForEachFunction: callback used by
// gst_pad_sticky_events_foreach().
//
// When this function returns TRUE, the next event will be returned. When FALSE
// is returned, gst_pad_sticky_events_foreach() will return.
//
// When event is set to NULL, the item will be removed from the list of
// sticky events. event can be replaced by assigning a new reference to it.
// This function is responsible for unreffing the old event when removing or
// modifying.
type PadStickyEventsForEachFunction func(pad *Pad, event *Event) (ok bool)

// PluginFeatureFilter: function that can be used with e.g.
// gst_registry_feature_filter() to get a list of pluginfeature that match
// certain criteria.
type PluginFeatureFilter func(feature PluginFeaturer) (ok bool)

// PluginFilter: function that can be used with e.g.
// gst_registry_plugin_filter() to get a list of plugins that match certain
// criteria.
type PluginFilter func(plugin *Plugin) (ok bool)

// PluginInitFullFunc: plugin should provide a pointer to a function of either
// PluginInitFunc or this type in the plugin_desc struct. The function will be
// called by the loader at startup. One would then register each PluginFeature.
// This version allows user data to be passed to init function (useful for
// bindings).
type PluginInitFullFunc func(plugin *Plugin) (ok bool)

type PromiseChangeFunc func(promise *Promise)

// StructureFilterMapFunc: function that will be called in
// gst_structure_filter_and_map_in_place(). The function may modify value,
// and the value will be removed from the structure if FALSE is returned.
type StructureFilterMapFunc func(fieldId glib.Quark, value *coreglib.Value) (ok bool)

// StructureForEachFunc: function that will be called in
// gst_structure_foreach(). The function may not modify value.
type StructureForEachFunc func(fieldId glib.Quark, value *coreglib.Value) (ok bool)

// StructureMapFunc: function that will be called in
// gst_structure_map_in_place(). The function may modify value.
type StructureMapFunc func(fieldId glib.Quark, value *coreglib.Value) (ok bool)

// TagForEachFunc: function that will be called in gst_tag_list_foreach().
// The function may not modify the tag list.
type TagForEachFunc func(list *TagList, tag string)

// TaskFunction: function that will repeatedly be called in the thread created
// by a Task.
type TaskFunction func()

// TypeFindFunction: function that will be called by typefinding.
type TypeFindFunction func(find *TypeFind)

// DebugAddRingBufferLogger adds a memory ringbuffer based debug logger that
// stores up to max_size_per_thread bytes of logs per thread and times out
// threads after thread_timeout seconds of inactivity.
//
// Logs can be fetched with gst_debug_ring_buffer_logger_get_logs() and the
// logger can be removed again with gst_debug_remove_ring_buffer_logger().
// Only one logger at a time is possible.
//
// The function takes the following parameters:
//
//   - maxSizePerThread: maximum size of log per thread in bytes.
//   - threadTimeout: timeout for threads in seconds.
func DebugAddRingBufferLogger(maxSizePerThread, threadTimeout uint) {
	var _arg1 C.guint // out
	var _arg2 C.guint // out

	_arg1 = C.guint(maxSizePerThread)
	_arg2 = C.guint(threadTimeout)

	C.gst_debug_add_ring_buffer_logger(_arg1, _arg2)
	runtime.KeepAlive(maxSizePerThread)
	runtime.KeepAlive(threadTimeout)
}

// DebugBinToDotData: to aid debugging applications one can use this method to
// obtain the whole network of gstreamer elements that form the pipeline into a
// dot file. This data can be processed with graphviz to get an image.
//
// The function takes the following parameters:
//
//   - bin: top-level pipeline that should be analyzed.
//   - details: type of DebugGraphDetails to use.
//
// The function returns the following values:
//
//   - utf8: string containing the pipeline in graphviz dot format.
func DebugBinToDotData(bin *Bin, details DebugGraphDetails) string {
	var _arg1 *C.GstBin              // out
	var _arg2 C.GstDebugGraphDetails // out
	var _cret *C.gchar               // in

	_arg1 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg2 = C.GstDebugGraphDetails(details)

	_cret = C.gst_debug_bin_to_dot_data(_arg1, _arg2)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(details)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DebugBinToDotFile: to aid debugging applications one can use this method to
// write out the whole network of gstreamer elements that form the pipeline into
// a dot file. This file can be processed with graphviz to get an image.
//
//	shell  dot -Tpng -oimage.png graph_lowlevel.dot.
//
// The function takes the following parameters:
//
//   - bin: top-level pipeline that should be analyzed.
//   - details: type of DebugGraphDetails to use.
//   - fileName: output base filename (e.g. "myplayer").
func DebugBinToDotFile(bin *Bin, details DebugGraphDetails, fileName string) {
	var _arg1 *C.GstBin              // out
	var _arg2 C.GstDebugGraphDetails // out
	var _arg3 *C.gchar               // out

	_arg1 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg2 = C.GstDebugGraphDetails(details)
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(_arg3))

	C.gst_debug_bin_to_dot_file(_arg1, _arg2, _arg3)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(details)
	runtime.KeepAlive(fileName)
}

// DebugBinToDotFileWithTs: this works like gst_debug_bin_to_dot_file(),
// but adds the current timestamp to the filename, so that it can be used to
// take multiple snapshots.
//
// The function takes the following parameters:
//
//   - bin: top-level pipeline that should be analyzed.
//   - details: type of DebugGraphDetails to use.
//   - fileName: output base filename (e.g. "myplayer").
func DebugBinToDotFileWithTs(bin *Bin, details DebugGraphDetails, fileName string) {
	var _arg1 *C.GstBin              // out
	var _arg2 C.GstDebugGraphDetails // out
	var _arg3 *C.gchar               // out

	_arg1 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg2 = C.GstDebugGraphDetails(details)
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(_arg3))

	C.gst_debug_bin_to_dot_file_with_ts(_arg1, _arg2, _arg3)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(details)
	runtime.KeepAlive(fileName)
}

// DebugConstructTermColor constructs a string that can be used for getting the
// desired color in color terminals. You need to free the string after use.
//
// The function takes the following parameters:
//
//   - colorinfo: color info.
//
// The function returns the following values:
//
//   - utf8: string containing the color definition.
func DebugConstructTermColor(colorinfo uint) string {
	var _arg1 C.guint  // out
	var _cret *C.gchar // in

	_arg1 = C.guint(colorinfo)

	_cret = C.gst_debug_construct_term_color(_arg1)
	runtime.KeepAlive(colorinfo)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DebugConstructWinColor constructs an integer that can be used for getting
// the desired color in windows' terminals (cmd.exe). As there is no mean to
// underline, we simply ignore this attribute.
//
// This function returns 0 on non-windows machines.
//
// The function takes the following parameters:
//
//   - colorinfo: color info.
//
// The function returns the following values:
//
//   - gint: integer containing the color definition.
func DebugConstructWinColor(colorinfo uint) int {
	var _arg1 C.guint // out
	var _cret C.gint  // in

	_arg1 = C.guint(colorinfo)

	_cret = C.gst_debug_construct_win_color(_arg1)
	runtime.KeepAlive(colorinfo)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// DebugGetAllCategories returns a snapshot of a all categories that are
// currently in use . This list may change anytime. The caller has to free the
// list after use.
//
// The function returns the following values:
//
//   - sList: list of debug categories.
func DebugGetAllCategories() []*DebugCategory {
	var _cret *C.GSList // in

	_cret = C.gst_debug_get_all_categories()

	var _sList []*DebugCategory // out

	_sList = make([]*DebugCategory, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstDebugCategory)(v)
		var dst *DebugCategory // out
		dst = (*DebugCategory)(gextras.NewStructNative(unsafe.Pointer(src)))
		_sList = append(_sList, dst)
	})

	return _sList
}

// DebugGetColorMode changes the coloring mode for debug output.
//
// The function returns the following values:
//
//   - debugColorMode: see GstDebugColorMode for possible values.
func DebugGetColorMode() DebugColorMode {
	var _cret C.GstDebugColorMode // in

	_cret = C.gst_debug_get_color_mode()

	var _debugColorMode DebugColorMode // out

	_debugColorMode = DebugColorMode(_cret)

	return _debugColorMode
}

// DebugGetDefaultThreshold returns the default threshold that is used for new
// categories.
//
// The function returns the following values:
//
//   - debugLevel: default threshold level.
func DebugGetDefaultThreshold() DebugLevel {
	var _cret C.GstDebugLevel // in

	_cret = C.gst_debug_get_default_threshold()

	var _debugLevel DebugLevel // out

	_debugLevel = DebugLevel(_cret)

	return _debugLevel
}

// The function takes the following parameters:
//
//   - flags: set of StackTraceFlags to determine how the stack trace should
//     look like. Pass T_STACK_TRACE_SHOW_NONE to retrieve a minimal backtrace.
//
// The function returns the following values:
//
//   - utf8 (optional): stack trace, if libunwind or glibc backtrace are
//     present, else NULL.
func DebugGetStackTrace(flags StackTraceFlags) string {
	var _arg1 C.GstStackTraceFlags // out
	var _cret *C.gchar             // in

	_arg1 = C.GstStackTraceFlags(flags)

	_cret = C.gst_debug_get_stack_trace(_arg1)
	runtime.KeepAlive(flags)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// DebugIsActive checks if debugging output is activated.
//
// The function returns the following values:
//
//   - ok: TRUE, if debugging is activated.
func DebugIsActive() bool {
	var _cret C.gboolean // in

	_cret = C.gst_debug_is_active()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DebugIsColored checks if the debugging output should be colored.
//
// The function returns the following values:
//
//   - ok: TRUE, if the debug output should be colored.
func DebugIsColored() bool {
	var _cret C.gboolean // in

	_cret = C.gst_debug_is_colored()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DebugLogIDLiteral logs the given message using the currently registered
// debugging handlers.
//
// The function takes the following parameters:
//
//   - category to log.
//   - level of the message is in.
//   - file that emitted the message, usually the __FILE__ identifier.
//   - function that emitted the message.
//   - line from that the message was emitted, usually __LINE__.
//   - id (optional): identifier of the object this message relates to or NULL
//     if none.
//   - messageString: message string.
func DebugLogIDLiteral(category *DebugCategory, level DebugLevel, file, function string, line int, id, messageString string) {
	var _arg1 *C.GstDebugCategory // out
	var _arg2 C.GstDebugLevel     // out
	var _arg3 *C.gchar            // out
	var _arg4 *C.gchar            // out
	var _arg5 C.gint              // out
	var _arg6 *C.gchar            // out
	var _arg7 *C.gchar            // out

	_arg1 = (*C.GstDebugCategory)(gextras.StructNative(unsafe.Pointer(category)))
	_arg2 = C.GstDebugLevel(level)
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(function)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = C.gint(line)
	if id != "" {
		_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(id)))
		defer C.free(unsafe.Pointer(_arg6))
	}
	_arg7 = (*C.gchar)(unsafe.Pointer(C.CString(messageString)))
	defer C.free(unsafe.Pointer(_arg7))

	C.gst_debug_log_id_literal(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(category)
	runtime.KeepAlive(level)
	runtime.KeepAlive(file)
	runtime.KeepAlive(function)
	runtime.KeepAlive(line)
	runtime.KeepAlive(id)
	runtime.KeepAlive(messageString)
}

// DebugLogLiteral logs the given message using the currently registered
// debugging handlers.
//
// The function takes the following parameters:
//
//   - category to log.
//   - level of the message is in.
//   - file that emitted the message, usually the __FILE__ identifier.
//   - function that emitted the message.
//   - line from that the message was emitted, usually __LINE__.
//   - object (optional) this message relates to, or NULL if none.
//   - messageString: message string.
func DebugLogLiteral(category *DebugCategory, level DebugLevel, file, function string, line int, object *coreglib.Object, messageString string) {
	var _arg1 *C.GstDebugCategory // out
	var _arg2 C.GstDebugLevel     // out
	var _arg3 *C.gchar            // out
	var _arg4 *C.gchar            // out
	var _arg5 C.gint              // out
	var _arg6 *C.GObject          // out
	var _arg7 *C.gchar            // out

	_arg1 = (*C.GstDebugCategory)(gextras.StructNative(unsafe.Pointer(category)))
	_arg2 = C.GstDebugLevel(level)
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(function)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = C.gint(line)
	if object != nil {
		_arg6 = (*C.GObject)(unsafe.Pointer(object.Native()))
	}
	_arg7 = (*C.gchar)(unsafe.Pointer(C.CString(messageString)))
	defer C.free(unsafe.Pointer(_arg7))

	C.gst_debug_log_literal(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(category)
	runtime.KeepAlive(level)
	runtime.KeepAlive(file)
	runtime.KeepAlive(function)
	runtime.KeepAlive(line)
	runtime.KeepAlive(object)
	runtime.KeepAlive(messageString)
}

// DebugPrintStackTrace: if libunwind, glibc backtrace or DbgHelp are present a
// stack trace is printed.
func DebugPrintStackTrace() {
	C.gst_debug_print_stack_trace()
}

// DebugRemoveLogFunctionByData removes all registered instances of log
// functions with the given user data.
//
// The function takes the following parameters:
//
//   - data (optional): user data of the log function to remove.
//
// The function returns the following values:
//
//   - guint: how many instances of the function were removed.
func DebugRemoveLogFunctionByData(data unsafe.Pointer) uint {
	var _arg1 C.gpointer // out
	var _cret C.guint    // in

	_arg1 = (C.gpointer)(unsafe.Pointer(data))

	_cret = C.gst_debug_remove_log_function_by_data(_arg1)
	runtime.KeepAlive(data)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// DebugRemoveRingBufferLogger removes any previously added ring buffer logger
// with gst_debug_add_ring_buffer_logger().
func DebugRemoveRingBufferLogger() {
	C.gst_debug_remove_ring_buffer_logger()
}

// DebugRingBufferLoggerGetLogs fetches the current logs per thread from the
// ring buffer logger. See gst_debug_add_ring_buffer_logger() for details.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of strings with the debug output per thread.
func DebugRingBufferLoggerGetLogs() []string {
	var _cret **C.gchar // in

	_cret = C.gst_debug_ring_buffer_logger_get_logs()

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// DebugSetActive: if activated, debugging messages are sent to the debugging
// handlers. It makes sense to deactivate it for speed issues. > This function
// is not threadsafe. It makes sense to only call it during initialization.
//
// The function takes the following parameters:
//
//   - active: whether to use debugging output or not.
func DebugSetActive(active bool) {
	var _arg1 C.gboolean // out

	if active {
		_arg1 = C.TRUE
	}

	C.gst_debug_set_active(_arg1)
	runtime.KeepAlive(active)
}

// DebugSetColorMode changes the coloring mode for debug output.
//
// This function may be called before gst_init().
//
// The function takes the following parameters:
//
//   - mode: coloring mode for debug output. See GstDebugColorMode.
func DebugSetColorMode(mode DebugColorMode) {
	var _arg1 C.GstDebugColorMode // out

	_arg1 = C.GstDebugColorMode(mode)

	C.gst_debug_set_color_mode(_arg1)
	runtime.KeepAlive(mode)
}

// DebugSetColorModeFromString changes the coloring mode for debug output.
//
// This function may be called before gst_init().
//
// The function takes the following parameters:
//
//   - mode: coloring mode for debug output. One of the following: "on", "auto",
//     "off", "disable", "unix".
func DebugSetColorModeFromString(mode string) {
	var _arg1 *C.gchar // out

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(mode)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_debug_set_color_mode_from_string(_arg1)
	runtime.KeepAlive(mode)
}

// DebugSetColored sets or unsets the use of coloured debugging output.
// Same as gst_debug_set_color_mode () with the argument being being
// GST_DEBUG_COLOR_MODE_ON or GST_DEBUG_COLOR_MODE_OFF.
//
// This function may be called before gst_init().
//
// The function takes the following parameters:
//
//   - colored: whether to use colored output or not.
func DebugSetColored(colored bool) {
	var _arg1 C.gboolean // out

	if colored {
		_arg1 = C.TRUE
	}

	C.gst_debug_set_colored(_arg1)
	runtime.KeepAlive(colored)
}

// DebugSetDefaultThreshold sets the default threshold to the given level and
// updates all categories to use this threshold.
//
// This function may be called before gst_init().
//
// The function takes the following parameters:
//
//   - level to set.
func DebugSetDefaultThreshold(level DebugLevel) {
	var _arg1 C.GstDebugLevel // out

	_arg1 = C.GstDebugLevel(level)

	C.gst_debug_set_default_threshold(_arg1)
	runtime.KeepAlive(level)
}

// DebugSetThresholdForName sets all categories which match the given glob style
// pattern to the given level.
//
// The function takes the following parameters:
//
//   - name of the categories to set.
//   - level to set them to.
func DebugSetThresholdForName(name string, level DebugLevel) {
	var _arg1 *C.gchar        // out
	var _arg2 C.GstDebugLevel // out

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GstDebugLevel(level)

	C.gst_debug_set_threshold_for_name(_arg1, _arg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(level)
}

// DebugSetThresholdFromString sets the debug logging wanted in the same form as
// with the GST_DEBUG environment variable. You can use wildcards such as *, but
// note that the order matters when you use wild cards, e.g. foosrc:6,*src:3,*:2
// sets everything to log level 2.
//
// The function takes the following parameters:
//
//   - list: comma-separated list of "category:level" pairs to be used as debug
//     logging levels.
//   - reset: TRUE to clear all previously-set debug levels before setting new
//     thresholds FALSE if adding the threshold described by list to the one
//     already set.
func DebugSetThresholdFromString(list string, reset bool) {
	var _arg1 *C.gchar   // out
	var _arg2 C.gboolean // out

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(list)))
	defer C.free(unsafe.Pointer(_arg1))
	if reset {
		_arg2 = C.TRUE
	}

	C.gst_debug_set_threshold_from_string(_arg1, _arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(reset)
}

// DebugUnsetThresholdForName resets all categories with the given name back to
// the default level.
//
// The function takes the following parameters:
//
//   - name of the categories to set.
func DebugUnsetThresholdForName(name string) {
	var _arg1 *C.gchar // out

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_debug_unset_threshold_for_name(_arg1)
	runtime.KeepAlive(name)
}

// Deinit: clean up any resources created by GStreamer in gst_init().
//
// It is normally not needed to call this function in a normal application as
// the resources will automatically be freed when the program terminates. This
// function is therefore mostly used by testsuites and other memory profiling
// tools.
//
// After this call GStreamer (including this method) should not be used anymore.
func Deinit() {
	C.gst_deinit()
}

// DynamicTypeRegister registers a new DynamicTypeFactory in the registry.
//
// The function takes the following parameters:
//
//   - plugin to register dyn_type for.
//   - typ to register dynamically.
func DynamicTypeRegister(plugin *Plugin, typ coreglib.Type) bool {
	var _arg1 *C.GstPlugin // out
	var _arg2 C.GType      // out
	var _cret C.gboolean   // in

	_arg1 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))
	_arg2 = C.GType(typ)

	_cret = C.gst_dynamic_type_register(_arg1, _arg2)
	runtime.KeepAlive(plugin)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ErrorGetMessage: get a string describing the error message in the current
// locale.
//
// The function takes the following parameters:
//
//   - domain: GStreamer error domain this error belongs to.
//   - code: error code belonging to the domain.
//
// The function returns the following values:
//
//   - utf8: newly allocated string describing the error message (in UTF-8
//     encoding).
func ErrorGetMessage(domain glib.Quark, code int) string {
	var _arg1 C.GQuark // out
	var _arg2 C.gint   // out
	var _cret *C.gchar // in

	_arg1 = C.GQuark(domain)
	_arg2 = C.gint(code)

	_cret = C.gst_error_get_message(_arg1, _arg2)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(code)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FilenameToURI: similar to g_filename_to_uri(), but attempts to handle
// relative file paths as well. Before converting filename into an URI, it
// will be prefixed by the current working directory if it is a relative path,
// and then the path will be canonicalised so that it doesn't contain any './'
// or '../' segments.
//
// On Windows filename should be in UTF-8 encoding.
//
// The function takes the following parameters:
//
//   - filename: absolute or relative file name path.
//
// The function returns the following values:
//
//   - utf8 (optional): newly-allocated URI string, or NULL on error. The caller
//     must free the URI string with g_free() when no longer needed.
func FilenameToURI(filename string) (string, error) {
	var _arg1 *C.gchar  // out
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_filename_to_uri(_arg1, &_cerr)
	runtime.KeepAlive(filename)

	var _utf8 string // out
	var _goerr error // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// FlowGetName gets a string representing the given flow return.
//
// The function takes the following parameters:
//
//   - ret to get the name of.
//
// The function returns the following values:
//
//   - utf8: static string with the name of the flow return.
func FlowGetName(ret FlowReturn) string {
	var _arg1 C.GstFlowReturn // out
	var _cret *C.gchar        // in

	_arg1 = C.GstFlowReturn(ret)

	_cret = C.gst_flow_get_name(_arg1)
	runtime.KeepAlive(ret)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// FlowToQuark: get the unique quark for the given GstFlowReturn.
//
// The function takes the following parameters:
//
//   - ret to get the quark of.
//
// The function returns the following values:
//
//   - quark associated with the flow return or 0 if an invalid return was
//     specified.
func FlowToQuark(ret FlowReturn) glib.Quark {
	var _arg1 C.GstFlowReturn // out
	var _cret C.GQuark        // in

	_arg1 = C.GstFlowReturn(ret)

	_cret = C.gst_flow_to_quark(_arg1)
	runtime.KeepAlive(ret)

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// FormatsContains: see if the given format is inside the format array.
//
// The function takes the following parameters:
//
//   - formats: format array to search.
//   - format to find.
//
// The function returns the following values:
//
//   - ok: TRUE if the format is found inside the array.
func FormatsContains(formats []Format, format Format) bool {
	var _arg1 *C.GstFormat // out
	var _arg2 C.GstFormat  // out
	var _cret C.gboolean   // in

	{
		var zero Format
		formats = append(formats, zero)
		_arg1 = (*C.GstFormat)(unsafe.Pointer(&formats[0]))
	}
	_arg2 = C.GstFormat(format)

	_cret = C.gst_formats_contains(_arg1, _arg2)
	runtime.KeepAlive(formats)
	runtime.KeepAlive(format)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GetMainExecutablePath: this helper is mostly helpful for plugins that need to
// inspect the folder of the main executable to determine their set of features.
//
// When a plugin is initialized from the gst-plugin-scanner external process,
// the returned path will be the same as from the parent process.
//
// The function returns the following values:
//
//   - utf8 (optional): path of the executable that initialized GStreamer,
//     or NULL if it could not be determined.
func GetMainExecutablePath() string {
	var _cret *C.gchar // in

	_cret = C.gst_get_main_executable_path()

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// IsCapsFeatures checks if obj is a CapsFeatures.
//
// The function returns the following values:
//
//   - ok: TRUE if obj is a CapsFeatures FALSE otherwise.
func IsCapsFeatures(obj unsafe.Pointer) bool {
	var _arg1 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(obj))

	_cret = C.gst_is_caps_features(_arg1)
	runtime.KeepAlive(obj)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsInitialized: use this function to check if GStreamer has been initialized
// with gst_init() or gst_init_check().
//
// The function returns the following values:
//
//   - ok: TRUE if initialization has been done, FALSE otherwise.
func IsInitialized() bool {
	var _cret C.gboolean // in

	_cret = C.gst_is_initialized()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func ParentBufferMetaApiGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.gst_parent_buffer_meta_api_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// ParseBinFromDescription: this is a convenience wrapper around
// gst_parse_launch() to create a Bin from a gst-launch-style pipeline
// description. See gst_parse_launch() and the gst-launch man page for details
// about the syntax. Ghost pads on the bin for unlinked source or sink pads
// within the bin can automatically be created (but only a maximum of one ghost
// pad for each direction will be created; if you expect multiple unlinked
// source pads or multiple unlinked sink pads and want them all ghosted,
// you will have to create the ghost pads yourself).
//
// The function takes the following parameters:
//
//   - binDescription: command line describing the bin.
//   - ghostUnlinkedPads: whether to automatically create ghost pads for
//     unlinked source or sink pads within the bin.
//
// The function returns the following values:
//
//   - bin: a newly-created bin, or NULL if an error occurred.
func ParseBinFromDescription(binDescription string, ghostUnlinkedPads bool) (*Bin, error) {
	var _arg1 *C.gchar      // out
	var _arg2 C.gboolean    // out
	var _cret *C.GstElement // in
	var _cerr *C.GError     // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(binDescription)))
	defer C.free(unsafe.Pointer(_arg1))
	if ghostUnlinkedPads {
		_arg2 = C.TRUE
	}

	_cret = C.gst_parse_bin_from_description(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(binDescription)
	runtime.KeepAlive(ghostUnlinkedPads)

	var _bin *Bin    // out
	var _goerr error // out

	_bin = wrapBin(coreglib.Take(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bin, _goerr
}

// ParseBinFromDescriptionFull: this is a convenience wrapper around
// gst_parse_launch() to create a Bin from a gst-launch-style pipeline
// description. See gst_parse_launch() and the gst-launch man page for details
// about the syntax. Ghost pads on the bin for unlinked source or sink pads
// within the bin can automatically be created (but only a maximum of one ghost
// pad for each direction will be created; if you expect multiple unlinked
// source pads or multiple unlinked sink pads and want them all ghosted,
// you will have to create the ghost pads yourself).
//
// The function takes the following parameters:
//
//   - binDescription: command line describing the bin.
//   - ghostUnlinkedPads: whether to automatically create ghost pads for
//     unlinked source or sink pads within the bin.
//   - context (optional): parse context allocated with gst_parse_context_new(),
//     or NULL.
//   - flags: parsing options, or T_PARSE_FLAG_NONE.
//
// The function returns the following values:
//
//   - element: newly-created element, which is guaranteed to be a bin unless
//     T_PARSE_FLAG_NO_SINGLE_ELEMENT_BINS was passed, or NULL if an error
//     occurred.
func ParseBinFromDescriptionFull(binDescription string, ghostUnlinkedPads bool, context *ParseContext, flags ParseFlags) (Elementer, error) {
	var _arg1 *C.gchar           // out
	var _arg2 C.gboolean         // out
	var _arg3 *C.GstParseContext // out
	var _arg4 C.GstParseFlags    // out
	var _cret *C.GstElement      // in
	var _cerr *C.GError          // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(binDescription)))
	defer C.free(unsafe.Pointer(_arg1))
	if ghostUnlinkedPads {
		_arg2 = C.TRUE
	}
	if context != nil {
		_arg3 = (*C.GstParseContext)(gextras.StructNative(unsafe.Pointer(context)))
	}
	_arg4 = C.GstParseFlags(flags)

	_cret = C.gst_parse_bin_from_description_full(_arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(binDescription)
	runtime.KeepAlive(ghostUnlinkedPads)
	runtime.KeepAlive(context)
	runtime.KeepAlive(flags)

	var _element Elementer // out
	var _goerr error       // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _element, _goerr
}

// ParseLaunch: create a new pipeline based on command line syntax. Please note
// that you might get a return value that is not NULL even though the error is
// set. In this case there was a recoverable parsing error and you can try to
// play the pipeline.
//
// To create a sub-pipeline (bin) for embedding into an existing pipeline use
// gst_parse_bin_from_description().
//
// The function takes the following parameters:
//
//   - pipelineDescription: command line describing the pipeline.
//
// The function returns the following values:
//
//   - element: new element on success, NULL on failure. If more than one
//     toplevel element is specified by the pipeline_description, all elements
//     are put into a Pipeline, which than is returned.
func ParseLaunch(pipelineDescription string) (Elementer, error) {
	var _arg1 *C.gchar      // out
	var _cret *C.GstElement // in
	var _cerr *C.GError     // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(pipelineDescription)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_parse_launch(_arg1, &_cerr)
	runtime.KeepAlive(pipelineDescription)

	var _element Elementer // out
	var _goerr error       // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _element, _goerr
}

// ParseLaunchFull: create a new pipeline based on command line syntax. Please
// note that you might get a return value that is not NULL even though the error
// is set. In this case there was a recoverable parsing error and you can try to
// play the pipeline.
//
// To create a sub-pipeline (bin) for embedding into an existing pipeline use
// gst_parse_bin_from_description_full().
//
// The function takes the following parameters:
//
//   - pipelineDescription: command line describing the pipeline.
//   - context (optional): parse context allocated with gst_parse_context_new(),
//     or NULL.
//   - flags: parsing options, or T_PARSE_FLAG_NONE.
//
// The function returns the following values:
//
//   - element: new element on success, NULL on failure. If more than
//     one toplevel element is specified by the pipeline_description,
//     all elements are put into a Pipeline, which then is returned (unless the
//     GST_PARSE_FLAG_PLACE_IN_BIN flag is set, in which case they are put in a
//     Bin instead).
func ParseLaunchFull(pipelineDescription string, context *ParseContext, flags ParseFlags) (Elementer, error) {
	var _arg1 *C.gchar           // out
	var _arg2 *C.GstParseContext // out
	var _arg3 C.GstParseFlags    // out
	var _cret *C.GstElement      // in
	var _cerr *C.GError          // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(pipelineDescription)))
	defer C.free(unsafe.Pointer(_arg1))
	if context != nil {
		_arg2 = (*C.GstParseContext)(gextras.StructNative(unsafe.Pointer(context)))
	}
	_arg3 = C.GstParseFlags(flags)

	_cret = C.gst_parse_launch_full(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(pipelineDescription)
	runtime.KeepAlive(context)
	runtime.KeepAlive(flags)

	var _element Elementer // out
	var _goerr error       // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _element, _goerr
}

// ParseLaunchv: create a new element based on command line syntax. error will
// contain an error message if an erroneous pipeline is specified. An error does
// not mean that the pipeline could not be constructed.
//
// The function takes the following parameters:
//
//   - argv: null-terminated array of arguments.
//
// The function returns the following values:
//
//   - element: new element on success and NULL on failure.
func ParseLaunchv(argv []string) (Elementer, error) {
	var _arg1 **C.gchar     // out
	var _cret *C.GstElement // in
	var _cerr *C.GError     // in

	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(argv) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(argv)+1)
			var zero *C.gchar
			out[len(argv)] = zero
			for i := range argv {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(argv[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.gst_parse_launchv(_arg1, &_cerr)
	runtime.KeepAlive(argv)

	var _element Elementer // out
	var _goerr error       // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _element, _goerr
}

// ParseLaunchvFull: create a new element based on command line syntax.
// error will contain an error message if an erroneous pipeline is specified.
// An error does not mean that the pipeline could not be constructed.
//
// The function takes the following parameters:
//
//   - argv: null-terminated array of arguments.
//   - context (optional): parse context allocated with gst_parse_context_new(),
//     or NULL.
//   - flags: parsing options, or T_PARSE_FLAG_NONE.
//
// The function returns the following values:
//
//   - element: new element on success; on failure, either NULL or a
//     partially-constructed bin or element will be returned and error will be
//     set (unless you passed T_PARSE_FLAG_FATAL_ERRORS in flags, then NULL will
//     always be returned on failure).
func ParseLaunchvFull(argv []string, context *ParseContext, flags ParseFlags) (Elementer, error) {
	var _arg1 **C.gchar          // out
	var _arg2 *C.GstParseContext // out
	var _arg3 C.GstParseFlags    // out
	var _cret *C.GstElement      // in
	var _cerr *C.GError          // in

	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(argv) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(argv)+1)
			var zero *C.gchar
			out[len(argv)] = zero
			for i := range argv {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(argv[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	if context != nil {
		_arg2 = (*C.GstParseContext)(gextras.StructNative(unsafe.Pointer(context)))
	}
	_arg3 = C.GstParseFlags(flags)

	_cret = C.gst_parse_launchv_full(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(argv)
	runtime.KeepAlive(context)
	runtime.KeepAlive(flags)

	var _element Elementer // out
	var _goerr error       // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _element, _goerr
}

// ProtectionFilterSystemsByAvailableDecryptors iterates the supplied list of
// UUIDs and checks the GstRegistry for all the decryptors supporting one of the
// supplied UUIDs.
//
// The function takes the following parameters:
//
//   - systemIdentifiers: A null terminated array of strings that contains the
//     UUID values of each protection system that is to be checked.
//
// The function returns the following values:
//
//   - utf8s (optional): A null terminated array containing all the
//     system_identifiers supported by the set of available decryptors, or NULL
//     if no matches were found.
func ProtectionFilterSystemsByAvailableDecryptors(systemIdentifiers []string) []string {
	var _arg1 **C.gchar // out
	var _cret **C.gchar // in

	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(systemIdentifiers) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(systemIdentifiers)+1)
			var zero *C.gchar
			out[len(systemIdentifiers)] = zero
			for i := range systemIdentifiers {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(systemIdentifiers[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.gst_protection_filter_systems_by_available_decryptors(_arg1)
	runtime.KeepAlive(systemIdentifiers)

	var _utf8s []string // out

	if _cret != nil {
		defer C.free(unsafe.Pointer(_cret))
		{
			var i int
			var z *C.gchar
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
				defer C.free(unsafe.Pointer(src[i]))
			}
		}
	}

	return _utf8s
}

func ProtectionMetaApiGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.gst_protection_meta_api_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// ProtectionSelectSystem iterates the supplied list of UUIDs and checks
// the GstRegistry for an element that supports one of the supplied UUIDs.
// If more than one element matches, the system ID of the highest ranked element
// is selected.
//
// The function takes the following parameters:
//
//   - systemIdentifiers: null terminated array of strings that contains the
//     UUID values of each protection system that is to be checked.
//
// The function returns the following values:
//
//   - utf8 (optional): one of the strings from system_identifiers that
//     indicates the highest ranked element that implements the protection
//     system indicated by that system ID, or NULL if no element has been found.
func ProtectionSelectSystem(systemIdentifiers []string) string {
	var _arg1 **C.gchar // out
	var _cret *C.gchar  // in

	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(systemIdentifiers) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(systemIdentifiers)+1)
			var zero *C.gchar
			out[len(systemIdentifiers)] = zero
			for i := range systemIdentifiers {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(systemIdentifiers[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.gst_protection_select_system(_arg1)
	runtime.KeepAlive(systemIdentifiers)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

func ReferenceTimestampMetaApiGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.gst_reference_timestamp_meta_api_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// SegtrapIsEnabled: some functions in the GStreamer core might install a
// custom SIGSEGV handler to better catch and report errors to the application.
// Currently this feature is enabled by default when loading plugins.
//
// Applications might want to disable this behaviour with the
// gst_segtrap_set_enabled() function. This is typically done if the application
// wants to install its own handler without GStreamer interfering.
//
// The function returns the following values:
//
//   - ok: TRUE if GStreamer is allowed to install a custom SIGSEGV handler.
func SegtrapIsEnabled() bool {
	var _cret C.gboolean // in

	_cret = C.gst_segtrap_is_enabled()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SegtrapSetEnabled applications might want to disable/enable the SIGSEGV
// handling of the GStreamer core. See gst_segtrap_is_enabled() for more
// information.
//
// The function takes the following parameters:
//
//   - enabled: whether a custom SIGSEGV handler should be installed.
func SegtrapSetEnabled(enabled bool) {
	var _arg1 C.gboolean // out

	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_segtrap_set_enabled(_arg1)
	runtime.KeepAlive(enabled)
}

// TagExists checks if the given type is already registered.
//
// The function takes the following parameters:
//
//   - tag: name of the tag.
//
// The function returns the following values:
//
//   - ok: TRUE if the type is already registered.
func TagExists(tag string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_exists(_arg1)
	runtime.KeepAlive(tag)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TagGetDescription returns the human-readable description of this tag,
// You must not change or free this string.
//
// The function takes the following parameters:
//
//   - tag: tag.
//
// The function returns the following values:
//
//   - utf8: human-readable description of this tag.
func TagGetDescription(tag string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_description(_arg1)
	runtime.KeepAlive(tag)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TagGetFlag gets the flag of tag.
//
// The function takes the following parameters:
//
//   - tag: tag.
//
// The function returns the following values:
//
//   - tagFlag: flag of this tag.
func TagGetFlag(tag string) TagFlag {
	var _arg1 *C.gchar     // out
	var _cret C.GstTagFlag // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_flag(_arg1)
	runtime.KeepAlive(tag)

	var _tagFlag TagFlag // out

	_tagFlag = TagFlag(_cret)

	return _tagFlag
}

// TagGetNick returns the human-readable name of this tag, You must not change
// or free this string.
//
// The function takes the following parameters:
//
//   - tag: tag.
//
// The function returns the following values:
//
//   - utf8: human-readable name of this tag.
func TagGetNick(tag string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_nick(_arg1)
	runtime.KeepAlive(tag)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TagGetType gets the #GType used for this tag.
//
// The function takes the following parameters:
//
//   - tag: tag.
//
// The function returns the following values:
//
//   - gType of this tag.
func TagGetType(tag string) coreglib.Type {
	var _arg1 *C.gchar // out
	var _cret C.GType  // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_type(_arg1)
	runtime.KeepAlive(tag)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// TagIsFixed checks if the given tag is fixed. A fixed tag can only contain one
// value. Unfixed tags can contain lists of values.
//
// The function takes the following parameters:
//
//   - tag to check.
//
// The function returns the following values:
//
//   - ok: TRUE, if the given tag is fixed.
func TagIsFixed(tag string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_is_fixed(_arg1)
	runtime.KeepAlive(tag)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TagMergeStringsWithComma: this is a convenience function for the func
// argument of gst_tag_register(). It concatenates all given strings using a
// comma. The tag must be registered as a G_TYPE_STRING or this function will
// fail.
//
// The function takes the following parameters:
//
//   - src: GValue to copy from.
//
// The function returns the following values:
//
//   - dest: uninitialized GValue to store result in.
func TagMergeStringsWithComma(src *coreglib.Value) coreglib.Value {
	var _arg1 C.GValue  // in
	var _arg2 *C.GValue // out

	_arg2 = (*C.GValue)(unsafe.Pointer(src.Native()))

	C.gst_tag_merge_strings_with_comma(&_arg1, _arg2)
	runtime.KeepAlive(src)

	var _dest coreglib.Value // out

	_dest = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))

	return _dest
}

// TagMergeUseFirst: this is a convenience function for the func argument of
// gst_tag_register(). It creates a copy of the first value from the list.
//
// The function takes the following parameters:
//
//   - src: GValue to copy from.
//
// The function returns the following values:
//
//   - dest: uninitialized GValue to store result in.
func TagMergeUseFirst(src *coreglib.Value) coreglib.Value {
	var _arg1 C.GValue  // in
	var _arg2 *C.GValue // out

	_arg2 = (*C.GValue)(unsafe.Pointer(src.Native()))

	C.gst_tag_merge_use_first(&_arg1, _arg2)
	runtime.KeepAlive(src)

	var _dest coreglib.Value // out

	_dest = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))

	return _dest
}

// TracingGetActiveTracers: get a list of all active tracer objects owned by
// the tracing framework for the entirety of the run-time of the process or till
// gst_deinit() is called.
//
// The function returns the following values:
//
//   - list of Tracer objects.
func TracingGetActiveTracers() []Tracerer {
	var _cret *C.GList // in

	_cret = C.gst_tracing_get_active_tracers()

	var _list []Tracerer // out

	_list = make([]Tracerer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstTracer)(v)
		var dst Tracerer // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gst.Tracerer is nil")
			}

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Tracerer)
				return ok
			})
			rv, ok := casted.(Tracerer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Tracerer")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// TypeIsPluginApi checks if type is plugin API. See
// gst_type_mark_as_plugin_api() for details.
//
// The function takes the following parameters:
//
//   - typ: GType.
//
// The function returns the following values:
//
//   - flags (optional): what PluginAPIFlags the plugin was marked with.
//   - ok: TRUE if type is plugin API or FALSE otherwise.
func TypeIsPluginApi(typ coreglib.Type) (PluginAPIFlags, bool) {
	var _arg1 C.GType             // out
	var _arg2 C.GstPluginAPIFlags // in
	var _cret C.gboolean          // in

	_arg1 = C.GType(typ)

	_cret = C.gst_type_is_plugin_api(_arg1, &_arg2)
	runtime.KeepAlive(typ)

	var _flags PluginAPIFlags // out
	var _ok bool              // out

	_flags = PluginAPIFlags(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _flags, _ok
}

// TypeMarkAsPluginApi marks type as plugin API. This should be called in
// class_init of elements that expose new types (i.e. enums, flags or internal
// GObjects) via properties, signals or pad templates.
//
// Types exposed by plugins are not automatically added to the documentation
// as they might originate from another library and should in that case be
// documented via that library instead.
//
// By marking a type as plugin API it will be included in the documentation of
// the plugin that defines it.
//
// The function takes the following parameters:
//
//   - typ: GType.
//   - flags: set of PluginAPIFlags to further inform cache generation.
func TypeMarkAsPluginApi(typ coreglib.Type, flags PluginAPIFlags) {
	var _arg1 C.GType             // out
	var _arg2 C.GstPluginAPIFlags // out

	_arg1 = C.GType(typ)
	_arg2 = C.GstPluginAPIFlags(flags)

	C.gst_type_mark_as_plugin_api(_arg1, _arg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(flags)
}

// UpdateRegistry forces GStreamer to re-scan its plugin paths and update the
// default plugin registry.
//
// Applications will almost never need to call this function, it is only
// useful if the application knows new plugins have been installed (or old
// ones removed) since the start of the application (or, to be precise,
// the first call to gst_init()) and the application wants to make use of any
// newly-installed plugins without restarting the application.
//
// Applications should assume that the registry update is neither atomic nor
// thread-safe and should therefore not have any dynamic pipelines running
// (including the playbin and decodebin elements) and should also not create any
// elements or access the GStreamer registry while the update is in progress.
//
// Note that this function may block for a significant amount of time.
//
// The function returns the following values:
//
//   - ok: TRUE if the registry has been updated successfully (does not imply
//     that there were changes), otherwise FALSE.
func UpdateRegistry() bool {
	var _cret C.gboolean // in

	_cret = C.gst_update_registry()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UtilArrayBinarySearch searches inside array for search_data by using the
// comparison function search_func. array must be sorted ascending.
//
// As search_data is always passed as second argument to search_func it's not
// required that search_data has the same type as the array elements.
//
// The complexity of this search function is O(log (num_elements)).
//
// The function takes the following parameters:
//
//   - array (optional): sorted input array.
//   - numElements: number of elements in the array.
//   - elementSize: size of every element in bytes.
//   - searchFunc: function to compare two elements, search_data will always be
//     passed as second argument.
//   - mode: search mode that should be used.
//   - searchData (optional): element that should be found.
//
// The function returns the following values:
//
//   - gpointer (optional) address of the found element or NULL if nothing was
//     found.
func UtilArrayBinarySearch(array unsafe.Pointer, numElements, elementSize uint, searchFunc glib.CompareDataFunc, mode SearchMode, searchData unsafe.Pointer) unsafe.Pointer {
	var _arg1 C.gpointer         // out
	var _arg2 C.guint            // out
	var _arg3 C.gsize            // out
	var _arg4 C.GCompareDataFunc // out
	var _arg7 C.gpointer
	var _arg5 C.GstSearchMode // out
	var _arg6 C.gconstpointer // out
	var _cret C.gpointer      // in

	_arg1 = (C.gpointer)(unsafe.Pointer(array))
	_arg2 = C.guint(numElements)
	_arg3 = C.gsize(elementSize)
	_arg4 = (*[0]byte)(C._gotk4_glib2_CompareDataFunc)
	_arg7 = C.gpointer(gbox.Assign(searchFunc))
	defer gbox.Delete(uintptr(_arg7))
	_arg5 = C.GstSearchMode(mode)
	_arg6 = (C.gconstpointer)(unsafe.Pointer(searchData))

	_cret = C.gst_util_array_binary_search(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(array)
	runtime.KeepAlive(numElements)
	runtime.KeepAlive(elementSize)
	runtime.KeepAlive(searchFunc)
	runtime.KeepAlive(mode)
	runtime.KeepAlive(searchData)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// UtilCeilLog2 returns smallest integral value not less than log2(v).
//
// The function takes the following parameters:
//
//   - v: #guint32 value.
//
// The function returns the following values:
//
//   - guint: computed #guint val.
func UtilCeilLog2(v uint32) uint {
	var _arg1 C.guint32 // out
	var _cret C.guint   // in

	_arg1 = C.guint32(v)

	_cret = C.gst_util_ceil_log2(_arg1)
	runtime.KeepAlive(v)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// UtilDoubleToFraction transforms a #gdouble to a fraction and simplifies the
// result.
//
// The function takes the following parameters:
//
//   - src to transform.
//
// The function returns the following values:
//
//   - destN: pointer to a #gint to hold the result numerator.
//   - destD: pointer to a #gint to hold the result denominator.
func UtilDoubleToFraction(src float64) (destN, destD int) {
	var _arg1 C.gdouble // out
	var _arg2 C.gint    // in
	var _arg3 C.gint    // in

	_arg1 = C.gdouble(src)

	C.gst_util_double_to_fraction(_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(src)

	var _destN int // out
	var _destD int // out

	_destN = int(_arg2)
	_destD = int(_arg3)

	return _destN, _destD
}

// UtilDumpBuffer dumps the buffer memory into a hex representation. Useful for
// debugging.
//
// The function takes the following parameters:
//
//   - buf whose memory to dump.
func UtilDumpBuffer(buf *Buffer) {
	var _arg1 *C.GstBuffer // out

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buf)))

	C.gst_util_dump_buffer(_arg1)
	runtime.KeepAlive(buf)
}

// UtilDumpMem dumps the memory block into a hex representation. Useful for
// debugging.
//
// The function takes the following parameters:
//
//   - mem: pointer to the memory to dump.
func UtilDumpMem(mem []byte) {
	var _arg1 *C.guchar // out
	var _arg2 C.guint

	_arg2 = (C.guint)(len(mem))
	if len(mem) > 0 {
		_arg1 = (*C.guchar)(unsafe.Pointer(&mem[0]))
	}

	C.gst_util_dump_mem(_arg1, _arg2)
	runtime.KeepAlive(mem)
}

// UtilFilenameCompare compares the given filenames using natural ordering.
//
// The function takes the following parameters:
//
//   - a: filename to compare with b.
//   - b: filename to compare with a.
func UtilFilenameCompare(a, b string) int {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret C.gint   // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(a)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(b)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_util_filename_compare(_arg1, _arg2)
	runtime.KeepAlive(a)
	runtime.KeepAlive(b)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UtilFractionAdd adds the fractions a_n/a_d and b_n/b_d and stores the result
// in res_n and res_d.
//
// The function takes the following parameters:
//
//   - aN: numerator of first value.
//   - aD: denominator of first value.
//   - bN: numerator of second value.
//   - bD: denominator of second value.
//
// The function returns the following values:
//
//   - resN: pointer to #gint to hold the result numerator.
//   - resD: pointer to #gint to hold the result denominator.
//   - ok: FALSE on overflow, TRUE otherwise.
func UtilFractionAdd(aN, aD, bN, bD int) (resN, resD int, ok bool) {
	var _arg1 C.gint     // out
	var _arg2 C.gint     // out
	var _arg3 C.gint     // out
	var _arg4 C.gint     // out
	var _arg5 C.gint     // in
	var _arg6 C.gint     // in
	var _cret C.gboolean // in

	_arg1 = C.gint(aN)
	_arg2 = C.gint(aD)
	_arg3 = C.gint(bN)
	_arg4 = C.gint(bD)

	_cret = C.gst_util_fraction_add(_arg1, _arg2, _arg3, _arg4, &_arg5, &_arg6)
	runtime.KeepAlive(aN)
	runtime.KeepAlive(aD)
	runtime.KeepAlive(bN)
	runtime.KeepAlive(bD)

	var _resN int // out
	var _resD int // out
	var _ok bool  // out

	_resN = int(_arg5)
	_resD = int(_arg6)
	if _cret != 0 {
		_ok = true
	}

	return _resN, _resD, _ok
}

// UtilFractionCompare compares the fractions a_n/a_d and b_n/b_d and returns -1
// if a < b, 0 if a = b and 1 if a > b.
//
// The function takes the following parameters:
//
//   - aN: numerator of first value.
//   - aD: denominator of first value.
//   - bN: numerator of second value.
//   - bD: denominator of second value.
//
// The function returns the following values:
//
//   - gint: -1 if a < b; 0 if a = b; 1 if a > b.
func UtilFractionCompare(aN, aD, bN, bD int) int {
	var _arg1 C.gint // out
	var _arg2 C.gint // out
	var _arg3 C.gint // out
	var _arg4 C.gint // out
	var _cret C.gint // in

	_arg1 = C.gint(aN)
	_arg2 = C.gint(aD)
	_arg3 = C.gint(bN)
	_arg4 = C.gint(bD)

	_cret = C.gst_util_fraction_compare(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(aN)
	runtime.KeepAlive(aD)
	runtime.KeepAlive(bN)
	runtime.KeepAlive(bD)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UtilFractionMultiply multiplies the fractions a_n/a_d and b_n/b_d and stores
// the result in res_n and res_d.
//
// The function takes the following parameters:
//
//   - aN: numerator of first value.
//   - aD: denominator of first value.
//   - bN: numerator of second value.
//   - bD: denominator of second value.
//
// The function returns the following values:
//
//   - resN: pointer to #gint to hold the result numerator.
//   - resD: pointer to #gint to hold the result denominator.
//   - ok: FALSE on overflow, TRUE otherwise.
func UtilFractionMultiply(aN, aD, bN, bD int) (resN, resD int, ok bool) {
	var _arg1 C.gint     // out
	var _arg2 C.gint     // out
	var _arg3 C.gint     // out
	var _arg4 C.gint     // out
	var _arg5 C.gint     // in
	var _arg6 C.gint     // in
	var _cret C.gboolean // in

	_arg1 = C.gint(aN)
	_arg2 = C.gint(aD)
	_arg3 = C.gint(bN)
	_arg4 = C.gint(bD)

	_cret = C.gst_util_fraction_multiply(_arg1, _arg2, _arg3, _arg4, &_arg5, &_arg6)
	runtime.KeepAlive(aN)
	runtime.KeepAlive(aD)
	runtime.KeepAlive(bN)
	runtime.KeepAlive(bD)

	var _resN int // out
	var _resD int // out
	var _ok bool  // out

	_resN = int(_arg5)
	_resD = int(_arg6)
	if _cret != 0 {
		_ok = true
	}

	return _resN, _resD, _ok
}

// UtilFractionToDouble transforms a fraction to a #gdouble.
//
// The function takes the following parameters:
//
//   - srcN: fraction numerator as #gint.
//   - srcD: fraction denominator #gint.
//
// The function returns the following values:
//
//   - dest: pointer to a #gdouble for the result.
func UtilFractionToDouble(srcN, srcD int) float64 {
	var _arg1 C.gint    // out
	var _arg2 C.gint    // out
	var _arg3 C.gdouble // in

	_arg1 = C.gint(srcN)
	_arg2 = C.gint(srcD)

	C.gst_util_fraction_to_double(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(srcN)
	runtime.KeepAlive(srcD)

	var _dest float64 // out

	_dest = float64(_arg3)

	return _dest
}

// The function takes the following parameters:
//
//   - value value to convert guint64 double.
//
// The function returns the following values:
//
//   - guint64: value casted to #guint64.
func UtilGdoubleToGuint64(value float64) uint64 {
	var _arg1 C.gdouble // out
	var _cret C.guint64 // in

	_arg1 = C.gdouble(value)

	_cret = C.gst_util_gdouble_to_guint64(_arg1)
	runtime.KeepAlive(value)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// UtilGetTimestamp: get a timestamp as GstClockTime to be used for interval
// measurements. The timestamp should not be interpreted in any other way.
//
// The function returns the following values:
//
//   - clockTime: timestamp.
func UtilGetTimestamp() ClockTime {
	var _cret C.GstClockTime // in

	_cret = C.gst_util_get_timestamp()

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// UtilGreatestCommonDivisor calculates the greatest common divisor of a and b.
//
// The function takes the following parameters:
//
//   - a: first value as #gint.
//   - b: second value as #gint.
//
// The function returns the following values:
//
//   - gint: greatest common divisor of a and b.
func UtilGreatestCommonDivisor(a, b int) int {
	var _arg1 C.gint // out
	var _arg2 C.gint // out
	var _cret C.gint // in

	_arg1 = C.gint(a)
	_arg2 = C.gint(b)

	_cret = C.gst_util_greatest_common_divisor(_arg1, _arg2)
	runtime.KeepAlive(a)
	runtime.KeepAlive(b)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UtilGreatestCommonDivisorInt64 calculates the greatest common divisor of a
// and b.
//
// The function takes the following parameters:
//
//   - a: first value as #gint64.
//   - b: second value as #gint64.
//
// The function returns the following values:
//
//   - gint64: greatest common divisor of a and b.
func UtilGreatestCommonDivisorInt64(a, b int64) int64 {
	var _arg1 C.gint64 // out
	var _arg2 C.gint64 // out
	var _cret C.gint64 // in

	_arg1 = C.gint64(a)
	_arg2 = C.gint64(b)

	_cret = C.gst_util_greatest_common_divisor_int64(_arg1, _arg2)
	runtime.KeepAlive(a)
	runtime.KeepAlive(b)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// UtilGroupIDNext: return a constantly incrementing group id.
//
// This function is used to generate a new group-id for the stream-start event.
//
// This function never returns GST_GROUP_ID_INVALID (which is 0).
//
// The function returns the following values:
//
//   - guint: constantly incrementing unsigned integer, which might overflow
//     back to 0 at some point.
func UtilGroupIDNext() uint {
	var _cret C.guint // in

	_cret = C.gst_util_group_id_next()

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function takes the following parameters:
//
//   - value value to convert to double.
//
// The function returns the following values:
//
//   - gdouble: value casted to #gdouble.
func UtilGuint64ToGdouble(value uint64) float64 {
	var _arg1 C.guint64 // out
	var _cret C.gdouble // in

	_arg1 = C.guint64(value)

	_cret = C.gst_util_guint64_to_gdouble(_arg1)
	runtime.KeepAlive(value)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// UtilSeqnumCompare: compare two sequence numbers, handling wraparound.
//
// The current implementation just returns (gint32)(s1 - s2).
//
// The function takes the following parameters:
//
//   - s1: sequence number.
//   - s2: another sequence number.
//
// The function returns the following values:
//
//   - gint32: negative number if s1 is before s2, 0 if they are equal, or a
//     positive number if s1 is after s2.
func UtilSeqnumCompare(s1, s2 uint32) int32 {
	var _arg1 C.guint32 // out
	var _arg2 C.guint32 // out
	var _cret C.gint32  // in

	_arg1 = C.guint32(s1)
	_arg2 = C.guint32(s2)

	_cret = C.gst_util_seqnum_compare(_arg1, _arg2)
	runtime.KeepAlive(s1)
	runtime.KeepAlive(s2)

	var _gint32 int32 // out

	_gint32 = int32(_cret)

	return _gint32
}

// UtilSeqnumNext: return a constantly incrementing sequence number.
//
// This function is used internally to GStreamer to be able to determine which
// events and messages are "the same". For example, elements may set the seqnum
// on a segment-done message to be the same as that of the last seek event,
// to indicate that event and the message correspond to the same segment.
//
// This function never returns GST_SEQNUM_INVALID (which is 0).
//
// The function returns the following values:
//
//   - guint32: constantly incrementing 32-bit unsigned integer, which might
//     overflow at some point. Use gst_util_seqnum_compare() to make sure you
//     handle wraparound correctly.
func UtilSeqnumNext() uint32 {
	var _cret C.guint32 // in

	_cret = C.gst_util_seqnum_next()

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// UtilSetObjectArg converts the string value to the type of the objects
// argument and sets the argument with it.
//
// Note that this function silently returns if object has no property named name
// or when value cannot be converted to the type of the property.
//
// The function takes the following parameters:
//
//   - object to set the argument of.
//   - name of the argument to set.
//   - value: string value to set.
func UtilSetObjectArg(object *coreglib.Object, name, value string) {
	var _arg1 *C.GObject // out
	var _arg2 *C.gchar   // out
	var _arg3 *C.gchar   // out

	_arg1 = (*C.GObject)(unsafe.Pointer(object.Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg3))

	C.gst_util_set_object_arg(_arg1, _arg2, _arg3)
	runtime.KeepAlive(object)
	runtime.KeepAlive(name)
	runtime.KeepAlive(value)
}

// UtilSetValueFromString converts the string to the type of the value and sets
// the value with it.
//
// Note that this function is dangerous as it does not return any indication if
// the conversion worked or not.
//
// The function takes the following parameters:
//
//   - valueStr: string to get the value from.
//
// The function returns the following values:
//
//   - value to set.
func UtilSetValueFromString(valueStr string) coreglib.Value {
	var _arg1 C.GValue // in
	var _arg2 *C.gchar // out

	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(valueStr)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gst_util_set_value_from_string(&_arg1, _arg2)
	runtime.KeepAlive(valueStr)

	var _value coreglib.Value // out

	_value = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))

	return _value
}

// UtilSimplifyFraction calculates the simpler representation of numerator and
// denominator and update both values with the resulting simplified fraction.
//
// Simplify a fraction using a simple continued fraction decomposition.
// The idea here is to convert fractions such as 333333/10000000 to 1/30 using
// 32 bit arithmetic only. The algorithm is not perfect and relies upon two
// arbitrary parameters to remove non-significative terms from the simple
// continued fraction decomposition. Using 8 and 333 for n_terms and threshold
// respectively seems to give nice results.
//
// The function takes the following parameters:
//
//   - numerator: first value as #gint.
//   - denominator: second value as #gint.
//   - nTerms: non-significative terms (typical value: 8).
//   - threshold (typical value: 333).
func UtilSimplifyFraction(numerator, denominator *int, nTerms, threshold uint) {
	var _arg1 *C.gint // out
	var _arg2 *C.gint // out
	var _arg3 C.guint // out
	var _arg4 C.guint // out

	_arg1 = (*C.gint)(unsafe.Pointer(numerator))
	_arg2 = (*C.gint)(unsafe.Pointer(denominator))
	_arg3 = C.guint(nTerms)
	_arg4 = C.guint(threshold)

	C.gst_util_simplify_fraction(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(numerator)
	runtime.KeepAlive(denominator)
	runtime.KeepAlive(nTerms)
	runtime.KeepAlive(threshold)
}

// UtilUint64Scale: scale val by the rational number num / denom, avoiding
// overflows and underflows and without loss of precision.
//
// This function can potentially be very slow if val and num are both greater
// than G_MAXUINT32.
//
// The function takes the following parameters:
//
//   - val: number to scale.
//   - num: numerator of the scale ratio.
//   - denom: denominator of the scale ratio.
//
// The function returns the following values:
//
//   - guint64: val * num / denom. In the case of an overflow, this function
//     returns G_MAXUINT64. If the result is not exactly representable as
//     an integer it is truncated. See also gst_util_uint64_scale_round(),
//     gst_util_uint64_scale_ceil(), gst_util_uint64_scale_int(),
//     gst_util_uint64_scale_int_round(), gst_util_uint64_scale_int_ceil().
func UtilUint64Scale(val, num, denom uint64) uint64 {
	var _arg1 C.guint64 // out
	var _arg2 C.guint64 // out
	var _arg3 C.guint64 // out
	var _cret C.guint64 // in

	_arg1 = C.guint64(val)
	_arg2 = C.guint64(num)
	_arg3 = C.guint64(denom)

	_cret = C.gst_util_uint64_scale(_arg1, _arg2, _arg3)
	runtime.KeepAlive(val)
	runtime.KeepAlive(num)
	runtime.KeepAlive(denom)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// UtilUint64ScaleCeil: scale val by the rational number num / denom, avoiding
// overflows and underflows and without loss of precision.
//
// This function can potentially be very slow if val and num are both greater
// than G_MAXUINT32.
//
// The function takes the following parameters:
//
//   - val: number to scale.
//   - num: numerator of the scale ratio.
//   - denom: denominator of the scale ratio.
//
// The function returns the following values:
//
//   - guint64: val * num / denom. In the case of an overflow, this function
//     returns G_MAXUINT64. If the result is not exactly representable as
//     an integer, it is rounded up. See also gst_util_uint64_scale(),
//     gst_util_uint64_scale_round(), gst_util_uint64_scale_int(),
//     gst_util_uint64_scale_int_round(), gst_util_uint64_scale_int_ceil().
func UtilUint64ScaleCeil(val, num, denom uint64) uint64 {
	var _arg1 C.guint64 // out
	var _arg2 C.guint64 // out
	var _arg3 C.guint64 // out
	var _cret C.guint64 // in

	_arg1 = C.guint64(val)
	_arg2 = C.guint64(num)
	_arg3 = C.guint64(denom)

	_cret = C.gst_util_uint64_scale_ceil(_arg1, _arg2, _arg3)
	runtime.KeepAlive(val)
	runtime.KeepAlive(num)
	runtime.KeepAlive(denom)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// UtilUint64ScaleInt: scale val by the rational number num / denom,
// avoiding overflows and underflows and without loss of precision. num must be
// non-negative and denom must be positive.
//
// The function takes the following parameters:
//
//   - val: guint64 (such as a ClockTime) to scale.
//   - num: numerator of the scale factor.
//   - denom: denominator of the scale factor.
//
// The function returns the following values:
//
//   - guint64: val * num / denom. In the case of an overflow, this function
//     returns G_MAXUINT64. If the result is not exactly representable as an
//     integer, it is truncated. See also gst_util_uint64_scale_int_round(),
//     gst_util_uint64_scale_int_ceil(), gst_util_uint64_scale(),
//     gst_util_uint64_scale_round(), gst_util_uint64_scale_ceil().
func UtilUint64ScaleInt(val uint64, num, denom int) uint64 {
	var _arg1 C.guint64 // out
	var _arg2 C.gint    // out
	var _arg3 C.gint    // out
	var _cret C.guint64 // in

	_arg1 = C.guint64(val)
	_arg2 = C.gint(num)
	_arg3 = C.gint(denom)

	_cret = C.gst_util_uint64_scale_int(_arg1, _arg2, _arg3)
	runtime.KeepAlive(val)
	runtime.KeepAlive(num)
	runtime.KeepAlive(denom)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// UtilUint64ScaleIntCeil: scale val by the rational number num / denom,
// avoiding overflows and underflows and without loss of precision. num must be
// non-negative and denom must be positive.
//
// The function takes the following parameters:
//
//   - val: guint64 (such as a ClockTime) to scale.
//   - num: numerator of the scale factor.
//   - denom: denominator of the scale factor.
//
// The function returns the following values:
//
//   - guint64: val * num / denom. In the case of an overflow, this function
//     returns G_MAXUINT64. If the result is not exactly representable as
//     an integer, it is rounded up. See also gst_util_uint64_scale_int(),
//     gst_util_uint64_scale_int_round(), gst_util_uint64_scale(),
//     gst_util_uint64_scale_round(), gst_util_uint64_scale_ceil().
func UtilUint64ScaleIntCeil(val uint64, num, denom int) uint64 {
	var _arg1 C.guint64 // out
	var _arg2 C.gint    // out
	var _arg3 C.gint    // out
	var _cret C.guint64 // in

	_arg1 = C.guint64(val)
	_arg2 = C.gint(num)
	_arg3 = C.gint(denom)

	_cret = C.gst_util_uint64_scale_int_ceil(_arg1, _arg2, _arg3)
	runtime.KeepAlive(val)
	runtime.KeepAlive(num)
	runtime.KeepAlive(denom)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// UtilUint64ScaleIntRound: scale val by the rational number num / denom,
// avoiding overflows and underflows and without loss of precision. num must be
// non-negative and denom must be positive.
//
// The function takes the following parameters:
//
//   - val: guint64 (such as a ClockTime) to scale.
//   - num: numerator of the scale factor.
//   - denom: denominator of the scale factor.
//
// The function returns the following values:
//
//   - guint64: val * num / denom. In the case of an overflow, this function
//     returns G_MAXUINT64. If the result is not exactly representable
//     as an integer, it is rounded to the nearest integer (half-way
//     cases are rounded up). See also gst_util_uint64_scale_int(),
//     gst_util_uint64_scale_int_ceil(), gst_util_uint64_scale(),
//     gst_util_uint64_scale_round(), gst_util_uint64_scale_ceil().
func UtilUint64ScaleIntRound(val uint64, num, denom int) uint64 {
	var _arg1 C.guint64 // out
	var _arg2 C.gint    // out
	var _arg3 C.gint    // out
	var _cret C.guint64 // in

	_arg1 = C.guint64(val)
	_arg2 = C.gint(num)
	_arg3 = C.gint(denom)

	_cret = C.gst_util_uint64_scale_int_round(_arg1, _arg2, _arg3)
	runtime.KeepAlive(val)
	runtime.KeepAlive(num)
	runtime.KeepAlive(denom)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// UtilUint64ScaleRound: scale val by the rational number num / denom, avoiding
// overflows and underflows and without loss of precision.
//
// This function can potentially be very slow if val and num are both greater
// than G_MAXUINT32.
//
// The function takes the following parameters:
//
//   - val: number to scale.
//   - num: numerator of the scale ratio.
//   - denom: denominator of the scale ratio.
//
// The function returns the following values:
//
//   - guint64: val * num / denom. In the case of an overflow, this function
//     returns G_MAXUINT64. If the result is not exactly representable as an
//     integer, it is rounded to the nearest integer (half-way cases are rounded
//     up). See also gst_util_uint64_scale(), gst_util_uint64_scale_ceil(),
//     gst_util_uint64_scale_int(), gst_util_uint64_scale_int_round(),
//     gst_util_uint64_scale_int_ceil().
func UtilUint64ScaleRound(val, num, denom uint64) uint64 {
	var _arg1 C.guint64 // out
	var _arg2 C.guint64 // out
	var _arg3 C.guint64 // out
	var _cret C.guint64 // in

	_arg1 = C.guint64(val)
	_arg2 = C.guint64(num)
	_arg3 = C.guint64(denom)

	_cret = C.gst_util_uint64_scale_round(_arg1, _arg2, _arg3)
	runtime.KeepAlive(val)
	runtime.KeepAlive(num)
	runtime.KeepAlive(denom)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// ValueCanCompare determines if value1 and value2 can be compared.
//
// The function takes the following parameters:
//
//   - value1: value to compare.
//   - value2: another value to compare.
//
// The function returns the following values:
//
//   - ok: TRUE if the values can be compared.
func ValueCanCompare(value1, value2 *coreglib.Value) bool {
	var _arg1 *C.GValue  // out
	var _arg2 *C.GValue  // out
	var _cret C.gboolean // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value1.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(value2.Native()))

	_cret = C.gst_value_can_compare(_arg1, _arg2)
	runtime.KeepAlive(value1)
	runtime.KeepAlive(value2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ValueCanIntersect determines if intersecting two values will produce a valid
// result. Two values will produce a valid intersection if they have the same
// type.
//
// The function takes the following parameters:
//
//   - value1: value to intersect.
//   - value2: another value to intersect.
//
// The function returns the following values:
//
//   - ok: TRUE if the values can intersect.
func ValueCanIntersect(value1, value2 *coreglib.Value) bool {
	var _arg1 *C.GValue  // out
	var _arg2 *C.GValue  // out
	var _cret C.gboolean // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value1.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(value2.Native()))

	_cret = C.gst_value_can_intersect(_arg1, _arg2)
	runtime.KeepAlive(value1)
	runtime.KeepAlive(value2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ValueCanSubtract checks if it's possible to subtract subtrahend from minuend.
//
// The function takes the following parameters:
//
//   - minuend: value to subtract from.
//   - subtrahend: value to subtract.
//
// The function returns the following values:
//
//   - ok: TRUE if a subtraction is possible.
func ValueCanSubtract(minuend, subtrahend *coreglib.Value) bool {
	var _arg1 *C.GValue  // out
	var _arg2 *C.GValue  // out
	var _cret C.gboolean // in

	_arg1 = (*C.GValue)(unsafe.Pointer(minuend.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(subtrahend.Native()))

	_cret = C.gst_value_can_subtract(_arg1, _arg2)
	runtime.KeepAlive(minuend)
	runtime.KeepAlive(subtrahend)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ValueCanUnion determines if value1 and value2 can be non-trivially unioned.
// Any two values can be trivially unioned by adding both of them to a
// GstValueList. However, certain types have the possibility to be unioned in
// a simpler way. For example, an integer range and an integer can be unioned
// if the integer is a subset of the integer range. If there is the possibility
// that two values can be unioned, this function returns TRUE.
//
// The function takes the following parameters:
//
//   - value1: value to union.
//   - value2: another value to union.
//
// The function returns the following values:
//
//   - ok: TRUE if there is a function allowing the two values to be unioned.
func ValueCanUnion(value1, value2 *coreglib.Value) bool {
	var _arg1 *C.GValue  // out
	var _arg2 *C.GValue  // out
	var _cret C.gboolean // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value1.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(value2.Native()))

	_cret = C.gst_value_can_union(_arg1, _arg2)
	runtime.KeepAlive(value1)
	runtime.KeepAlive(value2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ValueCompare compares value1 and value2. If value1 and value2 cannot be
// compared, the function returns GST_VALUE_UNORDERED. Otherwise, if value1
// is greater than value2, GST_VALUE_GREATER_THAN is returned. If value1 is
// less than value2, GST_VALUE_LESS_THAN is returned. If the values are equal,
// GST_VALUE_EQUAL is returned.
//
// The function takes the following parameters:
//
//   - value1: value to compare.
//   - value2: another value to compare.
//
// The function returns the following values:
//
//   - gint: comparison result.
func ValueCompare(value1, value2 *coreglib.Value) int {
	var _arg1 *C.GValue // out
	var _arg2 *C.GValue // out
	var _cret C.gint    // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value1.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(value2.Native()))

	_cret = C.gst_value_compare(_arg1, _arg2)
	runtime.KeepAlive(value1)
	runtime.KeepAlive(value2)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ValueDeserialize tries to deserialize a string into the type specified by the
// given GValue. If the operation succeeds, TRUE is returned, FALSE otherwise.
//
// The function takes the following parameters:
//
//   - src: string to deserialize.
//
// The function returns the following values:
//
//   - dest to fill with contents of deserialization.
//   - ok: TRUE on success.
func ValueDeserialize(src string) (coreglib.Value, bool) {
	var _arg1 C.GValue   // in
	var _arg2 *C.gchar   // out
	var _cret C.gboolean // in

	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(src)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_value_deserialize(&_arg1, _arg2)
	runtime.KeepAlive(src)

	var _dest coreglib.Value // out
	var _ok bool             // out

	_dest = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))
	if _cret != 0 {
		_ok = true
	}

	return _dest, _ok
}

// ValueFixate: fixate src into a new value dest. For ranges, the first element
// is taken. For lists and arrays, the first item is fixated and returned.
// If src is already fixed, this function returns FALSE.
//
// The function takes the following parameters:
//
//   - dest: #GValue destination.
//   - src to fixate.
//
// The function returns the following values:
//
//   - ok: TRUE if dest contains a fixated version of src.
func ValueFixate(dest, src *coreglib.Value) bool {
	var _arg1 *C.GValue  // out
	var _arg2 *C.GValue  // out
	var _cret C.gboolean // in

	_arg1 = (*C.GValue)(unsafe.Pointer(dest.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(src.Native()))

	_cret = C.gst_value_fixate(_arg1, _arg2)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(src)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ValueFractionMultiply multiplies the two #GValue items containing a
// T_TYPE_FRACTION and sets product to the product of the two fractions.
//
// The function takes the following parameters:
//
//   - product: GValue initialized to T_TYPE_FRACTION.
//   - factor1: GValue initialized to T_TYPE_FRACTION.
//   - factor2: GValue initialized to T_TYPE_FRACTION.
//
// The function returns the following values:
//
//   - ok: FALSE in case of an error (like integer overflow), TRUE otherwise.
func ValueFractionMultiply(product, factor1, factor2 *coreglib.Value) bool {
	var _arg1 *C.GValue  // out
	var _arg2 *C.GValue  // out
	var _arg3 *C.GValue  // out
	var _cret C.gboolean // in

	_arg1 = (*C.GValue)(unsafe.Pointer(product.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(factor1.Native()))
	_arg3 = (*C.GValue)(unsafe.Pointer(factor2.Native()))

	_cret = C.gst_value_fraction_multiply(_arg1, _arg2, _arg3)
	runtime.KeepAlive(product)
	runtime.KeepAlive(factor1)
	runtime.KeepAlive(factor2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ValueFractionSubtract subtracts the subtrahend from the minuend and sets dest
// to the result.
//
// The function takes the following parameters:
//
//   - dest: GValue initialized to T_TYPE_FRACTION.
//   - minuend: GValue initialized to T_TYPE_FRACTION.
//   - subtrahend: GValue initialized to T_TYPE_FRACTION.
//
// The function returns the following values:
//
//   - ok: FALSE in case of an error (like integer overflow), TRUE otherwise.
func ValueFractionSubtract(dest, minuend, subtrahend *coreglib.Value) bool {
	var _arg1 *C.GValue  // out
	var _arg2 *C.GValue  // out
	var _arg3 *C.GValue  // out
	var _cret C.gboolean // in

	_arg1 = (*C.GValue)(unsafe.Pointer(dest.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(minuend.Native()))
	_arg3 = (*C.GValue)(unsafe.Pointer(subtrahend.Native()))

	_cret = C.gst_value_fraction_subtract(_arg1, _arg2, _arg3)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(minuend)
	runtime.KeepAlive(subtrahend)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ValueGetBitmask gets the bitmask specified by value.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to T_TYPE_BITMASK.
//
// The function returns the following values:
//
//   - guint64: bitmask.
func ValueGetBitmask(value *coreglib.Value) uint64 {
	var _arg1 *C.GValue // out
	var _cret C.guint64 // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_bitmask(_arg1)
	runtime.KeepAlive(value)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// ValueGetCaps gets the contents of value. The reference count of the returned
// Caps will not be modified, therefore the caller must take one before getting
// rid of the value.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_CAPS.
//
// The function returns the following values:
//
//   - caps contents of value.
func ValueGetCaps(value *coreglib.Value) *Caps {
	var _arg1 *C.GValue  // out
	var _cret *C.GstCaps // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_caps(_arg1)
	runtime.KeepAlive(value)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _caps
}

// ValueGetCapsFeatures gets the contents of value.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_CAPS_FEATURES.
//
// The function returns the following values:
//
//   - capsFeatures contents of value.
func ValueGetCapsFeatures(value *coreglib.Value) *CapsFeatures {
	var _arg1 *C.GValue          // out
	var _cret *C.GstCapsFeatures // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_caps_features(_arg1)
	runtime.KeepAlive(value)

	var _capsFeatures *CapsFeatures // out

	_capsFeatures = (*CapsFeatures)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _capsFeatures
}

// ValueGetDoubleRangeMax gets the maximum of the range specified by value.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_DOUBLE_RANGE.
//
// The function returns the following values:
//
//   - gdouble: maximum of the range.
func ValueGetDoubleRangeMax(value *coreglib.Value) float64 {
	var _arg1 *C.GValue // out
	var _cret C.gdouble // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_double_range_max(_arg1)
	runtime.KeepAlive(value)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// ValueGetDoubleRangeMin gets the minimum of the range specified by value.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_DOUBLE_RANGE.
//
// The function returns the following values:
//
//   - gdouble: minimum of the range.
func ValueGetDoubleRangeMin(value *coreglib.Value) float64 {
	var _arg1 *C.GValue // out
	var _cret C.gdouble // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_double_range_min(_arg1)
	runtime.KeepAlive(value)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// ValueGetFlagsetFlags: retrieve the flags field of a GstFlagSet value.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to T_TYPE_FLAG_SET.
//
// The function returns the following values:
//
//   - guint flags field of the flagset instance.
func ValueGetFlagsetFlags(value *coreglib.Value) uint {
	var _arg1 *C.GValue // out
	var _cret C.guint   // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_flagset_flags(_arg1)
	runtime.KeepAlive(value)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ValueGetFlagsetMask: retrieve the mask field of a GstFlagSet value.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to T_TYPE_FLAG_SET.
//
// The function returns the following values:
//
//   - guint: mask field of the flagset instance.
func ValueGetFlagsetMask(value *coreglib.Value) uint {
	var _arg1 *C.GValue // out
	var _cret C.guint   // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_flagset_mask(_arg1)
	runtime.KeepAlive(value)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ValueGetFractionDenominator gets the denominator of the fraction specified by
// value.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to T_TYPE_FRACTION.
//
// The function returns the following values:
//
//   - gint: denominator of the fraction.
func ValueGetFractionDenominator(value *coreglib.Value) int {
	var _arg1 *C.GValue // out
	var _cret C.gint    // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_fraction_denominator(_arg1)
	runtime.KeepAlive(value)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ValueGetFractionNumerator gets the numerator of the fraction specified by
// value.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to T_TYPE_FRACTION.
//
// The function returns the following values:
//
//   - gint: numerator of the fraction.
func ValueGetFractionNumerator(value *coreglib.Value) int {
	var _arg1 *C.GValue // out
	var _cret C.gint    // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_fraction_numerator(_arg1)
	runtime.KeepAlive(value)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ValueGetFractionRangeMax gets the maximum of the range specified by value.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_FRACTION_RANGE.
//
// The function returns the following values:
//
//   - ret (optional): maximum of the range.
func ValueGetFractionRangeMax(value *coreglib.Value) *coreglib.Value {
	var _arg1 *C.GValue // out
	var _cret *C.GValue // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_fraction_range_max(_arg1)
	runtime.KeepAlive(value)

	var _ret *coreglib.Value // out

	if _cret != nil {
		_ret = coreglib.ValueFromNative(unsafe.Pointer(_cret))
	}

	return _ret
}

// ValueGetFractionRangeMin gets the minimum of the range specified by value.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_FRACTION_RANGE.
//
// The function returns the following values:
//
//   - ret (optional): minimum of the range.
func ValueGetFractionRangeMin(value *coreglib.Value) *coreglib.Value {
	var _arg1 *C.GValue // out
	var _cret *C.GValue // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_fraction_range_min(_arg1)
	runtime.KeepAlive(value)

	var _ret *coreglib.Value // out

	if _cret != nil {
		_ret = coreglib.ValueFromNative(unsafe.Pointer(_cret))
	}

	return _ret
}

// ValueGetInt64RangeMax gets the maximum of the range specified by value.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_INT64_RANGE.
//
// The function returns the following values:
//
//   - gint64: maximum of the range.
func ValueGetInt64RangeMax(value *coreglib.Value) int64 {
	var _arg1 *C.GValue // out
	var _cret C.gint64  // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_int64_range_max(_arg1)
	runtime.KeepAlive(value)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// ValueGetInt64RangeMin gets the minimum of the range specified by value.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_INT64_RANGE.
//
// The function returns the following values:
//
//   - gint64: minimum of the range.
func ValueGetInt64RangeMin(value *coreglib.Value) int64 {
	var _arg1 *C.GValue // out
	var _cret C.gint64  // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_int64_range_min(_arg1)
	runtime.KeepAlive(value)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// ValueGetInt64RangeStep gets the step of the range specified by value.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_INT64_RANGE.
//
// The function returns the following values:
//
//   - gint64: step of the range.
func ValueGetInt64RangeStep(value *coreglib.Value) int64 {
	var _arg1 *C.GValue // out
	var _cret C.gint64  // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_int64_range_step(_arg1)
	runtime.KeepAlive(value)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// ValueGetIntRangeMax gets the maximum of the range specified by value.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_INT_RANGE.
//
// The function returns the following values:
//
//   - gint: maximum of the range.
func ValueGetIntRangeMax(value *coreglib.Value) int {
	var _arg1 *C.GValue // out
	var _cret C.gint    // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_int_range_max(_arg1)
	runtime.KeepAlive(value)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ValueGetIntRangeMin gets the minimum of the range specified by value.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_INT_RANGE.
//
// The function returns the following values:
//
//   - gint: minimum of the range.
func ValueGetIntRangeMin(value *coreglib.Value) int {
	var _arg1 *C.GValue // out
	var _cret C.gint    // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_int_range_min(_arg1)
	runtime.KeepAlive(value)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ValueGetIntRangeStep gets the step of the range specified by value.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_INT_RANGE.
//
// The function returns the following values:
//
//   - gint: step of the range.
func ValueGetIntRangeStep(value *coreglib.Value) int {
	var _arg1 *C.GValue // out
	var _cret C.gint    // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_int_range_step(_arg1)
	runtime.KeepAlive(value)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ValueGetStructure gets the contents of value.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_STRUCTURE.
//
// The function returns the following values:
//
//   - structure contents of value.
func ValueGetStructure(value *coreglib.Value) *Structure {
	var _arg1 *C.GValue       // out
	var _cret *C.GstStructure // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_get_structure(_arg1)
	runtime.KeepAlive(value)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _structure
}

// ValueInitAndCopy initialises the target value to be of the same type as
// source and then copies the contents from source to target.
//
// The function takes the following parameters:
//
//   - src: source value.
//
// The function returns the following values:
//
//   - dest: target value.
func ValueInitAndCopy(src *coreglib.Value) coreglib.Value {
	var _arg1 C.GValue  // in
	var _arg2 *C.GValue // out

	_arg2 = (*C.GValue)(unsafe.Pointer(src.Native()))

	C.gst_value_init_and_copy(&_arg1, _arg2)
	runtime.KeepAlive(src)

	var _dest coreglib.Value // out

	_dest = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))

	return _dest
}

// ValueIntersect calculates the intersection of two values. If the values have
// a non-empty intersection, the value representing the intersection is placed
// in dest, unless NULL. If the intersection is non-empty, dest is not modified.
//
// The function takes the following parameters:
//
//   - value1: value to intersect.
//   - value2: another value to intersect.
//
// The function returns the following values:
//
//   - dest (optional): a uninitialized #GValue that will hold the calculated
//     intersection value. May be NULL if the resulting set if not needed.
//   - ok: TRUE if the intersection is non-empty.
func ValueIntersect(value1, value2 *coreglib.Value) (coreglib.Value, bool) {
	var _arg1 C.GValue   // in
	var _arg2 *C.GValue  // out
	var _arg3 *C.GValue  // out
	var _cret C.gboolean // in

	_arg2 = (*C.GValue)(unsafe.Pointer(value1.Native()))
	_arg3 = (*C.GValue)(unsafe.Pointer(value2.Native()))

	_cret = C.gst_value_intersect(&_arg1, _arg2, _arg3)
	runtime.KeepAlive(value1)
	runtime.KeepAlive(value2)

	var _dest coreglib.Value // out
	var _ok bool             // out

	_dest = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))
	runtime.SetFinalizer(_dest, func(v *coreglib.Value) {
		C.g_value_unset((*C.GValue)(unsafe.Pointer(v.Native())))
	})
	if _cret != 0 {
		_ok = true
	}

	return _dest, _ok
}

// ValueIsFixed tests if the given GValue, if available in a GstStructure
// (or any other container) contains a "fixed" (which means: one value) or an
// "unfixed" (which means: multiple possible values, such as data lists or data
// ranges) value.
//
// The function takes the following parameters:
//
//   - value to check.
//
// The function returns the following values:
//
//   - ok: true if the value is "fixed".
func ValueIsFixed(value *coreglib.Value) bool {
	var _arg1 *C.GValue  // out
	var _cret C.gboolean // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_is_fixed(_arg1)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ValueIsSubset: check that value1 is a subset of value2.
//
// The function takes the following parameters:
//
//   - value1: #GValue.
//   - value2: #GValue.
//
// The function returns the following values:
//
//   - ok: TRUE is value1 is a subset of value2.
func ValueIsSubset(value1, value2 *coreglib.Value) bool {
	var _arg1 *C.GValue  // out
	var _arg2 *C.GValue  // out
	var _cret C.gboolean // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value1.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(value2.Native()))

	_cret = C.gst_value_is_subset(_arg1, _arg2)
	runtime.KeepAlive(value1)
	runtime.KeepAlive(value2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ValueRegister registers functions to perform calculations on #GValue items of
// a given type. Each type can only be added once.
//
// The function takes the following parameters:
//
//   - table: structure containing functions to register.
func ValueRegister(table *ValueTable) {
	var _arg1 *C.GstValueTable // out

	_arg1 = (*C.GstValueTable)(gextras.StructNative(unsafe.Pointer(table)))

	C.gst_value_register(_arg1)
	runtime.KeepAlive(table)
}

// ValueSerialize tries to transform the given value into a string
// representation that allows getting back this string later on using
// gst_value_deserialize().
//
// Free-function: g_free.
//
// The function takes the following parameters:
//
//   - value to serialize.
//
// The function returns the following values:
//
//   - utf8 (optional): serialization for value or NULL if none exists.
func ValueSerialize(value *coreglib.Value) string {
	var _arg1 *C.GValue // out
	var _cret *C.gchar  // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_serialize(_arg1)
	runtime.KeepAlive(value)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// ValueSetBitmask sets value to the bitmask specified by bitmask.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to T_TYPE_BITMASK.
//   - bitmask: bitmask.
func ValueSetBitmask(value *coreglib.Value, bitmask uint64) {
	var _arg1 *C.GValue // out
	var _arg2 C.guint64 // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.guint64(bitmask)

	C.gst_value_set_bitmask(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(bitmask)
}

// ValueSetCaps sets the contents of value to caps. A reference to the provided
// caps will be taken by the value.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_CAPS.
//   - caps to set the value to.
func ValueSetCaps(value *coreglib.Value, caps *Caps) {
	var _arg1 *C.GValue  // out
	var _arg2 *C.GstCaps // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	C.gst_value_set_caps(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(caps)
}

// ValueSetCapsFeatures sets the contents of value to features.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_CAPS_FEATURES.
//   - features to set the value to.
func ValueSetCapsFeatures(value *coreglib.Value, features *CapsFeatures) {
	var _arg1 *C.GValue          // out
	var _arg2 *C.GstCapsFeatures // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))

	C.gst_value_set_caps_features(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(features)
}

// ValueSetDoubleRange sets value to the range specified by start and end.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_DOUBLE_RANGE.
//   - start of the range.
//   - end of the range.
func ValueSetDoubleRange(value *coreglib.Value, start, end float64) {
	var _arg1 *C.GValue // out
	var _arg2 C.gdouble // out
	var _arg3 C.gdouble // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.gdouble(start)
	_arg3 = C.gdouble(end)

	C.gst_value_set_double_range(_arg1, _arg2, _arg3)
	runtime.KeepAlive(value)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// ValueSetFlagset sets value to the flags and mask values provided in flags
// and mask. The flags value indicates the values of flags, the mask represents
// which bits in the flag value have been set, and which are "don't care".
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_FLAG_SET.
//   - flags: value of the flags set or unset.
//   - mask indicate which flags bits must match for comparisons.
func ValueSetFlagset(value *coreglib.Value, flags, mask uint) {
	var _arg1 *C.GValue // out
	var _arg2 C.guint   // out
	var _arg3 C.guint   // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.guint(flags)
	_arg3 = C.guint(mask)

	C.gst_value_set_flagset(_arg1, _arg2, _arg3)
	runtime.KeepAlive(value)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mask)
}

// ValueSetFraction sets value to the fraction specified by numerator over
// denominator. The fraction gets reduced to the smallest numerator and
// denominator, and if necessary the sign is moved to the numerator.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to T_TYPE_FRACTION.
//   - numerator of the fraction.
//   - denominator of the fraction.
func ValueSetFraction(value *coreglib.Value, numerator, denominator int) {
	var _arg1 *C.GValue // out
	var _arg2 C.gint    // out
	var _arg3 C.gint    // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.gint(numerator)
	_arg3 = C.gint(denominator)

	C.gst_value_set_fraction(_arg1, _arg2, _arg3)
	runtime.KeepAlive(value)
	runtime.KeepAlive(numerator)
	runtime.KeepAlive(denominator)
}

// ValueSetFractionRange sets value to the range specified by start and end.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_FRACTION_RANGE.
//   - start of the range (a GST_TYPE_FRACTION GValue).
//   - end of the range (a GST_TYPE_FRACTION GValue).
func ValueSetFractionRange(value, start, end *coreglib.Value) {
	var _arg1 *C.GValue // out
	var _arg2 *C.GValue // out
	var _arg3 *C.GValue // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(start.Native()))
	_arg3 = (*C.GValue)(unsafe.Pointer(end.Native()))

	C.gst_value_set_fraction_range(_arg1, _arg2, _arg3)
	runtime.KeepAlive(value)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// ValueSetFractionRangeFull sets value to the range specified by
// numerator_start/denominator_start and numerator_end/denominator_end.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_FRACTION_RANGE.
//   - numeratorStart: numerator start of the range.
//   - denominatorStart: denominator start of the range.
//   - numeratorEnd: numerator end of the range.
//   - denominatorEnd: denominator end of the range.
func ValueSetFractionRangeFull(value *coreglib.Value, numeratorStart, denominatorStart, numeratorEnd, denominatorEnd int) {
	var _arg1 *C.GValue // out
	var _arg2 C.gint    // out
	var _arg3 C.gint    // out
	var _arg4 C.gint    // out
	var _arg5 C.gint    // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.gint(numeratorStart)
	_arg3 = C.gint(denominatorStart)
	_arg4 = C.gint(numeratorEnd)
	_arg5 = C.gint(denominatorEnd)

	C.gst_value_set_fraction_range_full(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(value)
	runtime.KeepAlive(numeratorStart)
	runtime.KeepAlive(denominatorStart)
	runtime.KeepAlive(numeratorEnd)
	runtime.KeepAlive(denominatorEnd)
}

// ValueSetInt64Range sets value to the range specified by start and end.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_INT64_RANGE.
//   - start of the range.
//   - end of the range.
func ValueSetInt64Range(value *coreglib.Value, start, end int64) {
	var _arg1 *C.GValue // out
	var _arg2 C.gint64  // out
	var _arg3 C.gint64  // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.gint64(start)
	_arg3 = C.gint64(end)

	C.gst_value_set_int64_range(_arg1, _arg2, _arg3)
	runtime.KeepAlive(value)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// ValueSetInt64RangeStep sets value to the range specified by start, end and
// step.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_INT64_RANGE.
//   - start of the range.
//   - end of the range.
//   - step of the range.
func ValueSetInt64RangeStep(value *coreglib.Value, start, end, step int64) {
	var _arg1 *C.GValue // out
	var _arg2 C.gint64  // out
	var _arg3 C.gint64  // out
	var _arg4 C.gint64  // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.gint64(start)
	_arg3 = C.gint64(end)
	_arg4 = C.gint64(step)

	C.gst_value_set_int64_range_step(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(value)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(step)
}

// ValueSetIntRange sets value to the range specified by start and end.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_INT_RANGE.
//   - start of the range.
//   - end of the range.
func ValueSetIntRange(value *coreglib.Value, start, end int) {
	var _arg1 *C.GValue // out
	var _arg2 C.gint    // out
	var _arg3 C.gint    // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.gint(start)
	_arg3 = C.gint(end)

	C.gst_value_set_int_range(_arg1, _arg2, _arg3)
	runtime.KeepAlive(value)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// ValueSetIntRangeStep sets value to the range specified by start, end and
// step.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_INT_RANGE.
//   - start of the range.
//   - end of the range.
//   - step of the range.
func ValueSetIntRangeStep(value *coreglib.Value, start, end, step int) {
	var _arg1 *C.GValue // out
	var _arg2 C.gint    // out
	var _arg3 C.gint    // out
	var _arg4 C.gint    // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.gint(start)
	_arg3 = C.gint(end)
	_arg4 = C.gint(step)

	C.gst_value_set_int_range_step(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(value)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(step)
}

// ValueSetStructure sets the contents of value to structure.
//
// The function takes the following parameters:
//
//   - value: GValue initialized to GST_TYPE_STRUCTURE.
//   - structure to set the value to.
func ValueSetStructure(value *coreglib.Value, structure *Structure) {
	var _arg1 *C.GValue       // out
	var _arg2 *C.GstStructure // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))

	C.gst_value_set_structure(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(structure)
}

// ValueSubtract subtracts subtrahend from minuend and stores the result in
// dest. Note that this means subtraction as in sets, not as in mathematics.
//
// The function takes the following parameters:
//
//   - minuend: value to subtract from.
//   - subtrahend: value to subtract.
//
// The function returns the following values:
//
//   - dest (optional): destination value for the result if the subtraction
//     is not empty. May be NULL, in which case the resulting set will not be
//     computed, which can give a fair speedup.
//   - ok: TRUE if the subtraction is not empty.
func ValueSubtract(minuend, subtrahend *coreglib.Value) (coreglib.Value, bool) {
	var _arg1 C.GValue   // in
	var _arg2 *C.GValue  // out
	var _arg3 *C.GValue  // out
	var _cret C.gboolean // in

	_arg2 = (*C.GValue)(unsafe.Pointer(minuend.Native()))
	_arg3 = (*C.GValue)(unsafe.Pointer(subtrahend.Native()))

	_cret = C.gst_value_subtract(&_arg1, _arg2, _arg3)
	runtime.KeepAlive(minuend)
	runtime.KeepAlive(subtrahend)

	var _dest coreglib.Value // out
	var _ok bool             // out

	_dest = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))
	if _cret != 0 {
		_ok = true
	}

	return _dest, _ok
}

// ValueUnion creates a GValue corresponding to the union of value1 and value2.
//
// The function takes the following parameters:
//
//   - value1: value to union.
//   - value2: another value to union.
//
// The function returns the following values:
//
//   - dest: destination value.
//   - ok: TRUE if the union succeeded.
func ValueUnion(value1, value2 *coreglib.Value) (coreglib.Value, bool) {
	var _arg1 C.GValue   // in
	var _arg2 *C.GValue  // out
	var _arg3 *C.GValue  // out
	var _cret C.gboolean // in

	_arg2 = (*C.GValue)(unsafe.Pointer(value1.Native()))
	_arg3 = (*C.GValue)(unsafe.Pointer(value2.Native()))

	_cret = C.gst_value_union(&_arg1, _arg2, _arg3)
	runtime.KeepAlive(value1)
	runtime.KeepAlive(value2)

	var _dest coreglib.Value // out
	var _ok bool             // out

	_dest = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))
	if _cret != 0 {
		_ok = true
	}

	return _dest, _ok
}

// Version gets the version number of the GStreamer library.
//
// The function returns the following values:
//
//   - major: pointer to a guint to store the major version number.
//   - minor: pointer to a guint to store the minor version number.
//   - micro: pointer to a guint to store the micro version number.
//   - nano: pointer to a guint to store the nano version number.
func Version() (major, minor, micro, nano uint) {
	var _arg1 C.guint // in
	var _arg2 C.guint // in
	var _arg3 C.guint // in
	var _arg4 C.guint // in

	C.gst_version(&_arg1, &_arg2, &_arg3, &_arg4)

	var _major uint // out
	var _minor uint // out
	var _micro uint // out
	var _nano uint  // out

	_major = uint(_arg1)
	_minor = uint(_arg2)
	_micro = uint(_arg3)
	_nano = uint(_arg4)

	return _major, _minor, _micro, _nano
}

// VersionString: this function returns a string that is useful for describing
// this version of GStreamer to the outside world: user agent strings, logging,
// ...
//
// The function returns the following values:
//
//   - utf8: newly allocated string describing this version of GStreamer.
func VersionString() string {
	var _cret *C.gchar // in

	_cret = C.gst_version_string()

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ChildProxy: this interface abstracts handling of property sets for elements
// with children. Imagine elements such as mixers or polyphonic generators.
// They all have multiple Pad or some kind of voice objects. Another use case
// are container elements like Bin. The element implementing the interface acts
// as a parent for those child objects.
//
// By implementing this interface the child properties can be accessed from the
// parent element by using gst_child_proxy_get() and gst_child_proxy_set().
//
// Property names are written as child-name::property-name. The whole naming
// scheme is recursive. Thus child1::child2::property is valid too, if child1
// and child2 implement the ChildProxy interface.
//
// ChildProxy wraps an interface. This means the user can get the
// underlying type by calling Cast().
type ChildProxy struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ChildProxy)(nil)
)

// ChildProxier describes ChildProxy's interface methods.
type ChildProxier interface {
	coreglib.Objector

	// ChildAdded emits the ChildProxy::child-added signal.
	ChildAdded(child *coreglib.Object, name string)
	// ChildRemoved emits the ChildProxy::child-removed signal.
	ChildRemoved(child *coreglib.Object, name string)
	// ChildByIndex fetches a child by its number.
	ChildByIndex(index uint) *coreglib.Object
	// ChildByName looks up a child element by the given name.
	ChildByName(name string) *coreglib.Object
	// ChildByNameRecurse looks up a child element by the given full-path name.
	ChildByNameRecurse(name string) *coreglib.Object
	// ChildrenCount gets the number of child objects this parent contains.
	ChildrenCount() uint
	// Property gets a single property using the GstChildProxy mechanism.
	Property(name string) coreglib.Value
	// SetProperty sets a single property using the GstChildProxy mechanism.
	SetProperty(name string, value *coreglib.Value)

	// Child-added will be emitted after the object was added to the
	// child_proxy.
	ConnectChildAdded(func(object *coreglib.Object, name string)) coreglib.SignalHandle
	// Child-removed will be emitted after the object was removed from the
	// child_proxy.
	ConnectChildRemoved(func(object *coreglib.Object, name string)) coreglib.SignalHandle
}

var _ ChildProxier = (*ChildProxy)(nil)

func wrapChildProxy(obj *coreglib.Object) *ChildProxy {
	return &ChildProxy{
		Object: obj,
	}
}

func marshalChildProxy(p uintptr) (interface{}, error) {
	return wrapChildProxy(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChildAdded will be emitted after the object was added to the
// child_proxy.
func (parent *ChildProxy) ConnectChildAdded(f func(object *coreglib.Object, name string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(parent, "child-added", false, unsafe.Pointer(C._gotk4_gst1_ChildProxy_ConnectChildAdded), f)
}

// ConnectChildRemoved will be emitted after the object was removed from the
// child_proxy.
func (parent *ChildProxy) ConnectChildRemoved(f func(object *coreglib.Object, name string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(parent, "child-removed", false, unsafe.Pointer(C._gotk4_gst1_ChildProxy_ConnectChildRemoved), f)
}

// ChildAdded emits the ChildProxy::child-added signal.
//
// The function takes the following parameters:
//
//   - child: newly added child.
//   - name of the new child.
func (parent *ChildProxy) ChildAdded(child *coreglib.Object, name string) {
	var _arg0 *C.GstChildProxy // out
	var _arg1 *C.GObject       // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GstChildProxy)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	_arg1 = (*C.GObject)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gst_child_proxy_child_added(_arg0, _arg1, _arg2)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(child)
	runtime.KeepAlive(name)
}

// ChildRemoved emits the ChildProxy::child-removed signal.
//
// The function takes the following parameters:
//
//   - child: removed child.
//   - name of the old child.
func (parent *ChildProxy) ChildRemoved(child *coreglib.Object, name string) {
	var _arg0 *C.GstChildProxy // out
	var _arg1 *C.GObject       // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GstChildProxy)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	_arg1 = (*C.GObject)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gst_child_proxy_child_removed(_arg0, _arg1, _arg2)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(child)
	runtime.KeepAlive(name)
}

// ChildByIndex fetches a child by its number.
//
// The function takes the following parameters:
//
//   - index child's position in the child list.
//
// The function returns the following values:
//
//   - object (optional): child object or NULL if not found (index too high).
func (parent *ChildProxy) ChildByIndex(index uint) *coreglib.Object {
	var _arg0 *C.GstChildProxy // out
	var _arg1 C.guint          // out
	var _cret *C.GObject       // in

	_arg0 = (*C.GstChildProxy)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	_arg1 = C.guint(index)

	_cret = C.gst_child_proxy_get_child_by_index(_arg0, _arg1)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(index)

	var _object *coreglib.Object // out

	if _cret != nil {
		_object = coreglib.AssumeOwnership(unsafe.Pointer(_cret))
	}

	return _object
}

// ChildByName looks up a child element by the given name.
//
// This virtual method has a default implementation that uses Object together
// with gst_object_get_name(). If the interface is to be used with #GObjects,
// this methods needs to be overridden.
//
// The function takes the following parameters:
//
//   - name child's name.
//
// The function returns the following values:
//
//   - object (optional): child object or NULL if not found.
func (parent *ChildProxy) ChildByName(name string) *coreglib.Object {
	var _arg0 *C.GstChildProxy // out
	var _arg1 *C.gchar         // out
	var _cret *C.GObject       // in

	_arg0 = (*C.GstChildProxy)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_child_proxy_get_child_by_name(_arg0, _arg1)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(name)

	var _object *coreglib.Object // out

	if _cret != nil {
		_object = coreglib.AssumeOwnership(unsafe.Pointer(_cret))
	}

	return _object
}

// ChildByNameRecurse looks up a child element by the given full-path name.
//
// Similar to gst_child_proxy_get_child_by_name(), this method searches and
// returns a child given a name. The difference is that this method allows a
// hierarchical path in the form of child1::child2::child3. In the later example
// this method would return a reference to child3, if found. The name should be
// made of element names only and should not contain any property names.
//
// The function takes the following parameters:
//
//   - name: full-path child's name.
//
// The function returns the following values:
//
//   - object (optional): child object or NULL if not found.
func (childProxy *ChildProxy) ChildByNameRecurse(name string) *coreglib.Object {
	var _arg0 *C.GstChildProxy // out
	var _arg1 *C.gchar         // out
	var _cret *C.GObject       // in

	_arg0 = (*C.GstChildProxy)(unsafe.Pointer(coreglib.InternObject(childProxy).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_child_proxy_get_child_by_name_recurse(_arg0, _arg1)
	runtime.KeepAlive(childProxy)
	runtime.KeepAlive(name)

	var _object *coreglib.Object // out

	if _cret != nil {
		_object = coreglib.AssumeOwnership(unsafe.Pointer(_cret))
	}

	return _object
}

// ChildrenCount gets the number of child objects this parent contains.
//
// The function returns the following values:
//
//   - guint: number of child objects.
func (parent *ChildProxy) ChildrenCount() uint {
	var _arg0 *C.GstChildProxy // out
	var _cret C.guint          // in

	_arg0 = (*C.GstChildProxy)(unsafe.Pointer(coreglib.InternObject(parent).Native()))

	_cret = C.gst_child_proxy_get_children_count(_arg0)
	runtime.KeepAlive(parent)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Property gets a single property using the GstChildProxy mechanism. You are
// responsible for freeing it by calling g_value_unset().
//
// The function takes the following parameters:
//
//   - name of the property.
//
// The function returns the following values:
//
//   - value that should take the result.
func (object *ChildProxy) Property(name string) coreglib.Value {
	var _arg0 *C.GstChildProxy // out
	var _arg1 *C.gchar         // out
	var _arg2 C.GValue         // in

	_arg0 = (*C.GstChildProxy)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_child_proxy_get_property(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(object)
	runtime.KeepAlive(name)

	var _value coreglib.Value // out

	_value = *coreglib.ValueFromNative(unsafe.Pointer((&_arg2)))

	return _value
}

// SetProperty sets a single property using the GstChildProxy mechanism.
//
// The function takes the following parameters:
//
//   - name of the property to set.
//   - value: new #GValue for the property.
func (object *ChildProxy) SetProperty(name string, value *coreglib.Value) {
	var _arg0 *C.GstChildProxy // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GValue        // out

	_arg0 = (*C.GstChildProxy)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gst_child_proxy_set_property(_arg0, _arg1, _arg2)
	runtime.KeepAlive(object)
	runtime.KeepAlive(name)
	runtime.KeepAlive(value)
}

// childAdded emits the ChildProxy::child-added signal.
//
// The function takes the following parameters:
//
//   - child: newly added child.
//   - name of the new child.
func (parent *ChildProxy) childAdded(child *coreglib.Object, name string) {
	gclass := (*C.GstChildProxyInterface)(coreglib.PeekParentClass(parent))
	fnarg := gclass.child_added

	var _arg0 *C.GstChildProxy // out
	var _arg1 *C.GObject       // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GstChildProxy)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	_arg1 = (*C.GObject)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	C._gotk4_gst1_ChildProxy_virtual_child_added(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(child)
	runtime.KeepAlive(name)
}

// childRemoved emits the ChildProxy::child-removed signal.
//
// The function takes the following parameters:
//
//   - child: removed child.
//   - name of the old child.
func (parent *ChildProxy) childRemoved(child *coreglib.Object, name string) {
	gclass := (*C.GstChildProxyInterface)(coreglib.PeekParentClass(parent))
	fnarg := gclass.child_removed

	var _arg0 *C.GstChildProxy // out
	var _arg1 *C.GObject       // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GstChildProxy)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	_arg1 = (*C.GObject)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	C._gotk4_gst1_ChildProxy_virtual_child_removed(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(child)
	runtime.KeepAlive(name)
}

// childByIndex fetches a child by its number.
//
// The function takes the following parameters:
//
//   - index child's position in the child list.
//
// The function returns the following values:
//
//   - object (optional): child object or NULL if not found (index too high).
func (parent *ChildProxy) childByIndex(index uint) *coreglib.Object {
	gclass := (*C.GstChildProxyInterface)(coreglib.PeekParentClass(parent))
	fnarg := gclass.get_child_by_index

	var _arg0 *C.GstChildProxy // out
	var _arg1 C.guint          // out
	var _cret *C.GObject       // in

	_arg0 = (*C.GstChildProxy)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	_arg1 = C.guint(index)

	_cret = C._gotk4_gst1_ChildProxy_virtual_get_child_by_index(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(index)

	var _object *coreglib.Object // out

	if _cret != nil {
		_object = coreglib.AssumeOwnership(unsafe.Pointer(_cret))
	}

	return _object
}

// childByName looks up a child element by the given name.
//
// This virtual method has a default implementation that uses Object together
// with gst_object_get_name(). If the interface is to be used with #GObjects,
// this methods needs to be overridden.
//
// The function takes the following parameters:
//
//   - name child's name.
//
// The function returns the following values:
//
//   - object (optional): child object or NULL if not found.
func (parent *ChildProxy) childByName(name string) *coreglib.Object {
	gclass := (*C.GstChildProxyInterface)(coreglib.PeekParentClass(parent))
	fnarg := gclass.get_child_by_name

	var _arg0 *C.GstChildProxy // out
	var _arg1 *C.gchar         // out
	var _cret *C.GObject       // in

	_arg0 = (*C.GstChildProxy)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gst1_ChildProxy_virtual_get_child_by_name(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(name)

	var _object *coreglib.Object // out

	if _cret != nil {
		_object = coreglib.AssumeOwnership(unsafe.Pointer(_cret))
	}

	return _object
}

// childrenCount gets the number of child objects this parent contains.
//
// The function returns the following values:
//
//   - guint: number of child objects.
func (parent *ChildProxy) childrenCount() uint {
	gclass := (*C.GstChildProxyInterface)(coreglib.PeekParentClass(parent))
	fnarg := gclass.get_children_count

	var _arg0 *C.GstChildProxy // out
	var _cret C.guint          // in

	_arg0 = (*C.GstChildProxy)(unsafe.Pointer(coreglib.InternObject(parent).Native()))

	_cret = C._gotk4_gst1_ChildProxy_virtual_get_children_count(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(parent)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Preset: this interface offers methods to query and manipulate parameter
// preset sets. A preset is a bunch of property settings, together with meta
// data and a name. The name of a preset serves as key for subsequent method
// calls to manipulate single presets. All instances of one type will share the
// list of presets. The list is created on demand, if presets are not used,
// the list is not created.
//
// The interface comes with a default implementation that serves most plugins.
// Wrapper plugins will override most methods to implement support for
// the native preset format of those wrapped plugins. One method that is
// useful to be overridden is gst_preset_get_property_names(). With that
// one can control which properties are saved and in which order. When
// implementing support for read-only presets, one should set the vmethods for
// gst_preset_save_preset() and gst_preset_delete_preset() to NULL. Applications
// can use gst_preset_is_editable() to check for that.
//
// The default implementation supports presets located in a system directory,
// application specific directory and in the users home directory. When getting
// a list of presets individual presets are read and overlaid in 1) system,
// 2) application and 3) user order. Whenever an earlier entry is newer,
// the later entries will be updated. Since 1.8 you can also provide extra
// paths where to find presets through the GST_PRESET_PATH environment variable.
// Presets found in those paths will be considered as "app presets".
//
// Preset wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Preset struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Preset)(nil)
)

// Presetter describes Preset's interface methods.
type Presetter interface {
	coreglib.Objector

	// DeletePreset: delete the given preset.
	DeletePreset(name string) bool
	// Meta gets the value for an existing meta data tag.
	Meta(name, tag string) (string, bool)
	// PresetNames: get a copy of preset names as a NULL terminated string
	// array.
	PresetNames() []string
	// PropertyNames: get a the names of the GObject properties that can be used
	// for presets.
	PropertyNames() []string
	// IsEditable: check if one can add new presets, change existing ones and
	// remove presets.
	IsEditable() bool
	// LoadPreset: load the given preset.
	LoadPreset(name string) bool
	// RenamePreset renames a preset.
	RenamePreset(oldName, newName string) bool
	// SavePreset: save the current object settings as a preset under the given
	// name.
	SavePreset(name string) bool
	// SetMeta sets a new value for an existing meta data item or adds a new
	// item.
	SetMeta(name, tag, value string) bool
}

var _ Presetter = (*Preset)(nil)

func wrapPreset(obj *coreglib.Object) *Preset {
	return &Preset{
		Object: obj,
	}
}

func marshalPreset(p uintptr) (interface{}, error) {
	return wrapPreset(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// DeletePreset: delete the given preset.
//
// The function takes the following parameters:
//
//   - name: preset name to remove.
//
// The function returns the following values:
//
//   - ok: TRUE for success, FALSE if e.g. there is no preset with that name.
func (preset *Preset) DeletePreset(name string) bool {
	var _arg0 *C.GstPreset // out
	var _arg1 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPreset)(unsafe.Pointer(coreglib.InternObject(preset).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_preset_delete_preset(_arg0, _arg1)
	runtime.KeepAlive(preset)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Meta gets the value for an existing meta data tag. Meta data tag names can be
// something like e.g. "comment". Returned values need to be released when done.
//
// The function takes the following parameters:
//
//   - name: preset name.
//   - tag: meta data item name.
//
// The function returns the following values:
//
//   - value: value.
//   - ok: TRUE for success, FALSE if e.g. there is no preset with that name or
//     no value for the given tag.
func (preset *Preset) Meta(name, tag string) (string, bool) {
	var _arg0 *C.GstPreset // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out
	var _arg3 *C.gchar     // in
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPreset)(unsafe.Pointer(coreglib.InternObject(preset).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_preset_get_meta(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(preset)
	runtime.KeepAlive(name)
	runtime.KeepAlive(tag)

	var _value string // out
	var _ok bool      // out

	_value = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
	defer C.free(unsafe.Pointer(_arg3))
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// PresetNames: get a copy of preset names as a NULL terminated string array.
//
// The function returns the following values:
//
//   - utf8s: list with names, use g_strfreev() after usage.
func (preset *Preset) PresetNames() []string {
	var _arg0 *C.GstPreset // out
	var _cret **C.gchar    // in

	_arg0 = (*C.GstPreset)(unsafe.Pointer(coreglib.InternObject(preset).Native()))

	_cret = C.gst_preset_get_preset_names(_arg0)
	runtime.KeepAlive(preset)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// PropertyNames: get a the names of the GObject properties that can be used for
// presets.
//
// The function returns the following values:
//
//   - utf8s: an array of property names which should be freed with g_strfreev()
//     after use.
func (preset *Preset) PropertyNames() []string {
	var _arg0 *C.GstPreset // out
	var _cret **C.gchar    // in

	_arg0 = (*C.GstPreset)(unsafe.Pointer(coreglib.InternObject(preset).Native()))

	_cret = C.gst_preset_get_property_names(_arg0)
	runtime.KeepAlive(preset)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// IsEditable: check if one can add new presets, change existing ones and remove
// presets.
//
// The function returns the following values:
//
//   - ok: TRUE if presets are editable or FALSE if they are static.
func (preset *Preset) IsEditable() bool {
	var _arg0 *C.GstPreset // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPreset)(unsafe.Pointer(coreglib.InternObject(preset).Native()))

	_cret = C.gst_preset_is_editable(_arg0)
	runtime.KeepAlive(preset)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LoadPreset: load the given preset.
//
// The function takes the following parameters:
//
//   - name: preset name to load.
//
// The function returns the following values:
//
//   - ok: TRUE for success, FALSE if e.g. there is no preset with that name.
func (preset *Preset) LoadPreset(name string) bool {
	var _arg0 *C.GstPreset // out
	var _arg1 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPreset)(unsafe.Pointer(coreglib.InternObject(preset).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_preset_load_preset(_arg0, _arg1)
	runtime.KeepAlive(preset)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RenamePreset renames a preset. If there is already a preset by the new_name
// it will be overwritten.
//
// The function takes the following parameters:
//
//   - oldName: current preset name.
//   - newName: new preset name.
//
// The function returns the following values:
//
//   - ok: TRUE for success, FALSE if e.g. there is no preset with old_name.
func (preset *Preset) RenamePreset(oldName, newName string) bool {
	var _arg0 *C.GstPreset // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPreset)(unsafe.Pointer(coreglib.InternObject(preset).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(oldName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(newName)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_preset_rename_preset(_arg0, _arg1, _arg2)
	runtime.KeepAlive(preset)
	runtime.KeepAlive(oldName)
	runtime.KeepAlive(newName)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SavePreset: save the current object settings as a preset under the given
// name. If there is already a preset by this name it will be overwritten.
//
// The function takes the following parameters:
//
//   - name: preset name to save.
//
// The function returns the following values:
//
//   - ok: TRUE for success, FALSE.
func (preset *Preset) SavePreset(name string) bool {
	var _arg0 *C.GstPreset // out
	var _arg1 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPreset)(unsafe.Pointer(coreglib.InternObject(preset).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_preset_save_preset(_arg0, _arg1)
	runtime.KeepAlive(preset)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetMeta sets a new value for an existing meta data item or adds a new item.
// Meta data tag names can be something like e.g. "comment". Supplying NULL for
// the value will unset an existing value.
//
// The function takes the following parameters:
//
//   - name: preset name.
//   - tag: meta data item name.
//   - value (optional): new value.
//
// The function returns the following values:
//
//   - ok: TRUE for success, FALSE if e.g. there is no preset with that name.
func (preset *Preset) SetMeta(name, tag, value string) bool {
	var _arg0 *C.GstPreset // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out
	var _arg3 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPreset)(unsafe.Pointer(coreglib.InternObject(preset).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg2))
	if value != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	_cret = C.gst_preset_set_meta(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(preset)
	runtime.KeepAlive(name)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// deletePreset: delete the given preset.
//
// The function takes the following parameters:
//
//   - name: preset name to remove.
//
// The function returns the following values:
//
//   - ok: TRUE for success, FALSE if e.g. there is no preset with that name.
func (preset *Preset) deletePreset(name string) bool {
	gclass := (*C.GstPresetInterface)(coreglib.PeekParentClass(preset))
	fnarg := gclass.delete_preset

	var _arg0 *C.GstPreset // out
	var _arg1 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPreset)(unsafe.Pointer(coreglib.InternObject(preset).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gst1_Preset_virtual_delete_preset(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(preset)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Meta gets the value for an existing meta data tag. Meta data tag names can be
// something like e.g. "comment". Returned values need to be released when done.
//
// The function takes the following parameters:
//
//   - name: preset name.
//   - tag: meta data item name.
//
// The function returns the following values:
//
//   - value: value.
//   - ok: TRUE for success, FALSE if e.g. there is no preset with that name or
//     no value for the given tag.
func (preset *Preset) meta(name, tag string) (string, bool) {
	gclass := (*C.GstPresetInterface)(coreglib.PeekParentClass(preset))
	fnarg := gclass.get_meta

	var _arg0 *C.GstPreset // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out
	var _arg3 *C.gchar     // in
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPreset)(unsafe.Pointer(coreglib.InternObject(preset).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C._gotk4_gst1_Preset_virtual_get_meta(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(preset)
	runtime.KeepAlive(name)
	runtime.KeepAlive(tag)

	var _value string // out
	var _ok bool      // out

	_value = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
	defer C.free(unsafe.Pointer(_arg3))
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// presetNames: get a copy of preset names as a NULL terminated string array.
//
// The function returns the following values:
//
//   - utf8s: list with names, use g_strfreev() after usage.
func (preset *Preset) presetNames() []string {
	gclass := (*C.GstPresetInterface)(coreglib.PeekParentClass(preset))
	fnarg := gclass.get_preset_names

	var _arg0 *C.GstPreset // out
	var _cret **C.gchar    // in

	_arg0 = (*C.GstPreset)(unsafe.Pointer(coreglib.InternObject(preset).Native()))

	_cret = C._gotk4_gst1_Preset_virtual_get_preset_names(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(preset)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// propertyNames: get a the names of the GObject properties that can be used for
// presets.
//
// The function returns the following values:
//
//   - utf8s: an array of property names which should be freed with g_strfreev()
//     after use.
func (preset *Preset) propertyNames() []string {
	gclass := (*C.GstPresetInterface)(coreglib.PeekParentClass(preset))
	fnarg := gclass.get_property_names

	var _arg0 *C.GstPreset // out
	var _cret **C.gchar    // in

	_arg0 = (*C.GstPreset)(unsafe.Pointer(coreglib.InternObject(preset).Native()))

	_cret = C._gotk4_gst1_Preset_virtual_get_property_names(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(preset)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// loadPreset: load the given preset.
//
// The function takes the following parameters:
//
//   - name: preset name to load.
//
// The function returns the following values:
//
//   - ok: TRUE for success, FALSE if e.g. there is no preset with that name.
func (preset *Preset) loadPreset(name string) bool {
	gclass := (*C.GstPresetInterface)(coreglib.PeekParentClass(preset))
	fnarg := gclass.load_preset

	var _arg0 *C.GstPreset // out
	var _arg1 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPreset)(unsafe.Pointer(coreglib.InternObject(preset).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gst1_Preset_virtual_load_preset(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(preset)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// renamePreset renames a preset. If there is already a preset by the new_name
// it will be overwritten.
//
// The function takes the following parameters:
//
//   - oldName: current preset name.
//   - newName: new preset name.
//
// The function returns the following values:
//
//   - ok: TRUE for success, FALSE if e.g. there is no preset with old_name.
func (preset *Preset) renamePreset(oldName, newName string) bool {
	gclass := (*C.GstPresetInterface)(coreglib.PeekParentClass(preset))
	fnarg := gclass.rename_preset

	var _arg0 *C.GstPreset // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPreset)(unsafe.Pointer(coreglib.InternObject(preset).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(oldName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(newName)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C._gotk4_gst1_Preset_virtual_rename_preset(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(preset)
	runtime.KeepAlive(oldName)
	runtime.KeepAlive(newName)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// savePreset: save the current object settings as a preset under the given
// name. If there is already a preset by this name it will be overwritten.
//
// The function takes the following parameters:
//
//   - name: preset name to save.
//
// The function returns the following values:
//
//   - ok: TRUE for success, FALSE.
func (preset *Preset) savePreset(name string) bool {
	gclass := (*C.GstPresetInterface)(coreglib.PeekParentClass(preset))
	fnarg := gclass.save_preset

	var _arg0 *C.GstPreset // out
	var _arg1 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPreset)(unsafe.Pointer(coreglib.InternObject(preset).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gst1_Preset_virtual_save_preset(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(preset)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// setMeta sets a new value for an existing meta data item or adds a new item.
// Meta data tag names can be something like e.g. "comment". Supplying NULL for
// the value will unset an existing value.
//
// The function takes the following parameters:
//
//   - name: preset name.
//   - tag: meta data item name.
//   - value (optional): new value.
//
// The function returns the following values:
//
//   - ok: TRUE for success, FALSE if e.g. there is no preset with that name.
func (preset *Preset) setMeta(name, tag, value string) bool {
	gclass := (*C.GstPresetInterface)(coreglib.PeekParentClass(preset))
	fnarg := gclass.set_meta

	var _arg0 *C.GstPreset // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out
	var _arg3 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPreset)(unsafe.Pointer(coreglib.InternObject(preset).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg2))
	if value != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	_cret = C._gotk4_gst1_Preset_virtual_set_meta(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(preset)
	runtime.KeepAlive(name)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PresetGetAppDir gets the directory for application specific presets if set by
// the application.
//
// The function returns the following values:
//
//   - filename (optional): directory or NULL, don't free or modify the string.
func PresetGetAppDir() string {
	var _cret *C.gchar // in

	_cret = C.gst_preset_get_app_dir()

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _filename
}

// PresetSetAppDir sets an extra directory as an absolute path that should be
// considered when looking for presets. Any presets in the application dir will
// shadow the system presets.
//
// The function takes the following parameters:
//
//   - appDir: application specific preset dir.
//
// The function returns the following values:
//
//   - ok: TRUE for success, FALSE if the dir already has been set.
func PresetSetAppDir(appDir string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(appDir)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_preset_set_app_dir(_arg1)
	runtime.KeepAlive(appDir)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TagSetterOverrider contains methods that are overridable.
type TagSetterOverrider interface {
}

// TagSetter: element interface that allows setting of media metadata.
//
// Elements that support changing a stream's metadata will implement this
// interface. Examples of such elements are 'vorbisenc', 'theoraenc' and
// 'id3v2mux'.
//
// If you just want to retrieve metadata in your application then all
// you need to do is watch for tag messages on your pipeline's bus.
// This interface is only for setting metadata, not for extracting it. To set
// tags from the application, find tagsetter elements and set tags using e.g.
// gst_tag_setter_merge_tags() or gst_tag_setter_add_tags(). Also consider
// setting the TagMergeMode that is used for tag events that arrive at the
// tagsetter element (default mode is to keep existing tags). The application
// should do that before the element goes to GST_STATE_PAUSED.
//
// Elements implementing the TagSetter interface often have to merge any tags
// received from upstream and the tags set by the application via the interface.
// This can be done like this:
//
//	GstTagMergeMode merge_mode;
//	const GstTagList *application_tags;
//	const GstTagList *event_tags;
//	GstTagSetter *tagsetter;
//	GstTagList *result;
//
//	tagsetter = GST_TAG_SETTER (element);
//
//	merge_mode = gst_tag_setter_get_tag_merge_mode (tagsetter);
//	application_tags = gst_tag_setter_get_tag_list (tagsetter);
//	event_tags = (const GstTagList *) element->event_tags;
//
//	GST_LOG_OBJECT (tagsetter, "merging tags, merge mode = d", merge_mode);
//	GST_LOG_OBJECT (tagsetter, "event tags: %" GST_PTR_FORMAT, event_tags);
//	GST_LOG_OBJECT (tagsetter, "set   tags: %" GST_PTR_FORMAT, application_tags);
//
//	result = gst_tag_list_merge (application_tags, event_tags, merge_mode);
//
//	GST_LOG_OBJECT (tagsetter, "final tags: %" GST_PTR_FORMAT, result);.
//
// TagSetter wraps an interface. This means the user can get the
// underlying type by calling Cast().
type TagSetter struct {
	_ [0]func() // equal guard
	Element
}

var (
	_ Elementer = (*TagSetter)(nil)
)

// TagSetterer describes TagSetter's interface methods.
type TagSetterer interface {
	coreglib.Objector

	// AddTagValue adds the given tag / GValue pair on the setter using the
	// given merge mode.
	AddTagValue(mode TagMergeMode, tag string, value *coreglib.Value)
	// TagList returns the current list of tags the setter uses.
	TagList() *TagList
	// TagMergeMode queries the mode by which tags inside the setter are
	// overwritten by tags from events.
	TagMergeMode() TagMergeMode
	// MergeTags merges the given list into the setter's list using the given
	// mode.
	MergeTags(list *TagList, mode TagMergeMode)
	// ResetTags: reset the internal taglist.
	ResetTags()
	// SetTagMergeMode sets the given merge mode that is used for adding tags
	// from events to tags specified by this interface.
	SetTagMergeMode(mode TagMergeMode)
}

var _ TagSetterer = (*TagSetter)(nil)

func ifaceInitTagSetterer(gifacePtr, data C.gpointer) {
}

func wrapTagSetter(obj *coreglib.Object) *TagSetter {
	return &TagSetter{
		Element: Element{
			GstObject: GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalTagSetter(p uintptr) (interface{}, error) {
	return wrapTagSetter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// AddTagValue adds the given tag / GValue pair on the setter using the given
// merge mode.
//
// The function takes the following parameters:
//
//   - mode to use.
//   - tag to set.
//   - value: GValue to set for the tag.
func (setter *TagSetter) AddTagValue(mode TagMergeMode, tag string, value *coreglib.Value) {
	var _arg0 *C.GstTagSetter   // out
	var _arg1 C.GstTagMergeMode // out
	var _arg2 *C.gchar          // out
	var _arg3 *C.GValue         // out

	_arg0 = (*C.GstTagSetter)(unsafe.Pointer(coreglib.InternObject(setter).Native()))
	_arg1 = C.GstTagMergeMode(mode)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gst_tag_setter_add_tag_value(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(setter)
	runtime.KeepAlive(mode)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(value)
}

// TagList returns the current list of tags the setter uses. The list should not
// be modified or freed.
//
// This function is not thread-safe.
//
// The function returns the following values:
//
//   - tagList (optional): current snapshot of the taglist used in the setter or
//     NULL if none is used.
func (setter *TagSetter) TagList() *TagList {
	var _arg0 *C.GstTagSetter // out
	var _cret *C.GstTagList   // in

	_arg0 = (*C.GstTagSetter)(unsafe.Pointer(coreglib.InternObject(setter).Native()))

	_cret = C.gst_tag_setter_get_tag_list(_arg0)
	runtime.KeepAlive(setter)

	var _tagList *TagList // out

	if _cret != nil {
		_tagList = (*TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _tagList
}

// TagMergeMode queries the mode by which tags inside the setter are overwritten
// by tags from events.
//
// The function returns the following values:
//
//   - tagMergeMode: merge mode used inside the element.
func (setter *TagSetter) TagMergeMode() TagMergeMode {
	var _arg0 *C.GstTagSetter   // out
	var _cret C.GstTagMergeMode // in

	_arg0 = (*C.GstTagSetter)(unsafe.Pointer(coreglib.InternObject(setter).Native()))

	_cret = C.gst_tag_setter_get_tag_merge_mode(_arg0)
	runtime.KeepAlive(setter)

	var _tagMergeMode TagMergeMode // out

	_tagMergeMode = TagMergeMode(_cret)

	return _tagMergeMode
}

// MergeTags merges the given list into the setter's list using the given mode.
//
// The function takes the following parameters:
//
//   - list: tag list to merge from.
//   - mode to merge with.
func (setter *TagSetter) MergeTags(list *TagList, mode TagMergeMode) {
	var _arg0 *C.GstTagSetter   // out
	var _arg1 *C.GstTagList     // out
	var _arg2 C.GstTagMergeMode // out

	_arg0 = (*C.GstTagSetter)(unsafe.Pointer(coreglib.InternObject(setter).Native()))
	_arg1 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg2 = C.GstTagMergeMode(mode)

	C.gst_tag_setter_merge_tags(_arg0, _arg1, _arg2)
	runtime.KeepAlive(setter)
	runtime.KeepAlive(list)
	runtime.KeepAlive(mode)
}

// ResetTags: reset the internal taglist. Elements should call this from within
// the state-change handler.
func (setter *TagSetter) ResetTags() {
	var _arg0 *C.GstTagSetter // out

	_arg0 = (*C.GstTagSetter)(unsafe.Pointer(coreglib.InternObject(setter).Native()))

	C.gst_tag_setter_reset_tags(_arg0)
	runtime.KeepAlive(setter)
}

// SetTagMergeMode sets the given merge mode that is used for adding tags from
// events to tags specified by this interface. The default is T_TAG_MERGE_KEEP,
// which keeps the tags set with this interface and discards tags from events.
//
// The function takes the following parameters:
//
//   - mode with which tags are added.
func (setter *TagSetter) SetTagMergeMode(mode TagMergeMode) {
	var _arg0 *C.GstTagSetter   // out
	var _arg1 C.GstTagMergeMode // out

	_arg0 = (*C.GstTagSetter)(unsafe.Pointer(coreglib.InternObject(setter).Native()))
	_arg1 = C.GstTagMergeMode(mode)

	C.gst_tag_setter_set_tag_merge_mode(_arg0, _arg1)
	runtime.KeepAlive(setter)
	runtime.KeepAlive(mode)
}

// TocSetterOverrider contains methods that are overridable.
type TocSetterOverrider interface {
}

// TocSetter: element interface that allows setting of the TOC.
//
// Elements that support some kind of chapters or editions (or tracks like in
// the FLAC cue sheet) will implement this interface.
//
// If you just want to retrieve the TOC in your application then all you need to
// do is watch for TOC messages on your pipeline's bus (or you can perform TOC
// query). This interface is only for setting TOC data, not for extracting it.
// To set TOC from the application, find proper tocsetter element and set TOC
// using gst_toc_setter_set_toc().
//
// Elements implementing the TocSetter interface can extend existing TOC by
// getting extend UID for that (you can use gst_toc_find_entry() to retrieve it)
// with any TOC entries received from downstream.
//
// TocSetter wraps an interface. This means the user can get the
// underlying type by calling Cast().
type TocSetter struct {
	_ [0]func() // equal guard
	Element
}

var (
	_ Elementer = (*TocSetter)(nil)
)

// TocSetterer describes TocSetter's interface methods.
type TocSetterer interface {
	coreglib.Objector

	// Toc: return current TOC the setter uses.
	Toc() *Toc
	// Reset the internal TOC.
	Reset()
	// SetToc: set the given TOC on the setter.
	SetToc(toc *Toc)
}

var _ TocSetterer = (*TocSetter)(nil)

func ifaceInitTocSetterer(gifacePtr, data C.gpointer) {
}

func wrapTocSetter(obj *coreglib.Object) *TocSetter {
	return &TocSetter{
		Element: Element{
			GstObject: GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalTocSetter(p uintptr) (interface{}, error) {
	return wrapTocSetter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Toc: return current TOC the setter uses. The TOC should not be modified
// without making it writable first.
//
// The function returns the following values:
//
//   - toc (optional): TOC set, or NULL. Unref with gst_toc_unref() when no
//     longer needed.
func (setter *TocSetter) Toc() *Toc {
	var _arg0 *C.GstTocSetter // out
	var _cret *C.GstToc       // in

	_arg0 = (*C.GstTocSetter)(unsafe.Pointer(coreglib.InternObject(setter).Native()))

	_cret = C.gst_toc_setter_get_toc(_arg0)
	runtime.KeepAlive(setter)

	var _toc *Toc // out

	if _cret != nil {
		_toc = (*Toc)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_toc)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _toc
}

// Reset the internal TOC. Elements should call this from within the
// state-change handler.
func (setter *TocSetter) Reset() {
	var _arg0 *C.GstTocSetter // out

	_arg0 = (*C.GstTocSetter)(unsafe.Pointer(coreglib.InternObject(setter).Native()))

	C.gst_toc_setter_reset(_arg0)
	runtime.KeepAlive(setter)
}

// SetToc: set the given TOC on the setter. Previously set TOC will be unreffed
// before setting a new one.
//
// The function takes the following parameters:
//
//   - toc (optional) to set.
func (setter *TocSetter) SetToc(toc *Toc) {
	var _arg0 *C.GstTocSetter // out
	var _arg1 *C.GstToc       // out

	_arg0 = (*C.GstTocSetter)(unsafe.Pointer(coreglib.InternObject(setter).Native()))
	if toc != nil {
		_arg1 = (*C.GstToc)(gextras.StructNative(unsafe.Pointer(toc)))
	}

	C.gst_toc_setter_set_toc(_arg0, _arg1)
	runtime.KeepAlive(setter)
	runtime.KeepAlive(toc)
}

// URIHandler is an interface that is implemented by Source and Sink Element to
// unify handling of URI.
//
// An application can use the following functions to quickly get an element that
// handles the given URI for reading or writing (gst_element_make_from_uri()).
//
// Source and Sink plugins should implement this interface when possible.
//
// URIHandler wraps an interface. This means the user can get the
// underlying type by calling Cast().
type URIHandler struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*URIHandler)(nil)
)

// URIHandlerer describes URIHandler's interface methods.
type URIHandlerer interface {
	coreglib.Objector

	// Protocols gets the list of protocols supported by handler.
	Protocols() []string
	// URI gets the currently handled URI.
	URI() string
	// URIType gets the type of the given URI handler.
	URIType() URIType
	// SetURI tries to set the URI of the given handler.
	SetURI(uri string) error
}

var _ URIHandlerer = (*URIHandler)(nil)

func wrapURIHandler(obj *coreglib.Object) *URIHandler {
	return &URIHandler{
		Object: obj,
	}
}

func marshalURIHandler(p uintptr) (interface{}, error) {
	return wrapURIHandler(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Protocols gets the list of protocols supported by handler. This list may not
// be modified.
//
// The function returns the following values:
//
//   - utf8s (optional): the supported protocols. Returns NULL if the handler
//     isn't implemented properly, or the handler doesn't support any protocols.
func (handler *URIHandler) Protocols() []string {
	var _arg0 *C.GstURIHandler // out
	var _cret **C.gchar        // in

	_arg0 = (*C.GstURIHandler)(unsafe.Pointer(coreglib.InternObject(handler).Native()))

	_cret = C.gst_uri_handler_get_protocols(_arg0)
	runtime.KeepAlive(handler)

	var _utf8s []string // out

	if _cret != nil {
		{
			var i int
			var z *C.gchar
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			}
		}
	}

	return _utf8s
}

// URI gets the currently handled URI.
//
// The function returns the following values:
//
//   - utf8 (optional): URI currently handled by the handler. Returns NULL if
//     there are no URI currently handled. The returned string must be freed
//     with g_free() when no longer needed.
func (handler *URIHandler) URI() string {
	var _arg0 *C.GstURIHandler // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GstURIHandler)(unsafe.Pointer(coreglib.InternObject(handler).Native()))

	_cret = C.gst_uri_handler_get_uri(_arg0)
	runtime.KeepAlive(handler)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// URIType gets the type of the given URI handler.
//
// The function returns the following values:
//
//   - uriType of the URI handler. Returns T_URI_UNKNOWN if the handler isn't
//     implemented correctly.
func (handler *URIHandler) URIType() URIType {
	var _arg0 *C.GstURIHandler // out
	var _cret C.GstURIType     // in

	_arg0 = (*C.GstURIHandler)(unsafe.Pointer(coreglib.InternObject(handler).Native()))

	_cret = C.gst_uri_handler_get_uri_type(_arg0)
	runtime.KeepAlive(handler)

	var _uriType URIType // out

	_uriType = URIType(_cret)

	return _uriType
}

// SetURI tries to set the URI of the given handler.
//
// The function takes the following parameters:
//
//   - uri: URI to set.
func (handler *URIHandler) SetURI(uri string) error {
	var _arg0 *C.GstURIHandler // out
	var _arg1 *C.gchar         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GstURIHandler)(unsafe.Pointer(coreglib.InternObject(handler).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_uri_handler_set_uri(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(handler)
	runtime.KeepAlive(uri)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// urI gets the currently handled URI.
//
// The function returns the following values:
//
//   - utf8 (optional): URI currently handled by the handler. Returns NULL if
//     there are no URI currently handled. The returned string must be freed
//     with g_free() when no longer needed.
func (handler *URIHandler) urI() string {
	gclass := (*C.GstURIHandlerInterface)(coreglib.PeekParentClass(handler))
	fnarg := gclass.get_uri

	var _arg0 *C.GstURIHandler // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GstURIHandler)(unsafe.Pointer(coreglib.InternObject(handler).Native()))

	_cret = C._gotk4_gst1_URIHandler_virtual_get_uri(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(handler)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// setURI tries to set the URI of the given handler.
//
// The function takes the following parameters:
//
//   - uri: URI to set.
func (handler *URIHandler) setURI(uri string) error {
	gclass := (*C.GstURIHandlerInterface)(coreglib.PeekParentClass(handler))
	fnarg := gclass.set_uri

	var _arg0 *C.GstURIHandler // out
	var _arg1 *C.gchar         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GstURIHandler)(unsafe.Pointer(coreglib.InternObject(handler).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gst1_URIHandler_virtual_set_uri(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(handler)
	runtime.KeepAlive(uri)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AllocatorOverrides contains methods that are overridable.
type AllocatorOverrides struct {
	// Alloc: use allocator to allocate a new memory block with memory that is
	// at least size big.
	//
	// The optional params can specify the prefix and padding for the memory.
	// If NULL is passed, no flags, no extra prefix/padding and a default
	// alignment is used.
	//
	// The prefix/padding will be filled with 0 if flags contains
	// T_MEMORY_FLAG_ZERO_PREFIXED and T_MEMORY_FLAG_ZERO_PADDED respectively.
	//
	// When allocator is NULL, the default allocator will be used.
	//
	// The alignment in params is given as a bitmask so that align + 1 equals
	// the amount of bytes to align to. For example, to align to 8 bytes,
	// use an alignment of 7.
	//
	// The function takes the following parameters:
	//
	//   - size of the visible memory area.
	//   - params (optional): optional parameters.
	//
	// The function returns the following values:
	//
	//   - memory (optional): new Memory.
	Alloc func(size uint, params *AllocationParams) *Memory
}

func defaultAllocatorOverrides(v *Allocator) AllocatorOverrides {
	return AllocatorOverrides{
		Alloc: v.alloc,
	}
}

// Allocator: memory is usually created by allocators with a
// gst_allocator_alloc() method call. When NULL is used as the allocator,
// the default allocator will be used.
//
// New allocators can be registered with gst_allocator_register(). Allocators
// are identified by name and can be retrieved with gst_allocator_find().
// gst_allocator_set_default() can be used to change the default allocator.
//
// New memory can be created with gst_memory_new_wrapped() that wraps the memory
// allocated elsewhere.
type Allocator struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*Allocator)(nil)
)

// Allocatorrer describes types inherited from class Allocator.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Allocatorrer interface {
	coreglib.Objector
	baseAllocator() *Allocator
}

var _ Allocatorrer = (*Allocator)(nil)

func init() {
	coreglib.RegisterClassInfo[*Allocator, *AllocatorClass, AllocatorOverrides](
		GTypeAllocator,
		initAllocatorClass,
		wrapAllocator,
		defaultAllocatorOverrides,
	)
}

func initAllocatorClass(gclass unsafe.Pointer, overrides AllocatorOverrides, classInitFunc func(*AllocatorClass)) {
	pclass := (*C.GstAllocatorClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAllocator))))

	if overrides.Alloc != nil {
		pclass.alloc = (*[0]byte)(C._gotk4_gst1_AllocatorClass_alloc)
	}

	if classInitFunc != nil {
		class := (*AllocatorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAllocator(obj *coreglib.Object) *Allocator {
	return &Allocator{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalAllocator(p uintptr) (interface{}, error) {
	return wrapAllocator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (allocator *Allocator) baseAllocator() *Allocator {
	return allocator
}

// BaseAllocator returns the underlying base object.
func BaseAllocator(obj Allocatorrer) *Allocator {
	return obj.baseAllocator()
}

// Alloc: use allocator to allocate a new memory block with memory that is at
// least size big.
//
// The optional params can specify the prefix and padding for the memory.
// If NULL is passed, no flags, no extra prefix/padding and a default alignment
// is used.
//
// The prefix/padding will be filled with 0 if flags contains
// T_MEMORY_FLAG_ZERO_PREFIXED and T_MEMORY_FLAG_ZERO_PADDED respectively.
//
// When allocator is NULL, the default allocator will be used.
//
// The alignment in params is given as a bitmask so that align + 1 equals
// the amount of bytes to align to. For example, to align to 8 bytes, use an
// alignment of 7.
//
// The function takes the following parameters:
//
//   - size of the visible memory area.
//   - params (optional): optional parameters.
//
// The function returns the following values:
//
//   - memory (optional): new Memory.
func (allocator *Allocator) Alloc(size uint, params *AllocationParams) *Memory {
	var _arg0 *C.GstAllocator        // out
	var _arg1 C.gsize                // out
	var _arg2 *C.GstAllocationParams // out
	var _cret *C.GstMemory           // in

	if allocator != nil {
		_arg0 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	}
	_arg1 = C.gsize(size)
	if params != nil {
		_arg2 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	_cret = C.gst_allocator_alloc(_arg0, _arg1, _arg2)
	runtime.KeepAlive(allocator)
	runtime.KeepAlive(size)
	runtime.KeepAlive(params)

	var _memory *Memory // out

	if _cret != nil {
		_memory = (*Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_memory)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _memory
}

// SetDefault: set the default allocator.
func (allocator *Allocator) SetDefault() {
	var _arg0 *C.GstAllocator // out

	_arg0 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(allocator).Native()))

	C.gst_allocator_set_default(_arg0)
	runtime.KeepAlive(allocator)
}

// Alloc: use allocator to allocate a new memory block with memory that is at
// least size big.
//
// The optional params can specify the prefix and padding for the memory.
// If NULL is passed, no flags, no extra prefix/padding and a default alignment
// is used.
//
// The prefix/padding will be filled with 0 if flags contains
// T_MEMORY_FLAG_ZERO_PREFIXED and T_MEMORY_FLAG_ZERO_PADDED respectively.
//
// When allocator is NULL, the default allocator will be used.
//
// The alignment in params is given as a bitmask so that align + 1 equals
// the amount of bytes to align to. For example, to align to 8 bytes, use an
// alignment of 7.
//
// The function takes the following parameters:
//
//   - size of the visible memory area.
//   - params (optional): optional parameters.
//
// The function returns the following values:
//
//   - memory (optional): new Memory.
func (allocator *Allocator) alloc(size uint, params *AllocationParams) *Memory {
	gclass := (*C.GstAllocatorClass)(coreglib.PeekParentClass(allocator))
	fnarg := gclass.alloc

	var _arg0 *C.GstAllocator        // out
	var _arg1 C.gsize                // out
	var _arg2 *C.GstAllocationParams // out
	var _cret *C.GstMemory           // in

	if allocator != nil {
		_arg0 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	}
	_arg1 = C.gsize(size)
	if params != nil {
		_arg2 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	_cret = C._gotk4_gst1_Allocator_virtual_alloc(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(allocator)
	runtime.KeepAlive(size)
	runtime.KeepAlive(params)

	var _memory *Memory // out

	if _cret != nil {
		_memory = (*Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_memory)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _memory
}

// AllocatorFind: find a previously registered allocator with name. When name is
// NULL, the default allocator will be returned.
//
// The function takes the following parameters:
//
//   - name (optional) of the allocator.
//
// The function returns the following values:
//
//   - allocator (optional) or NULL when the allocator with name was not
//     registered.
func AllocatorFind(name string) Allocatorrer {
	var _arg1 *C.gchar        // out
	var _cret *C.GstAllocator // in

	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_allocator_find(_arg1)
	runtime.KeepAlive(name)

	var _allocator Allocatorrer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Allocatorrer)
				return ok
			})
			rv, ok := casted.(Allocatorrer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Allocatorrer")
			}
			_allocator = rv
		}
	}

	return _allocator
}

// AllocatorRegister registers the memory allocator with name.
//
// The function takes the following parameters:
//
//   - name of the allocator.
//   - allocator: Allocator.
func AllocatorRegister(name string, allocator Allocatorrer) {
	var _arg1 *C.gchar        // out
	var _arg2 *C.GstAllocator // out

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(allocator).Native()))

	C.gst_allocator_register(_arg1, _arg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(allocator)
}

// BinOverrides contains methods that are overridable.
type BinOverrides struct {
	// AddElement: method to add an element to the bin.
	//
	// The function takes the following parameters:
	//
	//   - element to be added.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if the element was added.
	AddElement func(element Elementer) bool
	// DeepElementAdded: method called when an element was added somewhere in
	// the bin hierarchy.
	//
	// The function takes the following parameters:
	//
	//   - subBin to which the element was added.
	//   - child: element that was added.
	DeepElementAdded func(subBin *Bin, child Elementer)
	// DeepElementRemoved: method called when an element was removed somewhere
	// in the bin hierarchy.
	//
	// The function takes the following parameters:
	//
	//   - subBin from which the element was removed.
	//   - child: element that was removed.
	DeepElementRemoved func(subBin *Bin, child Elementer)
	DoLatency          func() bool
	// ElementAdded: method called when an element was added to the bin.
	//
	// The function takes the following parameters:
	//
	//   - child: element that was added.
	ElementAdded func(child Elementer)
	// ElementRemoved: method called when an element was removed from the bin.
	//
	// The function takes the following parameters:
	//
	//   - child: element that was removed.
	ElementRemoved func(child Elementer)
	// HandleMessage: method to handle a message from the children.
	//
	// The function takes the following parameters:
	//
	//   - message to be handled.
	HandleMessage func(message *Message)
	// RemoveElement: method to remove an element from the bin.
	//
	// The function takes the following parameters:
	//
	//   - element to be removed.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if the element was removed.
	RemoveElement func(element Elementer) bool
}

func defaultBinOverrides(v *Bin) BinOverrides {
	return BinOverrides{
		AddElement:         v.addElement,
		DeepElementAdded:   v.deepElementAdded,
		DeepElementRemoved: v.deepElementRemoved,
		DoLatency:          v.doLatency,
		ElementAdded:       v.elementAdded,
		ElementRemoved:     v.elementRemoved,
		HandleMessage:      v.handleMessage,
		RemoveElement:      v.removeElement,
	}
}

// Bin is an element that can contain other Element, allowing them to be
// managed as a group. Pads from the child elements can be ghosted to the bin,
// see GhostPad. This makes the bin look like any other elements and enables
// creation of higher-level abstraction elements.
//
// A new Bin is created with gst_bin_new(). Use a Pipeline instead if you want
// to create a toplevel bin because a normal bin doesn't have a bus or handle
// clock distribution of its own.
//
// After the bin has been created you will typically add elements to it with
// gst_bin_add(). You can remove elements with gst_bin_remove().
//
// An element can be retrieved from a bin with gst_bin_get_by_name(), using the
// elements name. gst_bin_get_by_name_recurse_up() is mainly used for internal
// purposes and will query the parent bins when the element is not found in the
// current bin.
//
// An iterator of elements in a bin can be retrieved with
// gst_bin_iterate_elements(). Various other iterators exist to retrieve the
// elements in a bin.
//
// gst_object_unref() is used to drop your reference to the bin.
//
// The Bin::element-added signal is fired whenever a new element is added to the
// bin. Likewise the Bin::element-removed signal is fired whenever an element is
// removed from the bin.
//
// A Bin internally intercepts every Message posted by its children and
// implements the following default behaviour for each of them:
//
// * GST_MESSAGE_EOS: This message is only posted by sinks in the PLAYING state.
// If all sinks posted the EOS message, this bin will post and EOS message
// upwards.
//
// * GST_MESSAGE_SEGMENT_START: Just collected and never forwarded upwards.
// The messages are used to decide when all elements have completed playback of
// their segment.
//
// * GST_MESSAGE_SEGMENT_DONE: Is posted by Bin when all elements that posted a
// SEGMENT_START have posted a SEGMENT_DONE.
//
// * GST_MESSAGE_DURATION_CHANGED: Is posted by an element that detected
// a change in the stream duration. The duration change is posted to the
// application so that it can refetch the new duration with a duration query.
//
//	Note that these messages can be posted before the bin is prerolled, in which
//	case the duration query might fail.
//
//	Note also that there might be a discrepancy (due to internal buffering/queueing)
//	between the stream being currently displayed and the returned duration query.
//
//	Applications might want to also query for duration (and changes) by
//	listening to the GST_MESSAGE_STREAM_START message, signaling the active start
//	of a (new) stream.
//
// * GST_MESSAGE_CLOCK_LOST: This message is posted by an element when it can no
// longer provide a clock.
//
//	The default bin behaviour is to check if the lost clock was the one provided
//	by the bin. If so and the bin is currently in the PLAYING state, the message
//	is forwarded to the bin parent.
//
//	This message is also generated when a clock provider is removed from
//	the bin. If this message is received by the application, it should
//	PAUSE the pipeline and set it back to PLAYING to force a new clock
//	distribution.
//
// * GST_MESSAGE_CLOCK_PROVIDE: This message is generated when an element can
// provide a clock. This mostly happens when a new clock provider is added to
// the bin.
//
//	The default behaviour of the bin is to mark the currently selected clock as
//	dirty, which will perform a clock recalculation the next time the bin is
//	asked to provide a clock.
//
//	This message is never sent to the application but is forwarded to
//	the parent of the bin.
//
// * OTHERS: posted upwards.
//
// A Bin implements the following default behaviour for answering to a Query:
//
// * GST_QUERY_DURATION: The bin will forward the query to all sink elements
// contained within and will return the maximum value. If no sinks are available
// in the bin, the query fails.
//
// * GST_QUERY_POSITION: The query is sent to all sink elements in the bin and
// the MAXIMUM of all values is returned. If no sinks are available in the bin,
// the query fails.
//
// * OTHERS: the query is forwarded to all sink elements, the result of the
// first sink that answers the query successfully is returned. If no sink is in
// the bin, the query fails.
//
// A Bin will by default forward any event sent to it to all sink (
// GST_EVENT_TYPE_UPSTREAM ) or source ( GST_EVENT_TYPE_DOWNSTREAM ) elements
// depending on the event type.
//
// If all the elements return TRUE, the bin will also return TRUE, else FALSE
// is returned. If no elements of the required type are in the bin, the event
// handler will return TRUE.
type Bin struct {
	_ [0]func() // equal guard
	Element

	ChildProxy
}

var (
	_ Elementer = (*Bin)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Bin, *BinClass, BinOverrides](
		GTypeBin,
		initBinClass,
		wrapBin,
		defaultBinOverrides,
	)
}

func initBinClass(gclass unsafe.Pointer, overrides BinOverrides, classInitFunc func(*BinClass)) {
	pclass := (*C.GstBinClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeBin))))

	if overrides.AddElement != nil {
		pclass.add_element = (*[0]byte)(C._gotk4_gst1_BinClass_add_element)
	}

	if overrides.DeepElementAdded != nil {
		pclass.deep_element_added = (*[0]byte)(C._gotk4_gst1_BinClass_deep_element_added)
	}

	if overrides.DeepElementRemoved != nil {
		pclass.deep_element_removed = (*[0]byte)(C._gotk4_gst1_BinClass_deep_element_removed)
	}

	if overrides.DoLatency != nil {
		pclass.do_latency = (*[0]byte)(C._gotk4_gst1_BinClass_do_latency)
	}

	if overrides.ElementAdded != nil {
		pclass.element_added = (*[0]byte)(C._gotk4_gst1_BinClass_element_added)
	}

	if overrides.ElementRemoved != nil {
		pclass.element_removed = (*[0]byte)(C._gotk4_gst1_BinClass_element_removed)
	}

	if overrides.HandleMessage != nil {
		pclass.handle_message = (*[0]byte)(C._gotk4_gst1_BinClass_handle_message)
	}

	if overrides.RemoveElement != nil {
		pclass.remove_element = (*[0]byte)(C._gotk4_gst1_BinClass_remove_element)
	}

	if classInitFunc != nil {
		class := (*BinClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapBin(obj *coreglib.Object) *Bin {
	return &Bin{
		Element: Element{
			GstObject: GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
		ChildProxy: ChildProxy{
			Object: obj,
		},
	}
}

func marshalBin(p uintptr) (interface{}, error) {
	return wrapBin(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectDeepElementAdded will be emitted after the element was added to
// sub_bin.
func (bin *Bin) ConnectDeepElementAdded(f func(subBin *Bin, element Elementer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(bin, "deep-element-added", false, unsafe.Pointer(C._gotk4_gst1_Bin_ConnectDeepElementAdded), f)
}

// ConnectDeepElementRemoved will be emitted after the element was removed from
// sub_bin.
func (bin *Bin) ConnectDeepElementRemoved(f func(subBin *Bin, element Elementer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(bin, "deep-element-removed", false, unsafe.Pointer(C._gotk4_gst1_Bin_ConnectDeepElementRemoved), f)
}

// ConnectDoLatency will be emitted when the bin needs to perform latency
// calculations. This signal is only emitted for toplevel bins or when
// Bin:async-handling is enabled.
//
// Only one signal handler is invoked. If no signals are connected, the default
// handler is invoked, which will query and distribute the lowest possible
// latency to all sinks.
//
// Connect to this signal if the default latency calculations are not
// sufficient, like when you need different latencies for different sinks in the
// same pipeline.
func (bin *Bin) ConnectDoLatency(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(bin, "do-latency", false, unsafe.Pointer(C._gotk4_gst1_Bin_ConnectDoLatency), f)
}

// ConnectElementAdded will be emitted after the element was added to the bin.
func (bin *Bin) ConnectElementAdded(f func(element Elementer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(bin, "element-added", false, unsafe.Pointer(C._gotk4_gst1_Bin_ConnectElementAdded), f)
}

// ConnectElementRemoved will be emitted after the element was removed from the
// bin.
func (bin *Bin) ConnectElementRemoved(f func(element Elementer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(bin, "element-removed", false, unsafe.Pointer(C._gotk4_gst1_Bin_ConnectElementRemoved), f)
}

// NewBin creates a new bin with the given name.
//
// The function takes the following parameters:
//
//   - name (optional) of the new bin.
//
// The function returns the following values:
//
//   - bin: new Bin.
func NewBin(name string) *Bin {
	var _arg1 *C.gchar      // out
	var _cret *C.GstElement // in

	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_bin_new(_arg1)
	runtime.KeepAlive(name)

	var _bin *Bin // out

	_bin = wrapBin(coreglib.Take(unsafe.Pointer(_cret)))

	return _bin
}

// Add adds the given element to the bin. Sets the element's parent, and thus
// takes ownership of the element. An element can only be added to one bin.
//
// If the element's pads are linked to other pads, the pads will be unlinked
// before the element is added to the bin.
//
// > When you add an element to an already-running pipeline, you will have to
// > take care to set the state of the newly-added element to the desired >
// state (usually PLAYING or PAUSED, same you set the pipeline to originally) >
// with gst_element_set_state(), or use gst_element_sync_state_with_parent().
// > The bin or pipeline will not take care of this for you.
//
// The function takes the following parameters:
//
//   - element to add.
//
// The function returns the following values:
//
//   - ok: TRUE if the element could be added, FALSE if the bin does not want to
//     accept the element.
func (bin *Bin) Add(element Elementer) bool {
	var _arg0 *C.GstBin     // out
	var _arg1 *C.GstElement // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_bin_add(_arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(element)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FindUnlinkedPad: recursively looks for elements with an unlinked pad of the
// given direction within the specified bin and returns an unlinked pad if one
// is found, or NULL otherwise. If a pad is found, the caller owns a reference
// to it and should use gst_object_unref() on the pad when it is not needed any
// longer.
//
// The function takes the following parameters:
//
//   - direction: whether to look for an unlinked source or sink pad.
//
// The function returns the following values:
//
//   - pad (optional): unlinked pad of the given direction.
func (bin *Bin) FindUnlinkedPad(direction PadDirection) *Pad {
	var _arg0 *C.GstBin         // out
	var _arg1 C.GstPadDirection // out
	var _cret *C.GstPad         // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = C.GstPadDirection(direction)

	_cret = C.gst_bin_find_unlinked_pad(_arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(direction)

	var _pad *Pad // out

	if _cret != nil {
		_pad = wrapPad(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pad
}

// ByInterface looks for an element inside the bin that implements the given
// interface. If such an element is found, it returns the element. You can cast
// this element to the given interface afterwards. If you want all elements
// that implement the interface, use gst_bin_iterate_all_by_interface().
// This function recurses into child bins.
//
// The function takes the following parameters:
//
//   - iface of an interface.
//
// The function returns the following values:
//
//   - element (optional) inside the bin implementing the interface.
func (bin *Bin) ByInterface(iface coreglib.Type) Elementer {
	var _arg0 *C.GstBin     // out
	var _arg1 C.GType       // out
	var _cret *C.GstElement // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = C.GType(iface)

	_cret = C.gst_bin_get_by_interface(_arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(iface)

	var _element Elementer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Elementer)
				return ok
			})
			rv, ok := casted.(Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_element = rv
		}
	}

	return _element
}

// ByName gets the element with the given name from a bin. This function
// recurses into child bins.
//
// The function takes the following parameters:
//
//   - name: element name to search for.
//
// The function returns the following values:
//
//   - element (optional) with the given name.
func (bin *Bin) ByName(name string) Elementer {
	var _arg0 *C.GstBin     // out
	var _arg1 *C.gchar      // out
	var _cret *C.GstElement // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_bin_get_by_name(_arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(name)

	var _element Elementer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Elementer)
				return ok
			})
			rv, ok := casted.(Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_element = rv
		}
	}

	return _element
}

// ByNameRecurseUp gets the element with the given name from this bin. If the
// element is not found, a recursion is performed on the parent bin.
//
// The function takes the following parameters:
//
//   - name: element name to search for.
//
// The function returns the following values:
//
//   - element (optional) with the given name.
func (bin *Bin) ByNameRecurseUp(name string) Elementer {
	var _arg0 *C.GstBin     // out
	var _arg1 *C.gchar      // out
	var _cret *C.GstElement // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_bin_get_by_name_recurse_up(_arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(name)

	var _element Elementer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Elementer)
				return ok
			})
			rv, ok := casted.(Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_element = rv
		}
	}

	return _element
}

// The function returns the following values:
//
//   - elementFlags bin's suppressed ElementFlags.
func (bin *Bin) SuppressedFlags() ElementFlags {
	var _arg0 *C.GstBin         // out
	var _cret C.GstElementFlags // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))

	_cret = C.gst_bin_get_suppressed_flags(_arg0)
	runtime.KeepAlive(bin)

	var _elementFlags ElementFlags // out

	_elementFlags = ElementFlags(_cret)

	return _elementFlags
}

// IterateAllByElementFactoryName looks for all elements inside the bin with
// the given element factory name. The function recurses inside child bins.
// The iterator will yield a series of Element.
//
// The function takes the following parameters:
//
//   - factoryName: name of the ElementFactory.
//
// The function returns the following values:
//
//   - iterator (optional) of Element for all elements in the bin with the given
//     element factory name.
func (bin *Bin) IterateAllByElementFactoryName(factoryName string) *Iterator {
	var _arg0 *C.GstBin      // out
	var _arg1 *C.gchar       // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(factoryName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_bin_iterate_all_by_element_factory_name(_arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(factoryName)

	var _iterator *Iterator // out

	if _cret != nil {
		_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_iterator)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_iterator_free((*C.GstIterator)(intern.C))
			},
		)
	}

	return _iterator
}

// IterateAllByInterface looks for all elements inside the bin that implements
// the given interface. You can safely cast all returned elements to the given
// interface. The function recurses inside child bins. The iterator will yield a
// series of Element.
//
// The function takes the following parameters:
//
//   - iface of an interface.
//
// The function returns the following values:
//
//   - iterator (optional) of Element for all elements in the bin implementing
//     the given interface.
func (bin *Bin) IterateAllByInterface(iface coreglib.Type) *Iterator {
	var _arg0 *C.GstBin      // out
	var _arg1 C.GType        // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = C.GType(iface)

	_cret = C.gst_bin_iterate_all_by_interface(_arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(iface)

	var _iterator *Iterator // out

	if _cret != nil {
		_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_iterator)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_iterator_free((*C.GstIterator)(intern.C))
			},
		)
	}

	return _iterator
}

// IterateElements gets an iterator for the elements in this bin.
//
// The function returns the following values:
//
//   - iterator (optional) of Element.
func (bin *Bin) IterateElements() *Iterator {
	var _arg0 *C.GstBin      // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))

	_cret = C.gst_bin_iterate_elements(_arg0)
	runtime.KeepAlive(bin)

	var _iterator *Iterator // out

	if _cret != nil {
		_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_iterator)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_iterator_free((*C.GstIterator)(intern.C))
			},
		)
	}

	return _iterator
}

// IterateRecurse gets an iterator for the elements in this bin. This iterator
// recurses into GstBin children.
//
// The function returns the following values:
//
//   - iterator (optional) of Element.
func (bin *Bin) IterateRecurse() *Iterator {
	var _arg0 *C.GstBin      // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))

	_cret = C.gst_bin_iterate_recurse(_arg0)
	runtime.KeepAlive(bin)

	var _iterator *Iterator // out

	if _cret != nil {
		_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_iterator)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_iterator_free((*C.GstIterator)(intern.C))
			},
		)
	}

	return _iterator
}

// IterateSinks gets an iterator for all elements in the bin that have the
// T_ELEMENT_FLAG_SINK flag set.
//
// The function returns the following values:
//
//   - iterator (optional) of Element.
func (bin *Bin) IterateSinks() *Iterator {
	var _arg0 *C.GstBin      // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))

	_cret = C.gst_bin_iterate_sinks(_arg0)
	runtime.KeepAlive(bin)

	var _iterator *Iterator // out

	if _cret != nil {
		_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_iterator)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_iterator_free((*C.GstIterator)(intern.C))
			},
		)
	}

	return _iterator
}

// IterateSorted gets an iterator for the elements in this bin in topologically
// sorted order. This means that the elements are returned from the most
// downstream elements (sinks) to the sources.
//
// This function is used internally to perform the state changes of the bin
// elements and for clock selection.
//
// The function returns the following values:
//
//   - iterator (optional) of Element.
func (bin *Bin) IterateSorted() *Iterator {
	var _arg0 *C.GstBin      // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))

	_cret = C.gst_bin_iterate_sorted(_arg0)
	runtime.KeepAlive(bin)

	var _iterator *Iterator // out

	if _cret != nil {
		_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_iterator)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_iterator_free((*C.GstIterator)(intern.C))
			},
		)
	}

	return _iterator
}

// IterateSources gets an iterator for all elements in the bin that have the
// T_ELEMENT_FLAG_SOURCE flag set.
//
// The function returns the following values:
//
//   - iterator (optional) of Element.
func (bin *Bin) IterateSources() *Iterator {
	var _arg0 *C.GstBin      // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))

	_cret = C.gst_bin_iterate_sources(_arg0)
	runtime.KeepAlive(bin)

	var _iterator *Iterator // out

	if _cret != nil {
		_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_iterator)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_iterator_free((*C.GstIterator)(intern.C))
			},
		)
	}

	return _iterator
}

// RecalculateLatency queries bin for the current latency and reconfigures this
// latency on all the elements using a LATENCY event.
//
// This method is typically called on the pipeline when a T_MESSAGE_LATENCY is
// posted on the bus.
//
// This function simply emits the Bin::do-latency signal so any custom latency
// calculations will be performed.
//
// The function returns the following values:
//
//   - ok: TRUE if the latency could be queried and reconfigured.
func (bin *Bin) RecalculateLatency() bool {
	var _arg0 *C.GstBin  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))

	_cret = C.gst_bin_recalculate_latency(_arg0)
	runtime.KeepAlive(bin)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Remove removes the element from the bin, unparenting it as well. Unparenting
// the element means that the element will be dereferenced, so if the bin holds
// the only reference to the element, the element will be freed in the process
// of removing it from the bin. If you want the element to still exist after
// removing, you need to call gst_object_ref() before removing it from the bin.
//
// If the element's pads are linked to other pads, the pads will be unlinked
// before the element is removed from the bin.
//
// The function takes the following parameters:
//
//   - element to remove.
//
// The function returns the following values:
//
//   - ok: TRUE if the element could be removed, FALSE if the bin does not want
//     to remove the element.
func (bin *Bin) Remove(element Elementer) bool {
	var _arg0 *C.GstBin     // out
	var _arg1 *C.GstElement // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_bin_remove(_arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(element)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSuppressedFlags suppresses the given flags on the bin. ElementFlags of a
// child element are propagated when it is added to the bin. When suppressed
// flags are set, those specified flags will not be propagated to the bin.
//
// The function takes the following parameters:
//
//   - flags to suppress.
func (bin *Bin) SetSuppressedFlags(flags ElementFlags) {
	var _arg0 *C.GstBin         // out
	var _arg1 C.GstElementFlags // out

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = C.GstElementFlags(flags)

	C.gst_bin_set_suppressed_flags(_arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(flags)
}

// SyncChildrenStates synchronizes the state of every child of bin with the
// state of bin. See also gst_element_sync_state_with_parent().
//
// The function returns the following values:
//
//   - ok: TRUE if syncing the state was successful for all children, otherwise
//     FALSE.
func (bin *Bin) SyncChildrenStates() bool {
	var _arg0 *C.GstBin  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))

	_cret = C.gst_bin_sync_children_states(_arg0)
	runtime.KeepAlive(bin)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// addElement: method to add an element to the bin.
//
// The function takes the following parameters:
//
//   - element to be added.
//
// The function returns the following values:
//
//   - ok: TRUE if the element was added.
func (bin *Bin) addElement(element Elementer) bool {
	gclass := (*C.GstBinClass)(coreglib.PeekParentClass(bin))
	fnarg := gclass.add_element

	var _arg0 *C.GstBin     // out
	var _arg1 *C.GstElement // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C._gotk4_gst1_Bin_virtual_add_element(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(element)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// deepElementAdded: method called when an element was added somewhere in the
// bin hierarchy.
//
// The function takes the following parameters:
//
//   - subBin to which the element was added.
//   - child: element that was added.
func (bin *Bin) deepElementAdded(subBin *Bin, child Elementer) {
	gclass := (*C.GstBinClass)(coreglib.PeekParentClass(bin))
	fnarg := gclass.deep_element_added

	var _arg0 *C.GstBin     // out
	var _arg1 *C.GstBin     // out
	var _arg2 *C.GstElement // out

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(subBin).Native()))
	_arg2 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C._gotk4_gst1_Bin_virtual_deep_element_added(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(subBin)
	runtime.KeepAlive(child)
}

// deepElementRemoved: method called when an element was removed somewhere in
// the bin hierarchy.
//
// The function takes the following parameters:
//
//   - subBin from which the element was removed.
//   - child: element that was removed.
func (bin *Bin) deepElementRemoved(subBin *Bin, child Elementer) {
	gclass := (*C.GstBinClass)(coreglib.PeekParentClass(bin))
	fnarg := gclass.deep_element_removed

	var _arg0 *C.GstBin     // out
	var _arg1 *C.GstBin     // out
	var _arg2 *C.GstElement // out

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(subBin).Native()))
	_arg2 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C._gotk4_gst1_Bin_virtual_deep_element_removed(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(subBin)
	runtime.KeepAlive(child)
}

func (bin *Bin) doLatency() bool {
	gclass := (*C.GstBinClass)(coreglib.PeekParentClass(bin))
	fnarg := gclass.do_latency

	var _arg0 *C.GstBin  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))

	_cret = C._gotk4_gst1_Bin_virtual_do_latency(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(bin)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// elementAdded: method called when an element was added to the bin.
//
// The function takes the following parameters:
//
//   - child: element that was added.
func (bin *Bin) elementAdded(child Elementer) {
	gclass := (*C.GstBinClass)(coreglib.PeekParentClass(bin))
	fnarg := gclass.element_added

	var _arg0 *C.GstBin     // out
	var _arg1 *C.GstElement // out

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C._gotk4_gst1_Bin_virtual_element_added(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(child)
}

// elementRemoved: method called when an element was removed from the bin.
//
// The function takes the following parameters:
//
//   - child: element that was removed.
func (bin *Bin) elementRemoved(child Elementer) {
	gclass := (*C.GstBinClass)(coreglib.PeekParentClass(bin))
	fnarg := gclass.element_removed

	var _arg0 *C.GstBin     // out
	var _arg1 *C.GstElement // out

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C._gotk4_gst1_Bin_virtual_element_removed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(child)
}

// handleMessage: method to handle a message from the children.
//
// The function takes the following parameters:
//
//   - message to be handled.
func (bin *Bin) handleMessage(message *Message) {
	gclass := (*C.GstBinClass)(coreglib.PeekParentClass(bin))
	fnarg := gclass.handle_message

	var _arg0 *C.GstBin     // out
	var _arg1 *C.GstMessage // out

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(message)), nil)

	C._gotk4_gst1_Bin_virtual_handle_message(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(message)
}

// removeElement: method to remove an element from the bin.
//
// The function takes the following parameters:
//
//   - element to be removed.
//
// The function returns the following values:
//
//   - ok: TRUE if the element was removed.
func (bin *Bin) removeElement(element Elementer) bool {
	gclass := (*C.GstBinClass)(coreglib.PeekParentClass(bin))
	fnarg := gclass.remove_element

	var _arg0 *C.GstBin     // out
	var _arg1 *C.GstElement // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBin)(unsafe.Pointer(coreglib.InternObject(bin).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C._gotk4_gst1_Bin_virtual_remove_element(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(element)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Bitmask: fundamental type that describes a 64-bit bitmask.
type Bitmask struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Bitmask)(nil)
)

func wrapBitmask(obj *coreglib.Object) *Bitmask {
	return &Bitmask{
		Object: obj,
	}
}

func marshalBitmask(p uintptr) (interface{}, error) {
	return wrapBitmask(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// BufferPoolOverrides contains methods that are overridable.
type BufferPoolOverrides struct {
	// AcquireBuffer acquires a buffer from pool. buffer should point to a
	// memory location that can hold a pointer to the new buffer. When the pool
	// is empty, this function will by default block until a buffer is released
	// into the pool again or when the pool is set to flushing or deactivated.
	//
	// params can contain optional parameters to influence the allocation.
	//
	// The function takes the following parameters:
	//
	//   - params (optional): parameters.
	//
	// The function returns the following values:
	//
	//   - buffer (optional): location for a Buffer.
	//   - flowReturn such as GST_FLOW_FLUSHING when the pool is inactive.
	AcquireBuffer func(params *BufferPoolAcquireParams) (*Buffer, FlowReturn)
	// AllocBuffer: allocate a buffer. the default implementation allocates
	// buffers from the configured memory allocator and with the configured
	// parameters. All metadata that is present on the allocated buffer will
	// be marked as T_META_FLAG_POOLED and T_META_FLAG_LOCKED and will not be
	// removed from the buffer in BufferPoolClass::reset_buffer. The buffer
	// should have the T_BUFFER_FLAG_TAG_MEMORY cleared.
	//
	// The function takes the following parameters:
	//
	//   - params (optional): parameters.
	//
	// The function returns the following values:
	//
	//   - buffer (optional): location for a Buffer.
	//   - flowReturn to indicate whether the allocation was successful.
	AllocBuffer func(params *BufferPoolAcquireParams) (*Buffer, FlowReturn)
	// FlushStart: enter the flushing state.
	FlushStart func()
	// FlushStop: leave the flushing state.
	FlushStop func()
	// FreeBuffer: free a buffer. The default implementation unrefs the buffer.
	//
	// The function takes the following parameters:
	//
	//   - buffer to free.
	FreeBuffer func(buffer *Buffer)
	// Options gets a NULL terminated array of string with supported
	// bufferpool options for pool. An option would typically be enabled with
	// gst_buffer_pool_config_add_option().
	//
	// The function returns the following values:
	//
	//   - utf8s: NULL terminated array of strings.
	Options func() []string
	// ReleaseBuffer releases buffer to pool. buffer should have previously been
	// allocated from pool with gst_buffer_pool_acquire_buffer().
	//
	// This function is usually called automatically when the last ref on buffer
	// disappears.
	//
	// The function takes the following parameters:
	//
	//   - buffer: Buffer.
	ReleaseBuffer func(buffer *Buffer)
	// ResetBuffer: reset the buffer to its state when it was freshly allocated.
	// The default implementation will clear the flags, timestamps and will
	// remove the metadata without the T_META_FLAG_POOLED flag (even the
	// metadata with T_META_FLAG_LOCKED). If the T_BUFFER_FLAG_TAG_MEMORY was
	// set, this function can also try to restore the memory and clear the
	// T_BUFFER_FLAG_TAG_MEMORY again.
	//
	// The function takes the following parameters:
	//
	//   - buffer to reset.
	ResetBuffer func(buffer *Buffer)
	// SetConfig sets the configuration of the pool. If the pool is already
	// configured, and the configuration hasn't changed, this function will
	// return TRUE. If the pool is active, this method will return FALSE and
	// active configuration will remain. Buffers allocated from this pool must
	// be returned or else this function will do nothing and return FALSE.
	//
	// config is a Structure that contains the configuration parameters
	// for the pool. A default and mandatory set of parameters can
	// be configured with gst_buffer_pool_config_set_params(),
	// gst_buffer_pool_config_set_allocator() and
	// gst_buffer_pool_config_add_option().
	//
	// If the parameters in config can not be set exactly, this function returns
	// FALSE and will try to update as much state as possible. The new state can
	// then be retrieved and refined with gst_buffer_pool_get_config().
	//
	// This function takes ownership of config.
	//
	// The function takes the following parameters:
	//
	//   - config: Structure.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE when the configuration could be set.
	SetConfig func(config *Structure) bool
	// Start the bufferpool. The default implementation will preallocate
	// min-buffers buffers and put them in the queue.
	//
	// The function returns the following values:
	//
	//   - ok: whether the pool could be started.
	Start func() bool
	// Stop the bufferpool. the default implementation will free the
	// preallocated buffers. This function is called when all the buffers are
	// returned to the pool.
	//
	// The function returns the following values:
	//
	//   - ok: whether the pool could be stopped.
	Stop func() bool
}

func defaultBufferPoolOverrides(v *BufferPool) BufferPoolOverrides {
	return BufferPoolOverrides{
		AcquireBuffer: v.acquireBuffer,
		AllocBuffer:   v.allocBuffer,
		FlushStart:    v.flushStart,
		FlushStop:     v.flushStop,
		FreeBuffer:    v.freeBuffer,
		Options:       v.options,
		ReleaseBuffer: v.releaseBuffer,
		ResetBuffer:   v.resetBuffer,
		SetConfig:     v.setConfig,
		Start:         v.start,
		Stop:          v.stop,
	}
}

// BufferPool is an object that can be used to pre-allocate and recycle buffers
// of the same size and with the same properties.
//
// A BufferPool is created with gst_buffer_pool_new().
//
// Once a pool is created, it needs to be configured. A call to
// gst_buffer_pool_get_config() returns the current configuration
// structure from the pool. With gst_buffer_pool_config_set_params() and
// gst_buffer_pool_config_set_allocator() the bufferpool parameters and
// allocator can be configured. Other properties can be configured in the pool
// depending on the pool implementation.
//
// A bufferpool can have extra options that can be enabled with
// gst_buffer_pool_config_add_option(). The available options can be retrieved
// with gst_buffer_pool_get_options(). Some options allow for additional
// configuration properties to be set.
//
// After the configuration structure has been configured,
// gst_buffer_pool_set_config() updates the configuration in the pool. This can
// fail when the configuration structure is not accepted.
//
// After the pool has been configured, it can be activated with
// gst_buffer_pool_set_active(). This will preallocate the configured resources
// in the pool.
//
// When the pool is active, gst_buffer_pool_acquire_buffer() can be used to
// retrieve a buffer from the pool.
//
// Buffers allocated from a bufferpool will automatically be returned to the
// pool with gst_buffer_pool_release_buffer() when their refcount drops to 0.
//
// The bufferpool can be deactivated again with gst_buffer_pool_set_active().
// All further gst_buffer_pool_acquire_buffer() calls will return an error.
// When all buffers are returned to the pool they will be freed.
type BufferPool struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*BufferPool)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*BufferPool, *BufferPoolClass, BufferPoolOverrides](
		GTypeBufferPool,
		initBufferPoolClass,
		wrapBufferPool,
		defaultBufferPoolOverrides,
	)
}

func initBufferPoolClass(gclass unsafe.Pointer, overrides BufferPoolOverrides, classInitFunc func(*BufferPoolClass)) {
	pclass := (*C.GstBufferPoolClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeBufferPool))))

	if overrides.AcquireBuffer != nil {
		pclass.acquire_buffer = (*[0]byte)(C._gotk4_gst1_BufferPoolClass_acquire_buffer)
	}

	if overrides.AllocBuffer != nil {
		pclass.alloc_buffer = (*[0]byte)(C._gotk4_gst1_BufferPoolClass_alloc_buffer)
	}

	if overrides.FlushStart != nil {
		pclass.flush_start = (*[0]byte)(C._gotk4_gst1_BufferPoolClass_flush_start)
	}

	if overrides.FlushStop != nil {
		pclass.flush_stop = (*[0]byte)(C._gotk4_gst1_BufferPoolClass_flush_stop)
	}

	if overrides.FreeBuffer != nil {
		pclass.free_buffer = (*[0]byte)(C._gotk4_gst1_BufferPoolClass_free_buffer)
	}

	if overrides.Options != nil {
		pclass.get_options = (*[0]byte)(C._gotk4_gst1_BufferPoolClass_get_options)
	}

	if overrides.ReleaseBuffer != nil {
		pclass.release_buffer = (*[0]byte)(C._gotk4_gst1_BufferPoolClass_release_buffer)
	}

	if overrides.ResetBuffer != nil {
		pclass.reset_buffer = (*[0]byte)(C._gotk4_gst1_BufferPoolClass_reset_buffer)
	}

	if overrides.SetConfig != nil {
		pclass.set_config = (*[0]byte)(C._gotk4_gst1_BufferPoolClass_set_config)
	}

	if overrides.Start != nil {
		pclass.start = (*[0]byte)(C._gotk4_gst1_BufferPoolClass_start)
	}

	if overrides.Stop != nil {
		pclass.stop = (*[0]byte)(C._gotk4_gst1_BufferPoolClass_stop)
	}

	if classInitFunc != nil {
		class := (*BufferPoolClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapBufferPool(obj *coreglib.Object) *BufferPool {
	return &BufferPool{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalBufferPool(p uintptr) (interface{}, error) {
	return wrapBufferPool(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewBufferPool creates a new BufferPool instance.
//
// The function returns the following values:
//
//   - bufferPool: new BufferPool instance.
func NewBufferPool() *BufferPool {
	var _cret *C.GstBufferPool // in

	_cret = C.gst_buffer_pool_new()

	var _bufferPool *BufferPool // out

	_bufferPool = wrapBufferPool(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _bufferPool
}

// AcquireBuffer acquires a buffer from pool. buffer should point to a memory
// location that can hold a pointer to the new buffer. When the pool is empty,
// this function will by default block until a buffer is released into the pool
// again or when the pool is set to flushing or deactivated.
//
// params can contain optional parameters to influence the allocation.
//
// The function takes the following parameters:
//
//   - params (optional): parameters.
//
// The function returns the following values:
//
//   - buffer (optional): location for a Buffer.
//   - flowReturn such as GST_FLOW_FLUSHING when the pool is inactive.
func (pool *BufferPool) AcquireBuffer(params *BufferPoolAcquireParams) (*Buffer, FlowReturn) {
	var _arg0 *C.GstBufferPool              // out
	var _arg1 *C.GstBuffer                  // in
	var _arg2 *C.GstBufferPoolAcquireParams // out
	var _cret C.GstFlowReturn               // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	if params != nil {
		_arg2 = (*C.GstBufferPoolAcquireParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	_cret = C.gst_buffer_pool_acquire_buffer(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(params)

	var _buffer *Buffer        // out
	var _flowReturn FlowReturn // out

	if _arg1 != nil {
		_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_buffer)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}
	_flowReturn = FlowReturn(_cret)

	return _buffer, _flowReturn
}

// Config gets a copy of the current configuration of the pool. This
// configuration can be modified and used for the gst_buffer_pool_set_config()
// call.
//
// The function returns the following values:
//
//   - structure: copy of the current configuration of pool.
func (pool *BufferPool) Config() *Structure {
	var _arg0 *C.GstBufferPool // out
	var _cret *C.GstStructure  // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))

	_cret = C.gst_buffer_pool_get_config(_arg0)
	runtime.KeepAlive(pool)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_structure)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_structure_free((*C.GstStructure)(intern.C))
		},
	)

	return _structure
}

// Options gets a NULL terminated array of string with supported
// bufferpool options for pool. An option would typically be enabled with
// gst_buffer_pool_config_add_option().
//
// The function returns the following values:
//
//   - utf8s: NULL terminated array of strings.
func (pool *BufferPool) Options() []string {
	var _arg0 *C.GstBufferPool // out
	var _cret **C.gchar        // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))

	_cret = C.gst_buffer_pool_get_options(_arg0)
	runtime.KeepAlive(pool)

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// HasOption checks if the bufferpool supports option.
//
// The function takes the following parameters:
//
//   - option: option.
//
// The function returns the following values:
//
//   - ok: TRUE if the buffer pool contains option.
func (pool *BufferPool) HasOption(option string) bool {
	var _arg0 *C.GstBufferPool // out
	var _arg1 *C.gchar         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(option)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_buffer_pool_has_option(_arg0, _arg1)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(option)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsActive checks if pool is active. A pool can be activated with the
// gst_buffer_pool_set_active() call.
//
// The function returns the following values:
//
//   - ok: TRUE when the pool is active.
func (pool *BufferPool) IsActive() bool {
	var _arg0 *C.GstBufferPool // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))

	_cret = C.gst_buffer_pool_is_active(_arg0)
	runtime.KeepAlive(pool)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReleaseBuffer releases buffer to pool. buffer should have previously been
// allocated from pool with gst_buffer_pool_acquire_buffer().
//
// This function is usually called automatically when the last ref on buffer
// disappears.
//
// The function takes the following parameters:
//
//   - buffer: Buffer.
func (pool *BufferPool) ReleaseBuffer(buffer *Buffer) {
	var _arg0 *C.GstBufferPool // out
	var _arg1 *C.GstBuffer     // out

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	C.gst_buffer_pool_release_buffer(_arg0, _arg1)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(buffer)
}

// SetActive controls the active state of pool. When the pool is inactive, new
// calls to gst_buffer_pool_acquire_buffer() will return with GST_FLOW_FLUSHING.
//
// Activating the bufferpool will preallocate all resources in the pool based on
// the configuration of the pool.
//
// Deactivating will free the resources again when there are no outstanding
// buffers. When there are outstanding buffers, they will be freed as soon as
// they are all returned to the pool.
//
// The function takes the following parameters:
//
//   - active: new active state.
//
// The function returns the following values:
//
//   - ok: FALSE when the pool was not configured or when preallocation of the
//     buffers failed.
func (pool *BufferPool) SetActive(active bool) bool {
	var _arg0 *C.GstBufferPool // out
	var _arg1 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	if active {
		_arg1 = C.TRUE
	}

	_cret = C.gst_buffer_pool_set_active(_arg0, _arg1)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(active)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetConfig sets the configuration of the pool. If the pool is already
// configured, and the configuration hasn't changed, this function will return
// TRUE. If the pool is active, this method will return FALSE and active
// configuration will remain. Buffers allocated from this pool must be returned
// or else this function will do nothing and return FALSE.
//
// config is a Structure that contains the configuration parameters for the
// pool. A default and mandatory set of parameters can be configured with
// gst_buffer_pool_config_set_params(), gst_buffer_pool_config_set_allocator()
// and gst_buffer_pool_config_add_option().
//
// If the parameters in config can not be set exactly, this function returns
// FALSE and will try to update as much state as possible. The new state can
// then be retrieved and refined with gst_buffer_pool_get_config().
//
// This function takes ownership of config.
//
// The function takes the following parameters:
//
//   - config: Structure.
//
// The function returns the following values:
//
//   - ok: TRUE when the configuration could be set.
func (pool *BufferPool) SetConfig(config *Structure) bool {
	var _arg0 *C.GstBufferPool // out
	var _arg1 *C.GstStructure  // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(config)), nil)

	_cret = C.gst_buffer_pool_set_config(_arg0, _arg1)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(config)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetFlushing enables or disables the flushing state of a pool without freeing
// or allocating buffers.
//
// The function takes the following parameters:
//
//   - flushing: whether to start or stop flushing.
func (pool *BufferPool) SetFlushing(flushing bool) {
	var _arg0 *C.GstBufferPool // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	if flushing {
		_arg1 = C.TRUE
	}

	C.gst_buffer_pool_set_flushing(_arg0, _arg1)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(flushing)
}

// acquireBuffer acquires a buffer from pool. buffer should point to a memory
// location that can hold a pointer to the new buffer. When the pool is empty,
// this function will by default block until a buffer is released into the pool
// again or when the pool is set to flushing or deactivated.
//
// params can contain optional parameters to influence the allocation.
//
// The function takes the following parameters:
//
//   - params (optional): parameters.
//
// The function returns the following values:
//
//   - buffer (optional): location for a Buffer.
//   - flowReturn such as GST_FLOW_FLUSHING when the pool is inactive.
func (pool *BufferPool) acquireBuffer(params *BufferPoolAcquireParams) (*Buffer, FlowReturn) {
	gclass := (*C.GstBufferPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.acquire_buffer

	var _arg0 *C.GstBufferPool              // out
	var _arg1 *C.GstBuffer                  // in
	var _arg2 *C.GstBufferPoolAcquireParams // out
	var _cret C.GstFlowReturn               // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	if params != nil {
		_arg2 = (*C.GstBufferPoolAcquireParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	_cret = C._gotk4_gst1_BufferPool_virtual_acquire_buffer(unsafe.Pointer(fnarg), _arg0, &_arg1, _arg2)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(params)

	var _buffer *Buffer        // out
	var _flowReturn FlowReturn // out

	if _arg1 != nil {
		_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_buffer)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}
	_flowReturn = FlowReturn(_cret)

	return _buffer, _flowReturn
}

// allocBuffer: allocate a buffer. the default implementation allocates buffers
// from the configured memory allocator and with the configured parameters.
// All metadata that is present on the allocated buffer will be marked as
// T_META_FLAG_POOLED and T_META_FLAG_LOCKED and will not be removed from
// the buffer in BufferPoolClass::reset_buffer. The buffer should have the
// T_BUFFER_FLAG_TAG_MEMORY cleared.
//
// The function takes the following parameters:
//
//   - params (optional): parameters.
//
// The function returns the following values:
//
//   - buffer (optional): location for a Buffer.
//   - flowReturn to indicate whether the allocation was successful.
func (pool *BufferPool) allocBuffer(params *BufferPoolAcquireParams) (*Buffer, FlowReturn) {
	gclass := (*C.GstBufferPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.alloc_buffer

	var _arg0 *C.GstBufferPool              // out
	var _arg1 *C.GstBuffer                  // in
	var _arg2 *C.GstBufferPoolAcquireParams // out
	var _cret C.GstFlowReturn               // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	if params != nil {
		_arg2 = (*C.GstBufferPoolAcquireParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	_cret = C._gotk4_gst1_BufferPool_virtual_alloc_buffer(unsafe.Pointer(fnarg), _arg0, &_arg1, _arg2)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(params)

	var _buffer *Buffer        // out
	var _flowReturn FlowReturn // out

	if _arg1 != nil {
		_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_buffer)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}
	_flowReturn = FlowReturn(_cret)

	return _buffer, _flowReturn
}

// flushStart: enter the flushing state.
func (pool *BufferPool) flushStart() {
	gclass := (*C.GstBufferPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.flush_start

	var _arg0 *C.GstBufferPool // out

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))

	C._gotk4_gst1_BufferPool_virtual_flush_start(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(pool)
}

// flushStop: leave the flushing state.
func (pool *BufferPool) flushStop() {
	gclass := (*C.GstBufferPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.flush_stop

	var _arg0 *C.GstBufferPool // out

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))

	C._gotk4_gst1_BufferPool_virtual_flush_stop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(pool)
}

// freeBuffer: free a buffer. The default implementation unrefs the buffer.
//
// The function takes the following parameters:
//
//   - buffer to free.
func (pool *BufferPool) freeBuffer(buffer *Buffer) {
	gclass := (*C.GstBufferPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.free_buffer

	var _arg0 *C.GstBufferPool // out
	var _arg1 *C.GstBuffer     // out

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	C._gotk4_gst1_BufferPool_virtual_free_buffer(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(buffer)
}

// Options gets a NULL terminated array of string with supported
// bufferpool options for pool. An option would typically be enabled with
// gst_buffer_pool_config_add_option().
//
// The function returns the following values:
//
//   - utf8s: NULL terminated array of strings.
func (pool *BufferPool) options() []string {
	gclass := (*C.GstBufferPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.get_options

	var _arg0 *C.GstBufferPool // out
	var _cret **C.gchar        // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))

	_cret = C._gotk4_gst1_BufferPool_virtual_get_options(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(pool)

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// releaseBuffer releases buffer to pool. buffer should have previously been
// allocated from pool with gst_buffer_pool_acquire_buffer().
//
// This function is usually called automatically when the last ref on buffer
// disappears.
//
// The function takes the following parameters:
//
//   - buffer: Buffer.
func (pool *BufferPool) releaseBuffer(buffer *Buffer) {
	gclass := (*C.GstBufferPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.release_buffer

	var _arg0 *C.GstBufferPool // out
	var _arg1 *C.GstBuffer     // out

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	C._gotk4_gst1_BufferPool_virtual_release_buffer(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(buffer)
}

// resetBuffer: reset the buffer to its state when it was freshly allocated.
// The default implementation will clear the flags, timestamps and will remove
// the metadata without the T_META_FLAG_POOLED flag (even the metadata with
// T_META_FLAG_LOCKED). If the T_BUFFER_FLAG_TAG_MEMORY was set, this function
// can also try to restore the memory and clear the T_BUFFER_FLAG_TAG_MEMORY
// again.
//
// The function takes the following parameters:
//
//   - buffer to reset.
func (pool *BufferPool) resetBuffer(buffer *Buffer) {
	gclass := (*C.GstBufferPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.reset_buffer

	var _arg0 *C.GstBufferPool // out
	var _arg1 *C.GstBuffer     // out

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	C._gotk4_gst1_BufferPool_virtual_reset_buffer(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(buffer)
}

// setConfig sets the configuration of the pool. If the pool is already
// configured, and the configuration hasn't changed, this function will return
// TRUE. If the pool is active, this method will return FALSE and active
// configuration will remain. Buffers allocated from this pool must be returned
// or else this function will do nothing and return FALSE.
//
// config is a Structure that contains the configuration parameters for the
// pool. A default and mandatory set of parameters can be configured with
// gst_buffer_pool_config_set_params(), gst_buffer_pool_config_set_allocator()
// and gst_buffer_pool_config_add_option().
//
// If the parameters in config can not be set exactly, this function returns
// FALSE and will try to update as much state as possible. The new state can
// then be retrieved and refined with gst_buffer_pool_get_config().
//
// This function takes ownership of config.
//
// The function takes the following parameters:
//
//   - config: Structure.
//
// The function returns the following values:
//
//   - ok: TRUE when the configuration could be set.
func (pool *BufferPool) setConfig(config *Structure) bool {
	gclass := (*C.GstBufferPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.set_config

	var _arg0 *C.GstBufferPool // out
	var _arg1 *C.GstStructure  // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(config)), nil)

	_cret = C._gotk4_gst1_BufferPool_virtual_set_config(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(config)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Start: start the bufferpool. The default implementation will preallocate
// min-buffers buffers and put them in the queue.
//
// The function returns the following values:
//
//   - ok: whether the pool could be started.
func (pool *BufferPool) start() bool {
	gclass := (*C.GstBufferPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.start

	var _arg0 *C.GstBufferPool // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))

	_cret = C._gotk4_gst1_BufferPool_virtual_start(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(pool)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Stop: stop the bufferpool. the default implementation will free the
// preallocated buffers. This function is called when all the buffers are
// returned to the pool.
//
// The function returns the following values:
//
//   - ok: whether the pool could be stopped.
func (pool *BufferPool) stop() bool {
	gclass := (*C.GstBufferPoolClass)(coreglib.PeekParentClass(pool))
	fnarg := gclass.stop

	var _arg0 *C.GstBufferPool // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))

	_cret = C._gotk4_gst1_BufferPool_virtual_stop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(pool)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BufferPoolConfigAddOption enables the option in config. This will instruct
// the bufferpool to enable the specified option on the buffers that it
// allocates.
//
// The options supported by pool can be retrieved with
// gst_buffer_pool_get_options().
//
// The function takes the following parameters:
//
//   - config: BufferPool configuration.
//   - option to add.
func BufferPoolConfigAddOption(config *Structure, option string) {
	var _arg1 *C.GstStructure // out
	var _arg2 *C.gchar        // out

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(option)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gst_buffer_pool_config_add_option(_arg1, _arg2)
	runtime.KeepAlive(config)
	runtime.KeepAlive(option)
}

// BufferPoolConfigGetAllocator gets the allocator and params from config.
//
// The function takes the following parameters:
//
//   - config: BufferPool configuration.
//
// The function returns the following values:
//
//   - allocator (optional) or NULL.
//   - params (optional) or NULL.
//   - ok: TRUE, if the values are set.
func BufferPoolConfigGetAllocator(config *Structure) (Allocatorrer, *AllocationParams, bool) {
	var _arg1 *C.GstStructure       // out
	var _arg2 *C.GstAllocator       // in
	var _arg3 C.GstAllocationParams // in
	var _cret C.gboolean            // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))

	_cret = C.gst_buffer_pool_config_get_allocator(_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(config)

	var _allocator Allocatorrer   // out
	var _params *AllocationParams // out
	var _ok bool                  // out

	if _arg2 != nil {
		{
			objptr := unsafe.Pointer(_arg2)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Allocatorrer)
				return ok
			})
			rv, ok := casted.(Allocatorrer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Allocatorrer")
			}
			_allocator = rv
		}
	}
	_params = (*AllocationParams)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))
	if _cret != 0 {
		_ok = true
	}

	return _allocator, _params, _ok
}

// BufferPoolConfigGetOption parses an available config and gets the option at
// index of the options API array.
//
// The function takes the following parameters:
//
//   - config: BufferPool configuration.
//   - index: position in the option array to read.
//
// The function returns the following values:
//
//   - utf8 (optional): option at index.
func BufferPoolConfigGetOption(config *Structure, index uint) string {
	var _arg1 *C.GstStructure // out
	var _arg2 C.guint         // out
	var _cret *C.gchar        // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	_arg2 = C.guint(index)

	_cret = C.gst_buffer_pool_config_get_option(_arg1, _arg2)
	runtime.KeepAlive(config)
	runtime.KeepAlive(index)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// BufferPoolConfigGetParams gets the configuration values from config.
//
// The function takes the following parameters:
//
//   - config: BufferPool configuration.
//
// The function returns the following values:
//
//   - caps (optional) of buffers.
//   - size (optional) of each buffer, not including prefix and padding.
//   - minBuffers (optional): minimum amount of buffers to allocate.
//   - maxBuffers (optional): maximum amount of buffers to allocate or 0 for
//     unlimited.
//   - ok: TRUE if all parameters could be fetched.
func BufferPoolConfigGetParams(config *Structure) (caps *Caps, size, minBuffers, maxBuffers uint, ok bool) {
	var _arg1 *C.GstStructure // out
	var _arg2 *C.GstCaps      // in
	var _arg3 C.guint         // in
	var _arg4 C.guint         // in
	var _arg5 C.guint         // in
	var _cret C.gboolean      // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))

	_cret = C.gst_buffer_pool_config_get_params(_arg1, &_arg2, &_arg3, &_arg4, &_arg5)
	runtime.KeepAlive(config)

	var _caps *Caps      // out
	var _size uint       // out
	var _minBuffers uint // out
	var _maxBuffers uint // out
	var _ok bool         // out

	if _arg2 != nil {
		_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
	}
	_size = uint(_arg3)
	_minBuffers = uint(_arg4)
	_maxBuffers = uint(_arg5)
	if _cret != 0 {
		_ok = true
	}

	return _caps, _size, _minBuffers, _maxBuffers, _ok
}

// BufferPoolConfigHasOption checks if config contains option.
//
// The function takes the following parameters:
//
//   - config: BufferPool configuration.
//   - option: option.
//
// The function returns the following values:
//
//   - ok: TRUE if the options array contains option.
func BufferPoolConfigHasOption(config *Structure, option string) bool {
	var _arg1 *C.GstStructure // out
	var _arg2 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(option)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_buffer_pool_config_has_option(_arg1, _arg2)
	runtime.KeepAlive(config)
	runtime.KeepAlive(option)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BufferPoolConfigNOptions retrieves the number of values currently stored in
// the options array of the config structure.
//
// The function takes the following parameters:
//
//   - config: BufferPool configuration.
//
// The function returns the following values:
//
//   - guint options array size as a #guint.
func BufferPoolConfigNOptions(config *Structure) uint {
	var _arg1 *C.GstStructure // out
	var _cret C.guint         // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))

	_cret = C.gst_buffer_pool_config_n_options(_arg1)
	runtime.KeepAlive(config)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// BufferPoolConfigSetAllocator sets the allocator and params on config.
//
// One of allocator and params can be NULL, but not both. When allocator is
// NULL, the default allocator of the pool will use the values in param to
// perform its allocation. When param is NULL, the pool will use the provided
// allocator with its default AllocationParams.
//
// A call to gst_buffer_pool_set_config() can update the allocator and params
// with the values that it is able to do. Some pools are, for example, not able
// to operate with different allocators or cannot allocate with the values
// specified in params. Use gst_buffer_pool_get_config() to get the currently
// used values.
//
// The function takes the following parameters:
//
//   - config: BufferPool configuration.
//   - allocator (optional): Allocator.
//   - params (optional): AllocationParams.
func BufferPoolConfigSetAllocator(config *Structure, allocator Allocatorrer, params *AllocationParams) {
	var _arg1 *C.GstStructure        // out
	var _arg2 *C.GstAllocator        // out
	var _arg3 *C.GstAllocationParams // out

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	if allocator != nil {
		_arg2 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	}
	if params != nil {
		_arg3 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	C.gst_buffer_pool_config_set_allocator(_arg1, _arg2, _arg3)
	runtime.KeepAlive(config)
	runtime.KeepAlive(allocator)
	runtime.KeepAlive(params)
}

// BufferPoolConfigSetParams configures config with the given parameters.
//
// The function takes the following parameters:
//
//   - config: BufferPool configuration.
//   - caps (optional) for the buffers.
//   - size of each buffer, not including prefix and padding.
//   - minBuffers: minimum amount of buffers to allocate.
//   - maxBuffers: maximum amount of buffers to allocate or 0 for unlimited.
func BufferPoolConfigSetParams(config *Structure, caps *Caps, size, minBuffers, maxBuffers uint) {
	var _arg1 *C.GstStructure // out
	var _arg2 *C.GstCaps      // out
	var _arg3 C.guint         // out
	var _arg4 C.guint         // out
	var _arg5 C.guint         // out

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	if caps != nil {
		_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}
	_arg3 = C.guint(size)
	_arg4 = C.guint(minBuffers)
	_arg5 = C.guint(maxBuffers)

	C.gst_buffer_pool_config_set_params(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(config)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(size)
	runtime.KeepAlive(minBuffers)
	runtime.KeepAlive(maxBuffers)
}

// BufferPoolConfigValidateParams validates that changes made to config are
// still valid in the context of the expected parameters. This function is a
// helper that can be used to validate changes made by a pool to a config when
// gst_buffer_pool_set_config() returns FALSE. This expects that caps haven't
// changed and that min_buffers aren't lower then what we initially expected.
// This does not check if options or allocator parameters are still valid,
// won't check if size have changed, since changing the size is valid to adapt
// padding.
//
// The function takes the following parameters:
//
//   - config: BufferPool configuration.
//   - caps (optional): excepted caps of buffers.
//   - size: expected size of each buffer, not including prefix and padding.
//   - minBuffers: expected minimum amount of buffers to allocate.
//   - maxBuffers: expect maximum amount of buffers to allocate or 0 for
//     unlimited.
//
// The function returns the following values:
//
//   - ok: TRUE, if the parameters are valid in this context.
func BufferPoolConfigValidateParams(config *Structure, caps *Caps, size, minBuffers, maxBuffers uint) bool {
	var _arg1 *C.GstStructure // out
	var _arg2 *C.GstCaps      // out
	var _arg3 C.guint         // out
	var _arg4 C.guint         // out
	var _arg5 C.guint         // out
	var _cret C.gboolean      // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	if caps != nil {
		_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}
	_arg3 = C.guint(size)
	_arg4 = C.guint(minBuffers)
	_arg5 = C.guint(maxBuffers)

	_cret = C.gst_buffer_pool_config_validate_params(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(config)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(size)
	runtime.KeepAlive(minBuffers)
	runtime.KeepAlive(maxBuffers)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BusOverrides contains methods that are overridable.
type BusOverrides struct {
	// Message: message has been posted on the bus.
	//
	// The function takes the following parameters:
	//
	//   - message that has been posted asynchronously.
	Message func(message *Message)
	// SyncMessage: message has been posted on the bus.
	//
	// The function takes the following parameters:
	//
	//   - message that has been posted synchronously.
	SyncMessage func(message *Message)
}

func defaultBusOverrides(v *Bus) BusOverrides {
	return BusOverrides{
		Message:     v.message,
		SyncMessage: v.syncMessage,
	}
}

// Bus is an object responsible for delivering Message packets in a first-in
// first-out way from the streaming threads (see Task) to the application.
//
// Since the application typically only wants to deal with delivery of these
// messages from one thread, the GstBus will marshall the messages between
// different threads. This is important since the actual streaming of media is
// done in another thread than the application.
//
// The GstBus provides support for #GSource based notifications. This makes it
// possible to handle the delivery in the glib Loop.
//
// The #GSource callback function gst_bus_async_signal_func() can be used to
// convert all bus messages into signal emissions.
//
// A message is posted on the bus with the gst_bus_post() method. With the
// gst_bus_peek() and gst_bus_pop() methods one can look at or retrieve a
// previously posted message.
//
// The bus can be polled with the gst_bus_poll() method. This methods blocks
// up to the specified timeout value until one of the specified messages
// types is posted on the bus. The application can then gst_bus_pop() the
// messages from the bus to handle them. Alternatively the application can
// register an asynchronous bus function using gst_bus_add_watch_full() or
// gst_bus_add_watch(). This function will install a #GSource in the default
// glib main loop and will deliver messages a short while after they have been
// posted. Note that the main loop should be running for the asynchronous
// callbacks.
//
// It is also possible to get messages from the bus without any thread
// marshalling with the gst_bus_set_sync_handler() method. This makes it
// possible to react to a message in the same thread that posted the message
// on the bus. This should only be used if the application is able to deal with
// messages from different threads.
//
// Every Pipeline has one bus.
//
// Note that a Pipeline will set its bus into flushing state when changing from
// READY to NULL state.
type Bus struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*Bus)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Bus, *BusClass, BusOverrides](
		GTypeBus,
		initBusClass,
		wrapBus,
		defaultBusOverrides,
	)
}

func initBusClass(gclass unsafe.Pointer, overrides BusOverrides, classInitFunc func(*BusClass)) {
	pclass := (*C.GstBusClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeBus))))

	if overrides.Message != nil {
		pclass.message = (*[0]byte)(C._gotk4_gst1_BusClass_message)
	}

	if overrides.SyncMessage != nil {
		pclass.sync_message = (*[0]byte)(C._gotk4_gst1_BusClass_sync_message)
	}

	if classInitFunc != nil {
		class := (*BusClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapBus(obj *coreglib.Object) *Bus {
	return &Bus{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalBus(p uintptr) (interface{}, error) {
	return wrapBus(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectMessage has been posted on the bus. This signal is emitted from a
// #GSource added to the mainloop. this signal will only be emitted when there
// is a Loop running.
func (bus *Bus) ConnectMessage(f func(message *Message)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(bus, "message", false, unsafe.Pointer(C._gotk4_gst1_Bus_ConnectMessage), f)
}

// ConnectSyncMessage: message has been posted on the bus. This signal is
// emitted from the thread that posted the message so one has to be careful with
// locking.
//
// This signal will not be emitted by default, you have to call
// gst_bus_enable_sync_message_emission() before.
func (bus *Bus) ConnectSyncMessage(f func(message *Message)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(bus, "sync-message", false, unsafe.Pointer(C._gotk4_gst1_Bus_ConnectSyncMessage), f)
}

// NewBus creates a new Bus instance.
//
// The function returns the following values:
//
//   - bus: new Bus instance.
func NewBus() *Bus {
	var _cret *C.GstBus // in

	_cret = C.gst_bus_new()

	var _bus *Bus // out

	_bus = wrapBus(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _bus
}

// AddSignalWatch adds a bus signal watch to the default main context with
// the default priority ( G_PRIORITY_DEFAULT ). It is also possible to use a
// non-default main context set up using g_main_context_push_thread_default()
// (before one had to create a bus watch source and attach it to the desired
// main context 'manually').
//
// After calling this statement, the bus will emit the "message" signal for each
// message posted on the bus.
//
// This function may be called multiple times. To clean up, the caller is
// responsible for calling gst_bus_remove_signal_watch() as many times as this
// function is called.
func (bus *Bus) AddSignalWatch() {
	var _arg0 *C.GstBus // out

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))

	C.gst_bus_add_signal_watch(_arg0)
	runtime.KeepAlive(bus)
}

// AddSignalWatchFull adds a bus signal watch to the default main context with
// the given priority (e.g. G_PRIORITY_DEFAULT). It is also possible to use a
// non-default main context set up using g_main_context_push_thread_default()
// (before one had to create a bus watch source and attach it to the desired
// main context 'manually').
//
// After calling this statement, the bus will emit the "message" signal for each
// message posted on the bus when the Loop is running.
//
// This function may be called multiple times. To clean up, the caller is
// responsible for calling gst_bus_remove_signal_watch() as many times as this
// function is called.
//
// There can only be a single bus watch per bus, you must remove any signal
// watch before you can set another type of watch.
//
// The function takes the following parameters:
//
//   - priority of the watch.
func (bus *Bus) AddSignalWatchFull(priority int) {
	var _arg0 *C.GstBus // out
	var _arg1 C.gint    // out

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	_arg1 = C.gint(priority)

	C.gst_bus_add_signal_watch_full(_arg0, _arg1)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(priority)
}

// AddWatch adds a bus watch to the default main context with the given priority
// (e.g. G_PRIORITY_DEFAULT). It is also possible to use a non-default main
// context set up using g_main_context_push_thread_default() (before one had
// to create a bus watch source and attach it to the desired main context
// 'manually').
//
// This function is used to receive asynchronous messages in the main loop.
// There can only be a single bus watch per bus, you must remove it before you
// can set a new one.
//
// The bus watch will only work if a Loop is being run.
//
// When func is called, the message belongs to the caller; if you want to keep a
// copy of it, call gst_message_ref() before leaving func.
//
// The watch can be removed using gst_bus_remove_watch() or by returning FALSE
// from func. If the watch was added to the default main context it is also
// possible to remove the watch using g_source_remove().
//
// The bus watch will take its own reference to the bus, so it is safe to unref
// bus using gst_object_unref() after setting the bus watch.
//
// The function takes the following parameters:
//
//   - priority of the watch.
//   - fn: function to call when a message is received.
//
// The function returns the following values:
//
//   - guint: event source id or 0 if bus already got an event source.
func (bus *Bus) AddWatch(priority int, fn BusFunc) uint {
	var _arg0 *C.GstBus    // out
	var _arg1 C.gint       // out
	var _arg2 C.GstBusFunc // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify
	var _cret C.guint // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	_arg1 = C.gint(priority)
	_arg2 = (*[0]byte)(C._gotk4_gst1_BusFunc)
	_arg3 = C.gpointer(gbox.Assign(fn))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.gst_bus_add_watch_full(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(priority)
	runtime.KeepAlive(fn)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// AsyncSignalFunc: helper BusFunc that can be used to convert all asynchronous
// messages into signals.
//
// The function takes the following parameters:
//
//   - message: Message received.
//   - data (optional): user data.
//
// The function returns the following values:
//
//   - ok: TRUE.
func (bus *Bus) AsyncSignalFunc(message *Message, data unsafe.Pointer) bool {
	var _arg0 *C.GstBus     // out
	var _arg1 *C.GstMessage // out
	var _arg2 C.gpointer    // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg2 = (C.gpointer)(unsafe.Pointer(data))

	_cret = C.gst_bus_async_signal_func(_arg0, _arg1, _arg2)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(message)
	runtime.KeepAlive(data)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CreateWatch: create watch for this bus. The #GSource will be dispatched
// whenever a message is on the bus. After the GSource is dispatched, the
// message is popped off the bus and unreffed.
//
// As with other watches, there can only be one watch on the bus, including any
// signal watch added with #gst_bus_add_signal_watch.
//
// The function returns the following values:
//
//   - source (optional) that can be added to a Loop.
func (bus *Bus) CreateWatch() *glib.Source {
	var _arg0 *C.GstBus  // out
	var _cret *C.GSource // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))

	_cret = C.gst_bus_create_watch(_arg0)
	runtime.KeepAlive(bus)

	var _source *glib.Source // out

	if _cret != nil {
		_source = (*glib.Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_source)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_source_unref((*C.GSource)(intern.C))
			},
		)
	}

	return _source
}

// DisableSyncMessageEmission instructs GStreamer to stop
// emitting the "sync-message" signal for this bus. See
// gst_bus_enable_sync_message_emission() for more information.
//
// In the event that multiple pieces of code have called
// gst_bus_enable_sync_message_emission(), the sync-message emissions will
// only be stopped after all calls to gst_bus_enable_sync_message_emission()
// were "cancelled" by calling this function. In this way the semantics are
// exactly the same as gst_object_ref() that which calls enable should also call
// disable.
func (bus *Bus) DisableSyncMessageEmission() {
	var _arg0 *C.GstBus // out

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))

	C.gst_bus_disable_sync_message_emission(_arg0)
	runtime.KeepAlive(bus)
}

// EnableSyncMessageEmission instructs GStreamer to emit the "sync-message"
// signal after running the bus's sync handler. This function is here so that
// code can ensure that they can synchronously receive messages without having
// to affect what the bin's sync handler is.
//
// This function may be called multiple times. To clean up, the caller is
// responsible for calling gst_bus_disable_sync_message_emission() as many times
// as this function is called.
//
// While this function looks similar to gst_bus_add_signal_watch(), it is not
// exactly the same -- this function enables *synchronous* emission of signals
// when messages arrive; gst_bus_add_signal_watch() adds an idle callback to pop
// messages off the bus *asynchronously*. The sync-message signal comes from
// the thread of whatever object posted the message; the "message" signal is
// marshalled to the main thread via the Loop.
func (bus *Bus) EnableSyncMessageEmission() {
	var _arg0 *C.GstBus // out

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))

	C.gst_bus_enable_sync_message_emission(_arg0)
	runtime.KeepAlive(bus)
}

// HavePending checks if there are pending messages on the bus that should be
// handled.
//
// The function returns the following values:
//
//   - ok: TRUE if there are messages on the bus to be handled, FALSE otherwise.
func (bus *Bus) HavePending() bool {
	var _arg0 *C.GstBus  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))

	_cret = C.gst_bus_have_pending(_arg0)
	runtime.KeepAlive(bus)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Peek peeks the message on the top of the bus' queue. The message will remain
// on the bus' message queue.
//
// The function returns the following values:
//
//   - message (optional) that is on the bus, or NULL if the bus is empty.
func (bus *Bus) Peek() *Message {
	var _arg0 *C.GstBus     // out
	var _cret *C.GstMessage // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))

	_cret = C.gst_bus_peek(_arg0)
	runtime.KeepAlive(bus)

	var _message *Message // out

	if _cret != nil {
		_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_message)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _message
}

// Poll polls the bus for messages. Will block while waiting for messages to
// come. You can specify a maximum time to poll with the timeout parameter.
// If timeout is negative, this function will block indefinitely.
//
// All messages not in events will be popped off the bus and will be ignored.
// It is not possible to use message enums beyond T_MESSAGE_EXTENDED in the
// events mask
//
// Because poll is implemented using the "message" signal enabled by
// gst_bus_add_signal_watch(), calling gst_bus_poll() will cause the "message"
// signal to be emitted for every message that poll sees. Thus a "message"
// signal handler will see the same messages that this function sees -- neither
// will steal messages from the other.
//
// This function will run a Loop from the default main context when polling.
//
// You should never use this function, since it is pure evil. This is especially
// true for GUI applications based on Gtk+ or Qt, but also for any other
// non-trivial application that uses the GLib main loop. As this function runs
// a GLib main loop, any callback attached to the default GLib main context
// may be invoked. This could be timeouts, GUI events, I/O events etc.;
// even if gst_bus_poll() is called with a 0 timeout. Any of these callbacks
// may do things you do not expect, e.g. destroy the main application window
// or some other resource; change other application state; display a dialog
// and run another main loop until the user clicks it away. In short, using
// this function may add a lot of complexity to your code through unexpected
// re-entrancy and unexpected changes to your application's state.
//
// For 0 timeouts use gst_bus_pop_filtered() instead of this function; for other
// short timeouts use gst_bus_timed_pop_filtered(); everything else is better
// handled by setting up an asynchronous bus watch and doing things from there.
//
// The function takes the following parameters:
//
//   - events: mask of MessageType, representing the set of message types to
//     poll for (note special handling of extended message types below).
//   - timeout: poll timeout, as a ClockTime, or T_CLOCK_TIME_NONE to poll
//     indefinitely.
//
// The function returns the following values:
//
//   - message (optional) that was received, or NULL if the poll timed out.
func (bus *Bus) Poll(events MessageType, timeout ClockTime) *Message {
	var _arg0 *C.GstBus        // out
	var _arg1 C.GstMessageType // out
	var _arg2 C.GstClockTime   // out
	var _cret *C.GstMessage    // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	_arg1 = C.GstMessageType(events)
	_arg2 = C.GstClockTime(timeout)

	_cret = C.gst_bus_poll(_arg0, _arg1, _arg2)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(events)
	runtime.KeepAlive(timeout)

	var _message *Message // out

	if _cret != nil {
		_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_message)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _message
}

// Pop gets a message from the bus.
//
// The function returns the following values:
//
//   - message (optional) that is on the bus, or NULL if the bus is empty.
func (bus *Bus) Pop() *Message {
	var _arg0 *C.GstBus     // out
	var _cret *C.GstMessage // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))

	_cret = C.gst_bus_pop(_arg0)
	runtime.KeepAlive(bus)

	var _message *Message // out

	if _cret != nil {
		_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_message)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _message
}

// PopFiltered gets a message matching type from the bus. Will discard all
// messages on the bus that do not match type and that have been posted before
// the first message that does match type. If there is no message matching type
// on the bus, all messages will be discarded. It is not possible to use message
// enums beyond T_MESSAGE_EXTENDED in the events mask.
//
// The function takes the following parameters:
//
//   - types: message types to take into account.
//
// The function returns the following values:
//
//   - message (optional): next Message matching type that is on the bus,
//     or NULL if the bus is empty or there is no message matching type.
func (bus *Bus) PopFiltered(types MessageType) *Message {
	var _arg0 *C.GstBus        // out
	var _arg1 C.GstMessageType // out
	var _cret *C.GstMessage    // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	_arg1 = C.GstMessageType(types)

	_cret = C.gst_bus_pop_filtered(_arg0, _arg1)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(types)

	var _message *Message // out

	if _cret != nil {
		_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_message)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _message
}

// Post posts a message on the given bus. Ownership of the message is taken by
// the bus.
//
// The function takes the following parameters:
//
//   - message to post.
//
// The function returns the following values:
//
//   - ok: TRUE if the message could be posted, FALSE if the bus is flushing.
func (bus *Bus) Post(message *Message) bool {
	var _arg0 *C.GstBus     // out
	var _arg1 *C.GstMessage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(message)), nil)

	_cret = C.gst_bus_post(_arg0, _arg1)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(message)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveSignalWatch removes a signal watch previously added with
// gst_bus_add_signal_watch().
func (bus *Bus) RemoveSignalWatch() {
	var _arg0 *C.GstBus // out

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))

	C.gst_bus_remove_signal_watch(_arg0)
	runtime.KeepAlive(bus)
}

// RemoveWatch removes an installed bus watch from bus.
//
// The function returns the following values:
//
//   - ok: TRUE on success or FALSE if bus has no event source.
func (bus *Bus) RemoveWatch() bool {
	var _arg0 *C.GstBus  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))

	_cret = C.gst_bus_remove_watch(_arg0)
	runtime.KeepAlive(bus)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetFlushing: if flushing, flushes out and unrefs any messages queued in the
// bus. Releases references to the message origin objects. Will flush future
// messages until gst_bus_set_flushing() sets flushing to FALSE.
//
// The function takes the following parameters:
//
//   - flushing: whether or not to flush the bus.
func (bus *Bus) SetFlushing(flushing bool) {
	var _arg0 *C.GstBus  // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	if flushing {
		_arg1 = C.TRUE
	}

	C.gst_bus_set_flushing(_arg0, _arg1)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(flushing)
}

// SetSyncHandler sets the synchronous handler on the bus. The function will
// be called every time a new message is posted on the bus. Note that the
// function will be called in the same thread context as the posting object.
// This function is usually only called by the creator of the bus. Applications
// should handle messages asynchronously using the gst_bus watch and poll
// functions.
//
// Before 1.16.3 it was not possible to replace an existing handler and clearing
// an existing handler with NULL was not thread-safe.
//
// The function takes the following parameters:
//
//   - fn (optional): handler function to install.
func (bus *Bus) SetSyncHandler(fn BusSyncHandler) {
	var _arg0 *C.GstBus           // out
	var _arg1 C.GstBusSyncHandler // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	if fn != nil {
		_arg1 = (*[0]byte)(C._gotk4_gst1_BusSyncHandler)
		_arg2 = C.gpointer(gbox.Assign(fn))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gst_bus_set_sync_handler(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(fn)
}

// SyncSignalHandler: helper BusSyncHandler that can be used to convert all
// synchronous messages into signals.
//
// The function takes the following parameters:
//
//   - message: Message received.
//   - data (optional): user data.
//
// The function returns the following values:
//
//   - busSyncReply: GST_BUS_PASS.
func (bus *Bus) SyncSignalHandler(message *Message, data unsafe.Pointer) BusSyncReply {
	var _arg0 *C.GstBus         // out
	var _arg1 *C.GstMessage     // out
	var _arg2 C.gpointer        // out
	var _cret C.GstBusSyncReply // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg2 = (C.gpointer)(unsafe.Pointer(data))

	_cret = C.gst_bus_sync_signal_handler(_arg0, _arg1, _arg2)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(message)
	runtime.KeepAlive(data)

	var _busSyncReply BusSyncReply // out

	_busSyncReply = BusSyncReply(_cret)

	return _busSyncReply
}

// TimedPop gets a message from the bus, waiting up to the specified timeout.
//
// If timeout is 0, this function behaves like gst_bus_pop(). If timeout is
// T_CLOCK_TIME_NONE, this function will block forever until a message was
// posted on the bus.
//
// The function takes the following parameters:
//
//   - timeout: timeout.
//
// The function returns the following values:
//
//   - message (optional) that is on the bus after the specified timeout or NULL
//     if the bus is empty after the timeout expired.
func (bus *Bus) TimedPop(timeout ClockTime) *Message {
	var _arg0 *C.GstBus      // out
	var _arg1 C.GstClockTime // out
	var _cret *C.GstMessage  // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	_arg1 = C.GstClockTime(timeout)

	_cret = C.gst_bus_timed_pop(_arg0, _arg1)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(timeout)

	var _message *Message // out

	if _cret != nil {
		_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_message)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _message
}

// TimedPopFiltered gets a message from the bus whose type matches the message
// type mask types, waiting up to the specified timeout (and discarding any
// messages that do not match the mask provided).
//
// If timeout is 0, this function behaves like gst_bus_pop_filtered().
// If timeout is T_CLOCK_TIME_NONE, this function will block forever until a
// matching message was posted on the bus.
//
// The function takes the following parameters:
//
//   - timeout in nanoseconds, or GST_CLOCK_TIME_NONE to wait forever.
//   - types: message types to take into account, GST_MESSAGE_ANY for any type.
//
// The function returns the following values:
//
//   - message (optional) matching the filter in types, or NULL if no matching
//     message was found on the bus until the timeout expired.
func (bus *Bus) TimedPopFiltered(timeout ClockTime, types MessageType) *Message {
	var _arg0 *C.GstBus        // out
	var _arg1 C.GstClockTime   // out
	var _arg2 C.GstMessageType // out
	var _cret *C.GstMessage    // in

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	_arg1 = C.GstClockTime(timeout)
	_arg2 = C.GstMessageType(types)

	_cret = C.gst_bus_timed_pop_filtered(_arg0, _arg1, _arg2)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(timeout)
	runtime.KeepAlive(types)

	var _message *Message // out

	if _cret != nil {
		_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_message)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _message
}

// Message has been posted on the bus.
//
// The function takes the following parameters:
//
//   - message that has been posted asynchronously.
func (bus *Bus) message(message *Message) {
	gclass := (*C.GstBusClass)(coreglib.PeekParentClass(bus))
	fnarg := gclass.message

	var _arg0 *C.GstBus     // out
	var _arg1 *C.GstMessage // out

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C._gotk4_gst1_Bus_virtual_message(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(message)
}

// syncMessage: message has been posted on the bus.
//
// The function takes the following parameters:
//
//   - message that has been posted synchronously.
func (bus *Bus) syncMessage(message *Message) {
	gclass := (*C.GstBusClass)(coreglib.PeekParentClass(bus))
	fnarg := gclass.sync_message

	var _arg0 *C.GstBus     // out
	var _arg1 *C.GstMessage // out

	_arg0 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C._gotk4_gst1_Bus_virtual_sync_message(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(bus)
	runtime.KeepAlive(message)
}

// ClockOverrides contains methods that are overridable.
type ClockOverrides struct {
	// ChangeResolution: change the resolution of the clock. Not all values
	// might be acceptable.
	//
	// The function takes the following parameters:
	//
	//   - oldResolution previous resolution.
	//   - newResolution: new resolution.
	//
	// The function returns the following values:
	//
	//   - clockTime: new resolution.
	ChangeResolution func(oldResolution, newResolution ClockTime) ClockTime
	// InternalTime gets the current internal time of the given clock. The time
	// is returned unadjusted for the offset and the rate.
	//
	// The function returns the following values:
	//
	//   - clockTime: internal time of the clock. Or GST_CLOCK_TIME_NONE when
	//     given invalid input.
	InternalTime func() ClockTime
	// Resolution gets the accuracy of the clock. The accuracy of the clock is
	// the granularity of the values returned by gst_clock_get_time().
	//
	// The function returns the following values:
	//
	//   - clockTime: resolution of the clock in units of ClockTime.
	Resolution func() ClockTime
	// Unschedule: unblock a blocking or async wait operation.
	//
	// The function takes the following parameters:
	//
	//   - entry to unschedule.
	Unschedule func(entry *ClockEntry)
	// Wait: perform a blocking wait on the given ClockEntry and return the
	// jitter.
	//
	// The function takes the following parameters:
	//
	//   - entry to wait on.
	//
	// The function returns the following values:
	//
	//   - jitter (optional): pointer that will contain the jitter.
	//   - clockReturn: result of the blocking wait. T_CLOCK_EARLY will
	//     be returned if the current clock time is past the time of id,
	//     T_CLOCK_OK if id was scheduled in time. T_CLOCK_UNSCHEDULED if id was
	//     unscheduled with gst_clock_id_unschedule().
	Wait func(entry *ClockEntry) (ClockTimeDiff, ClockReturn)
	// WaitAsync: perform an asynchronous wait on the given ClockEntry.
	//
	// The function takes the following parameters:
	//
	//   - entry to wait on.
	//
	// The function returns the following values:
	//
	//   - clockReturn: result of the non blocking wait.
	WaitAsync func(entry *ClockEntry) ClockReturn
}

func defaultClockOverrides(v *Clock) ClockOverrides {
	return ClockOverrides{
		ChangeResolution: v.changeResolution,
		InternalTime:     v.internalTime,
		Resolution:       v.resolution,
		Unschedule:       v.unschedule,
		Wait:             v.wait,
		WaitAsync:        v.waitAsync,
	}
}

// Clock: GStreamer uses a global clock to synchronize the plugins in a
// pipeline. Different clock implementations are possible by implementing this
// abstract base class or, more conveniently, by subclassing SystemClock.
//
// The Clock returns a monotonically increasing time with the method
// gst_clock_get_time(). Its accuracy and base time depend on the specific
// clock implementation but time is always expressed in nanoseconds.
// Since the baseline of the clock is undefined, the clock time returned is not
// meaningful in itself, what matters are the deltas between two clock times.
// The time returned by a clock is called the absolute time.
//
// The pipeline uses the clock to calculate the running time. Usually all
// renderers synchronize to the global clock using the buffer timestamps,
// the T_EVENT_SEGMENT events and the element's base time, see Pipeline.
//
// A clock implementation can support periodic and single shot clock
// notifications both synchronous and asynchronous.
//
// One first needs to create a ClockID for the periodic or single
// shot notification using gst_clock_new_single_shot_id() or
// gst_clock_new_periodic_id().
//
// To perform a blocking wait for the specific time of the ClockID use
// gst_clock_id_wait(). To receive a callback when the specific time is
// reached in the clock use gst_clock_id_wait_async(). Both these calls can be
// interrupted with the gst_clock_id_unschedule() call. If the blocking wait is
// unscheduled a return value of T_CLOCK_UNSCHEDULED is returned.
//
// Periodic callbacks scheduled async will be repeatedly called automatically
// until they are unscheduled. To schedule a sync periodic callback,
// gst_clock_id_wait() should be called repeatedly.
//
// The async callbacks can happen from any thread, either provided by the core
// or from a streaming thread. The application should be prepared for this.
//
// A ClockID that has been unscheduled cannot be used again for any wait
// operation, a new ClockID should be created and the old unscheduled one should
// be destroyed with gst_clock_id_unref().
//
// It is possible to perform a blocking wait on the same ClockID from
// multiple threads. However, registering the same ClockID for multiple async
// notifications is not possible, the callback will only be called for the
// thread registering the entry last.
//
// None of the wait operations unref the ClockID, the owner is responsible
// for unreffing the ids itself. This holds for both periodic and single shot
// notifications. The reason being that the owner of the ClockID has to keep a
// handle to the ClockID to unblock the wait on FLUSHING events or state changes
// and if the entry would be unreffed automatically, the handle might become
// invalid without any notification.
//
// These clock operations do not operate on the running time, so the callbacks
// will also occur when not in PLAYING state as if the clock just keeps on
// running. Some clocks however do not progress when the element that provided
// the clock is not PLAYING.
//
// When a clock has the T_CLOCK_FLAG_CAN_SET_MASTER flag set, it can be
// slaved to another Clock with gst_clock_set_master(). The clock will then
// automatically be synchronized to this master clock by repeatedly sampling
// the master clock and the slave clock and recalibrating the slave clock with
// gst_clock_set_calibration(). This feature is mostly useful for plugins that
// have an internal clock but must operate with another clock selected by the
// Pipeline. They can track the offset and rate difference of their internal
// clock relative to the master clock by using the gst_clock_get_calibration()
// function.
//
// The master/slave synchronisation can be tuned with the Clock:timeout,
// Clock:window-size and Clock:window-threshold properties. The Clock:timeout
// property defines the interval to sample the master clock and run the
// calibration functions. Clock:window-size defines the number of samples to
// use when calibrating and Clock:window-threshold defines the minimum number of
// samples before the calibration is performed.
type Clock struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*Clock)(nil)
)

// Clocker describes types inherited from class Clock.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Clocker interface {
	coreglib.Objector
	baseClock() *Clock
}

var _ Clocker = (*Clock)(nil)

func init() {
	coreglib.RegisterClassInfo[*Clock, *ClockClass, ClockOverrides](
		GTypeClock,
		initClockClass,
		wrapClock,
		defaultClockOverrides,
	)
}

func initClockClass(gclass unsafe.Pointer, overrides ClockOverrides, classInitFunc func(*ClockClass)) {
	pclass := (*C.GstClockClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeClock))))

	if overrides.ChangeResolution != nil {
		pclass.change_resolution = (*[0]byte)(C._gotk4_gst1_ClockClass_change_resolution)
	}

	if overrides.InternalTime != nil {
		pclass.get_internal_time = (*[0]byte)(C._gotk4_gst1_ClockClass_get_internal_time)
	}

	if overrides.Resolution != nil {
		pclass.get_resolution = (*[0]byte)(C._gotk4_gst1_ClockClass_get_resolution)
	}

	if overrides.Unschedule != nil {
		pclass.unschedule = (*[0]byte)(C._gotk4_gst1_ClockClass_unschedule)
	}

	if overrides.Wait != nil {
		pclass.wait = (*[0]byte)(C._gotk4_gst1_ClockClass_wait)
	}

	if overrides.WaitAsync != nil {
		pclass.wait_async = (*[0]byte)(C._gotk4_gst1_ClockClass_wait_async)
	}

	if classInitFunc != nil {
		class := (*ClockClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapClock(obj *coreglib.Object) *Clock {
	return &Clock{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalClock(p uintptr) (interface{}, error) {
	return wrapClock(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (clock *Clock) baseClock() *Clock {
	return clock
}

// BaseClock returns the underlying base object.
func BaseClock(obj Clocker) *Clock {
	return obj.baseClock()
}

// ConnectSynced: signaled on clocks with GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC set
// once the clock is synchronized, or when it completely lost synchronization.
// This signal will not be emitted on clocks without the flag.
//
// This signal will be emitted from an arbitrary thread, most likely not the
// application's main thread.
func (clock *Clock) ConnectSynced(f func(synced bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(clock, "synced", false, unsafe.Pointer(C._gotk4_gst1_Clock_ConnectSynced), f)
}

// AddObservation: time master of the master clock and the time slave of the
// slave clock are added to the list of observations. If enough observations are
// available, a linear regression algorithm is run on the observations and clock
// is recalibrated.
//
// If this functions returns TRUE, r_squared will contain the correlation
// coefficient of the interpolation. A value of 1.0 means a perfect regression
// was performed. This value can be used to control the sampling frequency of
// the master and slave clocks.
//
// The function takes the following parameters:
//
//   - slave: time on the slave.
//   - master: time on the master.
//
// The function returns the following values:
//
//   - rSquared: pointer to hold the result.
//   - ok: TRUE if enough observations were added to run the regression
//     algorithm.
func (clock *Clock) AddObservation(slave, master ClockTime) (float64, bool) {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _arg2 C.GstClockTime // out
	var _arg3 C.gdouble      // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.GstClockTime(slave)
	_arg2 = C.GstClockTime(master)

	_cret = C.gst_clock_add_observation(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(slave)
	runtime.KeepAlive(master)

	var _rSquared float64 // out
	var _ok bool          // out

	_rSquared = float64(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _rSquared, _ok
}

// AddObservationUnapplied: add a clock observation to the internal slaving
// algorithm the same as gst_clock_add_observation(), and return the result of
// the master clock estimation, without updating the internal calibration.
//
// The caller can then take the results and call gst_clock_set_calibration()
// with the values, or some modified version of them.
//
// The function takes the following parameters:
//
//   - slave: time on the slave.
//   - master: time on the master.
//
// The function returns the following values:
//
//   - rSquared: pointer to hold the result.
//   - internal (optional): location to store the internal time.
//   - external (optional): location to store the external time.
//   - rateNum (optional): location to store the rate numerator.
//   - rateDenom (optional): location to store the rate denominator.
//   - ok: TRUE if enough observations were added to run the regression
//     algorithm.
func (clock *Clock) AddObservationUnapplied(slave, master ClockTime) (rSquared float64, internal, external, rateNum, rateDenom ClockTime, ok bool) {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _arg2 C.GstClockTime // out
	var _arg3 C.gdouble      // in
	var _arg4 C.GstClockTime // in
	var _arg5 C.GstClockTime // in
	var _arg6 C.GstClockTime // in
	var _arg7 C.GstClockTime // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.GstClockTime(slave)
	_arg2 = C.GstClockTime(master)

	_cret = C.gst_clock_add_observation_unapplied(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_arg5, &_arg6, &_arg7)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(slave)
	runtime.KeepAlive(master)

	var _rSquared float64    // out
	var _internal ClockTime  // out
	var _external ClockTime  // out
	var _rateNum ClockTime   // out
	var _rateDenom ClockTime // out
	var _ok bool             // out

	_rSquared = float64(_arg3)
	_internal = ClockTime(_arg4)
	_external = ClockTime(_arg5)
	_rateNum = ClockTime(_arg6)
	_rateDenom = ClockTime(_arg7)
	if _cret != 0 {
		_ok = true
	}

	return _rSquared, _internal, _external, _rateNum, _rateDenom, _ok
}

// AdjustUnlocked converts the given internal clock time to the
// external time, adjusting for the rate and reference time set with
// gst_clock_set_calibration() and making sure that the returned time is
// increasing. This function should be called with the clock's OBJECT_LOCK held
// and is mainly used by clock subclasses.
//
// This function is the reverse of gst_clock_unadjust_unlocked().
//
// The function takes the following parameters:
//
//   - internal: clock time.
//
// The function returns the following values:
//
//   - clockTime: converted time of the clock.
func (clock *Clock) AdjustUnlocked(internal ClockTime) ClockTime {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.GstClockTime(internal)

	_cret = C.gst_clock_adjust_unlocked(_arg0, _arg1)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(internal)

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// AdjustWithCalibration converts the given internal_target clock time to
// the external time, using the passed calibration parameters. This function
// performs the same calculation as gst_clock_adjust_unlocked() when called
// using the current calibration parameters, but doesn't ensure a monotonically
// increasing result as gst_clock_adjust_unlocked() does.
//
// Note: The clock parameter is unused and can be NULL.
//
// The function takes the following parameters:
//
//   - internalTarget: clock time.
//   - cinternal: reference internal time.
//   - cexternal: reference external time.
//   - cnum: numerator of the rate of the clock relative to its internal time.
//   - cdenom: denominator of the rate of the clock.
//
// The function returns the following values:
//
//   - clockTime: converted time of the clock.
func (clock *Clock) AdjustWithCalibration(internalTarget, cinternal, cexternal, cnum, cdenom ClockTime) ClockTime {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _arg2 C.GstClockTime // out
	var _arg3 C.GstClockTime // out
	var _arg4 C.GstClockTime // out
	var _arg5 C.GstClockTime // out
	var _cret C.GstClockTime // in

	if clock != nil {
		_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	}
	_arg1 = C.GstClockTime(internalTarget)
	_arg2 = C.GstClockTime(cinternal)
	_arg3 = C.GstClockTime(cexternal)
	_arg4 = C.GstClockTime(cnum)
	_arg5 = C.GstClockTime(cdenom)

	_cret = C.gst_clock_adjust_with_calibration(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(internalTarget)
	runtime.KeepAlive(cinternal)
	runtime.KeepAlive(cexternal)
	runtime.KeepAlive(cnum)
	runtime.KeepAlive(cdenom)

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// Calibration gets the internal rate and reference time of clock. See
// gst_clock_set_calibration() for more information.
//
// internal, external, rate_num, and rate_denom can be left NULL if the caller
// is not interested in the values.
//
// The function returns the following values:
//
//   - internal (optional): location to store the internal time.
//   - external (optional): location to store the external time.
//   - rateNum (optional): location to store the rate numerator.
//   - rateDenom (optional): location to store the rate denominator.
func (clock *Clock) Calibration() (internal, external, rateNum, rateDenom ClockTime) {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // in
	var _arg2 C.GstClockTime // in
	var _arg3 C.GstClockTime // in
	var _arg4 C.GstClockTime // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	C.gst_clock_get_calibration(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(clock)

	var _internal ClockTime  // out
	var _external ClockTime  // out
	var _rateNum ClockTime   // out
	var _rateDenom ClockTime // out

	_internal = ClockTime(_arg1)
	_external = ClockTime(_arg2)
	_rateNum = ClockTime(_arg3)
	_rateDenom = ClockTime(_arg4)

	return _internal, _external, _rateNum, _rateDenom
}

// InternalTime gets the current internal time of the given clock. The time is
// returned unadjusted for the offset and the rate.
//
// The function returns the following values:
//
//   - clockTime: internal time of the clock. Or GST_CLOCK_TIME_NONE when given
//     invalid input.
func (clock *Clock) InternalTime() ClockTime {
	var _arg0 *C.GstClock    // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	_cret = C.gst_clock_get_internal_time(_arg0)
	runtime.KeepAlive(clock)

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// Master gets the master clock that clock is slaved to or NULL when the clock
// is not slaved to any master clock.
//
// The function returns the following values:
//
//   - ret (optional): master Clock or NULL when this clock is not slaved to a
//     master clock.
func (clock *Clock) Master() Clocker {
	var _arg0 *C.GstClock // out
	var _cret *C.GstClock // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	_cret = C.gst_clock_get_master(_arg0)
	runtime.KeepAlive(clock)

	var _ret Clocker // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Clocker)
				return ok
			})
			rv, ok := casted.(Clocker)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Clocker")
			}
			_ret = rv
		}
	}

	return _ret
}

// Resolution gets the accuracy of the clock. The accuracy of the clock is the
// granularity of the values returned by gst_clock_get_time().
//
// The function returns the following values:
//
//   - clockTime: resolution of the clock in units of ClockTime.
func (clock *Clock) Resolution() ClockTime {
	var _arg0 *C.GstClock    // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	_cret = C.gst_clock_get_resolution(_arg0)
	runtime.KeepAlive(clock)

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// Time gets the current time of the given clock. The time is always
// monotonically increasing and adjusted according to the current offset and
// rate.
//
// The function returns the following values:
//
//   - clockTime: time of the clock. Or GST_CLOCK_TIME_NONE when given invalid
//     input.
func (clock *Clock) Time() ClockTime {
	var _arg0 *C.GstClock    // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	_cret = C.gst_clock_get_time(_arg0)
	runtime.KeepAlive(clock)

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// Timeout gets the amount of time that master and slave clocks are sampled.
//
// The function returns the following values:
//
//   - clockTime: interval between samples.
func (clock *Clock) Timeout() ClockTime {
	var _arg0 *C.GstClock    // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	_cret = C.gst_clock_get_timeout(_arg0)
	runtime.KeepAlive(clock)

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// IsSynced checks if the clock is currently synced, by looking at whether
// GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC is set.
//
// The function returns the following values:
//
//   - ok: TRUE if the clock is currently synced.
func (clock *Clock) IsSynced() bool {
	var _arg0 *C.GstClock // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	_cret = C.gst_clock_is_synced(_arg0)
	runtime.KeepAlive(clock)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NewPeriodicID gets an ID from clock to trigger a periodic notification.
// The periodic notifications will start at time start_time and will then be
// fired with the given interval.
//
// The function takes the following parameters:
//
//   - startTime: requested start time.
//   - interval: requested interval.
//
// The function returns the following values:
//
//   - clockID that can be used to request the time notification.
func (clock *Clock) NewPeriodicID(startTime, interval ClockTime) ClockID {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _arg2 C.GstClockTime // out
	var _cret C.GstClockID   // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.GstClockTime(startTime)
	_arg2 = C.GstClockTime(interval)

	_cret = C.gst_clock_new_periodic_id(_arg0, _arg1, _arg2)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(startTime)
	runtime.KeepAlive(interval)

	var _clockID ClockID // out

	_clockID = (ClockID)(unsafe.Pointer(_cret))

	return _clockID
}

// NewSingleShotID gets a ClockID from clock to trigger a single shot
// notification at the requested time.
//
// The function takes the following parameters:
//
//   - time: requested time.
//
// The function returns the following values:
//
//   - clockID that can be used to request the time notification.
func (clock *Clock) NewSingleShotID(time ClockTime) ClockID {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _cret C.GstClockID   // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.GstClockTime(time)

	_cret = C.gst_clock_new_single_shot_id(_arg0, _arg1)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(time)

	var _clockID ClockID // out

	_clockID = (ClockID)(unsafe.Pointer(_cret))

	return _clockID
}

// PeriodicIDReinit reinitializes the provided periodic id to the provided start
// time and interval. Does not modify the reference count.
//
// The function takes the following parameters:
//
//   - id: ClockID.
//   - startTime: requested start time.
//   - interval: requested interval.
//
// The function returns the following values:
//
//   - ok: TRUE if the GstClockID could be reinitialized to the provided time,
//     else FALSE.
func (clock *Clock) PeriodicIDReinit(id ClockID, startTime, interval ClockTime) bool {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockID   // out
	var _arg2 C.GstClockTime // out
	var _arg3 C.GstClockTime // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = (C.GstClockID)(unsafe.Pointer(id))
	_arg2 = C.GstClockTime(startTime)
	_arg3 = C.GstClockTime(interval)

	_cret = C.gst_clock_periodic_id_reinit(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(id)
	runtime.KeepAlive(startTime)
	runtime.KeepAlive(interval)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetCalibration adjusts the rate and time of clock. A rate of 1/1 is the
// normal speed of the clock. Values bigger than 1/1 make the clock go faster.
//
// internal and external are calibration parameters that arrange that
// gst_clock_get_time() should have been external at internal time internal.
// This internal time should not be in the future; that is, it should be less
// than the value of gst_clock_get_internal_time() when this function is called.
//
// Subsequent calls to gst_clock_get_time() will return clock times computed as
// follows:
//
//	C   time = (internal_time - internal) * rate_num / rate_denom + external
//
// This formula is implemented in gst_clock_adjust_unlocked(). Of course,
// it tries to do the integer arithmetic as precisely as possible.
//
// Note that gst_clock_get_time() always returns increasing values so when you
// move the clock backwards, gst_clock_get_time() will report the previous value
// until the clock catches up.
//
// The function takes the following parameters:
//
//   - internal: reference internal time.
//   - external: reference external time.
//   - rateNum: numerator of the rate of the clock relative to its internal
//     time.
//   - rateDenom: denominator of the rate of the clock.
func (clock *Clock) SetCalibration(internal, external, rateNum, rateDenom ClockTime) {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _arg2 C.GstClockTime // out
	var _arg3 C.GstClockTime // out
	var _arg4 C.GstClockTime // out

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.GstClockTime(internal)
	_arg2 = C.GstClockTime(external)
	_arg3 = C.GstClockTime(rateNum)
	_arg4 = C.GstClockTime(rateDenom)

	C.gst_clock_set_calibration(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(internal)
	runtime.KeepAlive(external)
	runtime.KeepAlive(rateNum)
	runtime.KeepAlive(rateDenom)
}

// SetMaster sets master as the master clock for clock. clock will be
// automatically calibrated so that gst_clock_get_time() reports the same time
// as the master clock.
//
// A clock provider that slaves its clock to a master can get the current
// calibration values with gst_clock_get_calibration().
//
// master can be NULL in which case clock will not be slaved anymore. It will
// however keep reporting its time adjusted with the last configured rate and
// time offsets.
//
// The function takes the following parameters:
//
//   - master (optional) Clock.
//
// The function returns the following values:
//
//   - ok: TRUE if the clock is capable of being slaved to a master clock.
//     Trying to set a master on a clock without the T_CLOCK_FLAG_CAN_SET_MASTER
//     flag will make this function return FALSE.
func (clock *Clock) SetMaster(master Clocker) bool {
	var _arg0 *C.GstClock // out
	var _arg1 *C.GstClock // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	if master != nil {
		_arg1 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(master).Native()))
	}

	_cret = C.gst_clock_set_master(_arg0, _arg1)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(master)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetResolution sets the accuracy of the clock. Some clocks have the
// possibility to operate with different accuracy at the expense of more
// resource usage. There is normally no need to change the default resolution of
// a clock. The resolution of a clock can only be changed if the clock has the
// T_CLOCK_FLAG_CAN_SET_RESOLUTION flag set.
//
// The function takes the following parameters:
//
//   - resolution to set.
//
// The function returns the following values:
//
//   - clockTime: new resolution of the clock.
func (clock *Clock) SetResolution(resolution ClockTime) ClockTime {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.GstClockTime(resolution)

	_cret = C.gst_clock_set_resolution(_arg0, _arg1)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(resolution)

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// SetSynced sets clock to synced and emits the Clock::synced signal, and wakes
// up any thread waiting in gst_clock_wait_for_sync().
//
// This function must only be called if GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC is set
// on the clock, and is intended to be called by subclasses only.
//
// The function takes the following parameters:
//
//   - synced: if the clock is synced.
func (clock *Clock) SetSynced(synced bool) {
	var _arg0 *C.GstClock // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	if synced {
		_arg1 = C.TRUE
	}

	C.gst_clock_set_synced(_arg0, _arg1)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(synced)
}

// SetTimeout sets the amount of time, in nanoseconds, to sample master and
// slave clocks.
//
// The function takes the following parameters:
//
//   - timeout: timeout.
func (clock *Clock) SetTimeout(timeout ClockTime) {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.GstClockTime(timeout)

	C.gst_clock_set_timeout(_arg0, _arg1)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(timeout)
}

// SingleShotIDReinit reinitializes the provided single shot id to the provided
// time. Does not modify the reference count.
//
// The function takes the following parameters:
//
//   - id: ClockID.
//   - time: requested time.
//
// The function returns the following values:
//
//   - ok: TRUE if the GstClockID could be reinitialized to the provided time,
//     else FALSE.
func (clock *Clock) SingleShotIDReinit(id ClockID, time ClockTime) bool {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockID   // out
	var _arg2 C.GstClockTime // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = (C.GstClockID)(unsafe.Pointer(id))
	_arg2 = C.GstClockTime(time)

	_cret = C.gst_clock_single_shot_id_reinit(_arg0, _arg1, _arg2)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(id)
	runtime.KeepAlive(time)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnadjustUnlocked converts the given external clock time to the
// internal time of clock, using the rate and reference time set with
// gst_clock_set_calibration(). This function should be called with the clock's
// OBJECT_LOCK held and is mainly used by clock subclasses.
//
// This function is the reverse of gst_clock_adjust_unlocked().
//
// The function takes the following parameters:
//
//   - external clock time.
//
// The function returns the following values:
//
//   - clockTime: internal time of the clock corresponding to external.
func (clock *Clock) UnadjustUnlocked(external ClockTime) ClockTime {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.GstClockTime(external)

	_cret = C.gst_clock_unadjust_unlocked(_arg0, _arg1)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(external)

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// UnadjustWithCalibration converts the given external_target clock time to
// the internal time, using the passed calibration parameters. This function
// performs the same calculation as gst_clock_unadjust_unlocked() when called
// using the current calibration parameters.
//
// Note: The clock parameter is unused and can be NULL.
//
// The function takes the following parameters:
//
//   - externalTarget: clock time.
//   - cinternal: reference internal time.
//   - cexternal: reference external time.
//   - cnum: numerator of the rate of the clock relative to its internal time.
//   - cdenom: denominator of the rate of the clock.
//
// The function returns the following values:
//
//   - clockTime: converted time of the clock.
func (clock *Clock) UnadjustWithCalibration(externalTarget, cinternal, cexternal, cnum, cdenom ClockTime) ClockTime {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _arg2 C.GstClockTime // out
	var _arg3 C.GstClockTime // out
	var _arg4 C.GstClockTime // out
	var _arg5 C.GstClockTime // out
	var _cret C.GstClockTime // in

	if clock != nil {
		_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	}
	_arg1 = C.GstClockTime(externalTarget)
	_arg2 = C.GstClockTime(cinternal)
	_arg3 = C.GstClockTime(cexternal)
	_arg4 = C.GstClockTime(cnum)
	_arg5 = C.GstClockTime(cdenom)

	_cret = C.gst_clock_unadjust_with_calibration(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(externalTarget)
	runtime.KeepAlive(cinternal)
	runtime.KeepAlive(cexternal)
	runtime.KeepAlive(cnum)
	runtime.KeepAlive(cdenom)

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// WaitForSync waits until clock is synced for reporting the current time.
// If timeout is GST_CLOCK_TIME_NONE it will wait forever, otherwise it will
// time out after timeout nanoseconds.
//
// For asynchronous waiting, the Clock::synced signal can be used.
//
// This returns immediately with TRUE if GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC is
// not set on the clock, or if the clock is already synced.
//
// The function takes the following parameters:
//
//   - timeout for waiting or GST_CLOCK_TIME_NONE.
//
// The function returns the following values:
//
//   - ok: TRUE if waiting was successful, or FALSE on timeout.
func (clock *Clock) WaitForSync(timeout ClockTime) bool {
	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.GstClockTime(timeout)

	_cret = C.gst_clock_wait_for_sync(_arg0, _arg1)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(timeout)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// changeResolution: change the resolution of the clock. Not all values might be
// acceptable.
//
// The function takes the following parameters:
//
//   - oldResolution previous resolution.
//   - newResolution: new resolution.
//
// The function returns the following values:
//
//   - clockTime: new resolution.
func (clock *Clock) changeResolution(oldResolution, newResolution ClockTime) ClockTime {
	gclass := (*C.GstClockClass)(coreglib.PeekParentClass(clock))
	fnarg := gclass.change_resolution

	var _arg0 *C.GstClock    // out
	var _arg1 C.GstClockTime // out
	var _arg2 C.GstClockTime // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = C.GstClockTime(oldResolution)
	_arg2 = C.GstClockTime(newResolution)

	_cret = C._gotk4_gst1_Clock_virtual_change_resolution(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(oldResolution)
	runtime.KeepAlive(newResolution)

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// internalTime gets the current internal time of the given clock. The time is
// returned unadjusted for the offset and the rate.
//
// The function returns the following values:
//
//   - clockTime: internal time of the clock. Or GST_CLOCK_TIME_NONE when given
//     invalid input.
func (clock *Clock) internalTime() ClockTime {
	gclass := (*C.GstClockClass)(coreglib.PeekParentClass(clock))
	fnarg := gclass.get_internal_time

	var _arg0 *C.GstClock    // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	_cret = C._gotk4_gst1_Clock_virtual_get_internal_time(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(clock)

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// Resolution gets the accuracy of the clock. The accuracy of the clock is the
// granularity of the values returned by gst_clock_get_time().
//
// The function returns the following values:
//
//   - clockTime: resolution of the clock in units of ClockTime.
func (clock *Clock) resolution() ClockTime {
	gclass := (*C.GstClockClass)(coreglib.PeekParentClass(clock))
	fnarg := gclass.get_resolution

	var _arg0 *C.GstClock    // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	_cret = C._gotk4_gst1_Clock_virtual_get_resolution(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(clock)

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// Unschedule: unblock a blocking or async wait operation.
//
// The function takes the following parameters:
//
//   - entry to unschedule.
func (clock *Clock) unschedule(entry *ClockEntry) {
	gclass := (*C.GstClockClass)(coreglib.PeekParentClass(clock))
	fnarg := gclass.unschedule

	var _arg0 *C.GstClock      // out
	var _arg1 *C.GstClockEntry // out

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = (*C.GstClockEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	C._gotk4_gst1_Clock_virtual_unschedule(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(entry)
}

// Wait: perform a blocking wait on the given ClockEntry and return the jitter.
//
// The function takes the following parameters:
//
//   - entry to wait on.
//
// The function returns the following values:
//
//   - jitter (optional): pointer that will contain the jitter.
//   - clockReturn: result of the blocking wait. T_CLOCK_EARLY will be returned
//     if the current clock time is past the time of id, T_CLOCK_OK if id
//     was scheduled in time. T_CLOCK_UNSCHEDULED if id was unscheduled with
//     gst_clock_id_unschedule().
func (clock *Clock) wait(entry *ClockEntry) (ClockTimeDiff, ClockReturn) {
	gclass := (*C.GstClockClass)(coreglib.PeekParentClass(clock))
	fnarg := gclass.wait

	var _arg0 *C.GstClock        // out
	var _arg1 *C.GstClockEntry   // out
	var _arg2 C.GstClockTimeDiff // in
	var _cret C.GstClockReturn   // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = (*C.GstClockEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C._gotk4_gst1_Clock_virtual_wait(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(entry)

	var _jitter ClockTimeDiff    // out
	var _clockReturn ClockReturn // out

	_jitter = ClockTimeDiff(_arg2)
	_clockReturn = ClockReturn(_cret)

	return _jitter, _clockReturn
}

// waitAsync: perform an asynchronous wait on the given ClockEntry.
//
// The function takes the following parameters:
//
//   - entry to wait on.
//
// The function returns the following values:
//
//   - clockReturn: result of the non blocking wait.
func (clock *Clock) waitAsync(entry *ClockEntry) ClockReturn {
	gclass := (*C.GstClockClass)(coreglib.PeekParentClass(clock))
	fnarg := gclass.wait_async

	var _arg0 *C.GstClock      // out
	var _arg1 *C.GstClockEntry // out
	var _cret C.GstClockReturn // in

	_arg0 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	_arg1 = (*C.GstClockEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C._gotk4_gst1_Clock_virtual_wait_async(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(entry)

	var _clockReturn ClockReturn // out

	_clockReturn = ClockReturn(_cret)

	return _clockReturn
}

// ClockIDCompareFunc compares the two ClockID instances. This function can be
// used as a GCompareFunc when sorting ids.
//
// The function takes the following parameters:
//
//   - id1 (optional): ClockID.
//   - id2 (optional) to compare with.
//
// The function returns the following values:
//
//   - gint: negative value if a < b; zero if a = b; positive value if a > b.
func ClockIDCompareFunc(id1, id2 unsafe.Pointer) int {
	var _arg1 C.gconstpointer // out
	var _arg2 C.gconstpointer // out
	var _cret C.gint          // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(id1))
	_arg2 = (C.gconstpointer)(unsafe.Pointer(id2))

	_cret = C.gst_clock_id_compare_func(_arg1, _arg2)
	runtime.KeepAlive(id1)
	runtime.KeepAlive(id2)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ClockIDGetClock: this function returns the underlying clock.
//
// The function takes the following parameters:
//
//   - id: ClockID.
//
// The function returns the following values:
//
//   - clock (optional) or NULL when the underlying clock has been freed.
func ClockIDGetClock(id ClockID) Clocker {
	var _arg1 C.GstClockID // out
	var _cret *C.GstClock  // in

	_arg1 = (C.GstClockID)(unsafe.Pointer(id))

	_cret = C.gst_clock_id_get_clock(_arg1)
	runtime.KeepAlive(id)

	var _clock Clocker // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Clocker)
				return ok
			})
			rv, ok := casted.(Clocker)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Clocker")
			}
			_clock = rv
		}
	}

	return _clock
}

// ClockIDGetTime gets the time of the clock ID.
//
// The function takes the following parameters:
//
//   - id to query.
//
// The function returns the following values:
//
//   - clockTime: time of the given clock id.
func ClockIDGetTime(id ClockID) ClockTime {
	var _arg1 C.GstClockID   // out
	var _cret C.GstClockTime // in

	_arg1 = (C.GstClockID)(unsafe.Pointer(id))

	_cret = C.gst_clock_id_get_time(_arg1)
	runtime.KeepAlive(id)

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// ClockIDUnschedule cancels an outstanding request with id. This can either
// be an outstanding async notification or a pending sync notification. After
// this call, id cannot be used anymore to receive sync or async notifications,
// you need to create a new ClockID.
//
// The function takes the following parameters:
//
//   - id to unschedule.
func ClockIDUnschedule(id ClockID) {
	var _arg1 C.GstClockID // out

	_arg1 = (C.GstClockID)(unsafe.Pointer(id))

	C.gst_clock_id_unschedule(_arg1)
	runtime.KeepAlive(id)
}

// ClockIDUsesClock: this function returns whether id uses clock as the
// underlying clock. clock can be NULL, in which case the return value indicates
// whether the underlying clock has been freed. If this is the case, the id is
// no longer usable and should be freed.
//
// The function takes the following parameters:
//
//   - id to check.
//   - clock to compare against.
//
// The function returns the following values:
//
//   - ok: whether the clock id uses the same underlying Clock clock.
func ClockIDUsesClock(id ClockID, clock Clocker) bool {
	var _arg1 C.GstClockID // out
	var _arg2 *C.GstClock  // out
	var _cret C.gboolean   // in

	_arg1 = (C.GstClockID)(unsafe.Pointer(id))
	_arg2 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	_cret = C.gst_clock_id_uses_clock(_arg1, _arg2)
	runtime.KeepAlive(id)
	runtime.KeepAlive(clock)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ClockIDWait performs a blocking wait on id. id should have been created with
// gst_clock_new_single_shot_id() or gst_clock_new_periodic_id() and should not
// have been unscheduled with a call to gst_clock_id_unschedule().
//
// If the jitter argument is not NULL and this function returns T_CLOCK_OK
// or T_CLOCK_EARLY, it will contain the difference against the clock and
// the time of id when this method was called. Positive values indicate how
// late id was relative to the clock (in which case this function will return
// T_CLOCK_EARLY). Negative values indicate how much time was spent waiting on
// the clock before this function returned.
//
// The function takes the following parameters:
//
//   - id to wait on.
//
// The function returns the following values:
//
//   - jitter (optional): pointer that will contain the jitter, can be NULL.
//   - clockReturn: result of the blocking wait. T_CLOCK_EARLY will be returned
//     if the current clock time is past the time of id, T_CLOCK_OK if id
//     was scheduled in time. T_CLOCK_UNSCHEDULED if id was unscheduled with
//     gst_clock_id_unschedule().
func ClockIDWait(id ClockID) (ClockTimeDiff, ClockReturn) {
	var _arg1 C.GstClockID       // out
	var _arg2 C.GstClockTimeDiff // in
	var _cret C.GstClockReturn   // in

	_arg1 = (C.GstClockID)(unsafe.Pointer(id))

	_cret = C.gst_clock_id_wait(_arg1, &_arg2)
	runtime.KeepAlive(id)

	var _jitter ClockTimeDiff    // out
	var _clockReturn ClockReturn // out

	_jitter = ClockTimeDiff(_arg2)
	_clockReturn = ClockReturn(_cret)

	return _jitter, _clockReturn
}

// ClockIDWaitAsync registers a callback on the given ClockID id with the
// given function and user_data. When passing a ClockID with an invalid time
// to this function, the callback will be called immediately with a time set to
// GST_CLOCK_TIME_NONE. The callback will be called when the time of id has been
// reached.
//
// The callback func can be invoked from any thread, either provided by the core
// or from a streaming thread. The application should be prepared for this.
//
// The function takes the following parameters:
//
//   - id to wait on.
//   - fn: callback function.
//
// The function returns the following values:
//
//   - clockReturn: result of the non blocking wait.
func ClockIDWaitAsync(id ClockID, fn ClockCallback) ClockReturn {
	var _arg1 C.GstClockID       // out
	var _arg2 C.GstClockCallback // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify
	var _cret C.GstClockReturn // in

	_arg1 = (C.GstClockID)(unsafe.Pointer(id))
	_arg2 = (*[0]byte)(C._gotk4_gst1_ClockCallback)
	_arg3 = C.gpointer(gbox.Assign(fn))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.gst_clock_id_wait_async(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(id)
	runtime.KeepAlive(fn)

	var _clockReturn ClockReturn // out

	_clockReturn = ClockReturn(_cret)

	return _clockReturn
}

// ControlBindingOverrides contains methods that are overridable.
type ControlBindingOverrides struct {
	// GValueArray gets a number of #GValues for the given controlled property
	// starting at the requested time. The array values need to hold enough
	// space for n_values of #GValue.
	//
	// This function is useful if one wants to e.g. draw a graph of the control
	// curve or apply a control curve sample by sample.
	//
	// The function takes the following parameters:
	//
	//   - timestamp: time that should be processed.
	//   - interval: time spacing between subsequent values.
	//   - values: array to put control-values in.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if the given array could be filled, FALSE otherwise.
	GValueArray func(timestamp, interval ClockTime, values []coreglib.Value) bool
	// Value gets the value for the given controlled property at the requested
	// time.
	//
	// The function takes the following parameters:
	//
	//   - timestamp: time the control-change should be read from.
	//
	// The function returns the following values:
	//
	//   - value (optional): GValue of the property at the given time, or NULL
	//     if the property isn't controlled.
	Value func(timestamp ClockTime) *coreglib.Value
	// SyncValues sets the property of the object, according to the
	// ControlSources that handles it and for the given timestamp.
	//
	// If this function fails, it is most likely the application developers
	// fault. Most probably the control sources are not setup correctly.
	//
	// The function takes the following parameters:
	//
	//   - object that has controlled properties.
	//   - timestamp: time that should be processed.
	//   - lastSync: last time this was called.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if the controller value could be applied to the object
	//     property, FALSE otherwise.
	SyncValues func(object GstObjector, timestamp, lastSync ClockTime) bool
}

func defaultControlBindingOverrides(v *ControlBinding) ControlBindingOverrides {
	return ControlBindingOverrides{
		GValueArray: v.gValueArray,
		Value:       v.value,
		SyncValues:  v.syncValues,
	}
}

// ControlBinding: base class for value mapping objects that attaches control
// sources to #GObject properties. Such an object is taking one or more
// ControlSource instances, combines them and maps the resulting value to the
// type and value range of the bound property.
type ControlBinding struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*ControlBinding)(nil)
)

// ControlBindinger describes types inherited from class ControlBinding.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type ControlBindinger interface {
	coreglib.Objector
	baseControlBinding() *ControlBinding
}

var _ ControlBindinger = (*ControlBinding)(nil)

func init() {
	coreglib.RegisterClassInfo[*ControlBinding, *ControlBindingClass, ControlBindingOverrides](
		GTypeControlBinding,
		initControlBindingClass,
		wrapControlBinding,
		defaultControlBindingOverrides,
	)
}

func initControlBindingClass(gclass unsafe.Pointer, overrides ControlBindingOverrides, classInitFunc func(*ControlBindingClass)) {
	pclass := (*C.GstControlBindingClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeControlBinding))))

	if overrides.GValueArray != nil {
		pclass.get_g_value_array = (*[0]byte)(C._gotk4_gst1_ControlBindingClass_get_g_value_array)
	}

	if overrides.Value != nil {
		pclass.get_value = (*[0]byte)(C._gotk4_gst1_ControlBindingClass_get_value)
	}

	if overrides.SyncValues != nil {
		pclass.sync_values = (*[0]byte)(C._gotk4_gst1_ControlBindingClass_sync_values)
	}

	if classInitFunc != nil {
		class := (*ControlBindingClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapControlBinding(obj *coreglib.Object) *ControlBinding {
	return &ControlBinding{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalControlBinding(p uintptr) (interface{}, error) {
	return wrapControlBinding(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (binding *ControlBinding) baseControlBinding() *ControlBinding {
	return binding
}

// BaseControlBinding returns the underlying base object.
func BaseControlBinding(obj ControlBindinger) *ControlBinding {
	return obj.baseControlBinding()
}

// GValueArray gets a number of #GValues for the given controlled property
// starting at the requested time. The array values need to hold enough space
// for n_values of #GValue.
//
// This function is useful if one wants to e.g. draw a graph of the control
// curve or apply a control curve sample by sample.
//
// The function takes the following parameters:
//
//   - timestamp: time that should be processed.
//   - interval: time spacing between subsequent values.
//   - values: array to put control-values in.
//
// The function returns the following values:
//
//   - ok: TRUE if the given array could be filled, FALSE otherwise.
func (binding *ControlBinding) GValueArray(timestamp, interval ClockTime, values []coreglib.Value) bool {
	var _arg0 *C.GstControlBinding // out
	var _arg1 C.GstClockTime       // out
	var _arg2 C.GstClockTime       // out
	var _arg4 *C.GValue            // out
	var _arg3 C.guint
	var _cret C.gboolean // in

	_arg0 = (*C.GstControlBinding)(unsafe.Pointer(coreglib.InternObject(binding).Native()))
	_arg1 = C.GstClockTime(timestamp)
	_arg2 = C.GstClockTime(interval)
	_arg3 = (C.guint)(len(values))
	_arg4 = (*C.GValue)(C.calloc(C.size_t(len(values)), C.size_t(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((*C.GValue)(_arg4), len(values))
		for i := range values {
			out[i] = *(*C.GValue)(unsafe.Pointer((&values[i]).Native()))
		}
	}

	_cret = C.gst_control_binding_get_g_value_array(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(binding)
	runtime.KeepAlive(timestamp)
	runtime.KeepAlive(interval)
	runtime.KeepAlive(values)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Value gets the value for the given controlled property at the requested time.
//
// The function takes the following parameters:
//
//   - timestamp: time the control-change should be read from.
//
// The function returns the following values:
//
//   - value (optional): GValue of the property at the given time, or NULL if
//     the property isn't controlled.
func (binding *ControlBinding) Value(timestamp ClockTime) *coreglib.Value {
	var _arg0 *C.GstControlBinding // out
	var _arg1 C.GstClockTime       // out
	var _cret *C.GValue            // in

	_arg0 = (*C.GstControlBinding)(unsafe.Pointer(coreglib.InternObject(binding).Native()))
	_arg1 = C.GstClockTime(timestamp)

	_cret = C.gst_control_binding_get_value(_arg0, _arg1)
	runtime.KeepAlive(binding)
	runtime.KeepAlive(timestamp)

	var _value *coreglib.Value // out

	if _cret != nil {
		_value = coreglib.ValueFromNative(unsafe.Pointer(_cret))
		runtime.SetFinalizer(_value, func(v *coreglib.Value) {
			C.g_value_unset((*C.GValue)(unsafe.Pointer(v.Native())))
		})
	}

	return _value
}

// IsDisabled checks if the control binding is disabled.
//
// The function returns the following values:
//
//   - ok: TRUE if the binding is inactive.
func (binding *ControlBinding) IsDisabled() bool {
	var _arg0 *C.GstControlBinding // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstControlBinding)(unsafe.Pointer(coreglib.InternObject(binding).Native()))

	_cret = C.gst_control_binding_is_disabled(_arg0)
	runtime.KeepAlive(binding)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetDisabled: this function is used to disable a control binding for some
// time, i.e. gst_object_sync_values() will do nothing.
//
// The function takes the following parameters:
//
//   - disabled: boolean that specifies whether to disable the controller or
//     not.
func (binding *ControlBinding) SetDisabled(disabled bool) {
	var _arg0 *C.GstControlBinding // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GstControlBinding)(unsafe.Pointer(coreglib.InternObject(binding).Native()))
	if disabled {
		_arg1 = C.TRUE
	}

	C.gst_control_binding_set_disabled(_arg0, _arg1)
	runtime.KeepAlive(binding)
	runtime.KeepAlive(disabled)
}

// SyncValues sets the property of the object, according to the ControlSources
// that handles it and for the given timestamp.
//
// If this function fails, it is most likely the application developers fault.
// Most probably the control sources are not setup correctly.
//
// The function takes the following parameters:
//
//   - object that has controlled properties.
//   - timestamp: time that should be processed.
//   - lastSync: last time this was called.
//
// The function returns the following values:
//
//   - ok: TRUE if the controller value could be applied to the object property,
//     FALSE otherwise.
func (binding *ControlBinding) SyncValues(object GstObjector, timestamp, lastSync ClockTime) bool {
	var _arg0 *C.GstControlBinding // out
	var _arg1 *C.GstObject         // out
	var _arg2 C.GstClockTime       // out
	var _arg3 C.GstClockTime       // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstControlBinding)(unsafe.Pointer(coreglib.InternObject(binding).Native()))
	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg2 = C.GstClockTime(timestamp)
	_arg3 = C.GstClockTime(lastSync)

	_cret = C.gst_control_binding_sync_values(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(binding)
	runtime.KeepAlive(object)
	runtime.KeepAlive(timestamp)
	runtime.KeepAlive(lastSync)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// gValueArray gets a number of #GValues for the given controlled property
// starting at the requested time. The array values need to hold enough space
// for n_values of #GValue.
//
// This function is useful if one wants to e.g. draw a graph of the control
// curve or apply a control curve sample by sample.
//
// The function takes the following parameters:
//
//   - timestamp: time that should be processed.
//   - interval: time spacing between subsequent values.
//   - values: array to put control-values in.
//
// The function returns the following values:
//
//   - ok: TRUE if the given array could be filled, FALSE otherwise.
func (binding *ControlBinding) gValueArray(timestamp, interval ClockTime, values []coreglib.Value) bool {
	gclass := (*C.GstControlBindingClass)(coreglib.PeekParentClass(binding))
	fnarg := gclass.get_g_value_array

	var _arg0 *C.GstControlBinding // out
	var _arg1 C.GstClockTime       // out
	var _arg2 C.GstClockTime       // out
	var _arg4 *C.GValue            // out
	var _arg3 C.guint
	var _cret C.gboolean // in

	_arg0 = (*C.GstControlBinding)(unsafe.Pointer(coreglib.InternObject(binding).Native()))
	_arg1 = C.GstClockTime(timestamp)
	_arg2 = C.GstClockTime(interval)
	_arg3 = (C.guint)(len(values))
	_arg4 = (*C.GValue)(C.calloc(C.size_t(len(values)), C.size_t(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((*C.GValue)(_arg4), len(values))
		for i := range values {
			out[i] = *(*C.GValue)(unsafe.Pointer((&values[i]).Native()))
		}
	}

	_cret = C._gotk4_gst1_ControlBinding_virtual_get_g_value_array(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(binding)
	runtime.KeepAlive(timestamp)
	runtime.KeepAlive(interval)
	runtime.KeepAlive(values)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Value gets the value for the given controlled property at the requested time.
//
// The function takes the following parameters:
//
//   - timestamp: time the control-change should be read from.
//
// The function returns the following values:
//
//   - value (optional): GValue of the property at the given time, or NULL if
//     the property isn't controlled.
func (binding *ControlBinding) value(timestamp ClockTime) *coreglib.Value {
	gclass := (*C.GstControlBindingClass)(coreglib.PeekParentClass(binding))
	fnarg := gclass.get_value

	var _arg0 *C.GstControlBinding // out
	var _arg1 C.GstClockTime       // out
	var _cret *C.GValue            // in

	_arg0 = (*C.GstControlBinding)(unsafe.Pointer(coreglib.InternObject(binding).Native()))
	_arg1 = C.GstClockTime(timestamp)

	_cret = C._gotk4_gst1_ControlBinding_virtual_get_value(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(binding)
	runtime.KeepAlive(timestamp)

	var _value *coreglib.Value // out

	if _cret != nil {
		_value = coreglib.ValueFromNative(unsafe.Pointer(_cret))
		runtime.SetFinalizer(_value, func(v *coreglib.Value) {
			C.g_value_unset((*C.GValue)(unsafe.Pointer(v.Native())))
		})
	}

	return _value
}

// syncValues sets the property of the object, according to the ControlSources
// that handles it and for the given timestamp.
//
// If this function fails, it is most likely the application developers fault.
// Most probably the control sources are not setup correctly.
//
// The function takes the following parameters:
//
//   - object that has controlled properties.
//   - timestamp: time that should be processed.
//   - lastSync: last time this was called.
//
// The function returns the following values:
//
//   - ok: TRUE if the controller value could be applied to the object property,
//     FALSE otherwise.
func (binding *ControlBinding) syncValues(object GstObjector, timestamp, lastSync ClockTime) bool {
	gclass := (*C.GstControlBindingClass)(coreglib.PeekParentClass(binding))
	fnarg := gclass.sync_values

	var _arg0 *C.GstControlBinding // out
	var _arg1 *C.GstObject         // out
	var _arg2 C.GstClockTime       // out
	var _arg3 C.GstClockTime       // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstControlBinding)(unsafe.Pointer(coreglib.InternObject(binding).Native()))
	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg2 = C.GstClockTime(timestamp)
	_arg3 = C.GstClockTime(lastSync)

	_cret = C._gotk4_gst1_ControlBinding_virtual_sync_values(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(binding)
	runtime.KeepAlive(object)
	runtime.KeepAlive(timestamp)
	runtime.KeepAlive(lastSync)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ControlSourceOverrides contains methods that are overridable.
type ControlSourceOverrides struct {
}

func defaultControlSourceOverrides(v *ControlSource) ControlSourceOverrides {
	return ControlSourceOverrides{}
}

// ControlSource is a base class for control value sources that could be used
// to get timestamp-value pairs. A control source essentially is a function over
// time.
//
// A ControlSource is used by first getting an instance of a specific
// control-source, creating a binding for the control-source to the target
// property of the element and then adding the binding to the element.
// The binding will convert the data types and value range to fit to the bound
// property.
//
// For implementing a new ControlSource one has to implement
// ControlSourceGetValue and ControlSourceGetValueArray functions.
// These are then used by gst_control_source_get_value() and
// gst_control_source_get_value_array() to get values for specific timestamps.
type ControlSource struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*ControlSource)(nil)
)

// ControlSourcer describes types inherited from class ControlSource.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type ControlSourcer interface {
	coreglib.Objector
	baseControlSource() *ControlSource
}

var _ ControlSourcer = (*ControlSource)(nil)

func init() {
	coreglib.RegisterClassInfo[*ControlSource, *ControlSourceClass, ControlSourceOverrides](
		GTypeControlSource,
		initControlSourceClass,
		wrapControlSource,
		defaultControlSourceOverrides,
	)
}

func initControlSourceClass(gclass unsafe.Pointer, overrides ControlSourceOverrides, classInitFunc func(*ControlSourceClass)) {
	if classInitFunc != nil {
		class := (*ControlSourceClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapControlSource(obj *coreglib.Object) *ControlSource {
	return &ControlSource{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalControlSource(p uintptr) (interface{}, error) {
	return wrapControlSource(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (self *ControlSource) baseControlSource() *ControlSource {
	return self
}

// BaseControlSource returns the underlying base object.
func BaseControlSource(obj ControlSourcer) *ControlSource {
	return obj.baseControlSource()
}

// ControlSourceGetValue gets the value for this ControlSource at a given
// timestamp.
//
// The function takes the following parameters:
//
//   - timestamp: time for which the value should be returned.
//
// The function returns the following values:
//
//   - value: value.
//   - ok: FALSE if the value couldn't be returned, TRUE otherwise.
func (self *ControlSource) ControlSourceGetValue(timestamp ClockTime) (float64, bool) {
	var _arg0 *C.GstControlSource // out
	var _arg1 C.GstClockTime      // out
	var _arg2 C.gdouble           // in
	var _cret C.gboolean          // in

	_arg0 = (*C.GstControlSource)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GstClockTime(timestamp)

	_cret = C.gst_control_source_get_value(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(timestamp)

	var _value float64 // out
	var _ok bool       // out

	_value = float64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// ControlSourceGetValueArray gets an array of values for for this
// ControlSource. Values that are undefined contain NANs.
//
// The function takes the following parameters:
//
//   - timestamp: first timestamp.
//   - interval: time steps.
//   - values: array to put control-values in.
//
// The function returns the following values:
//
//   - ok: TRUE if the given array could be filled, FALSE otherwise.
func (self *ControlSource) ControlSourceGetValueArray(timestamp, interval ClockTime, values []float64) bool {
	var _arg0 *C.GstControlSource // out
	var _arg1 C.GstClockTime      // out
	var _arg2 C.GstClockTime      // out
	var _arg4 *C.gdouble          // out
	var _arg3 C.guint
	var _cret C.gboolean // in

	_arg0 = (*C.GstControlSource)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GstClockTime(timestamp)
	_arg2 = C.GstClockTime(interval)
	_arg3 = (C.guint)(len(values))
	if len(values) > 0 {
		_arg4 = (*C.gdouble)(unsafe.Pointer(&values[0]))
	}

	_cret = C.gst_control_source_get_value_array(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(self)
	runtime.KeepAlive(timestamp)
	runtime.KeepAlive(interval)
	runtime.KeepAlive(values)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DeviceOverrides contains methods that are overridable.
type DeviceOverrides struct {
	// CreateElement creates the element with all of the required parameters set
	// to use this device.
	//
	// The function takes the following parameters:
	//
	//   - name (optional) of new element, or NULL to automatically create a
	//     unique name.
	//
	// The function returns the following values:
	//
	//   - element (optional): new Element configured to use this device.
	CreateElement func(name string) Elementer
	// ReconfigureElement tries to reconfigure an existing element to use the
	// device. If this function fails, then one must destroy the element and
	// create a new one using gst_device_create_element().
	//
	// Note: This should only be implemented for elements can change their
	// device in the PLAYING state.
	//
	// The function takes the following parameters:
	//
	//   - element: Element.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if the element could be reconfigured to use this device,
	//     FALSE otherwise.
	ReconfigureElement func(element Elementer) bool
}

func defaultDeviceOverrides(v *Device) DeviceOverrides {
	return DeviceOverrides{
		CreateElement:      v.createElement,
		ReconfigureElement: v.reconfigureElement,
	}
}

// Device are objects representing a device, they contain relevant metadata
// about the device, such as its class and the Caps representing the media types
// it can produce or handle.
//
// Device are created by DeviceProvider objects which can be aggregated by
// DeviceMonitor objects.
type Device struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*Device)(nil)
)

// Devicer describes types inherited from class Device.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Devicer interface {
	coreglib.Objector
	baseDevice() *Device
}

var _ Devicer = (*Device)(nil)

func init() {
	coreglib.RegisterClassInfo[*Device, *DeviceClass, DeviceOverrides](
		GTypeDevice,
		initDeviceClass,
		wrapDevice,
		defaultDeviceOverrides,
	)
}

func initDeviceClass(gclass unsafe.Pointer, overrides DeviceOverrides, classInitFunc func(*DeviceClass)) {
	pclass := (*C.GstDeviceClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeDevice))))

	if overrides.CreateElement != nil {
		pclass.create_element = (*[0]byte)(C._gotk4_gst1_DeviceClass_create_element)
	}

	if overrides.ReconfigureElement != nil {
		pclass.reconfigure_element = (*[0]byte)(C._gotk4_gst1_DeviceClass_reconfigure_element)
	}

	if classInitFunc != nil {
		class := (*DeviceClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDevice(obj *coreglib.Object) *Device {
	return &Device{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalDevice(p uintptr) (interface{}, error) {
	return wrapDevice(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (device *Device) baseDevice() *Device {
	return device
}

// BaseDevice returns the underlying base object.
func BaseDevice(obj Devicer) *Device {
	return obj.baseDevice()
}

func (device *Device) ConnectRemoved(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(device, "removed", false, unsafe.Pointer(C._gotk4_gst1_Device_ConnectRemoved), f)
}

// CreateElement creates the element with all of the required parameters set to
// use this device.
//
// The function takes the following parameters:
//
//   - name (optional) of new element, or NULL to automatically create a unique
//     name.
//
// The function returns the following values:
//
//   - element (optional): new Element configured to use this device.
func (device *Device) CreateElement(name string) Elementer {
	var _arg0 *C.GstDevice  // out
	var _arg1 *C.gchar      // out
	var _cret *C.GstElement // in

	_arg0 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_device_create_element(_arg0, _arg1)
	runtime.KeepAlive(device)
	runtime.KeepAlive(name)

	var _element Elementer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Elementer)
				return ok
			})
			rv, ok := casted.(Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_element = rv
		}
	}

	return _element
}

// Caps: getter for the Caps that this device supports.
//
// The function returns the following values:
//
//   - caps (optional) supported by this device. Unref with gst_caps_unref()
//     when done.
func (device *Device) Caps() *Caps {
	var _arg0 *C.GstDevice // out
	var _cret *C.GstCaps   // in

	_arg0 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gst_device_get_caps(_arg0)
	runtime.KeepAlive(device)

	var _caps *Caps // out

	if _cret != nil {
		_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_caps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _caps
}

// DeviceClass gets the "class" of a device. This is a "/" separated list of
// classes that represent this device. They are a subset of the classes of the
// DeviceProvider that produced this device.
//
// The function returns the following values:
//
//   - utf8: device class. Free with g_free() after use.
func (device *Device) DeviceClass() string {
	var _arg0 *C.GstDevice // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gst_device_get_device_class(_arg0)
	runtime.KeepAlive(device)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DisplayName gets the user-friendly name of the device.
//
// The function returns the following values:
//
//   - utf8: device name. Free with g_free() after use.
func (device *Device) DisplayName() string {
	var _arg0 *C.GstDevice // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gst_device_get_display_name(_arg0)
	runtime.KeepAlive(device)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Properties gets the extra properties of a device.
//
// The function returns the following values:
//
//   - structure (optional): extra properties or NULL when there are none.
//     Free with gst_structure_free() after use.
func (device *Device) Properties() *Structure {
	var _arg0 *C.GstDevice    // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gst_device_get_properties(_arg0)
	runtime.KeepAlive(device)

	var _structure *Structure // out

	if _cret != nil {
		_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_structure)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_structure_free((*C.GstStructure)(intern.C))
			},
		)
	}

	return _structure
}

// HasClasses: check if device matches all of the given classes.
//
// The function takes the following parameters:
//
//   - classes: "/"-separated list of device classes to match, only match if all
//     classes are matched.
//
// The function returns the following values:
//
//   - ok: TRUE if device matches.
func (device *Device) HasClasses(classes string) bool {
	var _arg0 *C.GstDevice // out
	var _arg1 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(classes)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_device_has_classes(_arg0, _arg1)
	runtime.KeepAlive(device)
	runtime.KeepAlive(classes)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasClassesv: check if factory matches all of the given classes.
//
// The function takes the following parameters:
//
//   - classes: NULL terminated array of classes to match, only match if all
//     classes are matched.
//
// The function returns the following values:
//
//   - ok: TRUE if device matches.
func (device *Device) HasClassesv(classes []string) bool {
	var _arg0 *C.GstDevice // out
	var _arg1 **C.gchar    // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(classes) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(classes)+1)
			var zero *C.gchar
			out[len(classes)] = zero
			for i := range classes {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(classes[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.gst_device_has_classesv(_arg0, _arg1)
	runtime.KeepAlive(device)
	runtime.KeepAlive(classes)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReconfigureElement tries to reconfigure an existing element to use the
// device. If this function fails, then one must destroy the element and create
// a new one using gst_device_create_element().
//
// Note: This should only be implemented for elements can change their device in
// the PLAYING state.
//
// The function takes the following parameters:
//
//   - element: Element.
//
// The function returns the following values:
//
//   - ok: TRUE if the element could be reconfigured to use this device,
//     FALSE otherwise.
func (device *Device) ReconfigureElement(element Elementer) bool {
	var _arg0 *C.GstDevice  // out
	var _arg1 *C.GstElement // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_device_reconfigure_element(_arg0, _arg1)
	runtime.KeepAlive(device)
	runtime.KeepAlive(element)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// createElement creates the element with all of the required parameters set to
// use this device.
//
// The function takes the following parameters:
//
//   - name (optional) of new element, or NULL to automatically create a unique
//     name.
//
// The function returns the following values:
//
//   - element (optional): new Element configured to use this device.
func (device *Device) createElement(name string) Elementer {
	gclass := (*C.GstDeviceClass)(coreglib.PeekParentClass(device))
	fnarg := gclass.create_element

	var _arg0 *C.GstDevice  // out
	var _arg1 *C.gchar      // out
	var _cret *C.GstElement // in

	_arg0 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C._gotk4_gst1_Device_virtual_create_element(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(device)
	runtime.KeepAlive(name)

	var _element Elementer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Elementer)
				return ok
			})
			rv, ok := casted.(Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_element = rv
		}
	}

	return _element
}

// reconfigureElement tries to reconfigure an existing element to use the
// device. If this function fails, then one must destroy the element and create
// a new one using gst_device_create_element().
//
// Note: This should only be implemented for elements can change their device in
// the PLAYING state.
//
// The function takes the following parameters:
//
//   - element: Element.
//
// The function returns the following values:
//
//   - ok: TRUE if the element could be reconfigured to use this device,
//     FALSE otherwise.
func (device *Device) reconfigureElement(element Elementer) bool {
	gclass := (*C.GstDeviceClass)(coreglib.PeekParentClass(device))
	fnarg := gclass.reconfigure_element

	var _arg0 *C.GstDevice  // out
	var _arg1 *C.GstElement // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C._gotk4_gst1_Device_virtual_reconfigure_element(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(device)
	runtime.KeepAlive(element)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DeviceMonitorOverrides contains methods that are overridable.
type DeviceMonitorOverrides struct {
}

func defaultDeviceMonitorOverrides(v *DeviceMonitor) DeviceMonitorOverrides {
	return DeviceMonitorOverrides{}
}

// DeviceMonitor applications should create a DeviceMonitor when they want to
// probe, list and monitor devices of a specific type. The DeviceMonitor will
// create the appropriate DeviceProvider objects and manage them. It will then
// post messages on its Bus for devices that have been added and removed.
//
// The device monitor will monitor all devices matching the filters that the
// application has set.
//
// The basic use pattern of a device monitor is as follows:
//
//	static gboolean
//	my_bus_func (GstBus * bus, GstMessage * message, gpointer user_data)
//	{
//	   GstDevice *device;
//	   gchar *name;
//
//	   switch (GST_MESSAGE_TYPE (message)) {
//	     case GST_MESSAGE_DEVICE_ADDED:
//	       gst_message_parse_device_added (message, &device);
//	       name = gst_device_get_display_name (device);
//	       g_print("Device added: s\n", name);
//	       g_free (name);
//	       gst_object_unref (device);
//	       break;
//	     case GST_MESSAGE_DEVICE_REMOVED:
//	       gst_message_parse_device_removed (message, &device);
//	       name = gst_device_get_display_name (device);
//	       g_print("Device removed: s\n", name);
//	       g_free (name);
//	       gst_object_unref (device);
//	       break;
//	     default:
//	       break;
//	   }
//
//	   return G_SOURCE_CONTINUE;
//	}
//
//	GstDeviceMonitor *
//	setup_raw_video_source_device_monitor (void) {
//	   GstDeviceMonitor *monitor;
//	   GstBus *bus;
//	   GstCaps *caps;
//
//	   monitor = gst_device_monitor_new ();
//
//	   bus = gst_device_monitor_get_bus (monitor);
//	   gst_bus_add_watch (bus, my_bus_func, NULL);
//	   gst_object_unref (bus);
//
//	   caps = gst_caps_new_empty_simple ("video/x-raw");
//	   gst_device_monitor_add_filter (monitor, "Video/Source", caps);
//	   gst_caps_unref (caps);
//
//	   gst_device_monitor_start (monitor);
//
//	   return monitor;
//	}.
type DeviceMonitor struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*DeviceMonitor)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*DeviceMonitor, *DeviceMonitorClass, DeviceMonitorOverrides](
		GTypeDeviceMonitor,
		initDeviceMonitorClass,
		wrapDeviceMonitor,
		defaultDeviceMonitorOverrides,
	)
}

func initDeviceMonitorClass(gclass unsafe.Pointer, overrides DeviceMonitorOverrides, classInitFunc func(*DeviceMonitorClass)) {
	if classInitFunc != nil {
		class := (*DeviceMonitorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDeviceMonitor(obj *coreglib.Object) *DeviceMonitor {
	return &DeviceMonitor{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalDeviceMonitor(p uintptr) (interface{}, error) {
	return wrapDeviceMonitor(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewDeviceMonitor: create a new DeviceMonitor.
//
// The function returns the following values:
//
//   - deviceMonitor: new device monitor.
func NewDeviceMonitor() *DeviceMonitor {
	var _cret *C.GstDeviceMonitor // in

	_cret = C.gst_device_monitor_new()

	var _deviceMonitor *DeviceMonitor // out

	_deviceMonitor = wrapDeviceMonitor(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _deviceMonitor
}

// AddFilter adds a filter for which Device will be monitored, any device that
// matches all these classes and the Caps will be returned.
//
// If this function is called multiple times to add more filters, each will be
// matched independently. That is, adding more filters will not further restrict
// what devices are matched.
//
// The Caps supported by the device as returned by gst_device_get_caps() are not
// intersected with caps filters added using this function.
//
// Filters must be added before the DeviceMonitor is started.
//
// The function takes the following parameters:
//
//   - classes (optional): device classes to use as filter or NULL for any
//     class.
//   - caps (optional) to filter or NULL for ANY.
//
// The function returns the following values:
//
//   - guint: id of the new filter or 0 if no provider matched the filter's
//     classes.
func (monitor *DeviceMonitor) AddFilter(classes string, caps *Caps) uint {
	var _arg0 *C.GstDeviceMonitor // out
	var _arg1 *C.gchar            // out
	var _arg2 *C.GstCaps          // out
	var _cret C.guint             // in

	_arg0 = (*C.GstDeviceMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	if classes != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(classes)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if caps != nil {
		_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}

	_cret = C.gst_device_monitor_add_filter(_arg0, _arg1, _arg2)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(classes)
	runtime.KeepAlive(caps)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Bus gets the Bus of this DeviceMonitor.
//
// The function returns the following values:
//
//   - bus: Bus.
func (monitor *DeviceMonitor) Bus() *Bus {
	var _arg0 *C.GstDeviceMonitor // out
	var _cret *C.GstBus           // in

	_arg0 = (*C.GstDeviceMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gst_device_monitor_get_bus(_arg0)
	runtime.KeepAlive(monitor)

	var _bus *Bus // out

	_bus = wrapBus(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _bus
}

// Devices gets a list of devices from all of the relevant monitors. This may
// actually probe the hardware if the monitor is not currently started.
//
// The function returns the following values:
//
//   - list (optional) of Device.
func (monitor *DeviceMonitor) Devices() []Devicer {
	var _arg0 *C.GstDeviceMonitor // out
	var _cret *C.GList            // in

	_arg0 = (*C.GstDeviceMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gst_device_monitor_get_devices(_arg0)
	runtime.KeepAlive(monitor)

	var _list []Devicer // out

	if _cret != nil {
		_list = make([]Devicer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
		gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
			src := (*C.GstDevice)(v)
			var dst Devicer // out
			{
				objptr := unsafe.Pointer(src)
				if objptr == nil {
					panic("object of type gst.Devicer is nil")
				}

				object := coreglib.AssumeOwnership(objptr)
				casted := object.WalkCast(func(obj coreglib.Objector) bool {
					_, ok := obj.(Devicer)
					return ok
				})
				rv, ok := casted.(Devicer)
				if !ok {
					panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Devicer")
				}
				dst = rv
			}
			_list = append(_list, dst)
		})
	}

	return _list
}

// Providers: get a list of the currently selected device provider factories.
//
// This.
//
// The function returns the following values:
//
//   - utf8s: A list of device provider factory names that are currently being
//     monitored by monitor or NULL when nothing is being monitored.
func (monitor *DeviceMonitor) Providers() []string {
	var _arg0 *C.GstDeviceMonitor // out
	var _cret **C.gchar           // in

	_arg0 = (*C.GstDeviceMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gst_device_monitor_get_providers(_arg0)
	runtime.KeepAlive(monitor)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// ShowAllDevices: get if monitor is currently showing all devices, even those
// from hidden providers.
//
// The function returns the following values:
//
//   - ok: TRUE when all devices will be shown.
func (monitor *DeviceMonitor) ShowAllDevices() bool {
	var _arg0 *C.GstDeviceMonitor // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstDeviceMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gst_device_monitor_get_show_all_devices(_arg0)
	runtime.KeepAlive(monitor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveFilter removes a filter from the DeviceMonitor using the id that was
// returned by gst_device_monitor_add_filter().
//
// The function takes the following parameters:
//
//   - filterId: id of the filter.
//
// The function returns the following values:
//
//   - ok: TRUE of the filter id was valid, FALSE otherwise.
func (monitor *DeviceMonitor) RemoveFilter(filterId uint) bool {
	var _arg0 *C.GstDeviceMonitor // out
	var _arg1 C.guint             // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstDeviceMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	_arg1 = C.guint(filterId)

	_cret = C.gst_device_monitor_remove_filter(_arg0, _arg1)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(filterId)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetShowAllDevices: set if all devices should be visible, even those devices
// from hidden providers. Setting show_all to true might show some devices
// multiple times.
//
// The function takes the following parameters:
//
//   - showAll: show all devices.
func (monitor *DeviceMonitor) SetShowAllDevices(showAll bool) {
	var _arg0 *C.GstDeviceMonitor // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GstDeviceMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	if showAll {
		_arg1 = C.TRUE
	}

	C.gst_device_monitor_set_show_all_devices(_arg0, _arg1)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(showAll)
}

// Start starts monitoring the devices, one this has succeeded, the
// GST_MESSAGE_DEVICE_ADDED and GST_MESSAGE_DEVICE_REMOVED messages will be
// emitted on the bus when the list of devices changes.
//
// The function returns the following values:
//
//   - ok: TRUE if the device monitoring could be started, i.e. at least a
//     single device provider was started successfully.
func (monitor *DeviceMonitor) Start() bool {
	var _arg0 *C.GstDeviceMonitor // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstDeviceMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.gst_device_monitor_start(_arg0)
	runtime.KeepAlive(monitor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Stop stops monitoring the devices.
func (monitor *DeviceMonitor) Stop() {
	var _arg0 *C.GstDeviceMonitor // out

	_arg0 = (*C.GstDeviceMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	C.gst_device_monitor_stop(_arg0)
	runtime.KeepAlive(monitor)
}

// DeviceProviderOverrides contains methods that are overridable.
type DeviceProviderOverrides struct {
	// Start starts providering the devices. This will cause
	// T_MESSAGE_DEVICE_ADDED and T_MESSAGE_DEVICE_REMOVED messages to be posted
	// on the provider's bus when devices are added or removed from the system.
	//
	// Since the DeviceProvider is a singleton, gst_device_provider_start()
	// may already have been called by another user of the object,
	// gst_device_provider_stop() needs to be called the same number of times.
	//
	// After this function has been called, gst_device_provider_get_devices()
	// will return the same objects that have been received from the
	// T_MESSAGE_DEVICE_ADDED messages and will no longer probe.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if the device providering could be started.
	Start func() bool
	// Stop decreases the use-count by one. If the use count reaches zero, this
	// DeviceProvider will stop providering the devices. This needs to be called
	// the same number of times that gst_device_provider_start() was called.
	Stop func()
}

func defaultDeviceProviderOverrides(v *DeviceProvider) DeviceProviderOverrides {
	return DeviceProviderOverrides{
		Start: v.start,
		Stop:  v.stop,
	}
}

// DeviceProvider subclass is provided by a plugin that handles devices if there
// is a way to programmatically list connected devices. It can also optionally
// provide updates to the list of connected devices.
//
// Each DeviceProvider subclass is a singleton, a plugin should normally provide
// a single subclass for all devices.
//
// Applications would normally use a DeviceMonitor to monitor devices from all
// relevant providers.
type DeviceProvider struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*DeviceProvider)(nil)
)

// DeviceProviderer describes types inherited from class DeviceProvider.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type DeviceProviderer interface {
	coreglib.Objector
	baseDeviceProvider() *DeviceProvider
}

var _ DeviceProviderer = (*DeviceProvider)(nil)

func init() {
	coreglib.RegisterClassInfo[*DeviceProvider, *DeviceProviderClass, DeviceProviderOverrides](
		GTypeDeviceProvider,
		initDeviceProviderClass,
		wrapDeviceProvider,
		defaultDeviceProviderOverrides,
	)
}

func initDeviceProviderClass(gclass unsafe.Pointer, overrides DeviceProviderOverrides, classInitFunc func(*DeviceProviderClass)) {
	pclass := (*C.GstDeviceProviderClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeDeviceProvider))))

	if overrides.Start != nil {
		pclass.start = (*[0]byte)(C._gotk4_gst1_DeviceProviderClass_start)
	}

	if overrides.Stop != nil {
		pclass.stop = (*[0]byte)(C._gotk4_gst1_DeviceProviderClass_stop)
	}

	if classInitFunc != nil {
		class := (*DeviceProviderClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDeviceProvider(obj *coreglib.Object) *DeviceProvider {
	return &DeviceProvider{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalDeviceProvider(p uintptr) (interface{}, error) {
	return wrapDeviceProvider(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (provider *DeviceProvider) baseDeviceProvider() *DeviceProvider {
	return provider
}

// BaseDeviceProvider returns the underlying base object.
func BaseDeviceProvider(obj DeviceProviderer) *DeviceProvider {
	return obj.baseDeviceProvider()
}

func (provider *DeviceProvider) ConnectProviderHidden(f func(object string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(provider, "provider-hidden", false, unsafe.Pointer(C._gotk4_gst1_DeviceProvider_ConnectProviderHidden), f)
}

func (provider *DeviceProvider) ConnectProviderUnhidden(f func(object string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(provider, "provider-unhidden", false, unsafe.Pointer(C._gotk4_gst1_DeviceProvider_ConnectProviderUnhidden), f)
}

func (provider *DeviceProvider) CanMonitor() bool {
	var _arg0 *C.GstDeviceProvider // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstDeviceProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	_cret = C.gst_device_provider_can_monitor(_arg0)
	runtime.KeepAlive(provider)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DeviceAdd posts a message on the provider's Bus to inform applications that a
// new device has been added.
//
// This is for use by subclasses.
//
// device's reference count will be incremented, and any floating reference will
// be removed (see gst_object_ref_sink()).
//
// The function takes the following parameters:
//
//   - device that has been added.
func (provider *DeviceProvider) DeviceAdd(device Devicer) {
	var _arg0 *C.GstDeviceProvider // out
	var _arg1 *C.GstDevice         // out

	_arg0 = (*C.GstDeviceProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))
	_arg1 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	C.gst_device_provider_device_add(_arg0, _arg1)
	runtime.KeepAlive(provider)
	runtime.KeepAlive(device)
}

// DeviceChanged: this function is used when changed_device was modified into
// its new form device. This will post a DEVICE_CHANGED message on the bus to
// let the application know that the device was modified. Device is immutable
// for MT. safety purposes so this is an "atomic" way of letting the application
// know when a device was modified.
//
// The function takes the following parameters:
//
//   - device: new version of changed_device.
//   - changedDevice: old version of the device that has been updated.
func (provider *DeviceProvider) DeviceChanged(device, changedDevice Devicer) {
	var _arg0 *C.GstDeviceProvider // out
	var _arg1 *C.GstDevice         // out
	var _arg2 *C.GstDevice         // out

	_arg0 = (*C.GstDeviceProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))
	_arg1 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg2 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(changedDevice).Native()))

	C.gst_device_provider_device_changed(_arg0, _arg1, _arg2)
	runtime.KeepAlive(provider)
	runtime.KeepAlive(device)
	runtime.KeepAlive(changedDevice)
}

// DeviceRemove posts a message on the provider's Bus to inform applications
// that a device has been removed.
//
// This is for use by subclasses.
//
// The function takes the following parameters:
//
//   - device that has been removed.
func (provider *DeviceProvider) DeviceRemove(device Devicer) {
	var _arg0 *C.GstDeviceProvider // out
	var _arg1 *C.GstDevice         // out

	_arg0 = (*C.GstDeviceProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))
	_arg1 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	C.gst_device_provider_device_remove(_arg0, _arg1)
	runtime.KeepAlive(provider)
	runtime.KeepAlive(device)
}

// Bus gets the Bus of this DeviceProvider.
//
// The function returns the following values:
//
//   - bus: Bus.
func (provider *DeviceProvider) Bus() *Bus {
	var _arg0 *C.GstDeviceProvider // out
	var _cret *C.GstBus            // in

	_arg0 = (*C.GstDeviceProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	_cret = C.gst_device_provider_get_bus(_arg0)
	runtime.KeepAlive(provider)

	var _bus *Bus // out

	_bus = wrapBus(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _bus
}

// Devices gets a list of devices that this provider understands. This may
// actually probe the hardware if the provider is not currently started.
//
// If the provider has been started, this will returned the same Device objedcts
// that have been returned by the T_MESSAGE_DEVICE_ADDED messages.
//
// The function returns the following values:
//
//   - list of Device.
func (provider *DeviceProvider) Devices() []Devicer {
	var _arg0 *C.GstDeviceProvider // out
	var _cret *C.GList             // in

	_arg0 = (*C.GstDeviceProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	_cret = C.gst_device_provider_get_devices(_arg0)
	runtime.KeepAlive(provider)

	var _list []Devicer // out

	_list = make([]Devicer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstDevice)(v)
		var dst Devicer // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gst.Devicer is nil")
			}

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Devicer)
				return ok
			})
			rv, ok := casted.(Devicer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Devicer")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// Factory retrieves the factory that was used to create this device provider.
//
// The function returns the following values:
//
//   - deviceProviderFactory (optional) used for creating this device provider.
//     no refcounting is needed.
func (provider *DeviceProvider) Factory() *DeviceProviderFactory {
	var _arg0 *C.GstDeviceProvider        // out
	var _cret *C.GstDeviceProviderFactory // in

	_arg0 = (*C.GstDeviceProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	_cret = C.gst_device_provider_get_factory(_arg0)
	runtime.KeepAlive(provider)

	var _deviceProviderFactory *DeviceProviderFactory // out

	if _cret != nil {
		_deviceProviderFactory = wrapDeviceProviderFactory(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _deviceProviderFactory
}

// HiddenProviders: get the provider factory names of the DeviceProvider
// instances that are hidden by provider.
//
// The function returns the following values:
//
//   - utf8s: a list of hidden providers factory names or NULL when nothing is
//     hidden by provider. Free with g_strfreev.
func (provider *DeviceProvider) HiddenProviders() []string {
	var _arg0 *C.GstDeviceProvider // out
	var _cret **C.gchar            // in

	_arg0 = (*C.GstDeviceProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	_cret = C.gst_device_provider_get_hidden_providers(_arg0)
	runtime.KeepAlive(provider)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// Metadata: get metadata with key in provider.
//
// The function takes the following parameters:
//
//   - key to get.
//
// The function returns the following values:
//
//   - utf8: metadata for key.
func (provider *DeviceProvider) Metadata(key string) string {
	var _arg0 *C.GstDeviceProvider // out
	var _arg1 *C.gchar             // out
	var _cret *C.gchar             // in

	_arg0 = (*C.GstDeviceProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_device_provider_get_metadata(_arg0, _arg1)
	runtime.KeepAlive(provider)
	runtime.KeepAlive(key)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// HideProvider: make provider hide the devices from the factory with name.
//
// This function is used when provider will also provide the devices reported by
// provider factory name. A monitor should stop monitoring the device provider
// with name to avoid duplicate devices.
//
// The function takes the following parameters:
//
//   - name: provider factory name.
func (provider *DeviceProvider) HideProvider(name string) {
	var _arg0 *C.GstDeviceProvider // out
	var _arg1 *C.gchar             // out

	_arg0 = (*C.GstDeviceProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_device_provider_hide_provider(_arg0, _arg1)
	runtime.KeepAlive(provider)
	runtime.KeepAlive(name)
}

// IsStarted: this function can be used to know if the provider was successfully
// started.
func (provider *DeviceProvider) IsStarted() bool {
	var _arg0 *C.GstDeviceProvider // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstDeviceProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	_cret = C.gst_device_provider_is_started(_arg0)
	runtime.KeepAlive(provider)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Start starts providering the devices. This will cause T_MESSAGE_DEVICE_ADDED
// and T_MESSAGE_DEVICE_REMOVED messages to be posted on the provider's bus when
// devices are added or removed from the system.
//
// Since the DeviceProvider is a singleton, gst_device_provider_start()
// may already have been called by another user of the object,
// gst_device_provider_stop() needs to be called the same number of times.
//
// After this function has been called, gst_device_provider_get_devices()
// will return the same objects that have been received from the
// T_MESSAGE_DEVICE_ADDED messages and will no longer probe.
//
// The function returns the following values:
//
//   - ok: TRUE if the device providering could be started.
func (provider *DeviceProvider) Start() bool {
	var _arg0 *C.GstDeviceProvider // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstDeviceProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	_cret = C.gst_device_provider_start(_arg0)
	runtime.KeepAlive(provider)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Stop decreases the use-count by one. If the use count reaches zero, this
// DeviceProvider will stop providering the devices. This needs to be called the
// same number of times that gst_device_provider_start() was called.
func (provider *DeviceProvider) Stop() {
	var _arg0 *C.GstDeviceProvider // out

	_arg0 = (*C.GstDeviceProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	C.gst_device_provider_stop(_arg0)
	runtime.KeepAlive(provider)
}

// UnhideProvider: make provider unhide the devices from factory name.
//
// This function is used when provider will no longer provide the devices
// reported by provider factory name. A monitor should start monitoring the
// devices from provider factory name in order to see all devices again.
//
// The function takes the following parameters:
//
//   - name: provider factory name.
func (provider *DeviceProvider) UnhideProvider(name string) {
	var _arg0 *C.GstDeviceProvider // out
	var _arg1 *C.gchar             // out

	_arg0 = (*C.GstDeviceProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_device_provider_unhide_provider(_arg0, _arg1)
	runtime.KeepAlive(provider)
	runtime.KeepAlive(name)
}

// Start starts providering the devices. This will cause T_MESSAGE_DEVICE_ADDED
// and T_MESSAGE_DEVICE_REMOVED messages to be posted on the provider's bus when
// devices are added or removed from the system.
//
// Since the DeviceProvider is a singleton, gst_device_provider_start()
// may already have been called by another user of the object,
// gst_device_provider_stop() needs to be called the same number of times.
//
// After this function has been called, gst_device_provider_get_devices()
// will return the same objects that have been received from the
// T_MESSAGE_DEVICE_ADDED messages and will no longer probe.
//
// The function returns the following values:
//
//   - ok: TRUE if the device providering could be started.
func (provider *DeviceProvider) start() bool {
	gclass := (*C.GstDeviceProviderClass)(coreglib.PeekParentClass(provider))
	fnarg := gclass.start

	var _arg0 *C.GstDeviceProvider // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstDeviceProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	_cret = C._gotk4_gst1_DeviceProvider_virtual_start(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(provider)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Stop decreases the use-count by one. If the use count reaches zero, this
// DeviceProvider will stop providering the devices. This needs to be called the
// same number of times that gst_device_provider_start() was called.
func (provider *DeviceProvider) stop() {
	gclass := (*C.GstDeviceProviderClass)(coreglib.PeekParentClass(provider))
	fnarg := gclass.stop

	var _arg0 *C.GstDeviceProvider // out

	_arg0 = (*C.GstDeviceProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	C._gotk4_gst1_DeviceProvider_virtual_stop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(provider)
}

// DeviceProviderRegister: create a new device providerfactory capable of
// instantiating objects of the type and add the factory to plugin.
//
// The function takes the following parameters:
//
//   - plugin (optional) to register the device provider with, or NULL for a
//     static device provider.
//   - name of device providers of this type.
//   - rank of device provider (higher rank means more importance when
//     autoplugging).
//   - typ: GType of device provider to register.
//
// The function returns the following values:
//
//   - ok: TRUE, if the registering succeeded, FALSE on error.
func DeviceProviderRegister(plugin *Plugin, name string, rank uint, typ coreglib.Type) bool {
	var _arg1 *C.GstPlugin // out
	var _arg2 *C.gchar     // out
	var _arg3 C.guint      // out
	var _arg4 C.GType      // out
	var _cret C.gboolean   // in

	if plugin != nil {
		_arg1 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.guint(rank)
	_arg4 = C.GType(typ)

	_cret = C.gst_device_provider_register(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(plugin)
	runtime.KeepAlive(name)
	runtime.KeepAlive(rank)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DeviceProviderFactory is used to create instances of device providers.
// A GstDeviceProviderfactory can be added to a Plugin as it is also a
// PluginFeature.
//
// Use the gst_device_provider_factory_find() and
// gst_device_provider_factory_get() functions to create device provider
// instances or use gst_device_provider_factory_get_by_name() as a convenient
// shortcut.
type DeviceProviderFactory struct {
	_ [0]func() // equal guard
	PluginFeature
}

var (
	_ PluginFeaturer = (*DeviceProviderFactory)(nil)
)

func wrapDeviceProviderFactory(obj *coreglib.Object) *DeviceProviderFactory {
	return &DeviceProviderFactory{
		PluginFeature: PluginFeature{
			GstObject: GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalDeviceProviderFactory(p uintptr) (interface{}, error) {
	return wrapDeviceProviderFactory(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Get returns the device provider of the type defined by the given device
// providerfactory.
//
// The function returns the following values:
//
//   - deviceProvider (optional) or NULL if the device provider couldn't be
//     created.
func (factory *DeviceProviderFactory) Get() DeviceProviderer {
	var _arg0 *C.GstDeviceProviderFactory // out
	var _cret *C.GstDeviceProvider        // in

	_arg0 = (*C.GstDeviceProviderFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))

	_cret = C.gst_device_provider_factory_get(_arg0)
	runtime.KeepAlive(factory)

	var _deviceProvider DeviceProviderer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(DeviceProviderer)
				return ok
			})
			rv, ok := casted.(DeviceProviderer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.DeviceProviderer")
			}
			_deviceProvider = rv
		}
	}

	return _deviceProvider
}

// DeviceProviderType: get the #GType for device providers managed by this
// factory. The type can only be retrieved if the device provider factory is
// loaded, which can be assured with gst_plugin_feature_load().
//
// The function returns the following values:
//
//   - gType for device providers managed by this factory.
func (factory *DeviceProviderFactory) DeviceProviderType() coreglib.Type {
	var _arg0 *C.GstDeviceProviderFactory // out
	var _cret C.GType                     // in

	_arg0 = (*C.GstDeviceProviderFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))

	_cret = C.gst_device_provider_factory_get_device_provider_type(_arg0)
	runtime.KeepAlive(factory)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// Metadata: get the metadata on factory with key.
//
// The function takes the following parameters:
//
//   - key: key.
//
// The function returns the following values:
//
//   - utf8 (optional): metadata with key on factory or NULL when there was no
//     metadata with the given key.
func (factory *DeviceProviderFactory) Metadata(key string) string {
	var _arg0 *C.GstDeviceProviderFactory // out
	var _arg1 *C.gchar                    // out
	var _cret *C.gchar                    // in

	_arg0 = (*C.GstDeviceProviderFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_device_provider_factory_get_metadata(_arg0, _arg1)
	runtime.KeepAlive(factory)
	runtime.KeepAlive(key)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// MetadataKeys: get the available keys for the metadata on factory.
//
// The function returns the following values:
//
//   - utf8s (optional): a NULL-terminated array of key strings, or NULL when
//     there is no metadata. Free with g_strfreev() when no longer needed.
func (factory *DeviceProviderFactory) MetadataKeys() []string {
	var _arg0 *C.GstDeviceProviderFactory // out
	var _cret **C.gchar                   // in

	_arg0 = (*C.GstDeviceProviderFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))

	_cret = C.gst_device_provider_factory_get_metadata_keys(_arg0)
	runtime.KeepAlive(factory)

	var _utf8s []string // out

	if _cret != nil {
		defer C.free(unsafe.Pointer(_cret))
		{
			var i int
			var z *C.gchar
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
				defer C.free(unsafe.Pointer(src[i]))
			}
		}
	}

	return _utf8s
}

// HasClasses: check if factory matches all of the given classes.
//
// The function takes the following parameters:
//
//   - classes (optional): "/" separate list of classes to match, only match if
//     all classes are matched.
//
// The function returns the following values:
//
//   - ok: TRUE if factory matches or if classes is NULL.
func (factory *DeviceProviderFactory) HasClasses(classes string) bool {
	var _arg0 *C.GstDeviceProviderFactory // out
	var _arg1 *C.gchar                    // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.GstDeviceProviderFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	if classes != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(classes)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_device_provider_factory_has_classes(_arg0, _arg1)
	runtime.KeepAlive(factory)
	runtime.KeepAlive(classes)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasClassesv: check if factory matches all of the given classes.
//
// The function takes the following parameters:
//
//   - classes (optional): NULL terminated array of classes to match, only match
//     if all classes are matched.
//
// The function returns the following values:
//
//   - ok: TRUE if factory matches.
func (factory *DeviceProviderFactory) HasClassesv(classes []string) bool {
	var _arg0 *C.GstDeviceProviderFactory // out
	var _arg1 **C.gchar                   // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.GstDeviceProviderFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(classes) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(classes)+1)
			var zero *C.gchar
			out[len(classes)] = zero
			for i := range classes {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(classes[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.gst_device_provider_factory_has_classesv(_arg0, _arg1)
	runtime.KeepAlive(factory)
	runtime.KeepAlive(classes)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DeviceProviderFactoryFind: search for an device provider factory of the given
// name. Refs the returned device provider factory; caller is responsible for
// unreffing.
//
// The function takes the following parameters:
//
//   - name of factory to find.
//
// The function returns the following values:
//
//   - deviceProviderFactory (optional) if found, NULL otherwise.
func DeviceProviderFactoryFind(name string) *DeviceProviderFactory {
	var _arg1 *C.gchar                    // out
	var _cret *C.GstDeviceProviderFactory // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_device_provider_factory_find(_arg1)
	runtime.KeepAlive(name)

	var _deviceProviderFactory *DeviceProviderFactory // out

	if _cret != nil {
		_deviceProviderFactory = wrapDeviceProviderFactory(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _deviceProviderFactory
}

// DeviceProviderFactoryGetByName returns the device provider of the type
// defined by the given device provider factory.
//
// The function takes the following parameters:
//
//   - factoryname: named factory to instantiate.
//
// The function returns the following values:
//
//   - deviceProvider (optional) or NULL if unable to create device provider.
func DeviceProviderFactoryGetByName(factoryname string) DeviceProviderer {
	var _arg1 *C.gchar             // out
	var _cret *C.GstDeviceProvider // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(factoryname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_device_provider_factory_get_by_name(_arg1)
	runtime.KeepAlive(factoryname)

	var _deviceProvider DeviceProviderer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(DeviceProviderer)
				return ok
			})
			rv, ok := casted.(DeviceProviderer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.DeviceProviderer")
			}
			_deviceProvider = rv
		}
	}

	return _deviceProvider
}

// DeviceProviderFactoryListGetDeviceProviders: get a list of factories with
// a rank greater or equal to minrank. The list of factories is returned by
// decreasing rank.
//
// The function takes the following parameters:
//
//   - minrank: minimum rank.
//
// The function returns the following values:
//
//   - list: a #GList of DeviceProviderFactory device providers. Use
//     gst_plugin_feature_list_free() after usage.
func DeviceProviderFactoryListGetDeviceProviders(minrank Rank) []*DeviceProviderFactory {
	var _arg1 C.GstRank // out
	var _cret *C.GList  // in

	_arg1 = C.GstRank(minrank)

	_cret = C.gst_device_provider_factory_list_get_device_providers(_arg1)
	runtime.KeepAlive(minrank)

	var _list []*DeviceProviderFactory // out

	_list = make([]*DeviceProviderFactory, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstDeviceProviderFactory)(v)
		var dst *DeviceProviderFactory // out
		dst = wrapDeviceProviderFactory(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// DoubleRange: fundamental type that describes a #gdouble range.
type DoubleRange struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*DoubleRange)(nil)
)

func wrapDoubleRange(obj *coreglib.Object) *DoubleRange {
	return &DoubleRange{
		Object: obj,
	}
}

func marshalDoubleRange(p uintptr) (interface{}, error) {
	return wrapDoubleRange(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// DynamicTypeFactory is used to represent a type that can be automatically
// loaded the first time it is used. For example, a non-standard type for use in
// caps fields.
//
// In general, applications and plugins don't need to use the factory beyond
// registering the type in a plugin init function. Once that is done, the type
// is stored in the registry, and ready as soon as the registry is loaded.
//
// # Registering a type for dynamic loading
//
//	static gboolean
//	plugin_init (GstPlugin * plugin)
//	{
//	  return gst_dynamic_type_register (plugin, GST_TYPE_CUSTOM_CAPS_FIELD);
//	}.
type DynamicTypeFactory struct {
	_ [0]func() // equal guard
	PluginFeature
}

var (
	_ PluginFeaturer = (*DynamicTypeFactory)(nil)
)

func wrapDynamicTypeFactory(obj *coreglib.Object) *DynamicTypeFactory {
	return &DynamicTypeFactory{
		PluginFeature: PluginFeature{
			GstObject: GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalDynamicTypeFactory(p uintptr) (interface{}, error) {
	return wrapDynamicTypeFactory(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func DynamicTypeFactoryLoad(factoryname string) coreglib.Type {
	var _arg1 *C.gchar // out
	var _cret C.GType  // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(factoryname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_dynamic_type_factory_load(_arg1)
	runtime.KeepAlive(factoryname)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// ElementOverrides contains methods that are overridable.
type ElementOverrides struct {
	// ChangeState: perform transition on element.
	//
	// This function must be called with STATE_LOCK held and is mainly used
	// internally.
	//
	// The function takes the following parameters:
	//
	//   - transition: requested transition.
	//
	// The function returns the following values:
	//
	//   - stateChangeReturn of the state transition.
	ChangeState func(transition StateChange) StateChangeReturn
	// State gets the state of the element.
	//
	// For elements that performed an ASYNC state change, as reported by
	// gst_element_set_state(), this function will block up to the specified
	// timeout value for the state change to complete. If the element
	// completes the state change or goes into an error, this function
	// returns immediately with a return value of GST_STATE_CHANGE_SUCCESS or
	// GST_STATE_CHANGE_FAILURE respectively.
	//
	// For elements that did not return GST_STATE_CHANGE_ASYNC, this function
	// returns the current and pending state immediately.
	//
	// This function returns GST_STATE_CHANGE_NO_PREROLL if the element
	// successfully changed its state but is not able to provide data yet.
	// This mostly happens for live sources that only produce data in
	// GST_STATE_PLAYING. While the state change return is equivalent to
	// GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal
	// that some sink elements might not be able to complete their state change
	// because an element is not producing data to complete the preroll. When
	// setting the element to playing, the preroll will complete and playback
	// will start.
	//
	// The function takes the following parameters:
	//
	//   - timeout to specify the timeout for an async state change or
	//     GST_CLOCK_TIME_NONE for infinite timeout.
	//
	// The function returns the following values:
	//
	//   - state (optional): pointer to State to hold the state. Can be NULL.
	//
	//   - pending (optional): pointer to State to hold the pending state.
	//     Can be NULL.
	//
	//   - stateChangeReturn: GST_STATE_CHANGE_SUCCESS if the element
	//     has no more pending state and the last state change succeeded,
	//     GST_STATE_CHANGE_ASYNC if the element is still performing a state
	//     change or GST_STATE_CHANGE_FAILURE if the last state change failed.
	//
	//     MT safe.
	State func(timeout ClockTime) (state, pending State, stateChangeReturn StateChangeReturn)
	// NoMorePads: use this function to signal that the element does not expect
	// any more pads to show up in the current pipeline. This function should be
	// called whenever pads have been added by the element itself. Elements with
	// T_PAD_SOMETIMES pad templates use this in combination with autopluggers
	// to figure out that the element is done initializing its pads.
	//
	// This function emits the Element::no-more-pads signal.
	//
	// MT safe.
	NoMorePads func()
	PadAdded   func(pad *Pad)
	PadRemoved func(pad *Pad)
	// PostMessage: post a message on the element's Bus. This function takes
	// ownership of the message; if you want to access the message after this
	// call, you should add an additional reference before calling.
	//
	// The function takes the following parameters:
	//
	//   - message to post.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if the message was successfully posted. The function returns
	//     FALSE if the element did not have a bus.
	//
	//     MT safe.
	PostMessage func(message *Message) bool
	// ProvideClock: get the clock provided by the given element. > An element
	// is only required to provide a clock in the PAUSED > state. Some elements
	// can provide a clock in other states.
	//
	// The function returns the following values:
	//
	//   - clock (optional): gstClock provided by the element or NULL if no
	//     clock could be provided. Unref after usage.
	//
	//     MT safe.
	ProvideClock func() Clocker
	// Query performs a query on the given element.
	//
	// For elements that don't implement a query handler, this function forwards
	// the query to a random srcpad or to the peer of a random linked sinkpad of
	// this element.
	//
	// Please note that some queries might need a running pipeline to work.
	//
	// The function takes the following parameters:
	//
	//   - query: Query.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if the query could be performed.
	//
	//     MT safe.
	Query func(query *Query) bool
	// ReleasePad: called when a request pad is to be released.
	ReleasePad func(pad *Pad)
	// SendEvent sends an event to an element. If the element doesn't implement
	// an event handler, the event will be pushed on a random linked sink pad
	// for downstream events or a random linked source pad for upstream events.
	//
	// This function takes ownership of the provided event so you should
	// gst_event_ref() it if you want to reuse the event after this call.
	//
	// MT safe.
	//
	// The function takes the following parameters:
	//
	//   - event to send to the element.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if the event was handled. Events that trigger a preroll
	//     (such as flushing seeks and steps) will emit GST_MESSAGE_ASYNC_DONE.
	SendEvent func(event *Event) bool
	// SetBus sets the bus of the element. Increases the refcount on the bus.
	// For internal use only, unless you're testing elements.
	//
	// MT safe.
	//
	// The function takes the following parameters:
	//
	//   - bus (optional) to set.
	SetBus func(bus *Bus)
	// SetClock sets the clock for the element. This function increases
	// the refcount on the clock. Any previously set clock on the object is
	// unreffed.
	//
	// The function takes the following parameters:
	//
	//   - clock (optional) to set for the element.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if the element accepted the clock. An element can refuse a
	//     clock when it, for example, is not able to slave its internal clock
	//     to the clock or when it requires a specific clock to operate.
	//
	//     MT safe.
	SetClock func(clock Clocker) bool
	// SetContext sets the context of the element. Increases the refcount of the
	// context.
	//
	// MT safe.
	//
	// The function takes the following parameters:
	//
	//   - context to set.
	SetContext func(context *Context)
	// SetState sets the state of the element. This function will try to set the
	// requested state by going through all the intermediary states and calling
	// the class's state change function for each.
	//
	// This function can return T_STATE_CHANGE_ASYNC, in which case the
	// element will perform the remainder of the state change asynchronously
	// in another thread. An application can use gst_element_get_state()
	// to wait for the completion of the state change or it can wait for a
	// GST_MESSAGE_ASYNC_DONE or GST_MESSAGE_STATE_CHANGED on the bus.
	//
	// State changes to GST_STATE_READY or GST_STATE_NULL never return
	// T_STATE_CHANGE_ASYNC.
	//
	// The function takes the following parameters:
	//
	//   - state element's new State.
	//
	// The function returns the following values:
	//
	//   - stateChangeReturn: result of the state change using
	//     StateChangeReturn.
	//
	//     MT safe.
	SetState func(state State) StateChangeReturn
	// StateChanged: called immediately after a new state was set.
	//
	// The function takes the following parameters:
	//
	//   - oldstate
	//   - newstate
	//   - pending
	StateChanged func(oldstate, newstate, pending State)
}

func defaultElementOverrides(v *Element) ElementOverrides {
	return ElementOverrides{
		ChangeState:  v.changeState,
		State:        v.state,
		NoMorePads:   v.noMorePads,
		PadAdded:     v.padAdded,
		PadRemoved:   v.padRemoved,
		PostMessage:  v.postMessage,
		ProvideClock: v.provideClock,
		Query:        v.query,
		ReleasePad:   v.releasePad,
		SendEvent:    v.sendEvent,
		SetBus:       v.setBus,
		SetClock:     v.setClock,
		SetContext:   v.setContext,
		SetState:     v.setState,
		StateChanged: v.stateChanged,
	}
}

// Element is the abstract base class needed to construct an element that can
// be used in a GStreamer pipeline. Please refer to the plugin writers guide for
// more information on creating Element subclasses.
//
// The name of a Element can be get with gst_element_get_name() and set with
// gst_element_set_name(). For speed, GST_ELEMENT_NAME() can be used in the
// core when using the appropriate locking. Do not use this in plug-ins or
// applications in order to retain ABI compatibility.
//
// Elements can have pads (of the type Pad). These pads link to pads on other
// elements. Buffer flow between these linked pads. A Element has a #GList of
// Pad structures for all their input (or sink) and output (or source) pads.
// Core and plug-in writers can add and remove pads with gst_element_add_pad()
// and gst_element_remove_pad().
//
// An existing pad of an element can be retrieved by name with
// gst_element_get_static_pad(). A new dynamic pad can be created using
// gst_element_request_pad() with a PadTemplate. An iterator of all pads can be
// retrieved with gst_element_iterate_pads().
//
// Elements can be linked through their pads. If the link is straightforward,
// use the gst_element_link() convenience function to link two
// elements, or gst_element_link_many() for more elements in a row.
// Use gst_element_link_filtered() to link two elements constrained by a
// specified set of Caps. For finer control, use gst_element_link_pads() and
// gst_element_link_pads_filtered() to specify the pads to link on each element
// by name.
//
// Each element has a state (see State). You can get and set the state of an
// element with gst_element_get_state() and gst_element_set_state(). Setting
// a state triggers a StateChange. To get a string representation of a State,
// use gst_element_state_get_name().
//
// You can get and set a Clock on an element using gst_element_get_clock()
// and gst_element_set_clock(). Some elements can provide a clock for
// the pipeline if the T_ELEMENT_FLAG_PROVIDE_CLOCK flag is set. With the
// gst_element_provide_clock() method one can retrieve the clock provided by
// such an element. Not all elements require a clock to operate correctly.
// If the T_ELEMENT_FLAG_REQUIRE_CLOCK() flag is set, a clock should be set on
// the element with gst_element_set_clock().
//
// Note that clock selection and distribution is normally handled by the
// toplevel Pipeline so the clock functions are only to be used in very specific
// situations.
type Element struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*Element)(nil)
)

// Elementer describes types inherited from class Element.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Elementer interface {
	coreglib.Objector
	baseElement() *Element
}

var _ Elementer = (*Element)(nil)

func init() {
	coreglib.RegisterClassInfo[*Element, *ElementClass, ElementOverrides](
		GTypeElement,
		initElementClass,
		wrapElement,
		defaultElementOverrides,
	)
}

func initElementClass(gclass unsafe.Pointer, overrides ElementOverrides, classInitFunc func(*ElementClass)) {
	pclass := (*C.GstElementClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeElement))))

	if overrides.ChangeState != nil {
		pclass.change_state = (*[0]byte)(C._gotk4_gst1_ElementClass_change_state)
	}

	if overrides.State != nil {
		pclass.get_state = (*[0]byte)(C._gotk4_gst1_ElementClass_get_state)
	}

	if overrides.NoMorePads != nil {
		pclass.no_more_pads = (*[0]byte)(C._gotk4_gst1_ElementClass_no_more_pads)
	}

	if overrides.PadAdded != nil {
		pclass.pad_added = (*[0]byte)(C._gotk4_gst1_ElementClass_pad_added)
	}

	if overrides.PadRemoved != nil {
		pclass.pad_removed = (*[0]byte)(C._gotk4_gst1_ElementClass_pad_removed)
	}

	if overrides.PostMessage != nil {
		pclass.post_message = (*[0]byte)(C._gotk4_gst1_ElementClass_post_message)
	}

	if overrides.ProvideClock != nil {
		pclass.provide_clock = (*[0]byte)(C._gotk4_gst1_ElementClass_provide_clock)
	}

	if overrides.Query != nil {
		pclass.query = (*[0]byte)(C._gotk4_gst1_ElementClass_query)
	}

	if overrides.ReleasePad != nil {
		pclass.release_pad = (*[0]byte)(C._gotk4_gst1_ElementClass_release_pad)
	}

	if overrides.SendEvent != nil {
		pclass.send_event = (*[0]byte)(C._gotk4_gst1_ElementClass_send_event)
	}

	if overrides.SetBus != nil {
		pclass.set_bus = (*[0]byte)(C._gotk4_gst1_ElementClass_set_bus)
	}

	if overrides.SetClock != nil {
		pclass.set_clock = (*[0]byte)(C._gotk4_gst1_ElementClass_set_clock)
	}

	if overrides.SetContext != nil {
		pclass.set_context = (*[0]byte)(C._gotk4_gst1_ElementClass_set_context)
	}

	if overrides.SetState != nil {
		pclass.set_state = (*[0]byte)(C._gotk4_gst1_ElementClass_set_state)
	}

	if overrides.StateChanged != nil {
		pclass.state_changed = (*[0]byte)(C._gotk4_gst1_ElementClass_state_changed)
	}

	if classInitFunc != nil {
		class := (*ElementClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapElement(obj *coreglib.Object) *Element {
	return &Element{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalElement(p uintptr) (interface{}, error) {
	return wrapElement(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (element *Element) baseElement() *Element {
	return element
}

// BaseElement returns the underlying base object.
func BaseElement(obj Elementer) *Element {
	return obj.baseElement()
}

// ConnectNoMorePads: this signals that the element will not generate more
// dynamic pads. Note that this signal will usually be emitted from the context
// of the streaming thread.
func (element *Element) ConnectNoMorePads(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(element, "no-more-pads", false, unsafe.Pointer(C._gotk4_gst1_Element_ConnectNoMorePads), f)
}

// ConnectPadAdded: new Pad has been added to the element. Note that this
// signal will usually be emitted from the context of the streaming thread.
// Also keep in mind that if you add new elements to the pipeline in the
// signal handler you will need to set them to the desired target state with
// gst_element_set_state() or gst_element_sync_state_with_parent().
func (element *Element) ConnectPadAdded(f func(newPad *Pad)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(element, "pad-added", false, unsafe.Pointer(C._gotk4_gst1_Element_ConnectPadAdded), f)
}

// ConnectPadRemoved has been removed from the element.
func (element *Element) ConnectPadRemoved(f func(oldPad *Pad)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(element, "pad-removed", false, unsafe.Pointer(C._gotk4_gst1_Element_ConnectPadRemoved), f)
}

// AbortState: abort the state change of the element. This function is used by
// elements that do asynchronous state changes and find out something is wrong.
//
// This function should be called with the STATE_LOCK held.
//
// MT safe.
func (element *Element) AbortState() {
	var _arg0 *C.GstElement // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	C.gst_element_abort_state(_arg0)
	runtime.KeepAlive(element)
}

// AddPad adds a pad (link point) to element. pad's parent will be set to
// element; see gst_object_set_parent() for refcounting information.
//
// Pads are automatically activated when added in the PAUSED or PLAYING state.
//
// The pad and the element should be unlocked when calling this function.
//
// This function will emit the Element::pad-added signal on the element.
//
// The function takes the following parameters:
//
//   - pad to add to the element.
//
// The function returns the following values:
//
//   - ok: TRUE if the pad could be added. This function can fail when a pad
//     with the same name already existed or the pad already had another parent.
//
//     MT safe.
func (element *Element) AddPad(pad *Pad) bool {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstPad     // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_element_add_pad(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - propertyName (optional): name of property to watch for changes, or NULL
//     to watch all properties.
//   - includeValue: whether to include the new property value in the message.
//
// The function returns the following values:
//
//   - gulong: watch id, which can be used in connection with
//     gst_element_remove_property_notify_watch() to remove the watch again.
func (element *Element) AddPropertyDeepNotifyWatch(propertyName string, includeValue bool) uint32 {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gboolean    // out
	var _cret C.gulong      // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	if propertyName != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if includeValue {
		_arg2 = C.TRUE
	}

	_cret = C.gst_element_add_property_deep_notify_watch(_arg0, _arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(includeValue)

	var _gulong uint32 // out

	_gulong = uint32(_cret)

	return _gulong
}

// The function takes the following parameters:
//
//   - propertyName (optional): name of property to watch for changes, or NULL
//     to watch all properties.
//   - includeValue: whether to include the new property value in the message.
//
// The function returns the following values:
//
//   - gulong: watch id, which can be used in connection with
//     gst_element_remove_property_notify_watch() to remove the watch again.
func (element *Element) AddPropertyNotifyWatch(propertyName string, includeValue bool) uint32 {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gboolean    // out
	var _cret C.gulong      // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	if propertyName != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if includeValue {
		_arg2 = C.TRUE
	}

	_cret = C.gst_element_add_property_notify_watch(_arg0, _arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(includeValue)

	var _gulong uint32 // out

	_gulong = uint32(_cret)

	return _gulong
}

// CallAsync calls func from another thread and passes user_data to it.
// This is to be used for cases when a state change has to be performed from a
// streaming thread, directly via gst_element_set_state() or indirectly e.g.
// via SEEK events.
//
// Calling those functions directly from the streaming thread will cause
// deadlocks in many situations, as they might involve waiting for the streaming
// thread to shut down from this very streaming thread.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - fn: function to call asynchronously from another thread.
func (element *Element) CallAsync(fn ElementCallAsyncFunc) {
	var _arg0 *C.GstElement             // out
	var _arg1 C.GstElementCallAsyncFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gst1_ElementCallAsyncFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.gst_element_call_async(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(element)
	runtime.KeepAlive(fn)
}

// ChangeState: perform transition on element.
//
// This function must be called with STATE_LOCK held and is mainly used
// internally.
//
// The function takes the following parameters:
//
//   - transition: requested transition.
//
// The function returns the following values:
//
//   - stateChangeReturn of the state transition.
func (element *Element) ChangeState(transition StateChange) StateChangeReturn {
	var _arg0 *C.GstElement          // out
	var _arg1 C.GstStateChange       // out
	var _cret C.GstStateChangeReturn // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstStateChange(transition)

	_cret = C.gst_element_change_state(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(transition)

	var _stateChangeReturn StateChangeReturn // out

	_stateChangeReturn = StateChangeReturn(_cret)

	return _stateChangeReturn
}

// ContinueState: commit the state change of the element and proceed to the next
// pending state if any. This function is used by elements that do asynchronous
// state changes. The core will normally call this method automatically when an
// element returned GST_STATE_CHANGE_SUCCESS from the state change function.
//
// If after calling this method the element still has not reached the pending
// state, the next state change is performed.
//
// This method is used internally and should normally not be called by plugins
// or applications.
//
// This function must be called with STATE_LOCK held.
//
// The function takes the following parameters:
//
//   - ret previous state return value.
//
// The function returns the following values:
//
//   - stateChangeReturn: result of the commit state change.
//
//     MT safe.
func (element *Element) ContinueState(ret StateChangeReturn) StateChangeReturn {
	var _arg0 *C.GstElement          // out
	var _arg1 C.GstStateChangeReturn // out
	var _cret C.GstStateChangeReturn // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstStateChangeReturn(ret)

	_cret = C.gst_element_continue_state(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(ret)

	var _stateChangeReturn StateChangeReturn // out

	_stateChangeReturn = StateChangeReturn(_cret)

	return _stateChangeReturn
}

// CreateAllPads creates a pad for each pad template that is always available.
// This function is only useful during object initialization of subclasses of
// Element.
func (element *Element) CreateAllPads() {
	var _arg0 *C.GstElement // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	C.gst_element_create_all_pads(_arg0)
	runtime.KeepAlive(element)
}

// DecorateStreamID creates a stream-id for element by combining the upstream
// information with the stream_id.
//
// This function generates an unique stream-id by getting the upstream
// stream-start event stream ID and appending stream_id to it. If the element
// has no sinkpad it will generate an upstream stream-id by doing an URI
// query on the element and in the worst case just uses a random number.
// Source elements that don't implement the URI handler interface should ideally
// generate a unique, deterministic stream-id manually instead.
//
// Since stream IDs are sorted alphabetically, any numbers in the stream ID
// should be printed with a fixed number of characters, preceded by 0's, such as
// by using the format \03u instead of \u.
//
// The function takes the following parameters:
//
//   - streamId: stream-id.
//
// The function returns the following values:
//
//   - utf8: stream-id for element.
func (element *Element) DecorateStreamID(streamId string) string {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(streamId)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_decorate_stream_id(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(streamId)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ForEachPad: call func with user_data for each of element's pads. func will
// be called exactly once for each pad that exists at the time of this call,
// unless one of the calls to func returns FALSE in which case we will stop
// iterating pads and return early. If new pads are added or pads are removed
// while pads are being iterated, this will not be taken into account until next
// time this function is used.
//
// The function takes the following parameters:
//
//   - fn: function to call for each pad.
//
// The function returns the following values:
//
//   - ok: FALSE if element had no pads or if one of the calls to func returned
//     FALSE.
func (element *Element) ForEachPad(fn ElementForEachPadFunc) bool {
	var _arg0 *C.GstElement              // out
	var _arg1 C.GstElementForeachPadFunc // out
	var _arg2 C.gpointer
	var _cret C.gboolean // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gst1_ElementForEachPadFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.gst_element_foreach_pad(_arg0, _arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(fn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForEachSinkPad: call func with user_data for each of element's sink pads.
// func will be called exactly once for each sink pad that exists at the time
// of this call, unless one of the calls to func returns FALSE in which case we
// will stop iterating pads and return early. If new sink pads are added or sink
// pads are removed while the sink pads are being iterated, this will not be
// taken into account until next time this function is used.
//
// The function takes the following parameters:
//
//   - fn: function to call for each sink pad.
//
// The function returns the following values:
//
//   - ok: FALSE if element had no sink pads or if one of the calls to func
//     returned FALSE.
func (element *Element) ForEachSinkPad(fn ElementForEachPadFunc) bool {
	var _arg0 *C.GstElement              // out
	var _arg1 C.GstElementForeachPadFunc // out
	var _arg2 C.gpointer
	var _cret C.gboolean // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gst1_ElementForEachPadFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.gst_element_foreach_sink_pad(_arg0, _arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(fn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForEachSrcPad: call func with user_data for each of element's source pads.
// func will be called exactly once for each source pad that exists at the
// time of this call, unless one of the calls to func returns FALSE in which
// case we will stop iterating pads and return early. If new source pads are
// added or source pads are removed while the source pads are being iterated,
// this will not be taken into account until next time this function is used.
//
// The function takes the following parameters:
//
//   - fn: function to call for each source pad.
//
// The function returns the following values:
//
//   - ok: FALSE if element had no source pads or if one of the calls to func
//     returned FALSE.
func (element *Element) ForEachSrcPad(fn ElementForEachPadFunc) bool {
	var _arg0 *C.GstElement              // out
	var _arg1 C.GstElementForeachPadFunc // out
	var _arg2 C.gpointer
	var _cret C.gboolean // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gst1_ElementForEachPadFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.gst_element_foreach_src_pad(_arg0, _arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(fn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BaseTime returns the base time of the element. The base time is the absolute
// time of the clock when this element was last put to PLAYING. Subtracting the
// base time from the clock time gives the running time of the element.
//
// The function returns the following values:
//
//   - clockTime: base time of the element.
//
//     MT safe.
func (element *Element) BaseTime() ClockTime {
	var _arg0 *C.GstElement  // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_get_base_time(_arg0)
	runtime.KeepAlive(element)

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// Bus returns the bus of the element. Note that only a Pipeline will provide a
// bus for the application.
//
// The function returns the following values:
//
//   - bus (optional) element's Bus. unref after usage.
//
//     MT safe.
func (element *Element) Bus() *Bus {
	var _arg0 *C.GstElement // out
	var _cret *C.GstBus     // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_get_bus(_arg0)
	runtime.KeepAlive(element)

	var _bus *Bus // out

	if _cret != nil {
		_bus = wrapBus(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _bus
}

// Clock gets the currently configured clock of the element. This is the clock
// as was last set with gst_element_set_clock().
//
// Elements in a pipeline will only have their clock set when the pipeline is in
// the PLAYING state.
//
// The function returns the following values:
//
//   - clock (optional) of the element. unref after usage.
//
//     MT safe.
func (element *Element) Clock() Clocker {
	var _arg0 *C.GstElement // out
	var _cret *C.GstClock   // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_get_clock(_arg0)
	runtime.KeepAlive(element)

	var _clock Clocker // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Clocker)
				return ok
			})
			rv, ok := casted.(Clocker)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Clocker")
			}
			_clock = rv
		}
	}

	return _clock
}

// CompatiblePad looks for an unlinked pad to which the given pad can link.
// It is not guaranteed that linking the pads will work, though it should work
// in most cases.
//
// This function will first attempt to find a compatible unlinked ALWAYS pad,
// and if none can be found, it will request a compatible REQUEST pad by looking
// at the templates of element.
//
// The function takes the following parameters:
//
//   - pad to find a compatible one for.
//   - caps (optional) to use as a filter.
//
// The function returns the following values:
//
//   - ret (optional) to which a link can be made, or NULL if one cannot be
//     found. gst_object_unref() after usage.
func (element *Element) CompatiblePad(pad *Pad, caps *Caps) *Pad {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstPad     // out
	var _arg2 *C.GstCaps    // out
	var _cret *C.GstPad     // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if caps != nil {
		_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}

	_cret = C.gst_element_get_compatible_pad(_arg0, _arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(caps)

	var _ret *Pad // out

	if _cret != nil {
		_ret = wrapPad(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _ret
}

// CompatiblePadTemplate retrieves a pad template from element that is
// compatible with compattempl. Pads from compatible templates can be linked
// together.
//
// The function takes the following parameters:
//
//   - compattempl to find a compatible template for.
//
// The function returns the following values:
//
//   - padTemplate (optional): compatible PadTemplate, or NULL if none was
//     found. No unreferencing is necessary.
func (element *Element) CompatiblePadTemplate(compattempl *PadTemplate) *PadTemplate {
	var _arg0 *C.GstElement     // out
	var _arg1 *C.GstPadTemplate // out
	var _cret *C.GstPadTemplate // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(compattempl).Native()))

	_cret = C.gst_element_get_compatible_pad_template(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(compattempl)

	var _padTemplate *PadTemplate // out

	if _cret != nil {
		_padTemplate = wrapPadTemplate(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _padTemplate
}

// Context gets the context with context_type set on the element or NULL.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - contextType: name of a context to retrieve.
//
// The function returns the following values:
//
//   - context (optional) or NULL.
func (element *Element) Context(contextType string) *Context {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _cret *C.GstContext // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(contextType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_get_context(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(contextType)

	var _context *Context // out

	if _cret != nil {
		_context = (*Context)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_context)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _context
}

// ContextUnlocked gets the context with context_type set on the element or
// NULL.
//
// The function takes the following parameters:
//
//   - contextType: name of a context to retrieve.
//
// The function returns the following values:
//
//   - context (optional) or NULL.
func (element *Element) ContextUnlocked(contextType string) *Context {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _cret *C.GstContext // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(contextType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_get_context_unlocked(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(contextType)

	var _context *Context // out

	if _cret != nil {
		_context = (*Context)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_context)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _context
}

// Contexts gets the contexts set on the element.
//
// MT safe.
//
// The function returns the following values:
//
//   - list: list of Context.
func (element *Element) Contexts() []*Context {
	var _arg0 *C.GstElement // out
	var _cret *C.GList      // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_get_contexts(_arg0)
	runtime.KeepAlive(element)

	var _list []*Context // out

	_list = make([]*Context, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstContext)(v)
		var dst *Context // out
		dst = (*Context)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
		_list = append(_list, dst)
	})

	return _list
}

// CurrentClockTime returns the current clock time of the element, as in,
// the time of the element's clock, or GST_CLOCK_TIME_NONE if there is no clock.
//
// The function returns the following values:
//
//   - clockTime: clock time of the element, or GST_CLOCK_TIME_NONE if there is
//     no clock.
func (element *Element) CurrentClockTime() ClockTime {
	var _arg0 *C.GstElement  // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_get_current_clock_time(_arg0)
	runtime.KeepAlive(element)

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// CurrentRunningTime returns the running time of the element. The running
// time is the element's clock time minus its base time. Will return
// GST_CLOCK_TIME_NONE if the element has no clock, or if its base time has not
// been set.
//
// The function returns the following values:
//
//   - clockTime: running time of the element, or GST_CLOCK_TIME_NONE if the
//     element has no clock or its base time has not been set.
func (element *Element) CurrentRunningTime() ClockTime {
	var _arg0 *C.GstElement  // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_get_current_running_time(_arg0)
	runtime.KeepAlive(element)

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// Factory retrieves the factory that was used to create this element.
//
// The function returns the following values:
//
//   - elementFactory (optional) used for creating this element or NULL if
//     element has not been registered (static element). no refcounting is
//     needed.
func (element *Element) Factory() *ElementFactory {
	var _arg0 *C.GstElement        // out
	var _cret *C.GstElementFactory // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_get_factory(_arg0)
	runtime.KeepAlive(element)

	var _elementFactory *ElementFactory // out

	if _cret != nil {
		_elementFactory = wrapElementFactory(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _elementFactory
}

// Metadata: get metadata with key in klass.
//
// The function takes the following parameters:
//
//   - key to get.
//
// The function returns the following values:
//
//   - utf8: metadata for key.
func (element *Element) Metadata(key string) string {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_get_metadata(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(key)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// PadTemplate retrieves a padtemplate from element with the given name.
//
// The function takes the following parameters:
//
//   - name of the PadTemplate to get.
//
// The function returns the following values:
//
//   - padTemplate (optional) with the given name, or NULL if none was found.
//     No unreferencing is necessary.
func (element *Element) PadTemplate(name string) *PadTemplate {
	var _arg0 *C.GstElement     // out
	var _arg1 *C.gchar          // out
	var _cret *C.GstPadTemplate // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_get_pad_template(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(name)

	var _padTemplate *PadTemplate // out

	if _cret != nil {
		_padTemplate = wrapPadTemplate(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _padTemplate
}

// PadTemplateList retrieves a list of the pad templates associated with
// element. The list must not be modified by the calling code.
//
// The function returns the following values:
//
//   - list of pad templates.
func (element *Element) PadTemplateList() []*PadTemplate {
	var _arg0 *C.GstElement // out
	var _cret *C.GList      // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_get_pad_template_list(_arg0)
	runtime.KeepAlive(element)

	var _list []*PadTemplate // out

	_list = make([]*PadTemplate, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstPadTemplate)(v)
		var dst *PadTemplate // out
		dst = wrapPadTemplate(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// GetRequestPad: name of this function is confusing to people learning
// GStreamer. gst_element_request_pad_simple() aims at making it more explicit
// it is a simplified gst_element_request_pad().
//
// Deprecated: Prefer using gst_element_request_pad_simple() which provides the
// exact same functionality.
//
// The function takes the following parameters:
//
//   - name of the request Pad to retrieve.
//
// The function returns the following values:
//
//   - pad (optional): requested Pad if found, otherwise NULL. Release after
//     usage.
func (element *Element) GetRequestPad(name string) *Pad {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _cret *C.GstPad     // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_get_request_pad(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(name)

	var _pad *Pad // out

	if _cret != nil {
		_pad = wrapPad(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pad
}

// StartTime returns the start time of the element. The start time is the
// running time of the clock when this element was last put to PAUSED.
//
// Usually the start_time is managed by a toplevel element such as Pipeline.
//
// MT safe.
//
// The function returns the following values:
//
//   - clockTime: start time of the element.
func (element *Element) StartTime() ClockTime {
	var _arg0 *C.GstElement  // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_get_start_time(_arg0)
	runtime.KeepAlive(element)

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// State gets the state of the element.
//
// For elements that performed an ASYNC state change, as reported by
// gst_element_set_state(), this function will block up to the specified timeout
// value for the state change to complete. If the element completes the state
// change or goes into an error, this function returns immediately with a return
// value of GST_STATE_CHANGE_SUCCESS or GST_STATE_CHANGE_FAILURE respectively.
//
// For elements that did not return GST_STATE_CHANGE_ASYNC, this function
// returns the current and pending state immediately.
//
// This function returns GST_STATE_CHANGE_NO_PREROLL if the element successfully
// changed its state but is not able to provide data yet. This mostly happens
// for live sources that only produce data in GST_STATE_PLAYING. While the state
// change return is equivalent to GST_STATE_CHANGE_SUCCESS, it is returned
// to the application to signal that some sink elements might not be able to
// complete their state change because an element is not producing data to
// complete the preroll. When setting the element to playing, the preroll will
// complete and playback will start.
//
// The function takes the following parameters:
//
//   - timeout to specify the timeout for an async state change or
//     GST_CLOCK_TIME_NONE for infinite timeout.
//
// The function returns the following values:
//
//   - state (optional): pointer to State to hold the state. Can be NULL.
//
//   - pending (optional): pointer to State to hold the pending state. Can be
//     NULL.
//
//   - stateChangeReturn: GST_STATE_CHANGE_SUCCESS if the element
//     has no more pending state and the last state change succeeded,
//     GST_STATE_CHANGE_ASYNC if the element is still performing a state change
//     or GST_STATE_CHANGE_FAILURE if the last state change failed.
//
//     MT safe.
func (element *Element) State(timeout ClockTime) (state, pending State, stateChangeReturn StateChangeReturn) {
	var _arg0 *C.GstElement          // out
	var _arg1 C.GstState             // in
	var _arg2 C.GstState             // in
	var _arg3 C.GstClockTime         // out
	var _cret C.GstStateChangeReturn // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg3 = C.GstClockTime(timeout)

	_cret = C.gst_element_get_state(_arg0, &_arg1, &_arg2, _arg3)
	runtime.KeepAlive(element)
	runtime.KeepAlive(timeout)

	var _state State                         // out
	var _pending State                       // out
	var _stateChangeReturn StateChangeReturn // out

	_state = State(_arg1)
	_pending = State(_arg2)
	_stateChangeReturn = StateChangeReturn(_cret)

	return _state, _pending, _stateChangeReturn
}

// StaticPad retrieves a pad from element by name. This version only retrieves
// already-existing (i.e. 'static') pads.
//
// The function takes the following parameters:
//
//   - name of the static Pad to retrieve.
//
// The function returns the following values:
//
//   - pad (optional): requested Pad if found, otherwise NULL. unref after
//     usage.
//
//     MT safe.
func (element *Element) StaticPad(name string) *Pad {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _cret *C.GstPad     // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_get_static_pad(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(name)

	var _pad *Pad // out

	if _cret != nil {
		_pad = wrapPad(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pad
}

// IsLockedState checks if the state of an element is locked. If the state of
// an element is locked, state changes of the parent don't affect the element.
// This way you can leave currently unused elements inside bins. Just lock their
// state before changing the state from T_STATE_NULL.
//
// MT safe.
//
// The function returns the following values:
//
//   - ok: TRUE, if the element's state is locked.
func (element *Element) IsLockedState() bool {
	var _arg0 *C.GstElement // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_is_locked_state(_arg0)
	runtime.KeepAlive(element)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IteratePads retrieves an iterator of element's pads. The iterator should
// be freed after usage. Also more specialized iterators exists such as
// gst_element_iterate_src_pads() or gst_element_iterate_sink_pads().
//
// The order of pads returned by the iterator will be the order in which the
// pads were added to the element.
//
// The function returns the following values:
//
//   - iterator of Pad.
//
//     MT safe.
func (element *Element) IteratePads() *Iterator {
	var _arg0 *C.GstElement  // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_iterate_pads(_arg0)
	runtime.KeepAlive(element)

	var _iterator *Iterator // out

	_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iterator)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_iterator_free((*C.GstIterator)(intern.C))
		},
	)

	return _iterator
}

// IterateSinkPads retrieves an iterator of element's sink pads.
//
// The order of pads returned by the iterator will be the order in which the
// pads were added to the element.
//
// The function returns the following values:
//
//   - iterator of Pad.
//
//     MT safe.
func (element *Element) IterateSinkPads() *Iterator {
	var _arg0 *C.GstElement  // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_iterate_sink_pads(_arg0)
	runtime.KeepAlive(element)

	var _iterator *Iterator // out

	_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iterator)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_iterator_free((*C.GstIterator)(intern.C))
		},
	)

	return _iterator
}

// IterateSrcPads retrieves an iterator of element's source pads.
//
// The order of pads returned by the iterator will be the order in which the
// pads were added to the element.
//
// The function returns the following values:
//
//   - iterator of Pad.
//
//     MT safe.
func (element *Element) IterateSrcPads() *Iterator {
	var _arg0 *C.GstElement  // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_iterate_src_pads(_arg0)
	runtime.KeepAlive(element)

	var _iterator *Iterator // out

	_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iterator)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_iterator_free((*C.GstIterator)(intern.C))
		},
	)

	return _iterator
}

// Link links src to dest. The link must be from source to destination;
// the other direction will not be tried. The function looks for existing pads
// that aren't linked yet. It will request new pads if necessary. Such pads
// need to be released manually when unlinking. If multiple links are possible,
// only one is established.
//
// Make sure you have added your elements to a bin or pipeline with
// gst_bin_add() before trying to link them.
//
// The function takes the following parameters:
//
//   - dest containing the destination pad.
//
// The function returns the following values:
//
//   - ok: TRUE if the elements could be linked, FALSE otherwise.
func (src *Element) Link(dest Elementer) bool {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstElement // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(dest).Native()))

	_cret = C.gst_element_link(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(dest)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LinkFiltered links src to dest using the given caps as filtercaps. The link
// must be from source to destination; the other direction will not be tried.
// The function looks for existing pads that aren't linked yet. It will
// request new pads if necessary. If multiple links are possible, only one is
// established.
//
// Make sure you have added your elements to a bin or pipeline with
// gst_bin_add() before trying to link them.
//
// The function takes the following parameters:
//
//   - dest containing the destination pad.
//   - filter (optional) to filter the link, or NULL for no filter.
//
// The function returns the following values:
//
//   - ok: TRUE if the pads could be linked, FALSE otherwise.
func (src *Element) LinkFiltered(dest Elementer, filter *Caps) bool {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstElement // out
	var _arg2 *C.GstCaps    // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(dest).Native()))
	if filter != nil {
		_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))
	}

	_cret = C.gst_element_link_filtered(_arg0, _arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(filter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LinkPads links the two named pads of the source and destination elements.
// Side effect is that if one of the pads has no parent, it becomes a child of
// the parent of the other element. If they have different parents, the link
// fails.
//
// The function takes the following parameters:
//
//   - srcpadname (optional): name of the Pad in source element or NULL for any
//     pad.
//   - dest containing the destination pad.
//   - destpadname (optional): name of the Pad in destination element, or NULL
//     for any pad.
//
// The function returns the following values:
//
//   - ok: TRUE if the pads could be linked, FALSE otherwise.
func (src *Element) LinkPads(srcpadname string, dest Elementer, destpadname string) bool {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GstElement // out
	var _arg3 *C.gchar      // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	if srcpadname != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(srcpadname)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(dest).Native()))
	if destpadname != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(destpadname)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	_cret = C.gst_element_link_pads(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(srcpadname)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(destpadname)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LinkPadsFiltered links the two named pads of the source and destination
// elements. Side effect is that if one of the pads has no parent, it becomes
// a child of the parent of the other element. If they have different parents,
// the link fails. If caps is not NULL, makes sure that the caps of the link is
// a subset of caps.
//
// The function takes the following parameters:
//
//   - srcpadname (optional): name of the Pad in source element or NULL for any
//     pad.
//   - dest containing the destination pad.
//   - destpadname (optional): name of the Pad in destination element or NULL
//     for any pad.
//   - filter (optional) to filter the link, or NULL for no filter.
//
// The function returns the following values:
//
//   - ok: TRUE if the pads could be linked, FALSE otherwise.
func (src *Element) LinkPadsFiltered(srcpadname string, dest Elementer, destpadname string, filter *Caps) bool {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GstElement // out
	var _arg3 *C.gchar      // out
	var _arg4 *C.GstCaps    // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	if srcpadname != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(srcpadname)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(dest).Native()))
	if destpadname != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(destpadname)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if filter != nil {
		_arg4 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))
	}

	_cret = C.gst_element_link_pads_filtered(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(src)
	runtime.KeepAlive(srcpadname)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(destpadname)
	runtime.KeepAlive(filter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LinkPadsFull links the two named pads of the source and destination elements.
// Side effect is that if one of the pads has no parent, it becomes a child of
// the parent of the other element. If they have different parents, the link
// fails.
//
// Calling gst_element_link_pads_full() with flags == GST_PAD_LINK_CHECK_DEFAULT
// is the same as calling gst_element_link_pads() and the recommended way of
// linking pads with safety checks applied.
//
// This is a convenience function for gst_pad_link_full().
//
// The function takes the following parameters:
//
//   - srcpadname (optional): name of the Pad in source element or NULL for any
//     pad.
//   - dest containing the destination pad.
//   - destpadname (optional): name of the Pad in destination element, or NULL
//     for any pad.
//   - flags to be performed when linking pads.
//
// The function returns the following values:
//
//   - ok: TRUE if the pads could be linked, FALSE otherwise.
func (src *Element) LinkPadsFull(srcpadname string, dest Elementer, destpadname string, flags PadLinkCheck) bool {
	var _arg0 *C.GstElement     // out
	var _arg1 *C.gchar          // out
	var _arg2 *C.GstElement     // out
	var _arg3 *C.gchar          // out
	var _arg4 C.GstPadLinkCheck // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	if srcpadname != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(srcpadname)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(dest).Native()))
	if destpadname != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(destpadname)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	_arg4 = C.GstPadLinkCheck(flags)

	_cret = C.gst_element_link_pads_full(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(src)
	runtime.KeepAlive(srcpadname)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(destpadname)
	runtime.KeepAlive(flags)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LostState brings the element to the lost state. The current state
// of the element is copied to the pending state so that any call to
// gst_element_get_state() will return GST_STATE_CHANGE_ASYNC.
//
// An ASYNC_START message is posted. If the element was PLAYING, it will go
// to PAUSED. The element will be restored to its PLAYING state by the parent
// pipeline when it prerolls again.
//
// This is mostly used for elements that lost their preroll buffer in the
// GST_STATE_PAUSED or GST_STATE_PLAYING state after a flush, they will go to
// their pending state again when a new preroll buffer is queued. This function
// can only be called when the element is currently not in error or an async
// state change.
//
// This function is used internally and should normally not be called from
// plugins or applications.
func (element *Element) LostState() {
	var _arg0 *C.GstElement // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	C.gst_element_lost_state(_arg0)
	runtime.KeepAlive(element)
}

// MessageFull: post an error, warning or info message on the bus from inside an
// element.
//
// type must be of T_MESSAGE_ERROR, T_MESSAGE_WARNING or T_MESSAGE_INFO.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - typ: MessageType.
//   - domain: GStreamer GError domain this message belongs to.
//   - code: GError code belonging to the domain.
//   - text (optional): allocated text string to be used as a replacement for
//     the default message connected to code, or NULL.
//   - debug (optional): allocated debug message to be used as a replacement for
//     the default debugging information, or NULL.
//   - file: source code file where the error was generated.
//   - function: source code function where the error was generated.
//   - line: source code line where the error was generated.
func (element *Element) MessageFull(typ MessageType, domain glib.Quark, code int, text, debug, file, function string, line int) {
	var _arg0 *C.GstElement    // out
	var _arg1 C.GstMessageType // out
	var _arg2 C.GQuark         // out
	var _arg3 C.gint           // out
	var _arg4 *C.gchar         // out
	var _arg5 *C.gchar         // out
	var _arg6 *C.gchar         // out
	var _arg7 *C.gchar         // out
	var _arg8 C.gint           // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstMessageType(typ)
	_arg2 = C.GQuark(domain)
	_arg3 = C.gint(code)
	if text != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	}
	if debug != "" {
		_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(debug)))
	}
	_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (*C.gchar)(unsafe.Pointer(C.CString(function)))
	defer C.free(unsafe.Pointer(_arg7))
	_arg8 = C.gint(line)

	C.gst_element_message_full(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(element)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(code)
	runtime.KeepAlive(text)
	runtime.KeepAlive(debug)
	runtime.KeepAlive(file)
	runtime.KeepAlive(function)
	runtime.KeepAlive(line)
}

// MessageFullWithDetails: post an error, warning or info message on the bus
// from inside an element.
//
// type must be of T_MESSAGE_ERROR, T_MESSAGE_WARNING or T_MESSAGE_INFO.
//
// The function takes the following parameters:
//
//   - typ: MessageType.
//   - domain: GStreamer GError domain this message belongs to.
//   - code: GError code belonging to the domain.
//   - text (optional): allocated text string to be used as a replacement for
//     the default message connected to code, or NULL.
//   - debug (optional): allocated debug message to be used as a replacement for
//     the default debugging information, or NULL.
//   - file: source code file where the error was generated.
//   - function: source code function where the error was generated.
//   - line: source code line where the error was generated.
//   - structure: optional details structure.
func (element *Element) MessageFullWithDetails(typ MessageType, domain glib.Quark, code int, text, debug, file, function string, line int, structure *Structure) {
	var _arg0 *C.GstElement    // out
	var _arg1 C.GstMessageType // out
	var _arg2 C.GQuark         // out
	var _arg3 C.gint           // out
	var _arg4 *C.gchar         // out
	var _arg5 *C.gchar         // out
	var _arg6 *C.gchar         // out
	var _arg7 *C.gchar         // out
	var _arg8 C.gint           // out
	var _arg9 *C.GstStructure  // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstMessageType(typ)
	_arg2 = C.GQuark(domain)
	_arg3 = C.gint(code)
	if text != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	}
	if debug != "" {
		_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(debug)))
	}
	_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (*C.gchar)(unsafe.Pointer(C.CString(function)))
	defer C.free(unsafe.Pointer(_arg7))
	_arg8 = C.gint(line)
	_arg9 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(structure)), nil)

	C.gst_element_message_full_with_details(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9)
	runtime.KeepAlive(element)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(code)
	runtime.KeepAlive(text)
	runtime.KeepAlive(debug)
	runtime.KeepAlive(file)
	runtime.KeepAlive(function)
	runtime.KeepAlive(line)
	runtime.KeepAlive(structure)
}

// NoMorePads: use this function to signal that the element does not expect
// any more pads to show up in the current pipeline. This function should be
// called whenever pads have been added by the element itself. Elements with
// T_PAD_SOMETIMES pad templates use this in combination with autopluggers to
// figure out that the element is done initializing its pads.
//
// This function emits the Element::no-more-pads signal.
//
// MT safe.
func (element *Element) NoMorePads() {
	var _arg0 *C.GstElement // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	C.gst_element_no_more_pads(_arg0)
	runtime.KeepAlive(element)
}

// PostMessage: post a message on the element's Bus. This function takes
// ownership of the message; if you want to access the message after this call,
// you should add an additional reference before calling.
//
// The function takes the following parameters:
//
//   - message to post.
//
// The function returns the following values:
//
//   - ok: TRUE if the message was successfully posted. The function returns
//     FALSE if the element did not have a bus.
//
//     MT safe.
func (element *Element) PostMessage(message *Message) bool {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstMessage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(message)), nil)

	_cret = C.gst_element_post_message(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(message)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ProvideClock: get the clock provided by the given element. > An element is
// only required to provide a clock in the PAUSED > state. Some elements can
// provide a clock in other states.
//
// The function returns the following values:
//
//   - clock (optional): gstClock provided by the element or NULL if no clock
//     could be provided. Unref after usage.
//
//     MT safe.
func (element *Element) ProvideClock() Clocker {
	var _arg0 *C.GstElement // out
	var _cret *C.GstClock   // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_provide_clock(_arg0)
	runtime.KeepAlive(element)

	var _clock Clocker // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Clocker)
				return ok
			})
			rv, ok := casted.(Clocker)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Clocker")
			}
			_clock = rv
		}
	}

	return _clock
}

// Query performs a query on the given element.
//
// For elements that don't implement a query handler, this function forwards the
// query to a random srcpad or to the peer of a random linked sinkpad of this
// element.
//
// Please note that some queries might need a running pipeline to work.
//
// The function takes the following parameters:
//
//   - query: Query.
//
// The function returns the following values:
//
//   - ok: TRUE if the query could be performed.
//
//     MT safe.
func (element *Element) Query(query *Query) bool {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstQuery   // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_element_query(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QueryConvert queries an element to convert src_val in src_format to
// dest_format.
//
// The function takes the following parameters:
//
//   - srcFormat to convert from.
//   - srcVal: value to convert.
//   - destFormat to convert to.
//
// The function returns the following values:
//
//   - destVal: pointer to the result.
//   - ok: TRUE if the query could be performed.
func (element *Element) QueryConvert(srcFormat Format, srcVal int64, destFormat Format) (int64, bool) {
	var _arg0 *C.GstElement // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.gint64      // out
	var _arg3 C.GstFormat   // out
	var _arg4 C.gint64      // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstFormat(srcFormat)
	_arg2 = C.gint64(srcVal)
	_arg3 = C.GstFormat(destFormat)

	_cret = C.gst_element_query_convert(_arg0, _arg1, _arg2, _arg3, &_arg4)
	runtime.KeepAlive(element)
	runtime.KeepAlive(srcFormat)
	runtime.KeepAlive(srcVal)
	runtime.KeepAlive(destFormat)

	var _destVal int64 // out
	var _ok bool       // out

	_destVal = int64(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _destVal, _ok
}

// QueryDuration queries an element (usually top-level pipeline or playbin
// element) for the total stream duration in nanoseconds. This query will only
// work once the pipeline is prerolled (i.e. reached PAUSED or PLAYING state).
// The application will receive an ASYNC_DONE message on the pipeline bus when
// that is the case.
//
// If the duration changes for some reason, you will get a DURATION_CHANGED
// message on the pipeline bus, in which case you should re-query the duration
// using this function.
//
// The function takes the following parameters:
//
//   - format: Format requested.
//
// The function returns the following values:
//
//   - duration (optional): location in which to store the total duration,
//     or NULL.
//   - ok: TRUE if the query could be performed.
func (element *Element) QueryDuration(format Format) (int64, bool) {
	var _arg0 *C.GstElement // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.gint64      // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstFormat(format)

	_cret = C.gst_element_query_duration(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(format)

	var _duration int64 // out
	var _ok bool        // out

	_duration = int64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _duration, _ok
}

// QueryPosition queries an element (usually top-level pipeline or playbin
// element) for the stream position in nanoseconds. This will be a value between
// 0 and the stream duration (if the stream duration is known). This query will
// usually only work once the pipeline is prerolled (i.e. reached PAUSED or
// PLAYING state). The application will receive an ASYNC_DONE message on the
// pipeline bus when that is the case.
//
// If one repeatedly calls this function one can also create a query and reuse
// it in gst_element_query().
//
// The function takes the following parameters:
//
//   - format: Format requested.
//
// The function returns the following values:
//
//   - cur (optional): location in which to store the current position, or NULL.
//   - ok: TRUE if the query could be performed.
func (element *Element) QueryPosition(format Format) (int64, bool) {
	var _arg0 *C.GstElement // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.gint64      // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstFormat(format)

	_cret = C.gst_element_query_position(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(format)

	var _cur int64 // out
	var _ok bool   // out

	_cur = int64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _cur, _ok
}

// ReleaseRequestPad makes the element free the previously requested pad as
// obtained with gst_element_request_pad().
//
// This does not unref the pad. If the pad was created by using
// gst_element_request_pad(), gst_element_release_request_pad() needs to be
// followed by gst_object_unref() to free the pad.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - pad to release.
func (element *Element) ReleaseRequestPad(pad *Pad) {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstPad     // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	C.gst_element_release_request_pad(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(pad)
}

// RemovePad removes pad from element. pad will be destroyed if it has not been
// referenced elsewhere using gst_object_unparent().
//
// This function is used by plugin developers and should not be
// used by applications. Pads that were dynamically requested from
// elements with gst_element_request_pad() should be released with the
// gst_element_release_request_pad() function instead.
//
// Pads are not automatically deactivated so elements should perform the
// needed steps to deactivate the pad in case this pad is removed in the
// PAUSED or PLAYING state. See gst_pad_set_active() for more information about
// deactivating pads.
//
// The pad and the element should be unlocked when calling this function.
//
// This function will emit the Element::pad-removed signal on the element.
//
// The function takes the following parameters:
//
//   - pad to remove from the element.
//
// The function returns the following values:
//
//   - ok: TRUE if the pad could be removed. Can return FALSE if the pad does
//     not belong to the provided element.
//
//     MT safe.
func (element *Element) RemovePad(pad *Pad) bool {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstPad     // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_element_remove_pad(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - watchId: watch id to remove.
func (element *Element) RemovePropertyNotifyWatch(watchId uint32) {
	var _arg0 *C.GstElement // out
	var _arg1 C.gulong      // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.gulong(watchId)

	C.gst_element_remove_property_notify_watch(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(watchId)
}

// RequestPad retrieves a request pad from the element according
// to the provided template. Pad templates can be looked up using
// gst_element_factory_get_static_pad_templates().
//
// The pad should be released with gst_element_release_request_pad().
//
// The function takes the following parameters:
//
//   - templ of which we want a pad of.
//   - name (optional) of the request Pad to retrieve. Can be NULL.
//   - caps (optional) of the pad we want to request. Can be NULL.
//
// The function returns the following values:
//
//   - pad (optional): requested Pad if found, otherwise NULL. Release after
//     usage.
func (element *Element) RequestPad(templ *PadTemplate, name string, caps *Caps) *Pad {
	var _arg0 *C.GstElement     // out
	var _arg1 *C.GstPadTemplate // out
	var _arg2 *C.gchar          // out
	var _arg3 *C.GstCaps        // out
	var _cret *C.GstPad         // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(templ).Native()))
	if name != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if caps != nil {
		_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}

	_cret = C.gst_element_request_pad(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(element)
	runtime.KeepAlive(templ)
	runtime.KeepAlive(name)
	runtime.KeepAlive(caps)

	var _pad *Pad // out

	if _cret != nil {
		_pad = wrapPad(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pad
}

// RequestPadSimple retrieves a pad from the element by name (e.g. "src_\d").
// This version only retrieves request pads. The pad should be released with
// gst_element_release_request_pad().
//
// This method is slower than manually getting the pad template and calling
// gst_element_request_pad() if the pads should have a specific name (e.g.
// name is "src_1" instead of "src_\u").
//
// Note that this function was introduced in GStreamer 1.20 in order to provide
// a better name to gst_element_get_request_pad(). Prior to 1.20, users should
// use gst_element_get_request_pad() which provides the same functionality.
//
// The function takes the following parameters:
//
//   - name of the request Pad to retrieve.
//
// The function returns the following values:
//
//   - pad (optional): requested Pad if found, otherwise NULL. Release after
//     usage.
func (element *Element) RequestPadSimple(name string) *Pad {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _cret *C.GstPad     // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_request_pad_simple(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(name)

	var _pad *Pad // out

	if _cret != nil {
		_pad = wrapPad(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pad
}

// Seek sends a seek event to an element. See gst_event_new_seek() for the
// details of the parameters. The seek event is sent to the element using
// gst_element_send_event().
//
// MT safe.
//
// The function takes the following parameters:
//
//   - rate: new playback rate.
//   - format of the seek values.
//   - flags: optional seek flags.
//   - startType: type and flags for the new start position.
//   - start: value of the new start position.
//   - stopType: type and flags for the new stop position.
//   - stop: value of the new stop position.
//
// The function returns the following values:
//
//   - ok: TRUE if the event was handled. Flushing seeks will trigger a preroll,
//     which will emit GST_MESSAGE_ASYNC_DONE.
func (element *Element) Seek(rate float64, format Format, flags SeekFlags, startType SeekType, start int64, stopType SeekType, stop int64) bool {
	var _arg0 *C.GstElement  // out
	var _arg1 C.gdouble      // out
	var _arg2 C.GstFormat    // out
	var _arg3 C.GstSeekFlags // out
	var _arg4 C.GstSeekType  // out
	var _arg5 C.gint64       // out
	var _arg6 C.GstSeekType  // out
	var _arg7 C.gint64       // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.gdouble(rate)
	_arg2 = C.GstFormat(format)
	_arg3 = C.GstSeekFlags(flags)
	_arg4 = C.GstSeekType(startType)
	_arg5 = C.gint64(start)
	_arg6 = C.GstSeekType(stopType)
	_arg7 = C.gint64(stop)

	_cret = C.gst_element_seek(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(element)
	runtime.KeepAlive(rate)
	runtime.KeepAlive(format)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(startType)
	runtime.KeepAlive(start)
	runtime.KeepAlive(stopType)
	runtime.KeepAlive(stop)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SeekSimple: simple API to perform a seek on the given element, meaning
// it just seeks to the given position relative to the start of the stream.
// For more complex operations like segment seeks (e.g. for looping) or changing
// the playback rate or seeking relative to the last configured playback segment
// you should use gst_element_seek().
//
// In a completely prerolled PAUSED or PLAYING pipeline, seeking is always
// guaranteed to return TRUE on a seekable media type or FALSE when the media
// type is certainly not seekable (such as a live stream).
//
// Some elements allow for seeking in the READY state, in this case they will
// store the seek event and execute it when they are put to PAUSED. If the
// element supports seek in READY, it will always return TRUE when it receives
// the event in the READY state.
//
// The function takes the following parameters:
//
//   - format to execute the seek in, such as T_FORMAT_TIME.
//   - seekFlags: seek options; playback applications will usually want to use
//     GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT here.
//   - seekPos: position to seek to (relative to the start); if you are doing
//     a seek in T_FORMAT_TIME this value is in nanoseconds - multiply with
//     T_SECOND to convert seconds to nanoseconds or with T_MSECOND to convert
//     milliseconds to nanoseconds.
//
// The function returns the following values:
//
//   - ok: TRUE if the seek operation succeeded. Flushing seeks will trigger a
//     preroll, which will emit GST_MESSAGE_ASYNC_DONE.
func (element *Element) SeekSimple(format Format, seekFlags SeekFlags, seekPos int64) bool {
	var _arg0 *C.GstElement  // out
	var _arg1 C.GstFormat    // out
	var _arg2 C.GstSeekFlags // out
	var _arg3 C.gint64       // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstFormat(format)
	_arg2 = C.GstSeekFlags(seekFlags)
	_arg3 = C.gint64(seekPos)

	_cret = C.gst_element_seek_simple(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(element)
	runtime.KeepAlive(format)
	runtime.KeepAlive(seekFlags)
	runtime.KeepAlive(seekPos)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SendEvent sends an event to an element. If the element doesn't implement
// an event handler, the event will be pushed on a random linked sink pad for
// downstream events or a random linked source pad for upstream events.
//
// This function takes ownership of the provided event so you should
// gst_event_ref() it if you want to reuse the event after this call.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - event to send to the element.
//
// The function returns the following values:
//
//   - ok: TRUE if the event was handled. Events that trigger a preroll (such as
//     flushing seeks and steps) will emit GST_MESSAGE_ASYNC_DONE.
func (element *Element) SendEvent(event *Event) bool {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstEvent   // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(event)), nil)

	_cret = C.gst_element_send_event(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetBaseTime: set the base time of an element. See
// gst_element_get_base_time().
//
// MT safe.
//
// The function takes the following parameters:
//
//   - time: base time to set.
func (element *Element) SetBaseTime(time ClockTime) {
	var _arg0 *C.GstElement  // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstClockTime(time)

	C.gst_element_set_base_time(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(time)
}

// SetBus sets the bus of the element. Increases the refcount on the bus.
// For internal use only, unless you're testing elements.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - bus (optional) to set.
func (element *Element) SetBus(bus *Bus) {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstBus     // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	if bus != nil {
		_arg1 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	}

	C.gst_element_set_bus(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(bus)
}

// SetClock sets the clock for the element. This function increases the refcount
// on the clock. Any previously set clock on the object is unreffed.
//
// The function takes the following parameters:
//
//   - clock (optional) to set for the element.
//
// The function returns the following values:
//
//   - ok: TRUE if the element accepted the clock. An element can refuse a clock
//     when it, for example, is not able to slave its internal clock to the
//     clock or when it requires a specific clock to operate.
//
//     MT safe.
func (element *Element) SetClock(clock Clocker) bool {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstClock   // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	if clock != nil {
		_arg1 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	}

	_cret = C.gst_element_set_clock(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(clock)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetContext sets the context of the element. Increases the refcount of the
// context.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - context to set.
func (element *Element) SetContext(context *Context) {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstContext // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstContext)(gextras.StructNative(unsafe.Pointer(context)))

	C.gst_element_set_context(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(context)
}

// SetLockedState locks the state of an element, so state changes of the parent
// don't affect this element anymore.
//
// Note that this is racy if the state lock of the parent bin is not taken.
// The parent bin might've just checked the flag in another thread and as the
// next step proceed to change the child element's state.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - lockedState: TRUE to lock the element's state.
//
// The function returns the following values:
//
//   - ok: TRUE if the state was changed, FALSE if bad parameters were given or
//     the elements state-locking needed no change.
func (element *Element) SetLockedState(lockedState bool) bool {
	var _arg0 *C.GstElement // out
	var _arg1 C.gboolean    // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	if lockedState {
		_arg1 = C.TRUE
	}

	_cret = C.gst_element_set_locked_state(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(lockedState)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetStartTime: set the start time of an element. The start time of the element
// is the running time of the element when it last went to the PAUSED state.
// In READY or after a flushing seek, it is set to 0.
//
// Toplevel elements like Pipeline will manage the start_time and base_time on
// its children. Setting the start_time to T_CLOCK_TIME_NONE on such a toplevel
// element will disable the distribution of the base_time to the children and
// can be useful if the application manages the base_time itself, for example
// if you want to synchronize capture from multiple pipelines, and you can also
// ensure that the pipelines have the same clock.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - time: base time to set.
func (element *Element) SetStartTime(time ClockTime) {
	var _arg0 *C.GstElement  // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstClockTime(time)

	C.gst_element_set_start_time(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(time)
}

// SetState sets the state of the element. This function will try to set the
// requested state by going through all the intermediary states and calling the
// class's state change function for each.
//
// This function can return T_STATE_CHANGE_ASYNC, in which case the element will
// perform the remainder of the state change asynchronously in another thread.
// An application can use gst_element_get_state() to wait for the completion
// of the state change or it can wait for a GST_MESSAGE_ASYNC_DONE or
// GST_MESSAGE_STATE_CHANGED on the bus.
//
// State changes to GST_STATE_READY or GST_STATE_NULL never return
// T_STATE_CHANGE_ASYNC.
//
// The function takes the following parameters:
//
//   - state element's new State.
//
// The function returns the following values:
//
//   - stateChangeReturn: result of the state change using StateChangeReturn.
//
//     MT safe.
func (element *Element) SetState(state State) StateChangeReturn {
	var _arg0 *C.GstElement          // out
	var _arg1 C.GstState             // out
	var _cret C.GstStateChangeReturn // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstState(state)

	_cret = C.gst_element_set_state(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(state)

	var _stateChangeReturn StateChangeReturn // out

	_stateChangeReturn = StateChangeReturn(_cret)

	return _stateChangeReturn
}

// SyncStateWithParent tries to change the state of the element to the same
// as its parent. If this function returns FALSE, the state of element is
// undefined.
//
// The function returns the following values:
//
//   - ok: TRUE, if the element's state could be synced to the parent's state.
//
//     MT safe.
func (element *Element) SyncStateWithParent() bool {
	var _arg0 *C.GstElement // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C.gst_element_sync_state_with_parent(_arg0)
	runtime.KeepAlive(element)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Unlink unlinks all source pads of the source element with all sink pads of
// the sink element to which they are linked.
//
// If the link has been made using gst_element_link(), it could have created an
// requestpad, which has to be released using gst_element_release_request_pad().
//
// The function takes the following parameters:
//
//   - dest: sink Element to unlink.
func (src *Element) Unlink(dest Elementer) {
	var _arg0 *C.GstElement // out
	var _arg1 *C.GstElement // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(dest).Native()))

	C.gst_element_unlink(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(dest)
}

// UnlinkPads unlinks the two named pads of the source and destination elements.
//
// This is a convenience function for gst_pad_unlink().
//
// The function takes the following parameters:
//
//   - srcpadname: name of the Pad in source element.
//   - dest containing the destination pad.
//   - destpadname: name of the Pad in destination element.
func (src *Element) UnlinkPads(srcpadname string, dest Elementer, destpadname string) {
	var _arg0 *C.GstElement // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GstElement // out
	var _arg3 *C.gchar      // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(srcpadname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(dest).Native()))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(destpadname)))
	defer C.free(unsafe.Pointer(_arg3))

	C.gst_element_unlink_pads(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(srcpadname)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(destpadname)
}

// changeState: perform transition on element.
//
// This function must be called with STATE_LOCK held and is mainly used
// internally.
//
// The function takes the following parameters:
//
//   - transition: requested transition.
//
// The function returns the following values:
//
//   - stateChangeReturn of the state transition.
func (element *Element) changeState(transition StateChange) StateChangeReturn {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.change_state

	var _arg0 *C.GstElement          // out
	var _arg1 C.GstStateChange       // out
	var _cret C.GstStateChangeReturn // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstStateChange(transition)

	_cret = C._gotk4_gst1_Element_virtual_change_state(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(transition)

	var _stateChangeReturn StateChangeReturn // out

	_stateChangeReturn = StateChangeReturn(_cret)

	return _stateChangeReturn
}

// State gets the state of the element.
//
// For elements that performed an ASYNC state change, as reported by
// gst_element_set_state(), this function will block up to the specified timeout
// value for the state change to complete. If the element completes the state
// change or goes into an error, this function returns immediately with a return
// value of GST_STATE_CHANGE_SUCCESS or GST_STATE_CHANGE_FAILURE respectively.
//
// For elements that did not return GST_STATE_CHANGE_ASYNC, this function
// returns the current and pending state immediately.
//
// This function returns GST_STATE_CHANGE_NO_PREROLL if the element successfully
// changed its state but is not able to provide data yet. This mostly happens
// for live sources that only produce data in GST_STATE_PLAYING. While the state
// change return is equivalent to GST_STATE_CHANGE_SUCCESS, it is returned
// to the application to signal that some sink elements might not be able to
// complete their state change because an element is not producing data to
// complete the preroll. When setting the element to playing, the preroll will
// complete and playback will start.
//
// The function takes the following parameters:
//
//   - timeout to specify the timeout for an async state change or
//     GST_CLOCK_TIME_NONE for infinite timeout.
//
// The function returns the following values:
//
//   - state (optional): pointer to State to hold the state. Can be NULL.
//
//   - pending (optional): pointer to State to hold the pending state. Can be
//     NULL.
//
//   - stateChangeReturn: GST_STATE_CHANGE_SUCCESS if the element
//     has no more pending state and the last state change succeeded,
//     GST_STATE_CHANGE_ASYNC if the element is still performing a state change
//     or GST_STATE_CHANGE_FAILURE if the last state change failed.
//
//     MT safe.
func (element *Element) state(timeout ClockTime) (state, pending State, stateChangeReturn StateChangeReturn) {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.get_state

	var _arg0 *C.GstElement          // out
	var _arg1 C.GstState             // in
	var _arg2 C.GstState             // in
	var _arg3 C.GstClockTime         // out
	var _cret C.GstStateChangeReturn // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg3 = C.GstClockTime(timeout)

	_cret = C._gotk4_gst1_Element_virtual_get_state(unsafe.Pointer(fnarg), _arg0, &_arg1, &_arg2, _arg3)
	runtime.KeepAlive(element)
	runtime.KeepAlive(timeout)

	var _state State                         // out
	var _pending State                       // out
	var _stateChangeReturn StateChangeReturn // out

	_state = State(_arg1)
	_pending = State(_arg2)
	_stateChangeReturn = StateChangeReturn(_cret)

	return _state, _pending, _stateChangeReturn
}

// noMorePads: use this function to signal that the element does not expect
// any more pads to show up in the current pipeline. This function should be
// called whenever pads have been added by the element itself. Elements with
// T_PAD_SOMETIMES pad templates use this in combination with autopluggers to
// figure out that the element is done initializing its pads.
//
// This function emits the Element::no-more-pads signal.
//
// MT safe.
func (element *Element) noMorePads() {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.no_more_pads

	var _arg0 *C.GstElement // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	C._gotk4_gst1_Element_virtual_no_more_pads(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(element)
}

func (element *Element) padAdded(pad *Pad) {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.pad_added

	var _arg0 *C.GstElement // out
	var _arg1 *C.GstPad     // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	C._gotk4_gst1_Element_virtual_pad_added(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(pad)
}

func (element *Element) padRemoved(pad *Pad) {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.pad_removed

	var _arg0 *C.GstElement // out
	var _arg1 *C.GstPad     // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	C._gotk4_gst1_Element_virtual_pad_removed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(pad)
}

// postMessage: post a message on the element's Bus. This function takes
// ownership of the message; if you want to access the message after this call,
// you should add an additional reference before calling.
//
// The function takes the following parameters:
//
//   - message to post.
//
// The function returns the following values:
//
//   - ok: TRUE if the message was successfully posted. The function returns
//     FALSE if the element did not have a bus.
//
//     MT safe.
func (element *Element) postMessage(message *Message) bool {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.post_message

	var _arg0 *C.GstElement // out
	var _arg1 *C.GstMessage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(message)), nil)

	_cret = C._gotk4_gst1_Element_virtual_post_message(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(message)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// provideClock: get the clock provided by the given element. > An element is
// only required to provide a clock in the PAUSED > state. Some elements can
// provide a clock in other states.
//
// The function returns the following values:
//
//   - clock (optional): gstClock provided by the element or NULL if no clock
//     could be provided. Unref after usage.
//
//     MT safe.
func (element *Element) provideClock() Clocker {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.provide_clock

	var _arg0 *C.GstElement // out
	var _cret *C.GstClock   // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))

	_cret = C._gotk4_gst1_Element_virtual_provide_clock(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(element)

	var _clock Clocker // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Clocker)
				return ok
			})
			rv, ok := casted.(Clocker)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Clocker")
			}
			_clock = rv
		}
	}

	return _clock
}

// Query performs a query on the given element.
//
// For elements that don't implement a query handler, this function forwards the
// query to a random srcpad or to the peer of a random linked sinkpad of this
// element.
//
// Please note that some queries might need a running pipeline to work.
//
// The function takes the following parameters:
//
//   - query: Query.
//
// The function returns the following values:
//
//   - ok: TRUE if the query could be performed.
//
//     MT safe.
func (element *Element) query(query *Query) bool {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.query

	var _arg0 *C.GstElement // out
	var _arg1 *C.GstQuery   // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gst1_Element_virtual_query(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// releasePad: called when a request pad is to be released.
func (element *Element) releasePad(pad *Pad) {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.release_pad

	var _arg0 *C.GstElement // out
	var _arg1 *C.GstPad     // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	C._gotk4_gst1_Element_virtual_release_pad(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(pad)
}

// requestNewPad retrieves a request pad from the element according
// to the provided template. Pad templates can be looked up using
// gst_element_factory_get_static_pad_templates().
//
// The pad should be released with gst_element_release_request_pad().
//
// The function takes the following parameters:
//
//   - templ of which we want a pad of.
//   - name (optional) of the request Pad to retrieve. Can be NULL.
//   - caps (optional) of the pad we want to request. Can be NULL.
//
// The function returns the following values:
//
//   - pad (optional): requested Pad if found, otherwise NULL. Release after
//     usage.
func (element *Element) requestNewPad(templ *PadTemplate, name string, caps *Caps) *Pad {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.request_new_pad

	var _arg0 *C.GstElement     // out
	var _arg1 *C.GstPadTemplate // out
	var _arg2 *C.gchar          // out
	var _arg3 *C.GstCaps        // out
	var _cret *C.GstPad         // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(templ).Native()))
	if name != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if caps != nil {
		_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}

	_cret = C._gotk4_gst1_Element_virtual_request_new_pad(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(element)
	runtime.KeepAlive(templ)
	runtime.KeepAlive(name)
	runtime.KeepAlive(caps)

	var _pad *Pad // out

	if _cret != nil {
		_pad = wrapPad(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pad
}

// sendEvent sends an event to an element. If the element doesn't implement
// an event handler, the event will be pushed on a random linked sink pad for
// downstream events or a random linked source pad for upstream events.
//
// This function takes ownership of the provided event so you should
// gst_event_ref() it if you want to reuse the event after this call.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - event to send to the element.
//
// The function returns the following values:
//
//   - ok: TRUE if the event was handled. Events that trigger a preroll (such as
//     flushing seeks and steps) will emit GST_MESSAGE_ASYNC_DONE.
func (element *Element) sendEvent(event *Event) bool {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.send_event

	var _arg0 *C.GstElement // out
	var _arg1 *C.GstEvent   // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(event)), nil)

	_cret = C._gotk4_gst1_Element_virtual_send_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// setBus sets the bus of the element. Increases the refcount on the bus.
// For internal use only, unless you're testing elements.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - bus (optional) to set.
func (element *Element) setBus(bus *Bus) {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.set_bus

	var _arg0 *C.GstElement // out
	var _arg1 *C.GstBus     // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	if bus != nil {
		_arg1 = (*C.GstBus)(unsafe.Pointer(coreglib.InternObject(bus).Native()))
	}

	C._gotk4_gst1_Element_virtual_set_bus(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(bus)
}

// setClock sets the clock for the element. This function increases the refcount
// on the clock. Any previously set clock on the object is unreffed.
//
// The function takes the following parameters:
//
//   - clock (optional) to set for the element.
//
// The function returns the following values:
//
//   - ok: TRUE if the element accepted the clock. An element can refuse a clock
//     when it, for example, is not able to slave its internal clock to the
//     clock or when it requires a specific clock to operate.
//
//     MT safe.
func (element *Element) setClock(clock Clocker) bool {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.set_clock

	var _arg0 *C.GstElement // out
	var _arg1 *C.GstClock   // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	if clock != nil {
		_arg1 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	}

	_cret = C._gotk4_gst1_Element_virtual_set_clock(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(clock)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// setContext sets the context of the element. Increases the refcount of the
// context.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - context to set.
func (element *Element) setContext(context *Context) {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.set_context

	var _arg0 *C.GstElement // out
	var _arg1 *C.GstContext // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = (*C.GstContext)(gextras.StructNative(unsafe.Pointer(context)))

	C._gotk4_gst1_Element_virtual_set_context(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(context)
}

// setState sets the state of the element. This function will try to set the
// requested state by going through all the intermediary states and calling the
// class's state change function for each.
//
// This function can return T_STATE_CHANGE_ASYNC, in which case the element will
// perform the remainder of the state change asynchronously in another thread.
// An application can use gst_element_get_state() to wait for the completion
// of the state change or it can wait for a GST_MESSAGE_ASYNC_DONE or
// GST_MESSAGE_STATE_CHANGED on the bus.
//
// State changes to GST_STATE_READY or GST_STATE_NULL never return
// T_STATE_CHANGE_ASYNC.
//
// The function takes the following parameters:
//
//   - state element's new State.
//
// The function returns the following values:
//
//   - stateChangeReturn: result of the state change using StateChangeReturn.
//
//     MT safe.
func (element *Element) setState(state State) StateChangeReturn {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.set_state

	var _arg0 *C.GstElement          // out
	var _arg1 C.GstState             // out
	var _cret C.GstStateChangeReturn // in

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstState(state)

	_cret = C._gotk4_gst1_Element_virtual_set_state(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(state)

	var _stateChangeReturn StateChangeReturn // out

	_stateChangeReturn = StateChangeReturn(_cret)

	return _stateChangeReturn
}

// stateChanged: called immediately after a new state was set.
//
// The function takes the following parameters:
//
//   - oldstate
//   - newstate
//   - pending
func (element *Element) stateChanged(oldstate, newstate, pending State) {
	gclass := (*C.GstElementClass)(coreglib.PeekParentClass(element))
	fnarg := gclass.state_changed

	var _arg0 *C.GstElement // out
	var _arg1 C.GstState    // out
	var _arg2 C.GstState    // out
	var _arg3 C.GstState    // out

	_arg0 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg1 = C.GstState(oldstate)
	_arg2 = C.GstState(newstate)
	_arg3 = C.GstState(pending)

	C._gotk4_gst1_Element_virtual_state_changed(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(element)
	runtime.KeepAlive(oldstate)
	runtime.KeepAlive(newstate)
	runtime.KeepAlive(pending)
}

// ElementMakeFromURI creates an element for handling the given URI.
//
// The function takes the following parameters:
//
//   - typ: whether to create a source or a sink.
//   - uri: URI to create an element for.
//   - elementname (optional): name of created element, can be NULL.
//
// The function returns the following values:
//
//   - element: new element or NULL if none could be created.
func ElementMakeFromURI(typ URIType, uri, elementname string) (Elementer, error) {
	var _arg1 C.GstURIType  // out
	var _arg2 *C.gchar      // out
	var _arg3 *C.gchar      // out
	var _cret *C.GstElement // in
	var _cerr *C.GError     // in

	_arg1 = C.GstURIType(typ)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg2))
	if elementname != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(elementname)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	_cret = C.gst_element_make_from_uri(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(elementname)

	var _element Elementer // out
	var _goerr error       // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _element, _goerr
}

// ElementRegister: create a new elementfactory capable of instantiating objects
// of the type and add the factory to plugin.
//
// The function takes the following parameters:
//
//   - plugin (optional) to register the element with, or NULL for a static
//     element.
//   - name of elements of this type.
//   - rank of element (higher rank means more importance when autoplugging).
//   - typ: GType of element to register.
//
// The function returns the following values:
//
//   - ok: TRUE, if the registering succeeded, FALSE on error.
func ElementRegister(plugin *Plugin, name string, rank uint, typ coreglib.Type) bool {
	var _arg1 *C.GstPlugin // out
	var _arg2 *C.gchar     // out
	var _arg3 C.guint      // out
	var _arg4 C.GType      // out
	var _cret C.gboolean   // in

	if plugin != nil {
		_arg1 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.guint(rank)
	_arg4 = C.GType(typ)

	_cret = C.gst_element_register(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(plugin)
	runtime.KeepAlive(name)
	runtime.KeepAlive(rank)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ElementStateChangeReturnGetName gets a string representing the given state
// change result.
//
// The function takes the following parameters:
//
//   - stateRet to get the name of.
//
// The function returns the following values:
//
//   - utf8: string with the name of the state result.
func ElementStateChangeReturnGetName(stateRet StateChangeReturn) string {
	var _arg1 C.GstStateChangeReturn // out
	var _cret *C.gchar               // in

	_arg1 = C.GstStateChangeReturn(stateRet)

	_cret = C.gst_element_state_change_return_get_name(_arg1)
	runtime.KeepAlive(stateRet)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ElementStateGetName gets a string representing the given state.
//
// The function takes the following parameters:
//
//   - state to get the name of.
//
// The function returns the following values:
//
//   - utf8: string with the name of the state.
func ElementStateGetName(state State) string {
	var _arg1 C.GstState // out
	var _cret *C.gchar   // in

	_arg1 = C.GstState(state)

	_cret = C.gst_element_state_get_name(_arg1)
	runtime.KeepAlive(state)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ElementTypeSetSkipDocumentation marks type as "documentation should be
// skipped". Can be useful for dynamically registered element to be excluded
// from plugin documentation system.
//
// Example:
//
//	GType my_type;
//	GTypeInfo my_type_info;
//
//	// Fill "my_type_info"
//	...
//
//	my_type = g_type_register_static (GST_TYPE_MY_ELEMENT, "my-type-name",
//	   &my_type_info, 0);
//	gst_element_type_set_skip_documentation (my_type);
//	gst_element_register (plugin, "my-plugin-feature-name", rank, my_type);.
//
// The function takes the following parameters:
//
//   - typ of element.
func ElementTypeSetSkipDocumentation(typ coreglib.Type) {
	var _arg1 C.GType // out

	_arg1 = C.GType(typ)

	C.gst_element_type_set_skip_documentation(_arg1)
	runtime.KeepAlive(typ)
}

// ElementFactory is used to create instances of elements. A GstElementFactory
// can be added to a Plugin as it is also a PluginFeature.
//
// Use the gst_element_factory_find() and gst_element_factory_create() functions
// to create element instances or use gst_element_factory_make() as a convenient
// shortcut.
//
// The following code example shows you how to create a GstFileSrc element.
//
// Using an element factory
//
//	#include <gst/gst.h>
//
//	GstElement *src;
//	GstElementFactory *srcfactory;
//
//	gst_init (&argc, &argv);
//
//	srcfactory = gst_element_factory_find ("filesrc");
//	g_return_if_fail (srcfactory != NULL);
//	src = gst_element_factory_create (srcfactory, "src");
//	g_return_if_fail (src != NULL);
//	...
type ElementFactory struct {
	_ [0]func() // equal guard
	PluginFeature
}

var (
	_ PluginFeaturer = (*ElementFactory)(nil)
)

func wrapElementFactory(obj *coreglib.Object) *ElementFactory {
	return &ElementFactory{
		PluginFeature: PluginFeature{
			GstObject: GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalElementFactory(p uintptr) (interface{}, error) {
	return wrapElementFactory(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// CanSinkAllCaps checks if the factory can sink all possible capabilities.
//
// The function takes the following parameters:
//
//   - caps to check.
//
// The function returns the following values:
//
//   - ok: TRUE if the caps are fully compatible.
func (factory *ElementFactory) CanSinkAllCaps(caps *Caps) bool {
	var _arg0 *C.GstElementFactory // out
	var _arg1 *C.GstCaps           // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_element_factory_can_sink_all_caps(_arg0, _arg1)
	runtime.KeepAlive(factory)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanSinkAnyCaps checks if the factory can sink any possible capability.
//
// The function takes the following parameters:
//
//   - caps to check.
//
// The function returns the following values:
//
//   - ok: TRUE if the caps have a common subset.
func (factory *ElementFactory) CanSinkAnyCaps(caps *Caps) bool {
	var _arg0 *C.GstElementFactory // out
	var _arg1 *C.GstCaps           // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_element_factory_can_sink_any_caps(_arg0, _arg1)
	runtime.KeepAlive(factory)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanSrcAllCaps checks if the factory can src all possible capabilities.
//
// The function takes the following parameters:
//
//   - caps to check.
//
// The function returns the following values:
//
//   - ok: TRUE if the caps are fully compatible.
func (factory *ElementFactory) CanSrcAllCaps(caps *Caps) bool {
	var _arg0 *C.GstElementFactory // out
	var _arg1 *C.GstCaps           // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_element_factory_can_src_all_caps(_arg0, _arg1)
	runtime.KeepAlive(factory)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanSrcAnyCaps checks if the factory can src any possible capability.
//
// The function takes the following parameters:
//
//   - caps to check.
//
// The function returns the following values:
//
//   - ok: TRUE if the caps have a common subset.
func (factory *ElementFactory) CanSrcAnyCaps(caps *Caps) bool {
	var _arg0 *C.GstElementFactory // out
	var _arg1 *C.GstCaps           // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_element_factory_can_src_any_caps(_arg0, _arg1)
	runtime.KeepAlive(factory)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Create a new element of the type defined by the given elementfactory. It will
// be given the name supplied, since all elements require a name as their first
// argument.
//
// The function takes the following parameters:
//
//   - name (optional) of new element, or NULL to automatically create a unique
//     name.
//
// The function returns the following values:
//
//   - element (optional): new Element or NULL if the element couldn't be
//     created.
func (factory *ElementFactory) Create(name string) Elementer {
	var _arg0 *C.GstElementFactory // out
	var _arg1 *C.gchar             // out
	var _cret *C.GstElement        // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_element_factory_create(_arg0, _arg1)
	runtime.KeepAlive(factory)
	runtime.KeepAlive(name)

	var _element Elementer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Elementer)
				return ok
			})
			rv, ok := casted.(Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_element = rv
		}
	}

	return _element
}

// CreateWithProperties: create a new element of the type defined by the given
// elementfactory. The supplied list of properties, will be passed at object
// construction.
//
// The function takes the following parameters:
//
//   - names (optional): array of properties names.
//   - values (optional): array of associated properties values.
//
// The function returns the following values:
//
//   - element (optional): new Element or NULL if the element couldn't be
//     created.
func (factory *ElementFactory) CreateWithProperties(names []string, values []coreglib.Value) Elementer {
	var _arg0 *C.GstElementFactory // out
	var _arg2 **C.gchar            // out
	var _arg1 C.guint
	var _arg3 *C.GValue     // out
	var _cret *C.GstElement // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	_arg1 = (C.guint)(len(names))
	_arg2 = (**C.gchar)(C.calloc(C.size_t(len(names)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((**C.gchar)(_arg2), len(names))
		for i := range names {
			out[i] = (*C.gchar)(unsafe.Pointer(C.CString(names[i])))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	_arg1 = (C.guint)(len(values))
	_arg3 = (*C.GValue)(C.calloc(C.size_t(len(values)), C.size_t(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice((*C.GValue)(_arg3), len(values))
		for i := range values {
			out[i] = *(*C.GValue)(unsafe.Pointer((&values[i]).Native()))
		}
	}

	_cret = C.gst_element_factory_create_with_properties(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(factory)
	runtime.KeepAlive(names)
	runtime.KeepAlive(values)

	var _element Elementer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Elementer)
				return ok
			})
			rv, ok := casted.(Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_element = rv
		}
	}

	return _element
}

// ElementType: get the #GType for elements managed by this factory. The type
// can only be retrieved if the element factory is loaded, which can be assured
// with gst_plugin_feature_load().
//
// The function returns the following values:
//
//   - gType for elements managed by this factory or 0 if the factory is not
//     loaded.
func (factory *ElementFactory) ElementType() coreglib.Type {
	var _arg0 *C.GstElementFactory // out
	var _cret C.GType              // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))

	_cret = C.gst_element_factory_get_element_type(_arg0)
	runtime.KeepAlive(factory)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// Metadata: get the metadata on factory with key.
//
// The function takes the following parameters:
//
//   - key: key.
//
// The function returns the following values:
//
//   - utf8 (optional): metadata with key on factory or NULL when there was no
//     metadata with the given key.
func (factory *ElementFactory) Metadata(key string) string {
	var _arg0 *C.GstElementFactory // out
	var _arg1 *C.gchar             // out
	var _cret *C.gchar             // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_factory_get_metadata(_arg0, _arg1)
	runtime.KeepAlive(factory)
	runtime.KeepAlive(key)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// MetadataKeys: get the available keys for the metadata on factory.
//
// The function returns the following values:
//
//   - utf8s (optional): a NULL-terminated array of key strings, or NULL when
//     there is no metadata. Free with g_strfreev() when no longer needed.
func (factory *ElementFactory) MetadataKeys() []string {
	var _arg0 *C.GstElementFactory // out
	var _cret **C.gchar            // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))

	_cret = C.gst_element_factory_get_metadata_keys(_arg0)
	runtime.KeepAlive(factory)

	var _utf8s []string // out

	if _cret != nil {
		defer C.free(unsafe.Pointer(_cret))
		{
			var i int
			var z *C.gchar
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
				defer C.free(unsafe.Pointer(src[i]))
			}
		}
	}

	return _utf8s
}

// NumPadTemplates gets the number of pad_templates in this factory.
//
// The function returns the following values:
//
//   - guint: number of pad_templates.
func (factory *ElementFactory) NumPadTemplates() uint {
	var _arg0 *C.GstElementFactory // out
	var _cret C.guint              // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))

	_cret = C.gst_element_factory_get_num_pad_templates(_arg0)
	runtime.KeepAlive(factory)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SkipDocumentation queries whether registered element managed by factory needs
// to be excluded from documentation system or not.
//
// The function returns the following values:
//
//   - ok: TRUE if documentation should be skipped.
func (factory *ElementFactory) SkipDocumentation() bool {
	var _arg0 *C.GstElementFactory // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))

	_cret = C.gst_element_factory_get_skip_documentation(_arg0)
	runtime.KeepAlive(factory)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StaticPadTemplates gets the #GList of StaticPadTemplate for this factory.
//
// The function returns the following values:
//
//   - list: the static pad templates.
func (factory *ElementFactory) StaticPadTemplates() []*StaticPadTemplate {
	var _arg0 *C.GstElementFactory // out
	var _cret *C.GList             // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))

	_cret = C.gst_element_factory_get_static_pad_templates(_arg0)
	runtime.KeepAlive(factory)

	var _list []*StaticPadTemplate // out

	_list = make([]*StaticPadTemplate, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstStaticPadTemplate)(v)
		var dst *StaticPadTemplate // out
		dst = (*StaticPadTemplate)(gextras.NewStructNative(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// URIProtocols gets a NULL-terminated array of protocols this element supports
// or NULL if no protocols are supported. You may not change the contents of the
// returned array, as it is still owned by the element factory. Use g_strdupv()
// to make a copy of the protocol string array if you need to.
//
// The function returns the following values:
//
//   - utf8s: supported protocols or NULL.
func (factory *ElementFactory) URIProtocols() []string {
	var _arg0 *C.GstElementFactory // out
	var _cret **C.gchar            // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))

	_cret = C.gst_element_factory_get_uri_protocols(_arg0)
	runtime.KeepAlive(factory)

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// URIType gets the type of URIs the element supports or T_URI_UNKNOWN if none.
//
// The function returns the following values:
//
//   - uriType: type of URIs this element supports.
func (factory *ElementFactory) URIType() URIType {
	var _arg0 *C.GstElementFactory // out
	var _cret C.GstURIType         // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))

	_cret = C.gst_element_factory_get_uri_type(_arg0)
	runtime.KeepAlive(factory)

	var _uriType URIType // out

	_uriType = URIType(_cret)

	return _uriType
}

// HasInterface: check if factory implements the interface with name
// interfacename.
//
// The function takes the following parameters:
//
//   - interfacename: interface name.
//
// The function returns the following values:
//
//   - ok: TRUE when factory implement the interface.
func (factory *ElementFactory) HasInterface(interfacename string) bool {
	var _arg0 *C.GstElementFactory // out
	var _arg1 *C.gchar             // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(interfacename)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_factory_has_interface(_arg0, _arg1)
	runtime.KeepAlive(factory)
	runtime.KeepAlive(interfacename)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListIsType: check if factory is of the given types.
//
// The function takes the following parameters:
//
//   - typ: ElementFactoryListType.
//
// The function returns the following values:
//
//   - ok: TRUE if factory is of type.
func (factory *ElementFactory) ListIsType(typ ElementFactoryListType) bool {
	var _arg0 *C.GstElementFactory        // out
	var _arg1 C.GstElementFactoryListType // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	_arg1 = C.GstElementFactoryListType(typ)

	_cret = C.gst_element_factory_list_is_type(_arg0, _arg1)
	runtime.KeepAlive(factory)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ElementFactoryFind: search for an element factory of the given name. Refs the
// returned element factory; caller is responsible for unreffing.
//
// The function takes the following parameters:
//
//   - name of factory to find.
//
// The function returns the following values:
//
//   - elementFactory (optional) if found, NULL otherwise.
func ElementFactoryFind(name string) *ElementFactory {
	var _arg1 *C.gchar             // out
	var _cret *C.GstElementFactory // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_factory_find(_arg1)
	runtime.KeepAlive(name)

	var _elementFactory *ElementFactory // out

	if _cret != nil {
		_elementFactory = wrapElementFactory(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _elementFactory
}

// ElementFactoryListFilter: filter out all the elementfactories in list that
// can handle caps in the given direction.
//
// If subsetonly is TRUE, then only the elements whose pads templates are
// a complete superset of caps will be returned. Else any element whose pad
// templates caps can intersect with caps will be returned.
//
// The function takes the following parameters:
//
//   - list of ElementFactory to filter.
//   - caps: Caps.
//   - direction to filter on.
//   - subsetonly: whether to filter on caps subsets or not.
//
// The function returns the following values:
//
//   - ret of ElementFactory elements that match the given requisites. Use
//     #gst_plugin_feature_list_free after usage.
func ElementFactoryListFilter(list []*ElementFactory, caps *Caps, direction PadDirection, subsetonly bool) []*ElementFactory {
	var _arg1 *C.GList          // out
	var _arg2 *C.GstCaps        // out
	var _arg3 C.GstPadDirection // out
	var _arg4 C.gboolean        // out
	var _cret *C.GList          // in

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.GstElementFactory // out
		dst = (*C.GstElementFactory)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg1)
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg3 = C.GstPadDirection(direction)
	if subsetonly {
		_arg4 = C.TRUE
	}

	_cret = C.gst_element_factory_list_filter(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(list)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(subsetonly)

	var _ret []*ElementFactory // out

	_ret = make([]*ElementFactory, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstElementFactory)(v)
		var dst *ElementFactory // out
		dst = wrapElementFactory(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_ret = append(_ret, dst)
	})

	return _ret
}

// ElementFactoryListGetElements: get a list of factories that match the given
// type. Only elements with a rank greater or equal to minrank will be returned.
// The list of factories is returned by decreasing rank.
//
// The function takes the following parameters:
//
//   - typ: ElementFactoryListType.
//   - minrank: minimum rank.
//
// The function returns the following values:
//
//   - list of ElementFactory elements. Use gst_plugin_feature_list_free() after
//     usage.
func ElementFactoryListGetElements(typ ElementFactoryListType, minrank Rank) []*ElementFactory {
	var _arg1 C.GstElementFactoryListType // out
	var _arg2 C.GstRank                   // out
	var _cret *C.GList                    // in

	_arg1 = C.GstElementFactoryListType(typ)
	_arg2 = C.GstRank(minrank)

	_cret = C.gst_element_factory_list_get_elements(_arg1, _arg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(minrank)

	var _list []*ElementFactory // out

	_list = make([]*ElementFactory, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstElementFactory)(v)
		var dst *ElementFactory // out
		dst = wrapElementFactory(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// ElementFactoryMake: create a new element of the type defined by the given
// element factory. If name is NULL, then the element will receive a guaranteed
// unique name, consisting of the element factory name and a number. If name is
// given, it will be given the name supplied.
//
// The function takes the following parameters:
//
//   - factoryname: named factory to instantiate.
//   - name (optional) of new element, or NULL to automatically create a unique
//     name.
//
// The function returns the following values:
//
//   - element (optional): new Element or NULL if unable to create element.
func ElementFactoryMake(factoryname, name string) Elementer {
	var _arg1 *C.gchar      // out
	var _arg2 *C.gchar      // out
	var _cret *C.GstElement // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(factoryname)))
	defer C.free(unsafe.Pointer(_arg1))
	if name != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gst_element_factory_make(_arg1, _arg2)
	runtime.KeepAlive(factoryname)
	runtime.KeepAlive(name)

	var _element Elementer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Elementer)
				return ok
			})
			rv, ok := casted.(Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_element = rv
		}
	}

	return _element
}

// ElementFactoryMakeWithProperties: create a new element of the type defined by
// the given elementfactory. The supplied list of properties, will be passed at
// object construction.
//
// The function takes the following parameters:
//
//   - factoryname: named factory to instantiate.
//   - names (optional): array of properties names.
//   - values (optional): array of associated properties values.
//
// The function returns the following values:
//
//   - element (optional): new Element or NULL if the element couldn't be
//     created.
func ElementFactoryMakeWithProperties(factoryname string, names []string, values []coreglib.Value) Elementer {
	var _arg1 *C.gchar  // out
	var _arg3 **C.gchar // out
	var _arg2 C.guint
	var _arg4 *C.GValue     // out
	var _cret *C.GstElement // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(factoryname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint)(len(names))
	_arg3 = (**C.gchar)(C.calloc(C.size_t(len(names)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice((**C.gchar)(_arg3), len(names))
		for i := range names {
			out[i] = (*C.gchar)(unsafe.Pointer(C.CString(names[i])))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	_arg2 = (C.guint)(len(values))
	_arg4 = (*C.GValue)(C.calloc(C.size_t(len(values)), C.size_t(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((*C.GValue)(_arg4), len(values))
		for i := range values {
			out[i] = *(*C.GValue)(unsafe.Pointer((&values[i]).Native()))
		}
	}

	_cret = C.gst_element_factory_make_with_properties(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(factoryname)
	runtime.KeepAlive(names)
	runtime.KeepAlive(values)

	var _element Elementer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Elementer)
				return ok
			})
			rv, ok := casted.(Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_element = rv
		}
	}

	return _element
}

// FlagSet: fundamental type that describes a 32-bit flag bitfield, with 32-bit
// mask indicating which of the bits in the field are explicitly set.
type FlagSet struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*FlagSet)(nil)
)

func wrapFlagSet(obj *coreglib.Object) *FlagSet {
	return &FlagSet{
		Object: obj,
	}
}

func marshalFlagSet(p uintptr) (interface{}, error) {
	return wrapFlagSet(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// FlagSetRegister: create a new sub-class of T_TYPE_FLAG_SET which will
// pretty-print the human-readable flags when serializing, for easier debugging.
//
// The function takes the following parameters:
//
//   - flagsType of a TYPE_FLAGS type.
func FlagSetRegister(flagsType coreglib.Type) coreglib.Type {
	var _arg1 C.GType // out
	var _cret C.GType // in

	_arg1 = C.GType(flagsType)

	_cret = C.gst_flagset_register(_arg1)
	runtime.KeepAlive(flagsType)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// Fraction: fundamental type that describes a fraction of an integer numerator
// over an integer denominator.
type Fraction struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Fraction)(nil)
)

func wrapFraction(obj *coreglib.Object) *Fraction {
	return &Fraction{
		Object: obj,
	}
}

func marshalFraction(p uintptr) (interface{}, error) {
	return wrapFraction(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// FractionRange: fundamental type that describes a FractionRange range.
type FractionRange struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*FractionRange)(nil)
)

func wrapFractionRange(obj *coreglib.Object) *FractionRange {
	return &FractionRange{
		Object: obj,
	}
}

func marshalFractionRange(p uintptr) (interface{}, error) {
	return wrapFractionRange(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// GhostPadOverrides contains methods that are overridable.
type GhostPadOverrides struct {
}

func defaultGhostPadOverrides(v *GhostPad) GhostPadOverrides {
	return GhostPadOverrides{}
}

// GhostPad ghostPads are useful when organizing pipelines with Bin like
// elements. The idea here is to create hierarchical element graphs.
// The bin element contains a sub-graph. Now one would like to treat the
// bin-element like any other Element. This is where GhostPads come into play.
// A GhostPad acts as a proxy for another pad. Thus the bin can have sink and
// source ghost-pads that are associated with sink and source pads of the child
// elements.
//
// If the target pad is known at creation time, gst_ghost_pad_new()
// is the function to use to get a ghost-pad. Otherwise one can use
// gst_ghost_pad_new_no_target() to create the ghost-pad and use
// gst_ghost_pad_set_target() to establish the association later on.
//
// Note that GhostPads add overhead to the data processing of a pipeline.
type GhostPad struct {
	_ [0]func() // equal guard
	ProxyPad
}

var (
	_ GstObjector = (*GhostPad)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GhostPad, *GhostPadClass, GhostPadOverrides](
		GTypeGhostPad,
		initGhostPadClass,
		wrapGhostPad,
		defaultGhostPadOverrides,
	)
}

func initGhostPadClass(gclass unsafe.Pointer, overrides GhostPadOverrides, classInitFunc func(*GhostPadClass)) {
	if classInitFunc != nil {
		class := (*GhostPadClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGhostPad(obj *coreglib.Object) *GhostPad {
	return &GhostPad{
		ProxyPad: ProxyPad{
			Pad: Pad{
				GstObject: GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalGhostPad(p uintptr) (interface{}, error) {
	return wrapGhostPad(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewGhostPad: create a new ghostpad with target as the target. The direction
// will be taken from the target pad. target must be unlinked.
//
// Will ref the target.
//
// The function takes the following parameters:
//
//   - name (optional) of the new pad, or NULL to assign a default name.
//   - target: pad to ghost.
//
// The function returns the following values:
//
//   - ghostPad (optional): new Pad, or NULL in case of an error.
func NewGhostPad(name string, target *Pad) *GhostPad {
	var _arg1 *C.gchar  // out
	var _arg2 *C.GstPad // out
	var _cret *C.GstPad // in

	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(target).Native()))

	_cret = C.gst_ghost_pad_new(_arg1, _arg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(target)

	var _ghostPad *GhostPad // out

	if _cret != nil {
		_ghostPad = wrapGhostPad(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _ghostPad
}

// NewGhostPadFromTemplate: create a new ghostpad with target as the target.
// The direction will be taken from the target pad. The template used on the
// ghostpad will be template.
//
// Will ref the target.
//
// The function takes the following parameters:
//
//   - name (optional) of the new pad, or NULL to assign a default name.
//   - target: pad to ghost.
//   - templ to use on the ghostpad.
//
// The function returns the following values:
//
//   - ghostPad (optional): new Pad, or NULL in case of an error.
func NewGhostPadFromTemplate(name string, target *Pad, templ *PadTemplate) *GhostPad {
	var _arg1 *C.gchar          // out
	var _arg2 *C.GstPad         // out
	var _arg3 *C.GstPadTemplate // out
	var _cret *C.GstPad         // in

	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(target).Native()))
	_arg3 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(templ).Native()))

	_cret = C.gst_ghost_pad_new_from_template(_arg1, _arg2, _arg3)
	runtime.KeepAlive(name)
	runtime.KeepAlive(target)
	runtime.KeepAlive(templ)

	var _ghostPad *GhostPad // out

	if _cret != nil {
		_ghostPad = wrapGhostPad(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _ghostPad
}

// NewGhostPadNoTarget: create a new ghostpad without a target with the
// given direction. A target can be set on the ghostpad later with the
// gst_ghost_pad_set_target() function.
//
// The created ghostpad will not have a padtemplate.
//
// The function takes the following parameters:
//
//   - name (optional) of the new pad, or NULL to assign a default name.
//   - dir: direction of the ghostpad.
//
// The function returns the following values:
//
//   - ghostPad (optional): new Pad, or NULL in case of an error.
func NewGhostPadNoTarget(name string, dir PadDirection) *GhostPad {
	var _arg1 *C.gchar          // out
	var _arg2 C.GstPadDirection // out
	var _cret *C.GstPad         // in

	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = C.GstPadDirection(dir)

	_cret = C.gst_ghost_pad_new_no_target(_arg1, _arg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(dir)

	var _ghostPad *GhostPad // out

	if _cret != nil {
		_ghostPad = wrapGhostPad(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _ghostPad
}

// NewGhostPadNoTargetFromTemplate: create a new ghostpad based on templ,
// without setting a target. The direction will be taken from the templ.
//
// The function takes the following parameters:
//
//   - name (optional) of the new pad, or NULL to assign a default name.
//   - templ to create the ghostpad from.
//
// The function returns the following values:
//
//   - ghostPad (optional): new Pad, or NULL in case of an error.
func NewGhostPadNoTargetFromTemplate(name string, templ *PadTemplate) *GhostPad {
	var _arg1 *C.gchar          // out
	var _arg2 *C.GstPadTemplate // out
	var _cret *C.GstPad         // in

	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(templ).Native()))

	_cret = C.gst_ghost_pad_new_no_target_from_template(_arg1, _arg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(templ)

	var _ghostPad *GhostPad // out

	if _cret != nil {
		_ghostPad = wrapGhostPad(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _ghostPad
}

// Construct: finish initialization of a newly allocated ghost pad.
//
// This function is most useful in language bindings and when subclassing
// GhostPad; plugin and application developers normally will not call this
// function. Call this function directly after a call to g_object_new
// (GST_TYPE_GHOST_PAD, "direction", dir, ..., NULL).
//
// Deprecated: This function is deprecated since 1.18 and does nothing anymore.
//
// The function returns the following values:
//
//   - ok: TRUE if the construction succeeds, FALSE otherwise.
func (gpad *GhostPad) Construct() bool {
	var _arg0 *C.GstGhostPad // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGhostPad)(unsafe.Pointer(coreglib.InternObject(gpad).Native()))

	_cret = C.gst_ghost_pad_construct(_arg0)
	runtime.KeepAlive(gpad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Target: get the target pad of gpad. Unref target pad after usage.
//
// The function returns the following values:
//
//   - pad (optional): target Pad, can be NULL if the ghostpad has no target
//     set. Unref target pad after usage.
func (gpad *GhostPad) Target() *Pad {
	var _arg0 *C.GstGhostPad // out
	var _cret *C.GstPad      // in

	_arg0 = (*C.GstGhostPad)(unsafe.Pointer(coreglib.InternObject(gpad).Native()))

	_cret = C.gst_ghost_pad_get_target(_arg0)
	runtime.KeepAlive(gpad)

	var _pad *Pad // out

	if _cret != nil {
		_pad = wrapPad(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pad
}

// SetTarget: set the new target of the ghostpad gpad. Any existing target is
// unlinked and links to the new target are established. if newtarget is NULL
// the target will be cleared.
//
// The function takes the following parameters:
//
//   - newtarget (optional): new pad target.
//
// The function returns the following values:
//
//   - ok: TRUE if the new target could be set. This function can return FALSE
//     when the internal pads could not be linked.
func (gpad *GhostPad) SetTarget(newtarget *Pad) bool {
	var _arg0 *C.GstGhostPad // out
	var _arg1 *C.GstPad      // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGhostPad)(unsafe.Pointer(coreglib.InternObject(gpad).Native()))
	if newtarget != nil {
		_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(newtarget).Native()))
	}

	_cret = C.gst_ghost_pad_set_target(_arg0, _arg1)
	runtime.KeepAlive(gpad)
	runtime.KeepAlive(newtarget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GhostPadActivateModeDefault: invoke the default activate mode function of a
// ghost pad.
//
// The function takes the following parameters:
//
//   - pad to activate or deactivate.
//   - parent (optional) of pad or NULL.
//   - mode: requested activation mode.
//   - active: whether the pad should be active or not.
//
// The function returns the following values:
//
//   - ok: TRUE if the operation was successful.
func GhostPadActivateModeDefault(pad *Pad, parent GstObjector, mode PadMode, active bool) bool {
	var _arg1 *C.GstPad    // out
	var _arg2 *C.GstObject // out
	var _arg3 C.GstPadMode // out
	var _arg4 C.gboolean   // out
	var _cret C.gboolean   // in

	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if parent != nil {
		_arg2 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	_arg3 = C.GstPadMode(mode)
	if active {
		_arg4 = C.TRUE
	}

	_cret = C.gst_ghost_pad_activate_mode_default(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(mode)
	runtime.KeepAlive(active)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GhostPadInternalActivateModeDefault: invoke the default activate mode
// function of a proxy pad that is owned by a ghost pad.
//
// The function takes the following parameters:
//
//   - pad to activate or deactivate.
//   - parent (optional) of pad or NULL.
//   - mode: requested activation mode.
//   - active: whether the pad should be active or not.
//
// The function returns the following values:
//
//   - ok: TRUE if the operation was successful.
func GhostPadInternalActivateModeDefault(pad *Pad, parent GstObjector, mode PadMode, active bool) bool {
	var _arg1 *C.GstPad    // out
	var _arg2 *C.GstObject // out
	var _arg3 C.GstPadMode // out
	var _arg4 C.gboolean   // out
	var _cret C.gboolean   // in

	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if parent != nil {
		_arg2 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	_arg3 = C.GstPadMode(mode)
	if active {
		_arg4 = C.TRUE
	}

	_cret = C.gst_ghost_pad_internal_activate_mode_default(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(mode)
	runtime.KeepAlive(active)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Int64Range: fundamental type that describes a #gint64 range.
type Int64Range struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Int64Range)(nil)
)

func wrapInt64Range(obj *coreglib.Object) *Int64Range {
	return &Int64Range{
		Object: obj,
	}
}

func marshalInt64Range(p uintptr) (interface{}, error) {
	return wrapInt64Range(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// IntRange: fundamental type that describes a #gint range.
type IntRange struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*IntRange)(nil)
)

func wrapIntRange(obj *coreglib.Object) *IntRange {
	return &IntRange{
		Object: obj,
	}
}

func marshalIntRange(p uintptr) (interface{}, error) {
	return wrapIntRange(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// GstObjectOverrides contains methods that are overridable.
type GstObjectOverrides struct {
}

func defaultGstObjectOverrides(v *GstObject) GstObjectOverrides {
	return GstObjectOverrides{}
}

// GstObject provides a root for the object hierarchy tree filed in by the
// GStreamer library. It is currently a thin wrapper on top of Unowned. It is an
// abstract class that is not very usable on its own.
//
// Object gives us basic refcounting, parenting functionality and locking. Most
// of the functions are just extended for special GStreamer needs and can be
// found under the same name in the base class of Object which is #GObject (e.g.
// g_object_ref() becomes gst_object_ref()).
//
// Since Object derives from Unowned, it also inherits the floating reference.
// Be aware that functions such as gst_bin_add() and gst_element_add_pad() take
// ownership of the floating reference.
//
// In contrast to #GObject instances, Object adds a name property. The functions
// gst_object_set_name() and gst_object_get_name() are used to set/get the name
// of the object.
//
// controlled properties
//
// Controlled properties offers a lightweight way to adjust gobject properties
// over stream-time. It works by using time-stamped value pairs that are queued
// for element-properties. At run-time the elements continuously pull value
// changes for the current stream-time.
//
// What needs to be changed in a Element? Very little - it is just two steps to
// make a plugin controllable!
//
//   - mark gobject-properties paramspecs that make sense to be controlled,
//     by GST_PARAM_CONTROLLABLE.
//
//   - when processing data (get, chain, loop function) at the beginning call
//     gst_object_sync_values(element,timestamp). This will make the controller
//     update all GObject properties that are under its control with the current
//     values based on the timestamp.
//
// What needs to be done in applications? Again it's not a lot to change.
//
//   - create a ControlSource. csource = gst_interpolation_control_source_new
//     (); g_object_set (csource, "mode", GST_INTERPOLATION_MODE_LINEAR, NULL);
//
//   - Attach the ControlSource on the controller to a property.
//     gst_object_add_control_binding (object, gst_direct_control_binding_new
//     (object, "prop1", csource));
//
//   - Set the control values gst_timed_value_control_source_set
//     ((GstTimedValueControlSource *)csource,0 * GST_SECOND, value1);
//     gst_timed_value_control_source_set ((GstTimedValueControlSource
//     *)csource,1 * GST_SECOND, value2);
//
//   - start your pipeline.
type GstObject struct {
	_ [0]func() // equal guard
	coreglib.InitiallyUnowned
}

var ()

// GstObjector describes types inherited from class GstObject.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type GstObjector interface {
	coreglib.Objector
	baseGstObject() *GstObject
}

var _ GstObjector = (*GstObject)(nil)

func init() {
	coreglib.RegisterClassInfo[*GstObject, *ObjectClass, GstObjectOverrides](
		GTypeGstObject,
		initObjectClass,
		wrapObject,
		defaultGstObjectOverrides,
	)
}

func initObjectClass(gclass unsafe.Pointer, overrides GstObjectOverrides, classInitFunc func(*ObjectClass)) {
	if classInitFunc != nil {
		class := (*ObjectClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapObject(obj *coreglib.Object) *GstObject {
	return &GstObject{
		InitiallyUnowned: coreglib.InitiallyUnowned{
			Object: obj,
		},
	}
}

func marshalGstObject(p uintptr) (interface{}, error) {
	return wrapObject(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (object *GstObject) baseGstObject() *GstObject {
	return object
}

// BaseGstObject returns the underlying base object.
func BaseGstObject(obj GstObjector) *GstObject {
	return obj.baseGstObject()
}

// AddControlBinding: attach the ControlBinding to the object. If there already
// was a ControlBinding for this property it will be replaced.
//
// The object's reference count will be incremented, and any floating reference
// will be removed (see gst_object_ref_sink()).
//
// The function takes the following parameters:
//
//   - binding that should be used.
//
// The function returns the following values:
//
//   - ok: FALSE if the given binding has not been setup for this object or has
//     been setup for a non suitable property, TRUE otherwise.
func (object *GstObject) AddControlBinding(binding ControlBindinger) bool {
	var _arg0 *C.GstObject         // out
	var _arg1 *C.GstControlBinding // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.GstControlBinding)(unsafe.Pointer(coreglib.InternObject(binding).Native()))

	_cret = C.gst_object_add_control_binding(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(binding)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DefaultError: default error function that uses g_printerr() to display the
// error message and the optional debug string..
//
// The default handler will simply print the error string using g_print.
//
// The function takes the following parameters:
//
//   - err: GError.
//   - debug (optional): additional debug information string, or NULL.
func (source *GstObject) DefaultError(err error, debug string) {
	var _arg0 *C.GstObject // out
	var _arg1 *C.GError    // out
	var _arg2 *C.gchar     // out

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(source).Native()))
	if err != nil {
		_arg1 = (*C.GError)(gerror.New(err))
	}
	if debug != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(debug)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.gst_object_default_error(_arg0, _arg1, _arg2)
	runtime.KeepAlive(source)
	runtime.KeepAlive(err)
	runtime.KeepAlive(debug)
}

// ControlBinding gets the corresponding ControlBinding for the property.
// This should be unreferenced again after use.
//
// The function takes the following parameters:
//
//   - propertyName: name of the property.
//
// The function returns the following values:
//
//   - controlBinding (optional) for property_name or NULL if the property is
//     not controlled.
func (object *GstObject) ControlBinding(propertyName string) ControlBindinger {
	var _arg0 *C.GstObject         // out
	var _arg1 *C.gchar             // out
	var _cret *C.GstControlBinding // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_object_get_control_binding(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(propertyName)

	var _controlBinding ControlBindinger // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(ControlBindinger)
				return ok
			})
			rv, ok := casted.(ControlBindinger)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.ControlBindinger")
			}
			_controlBinding = rv
		}
	}

	return _controlBinding
}

// ControlRate: obtain the control-rate for this object. Audio processing
// Element objects will use this rate to sub-divide their processing loop and
// call gst_object_sync_values() in between. The length of the processing
// segment should be up to control-rate nanoseconds.
//
// If the object is not under property control, this will return
// GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
//
// The control-rate is not expected to change if the element is in
// GST_STATE_PAUSED or GST_STATE_PLAYING.
//
// The function returns the following values:
//
//   - clockTime: control rate in nanoseconds.
func (object *GstObject) ControlRate() ClockTime {
	var _arg0 *C.GstObject   // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	_cret = C.gst_object_get_control_rate(_arg0)
	runtime.KeepAlive(object)

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// GValueArray gets a number of #GValues for the given controlled property
// starting at the requested time. The array values need to hold enough space
// for n_values of #GValue.
//
// This function is useful if one wants to e.g. draw a graph of the control
// curve or apply a control curve sample by sample.
//
// The function takes the following parameters:
//
//   - propertyName: name of the property to get.
//   - timestamp: time that should be processed.
//   - interval: time spacing between subsequent values.
//   - values: array to put control-values in.
//
// The function returns the following values:
//
//   - ok: TRUE if the given array could be filled, FALSE otherwise.
func (object *GstObject) GValueArray(propertyName string, timestamp, interval ClockTime, values []coreglib.Value) bool {
	var _arg0 *C.GstObject   // out
	var _arg1 *C.gchar       // out
	var _arg2 C.GstClockTime // out
	var _arg3 C.GstClockTime // out
	var _arg5 *C.GValue      // out
	var _arg4 C.guint
	var _cret C.gboolean // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GstClockTime(timestamp)
	_arg3 = C.GstClockTime(interval)
	_arg4 = (C.guint)(len(values))
	_arg5 = (*C.GValue)(C.calloc(C.size_t(len(values)), C.size_t(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg5))
	{
		out := unsafe.Slice((*C.GValue)(_arg5), len(values))
		for i := range values {
			out[i] = *(*C.GValue)(unsafe.Pointer((&values[i]).Native()))
		}
	}

	_cret = C.gst_object_get_g_value_array(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(object)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(timestamp)
	runtime.KeepAlive(interval)
	runtime.KeepAlive(values)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Name returns a copy of the name of object. Caller should g_free() the return
// value after usage. For a nameless object, this returns NULL, which you can
// safely g_free() as well.
//
// Free-function: g_free.
//
// The function returns the following values:
//
//   - utf8 (optional): name of object. g_free() after usage.
//
//     MT safe. This function grabs and releases object's LOCK.
func (object *GstObject) Name() string {
	var _arg0 *C.GstObject // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	_cret = C.gst_object_get_name(_arg0)
	runtime.KeepAlive(object)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// Parent returns the parent of object. This function increases the refcount of
// the parent object so you should gst_object_unref() it after usage.
//
// The function returns the following values:
//
//   - ret (optional): parent of object, this can be NULL if object has no
//     parent. unref after usage.
//
//     MT safe. Grabs and releases object's LOCK.
func (object *GstObject) Parent() GstObjector {
	var _arg0 *C.GstObject // out
	var _cret *C.GstObject // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	_cret = C.gst_object_get_parent(_arg0)
	runtime.KeepAlive(object)

	var _ret GstObjector // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(GstObjector)
				return ok
			})
			rv, ok := casted.(GstObjector)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.GstObjector")
			}
			_ret = rv
		}
	}

	return _ret
}

// PathString generates a string describing the path of object in the object
// hierarchy. Only useful (or used) for debugging.
//
// Free-function: g_free.
//
// The function returns the following values:
//
//   - utf8: string describing the path of object. You must g_free() the string
//     after usage.
//
//     MT safe. Grabs and releases the Object's LOCK for all objects in the
//     hierarchy.
func (object *GstObject) PathString() string {
	var _arg0 *C.GstObject // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	_cret = C.gst_object_get_path_string(_arg0)
	runtime.KeepAlive(object)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Value gets the value for the given controlled property at the requested time.
//
// The function takes the following parameters:
//
//   - propertyName: name of the property to get.
//   - timestamp: time the control-change should be read from.
//
// The function returns the following values:
//
//   - value (optional): GValue of the property at the given time, or NULL if
//     the property isn't controlled.
func (object *GstObject) Value(propertyName string, timestamp ClockTime) *coreglib.Value {
	var _arg0 *C.GstObject   // out
	var _arg1 *C.gchar       // out
	var _arg2 C.GstClockTime // out
	var _cret *C.GValue      // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GstClockTime(timestamp)

	_cret = C.gst_object_get_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(object)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(timestamp)

	var _value *coreglib.Value // out

	if _cret != nil {
		_value = coreglib.ValueFromNative(unsafe.Pointer(_cret))
		runtime.SetFinalizer(_value, func(v *coreglib.Value) {
			C.g_value_unset((*C.GValue)(unsafe.Pointer(v.Native())))
		})
	}

	return _value
}

// HasActiveControlBindings: check if the object has active controlled
// properties.
//
// The function returns the following values:
//
//   - ok: TRUE if the object has active controlled properties.
func (object *GstObject) HasActiveControlBindings() bool {
	var _arg0 *C.GstObject // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	_cret = C.gst_object_has_active_control_bindings(_arg0)
	runtime.KeepAlive(object)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasAncestor: check if object has an ancestor ancestor somewhere up in the
// hierarchy. One can e.g. check if a Element is inside a Pipeline.
//
// Deprecated: Use gst_object_has_as_ancestor() instead.
//
// MT safe. Grabs and releases object's locks.
//
// The function takes the following parameters:
//
//   - ancestor to check as ancestor.
//
// The function returns the following values:
//
//   - ok: TRUE if ancestor is an ancestor of object.
func (object *GstObject) HasAncestor(ancestor GstObjector) bool {
	var _arg0 *C.GstObject // out
	var _arg1 *C.GstObject // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(ancestor).Native()))

	_cret = C.gst_object_has_ancestor(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(ancestor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasAsAncestor: check if object has an ancestor ancestor somewhere up in the
// hierarchy. One can e.g. check if a Element is inside a Pipeline.
//
// The function takes the following parameters:
//
//   - ancestor to check as ancestor.
//
// The function returns the following values:
//
//   - ok: TRUE if ancestor is an ancestor of object.
//
//     MT safe. Grabs and releases object's locks.
func (object *GstObject) HasAsAncestor(ancestor GstObjector) bool {
	var _arg0 *C.GstObject // out
	var _arg1 *C.GstObject // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(ancestor).Native()))

	_cret = C.gst_object_has_as_ancestor(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(ancestor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasAsParent: check if parent is the parent of object. E.g. a Element can
// check if it owns a given Pad.
//
// The function takes the following parameters:
//
//   - parent to check as parent.
//
// The function returns the following values:
//
//   - ok: FALSE if either object or parent is NULL. TRUE if parent is the
//     parent of object. Otherwise FALSE.
//
//     MT safe. Grabs and releases object's locks.
func (object *GstObject) HasAsParent(parent GstObjector) bool {
	var _arg0 *C.GstObject // out
	var _arg1 *C.GstObject // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))

	_cret = C.gst_object_has_as_parent(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(parent)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveControlBinding removes the corresponding ControlBinding. If it was the
// last ref of the binding, it will be disposed.
//
// The function takes the following parameters:
//
//   - binding: binding.
//
// The function returns the following values:
//
//   - ok: TRUE if the binding could be removed.
func (object *GstObject) RemoveControlBinding(binding ControlBindinger) bool {
	var _arg0 *C.GstObject         // out
	var _arg1 *C.GstControlBinding // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.GstControlBinding)(unsafe.Pointer(coreglib.InternObject(binding).Native()))

	_cret = C.gst_object_remove_control_binding(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(binding)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetControlBindingDisabled: this function is used to disable the control
// bindings on a property for some time, i.e. gst_object_sync_values() will do
// nothing for the property.
//
// The function takes the following parameters:
//
//   - propertyName: property to disable.
//   - disabled: boolean that specifies whether to disable the controller or
//     not.
func (object *GstObject) SetControlBindingDisabled(propertyName string, disabled bool) {
	var _arg0 *C.GstObject // out
	var _arg1 *C.gchar     // out
	var _arg2 C.gboolean   // out

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg1))
	if disabled {
		_arg2 = C.TRUE
	}

	C.gst_object_set_control_binding_disabled(_arg0, _arg1, _arg2)
	runtime.KeepAlive(object)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(disabled)
}

// SetControlBindingsDisabled: this function is used to disable all controlled
// properties of the object for some time, i.e. gst_object_sync_values() will do
// nothing.
//
// The function takes the following parameters:
//
//   - disabled: boolean that specifies whether to disable the controller or
//     not.
func (object *GstObject) SetControlBindingsDisabled(disabled bool) {
	var _arg0 *C.GstObject // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	if disabled {
		_arg1 = C.TRUE
	}

	C.gst_object_set_control_bindings_disabled(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(disabled)
}

// SetControlRate: change the control-rate for this object. Audio processing
// Element objects will use this rate to sub-divide their processing loop and
// call gst_object_sync_values() in between. The length of the processing
// segment should be up to control-rate nanoseconds.
//
// The control-rate should not change if the element is in GST_STATE_PAUSED or
// GST_STATE_PLAYING.
//
// The function takes the following parameters:
//
//   - controlRate: new control-rate in nanoseconds.
func (object *GstObject) SetControlRate(controlRate ClockTime) {
	var _arg0 *C.GstObject   // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = C.GstClockTime(controlRate)

	C.gst_object_set_control_rate(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(controlRate)
}

// SetName sets the name of object, or gives object a guaranteed unique name (if
// name is NULL). This function makes a copy of the provided name, so the caller
// retains ownership of the name it sent.
//
// The function takes the following parameters:
//
//   - name (optional): new name of object.
//
// The function returns the following values:
//
//   - ok: TRUE if the name could be set. Since Objects that have a parent
//     cannot be renamed, this function returns FALSE in those cases.
//
//     MT safe. This function grabs and releases object's LOCK.
func (object *GstObject) SetName(name string) bool {
	var _arg0 *C.GstObject // out
	var _arg1 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_object_set_name(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetParent sets the parent of object to parent. The object's reference
// count will be incremented, and any floating reference will be removed (see
// gst_object_ref_sink()).
//
// The function takes the following parameters:
//
//   - parent: new parent of object.
//
// The function returns the following values:
//
//   - ok: TRUE if parent could be set or FALSE when object already had a parent
//     or object and parent are the same.
//
//     MT safe. Grabs and releases object's LOCK.
func (object *GstObject) SetParent(parent GstObjector) bool {
	var _arg0 *C.GstObject // out
	var _arg1 *C.GstObject // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))

	_cret = C.gst_object_set_parent(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(parent)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SuggestNextSync returns a suggestion for timestamps where buffers should be
// split to get best controller results.
//
// The function returns the following values:
//
//   - clockTime returns the suggested timestamp or GST_CLOCK_TIME_NONE if no
//     control-rate was set.
func (object *GstObject) SuggestNextSync() ClockTime {
	var _arg0 *C.GstObject   // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	_cret = C.gst_object_suggest_next_sync(_arg0)
	runtime.KeepAlive(object)

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// SyncValues sets the properties of the object, according to the ControlSources
// that (maybe) handle them and for the given timestamp.
//
// If this function fails, it is most likely the application developers fault.
// Most probably the control sources are not setup correctly.
//
// The function takes the following parameters:
//
//   - timestamp: time that should be processed.
//
// The function returns the following values:
//
//   - ok: TRUE if the controller values could be applied to the object
//     properties, FALSE otherwise.
func (object *GstObject) SyncValues(timestamp ClockTime) bool {
	var _arg0 *C.GstObject   // out
	var _arg1 C.GstClockTime // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))
	_arg1 = C.GstClockTime(timestamp)

	_cret = C.gst_object_sync_values(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(timestamp)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Unparent: clear the parent of object, removing the associated reference.
// This function decreases the refcount of object.
//
// MT safe. Grabs and releases object's lock.
func (object *GstObject) Unparent() {
	var _arg0 *C.GstObject // out

	_arg0 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	C.gst_object_unparent(_arg0)
	runtime.KeepAlive(object)
}

// ObjectCheckUniqueness checks to see if there is any object named name in
// list. This function does not do any locking of any kind. You might want
// to protect the provided list with the lock of the owner of the list. This
// function will lock each Object in the list to compare the name, so be careful
// when passing a list with a locked object.
//
// The function takes the following parameters:
//
//   - list of Object to check through.
//   - name to search for.
//
// The function returns the following values:
//
//   - ok: TRUE if a Object named name does not appear in list, FALSE if it
//     does.
//
//     MT safe. Grabs and releases the LOCK of each object in the list.
func ObjectCheckUniqueness(list []GstObjector, name string) bool {
	var _arg1 *C.GList   // out
	var _arg2 *C.gchar   // out
	var _cret C.gboolean // in

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.GstObject // out
		dst = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg1)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_object_check_uniqueness(_arg1, _arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PadOverrides contains methods that are overridable.
type PadOverrides struct {
	Linked   func(peer *Pad)
	Unlinked func(peer *Pad)
}

func defaultPadOverrides(v *Pad) PadOverrides {
	return PadOverrides{
		Linked:   v.linked,
		Unlinked: v.unlinked,
	}
}

// Pad is linked to other elements via "pads", which are extremely light-weight
// generic link points.
//
// Pads have a PadDirection, source pads produce data, sink pads consume data.
//
// Pads are typically created from a PadTemplate with
// gst_pad_new_from_template() and are then added to a Element. This usually
// happens when the element is created but it can also happen dynamically based
// on the data that the element is processing or based on the pads that the
// application requests.
//
// Pads without pad templates can be created with gst_pad_new(), which takes a
// direction and a name as an argument. If the name is NULL, then a guaranteed
// unique name will be assigned to it.
//
// A Element creating a pad will typically use the various
// gst_pad_set_*_function\() calls to register callbacks for events, queries or
// dataflow on the pads.
//
// gst_pad_get_parent() will retrieve the Element that owns the pad.
//
// After two pads are retrieved from an element by gst_element_get_static_pad(),
// the pads can be linked with gst_pad_link(). (For quick links, you can
// also use gst_element_link(), which will make the obvious link for you if
// it's straightforward.). Pads can be unlinked again with gst_pad_unlink().
// gst_pad_get_peer() can be used to check what the pad is linked to.
//
// Before dataflow is possible on the pads, they need to be activated with
// gst_pad_set_active().
//
// gst_pad_query() and gst_pad_peer_query() can be used to query various
// properties of the pad and the stream.
//
// To send a Event on a pad, use gst_pad_send_event() and gst_pad_push_event().
// Some events will be sticky on the pad, meaning that after they pass
// on the pad they can be queried later with gst_pad_get_sticky_event()
// and gst_pad_sticky_events_foreach(). gst_pad_get_current_caps() and
// gst_pad_has_current_caps() are convenience functions to query the current
// sticky CAPS event on a pad.
//
// GstElements will use gst_pad_push() and gst_pad_pull_range() to push out or
// pull in a buffer.
//
// The dataflow, events and queries that happen on a pad can be monitored with
// probes that can be installed with gst_pad_add_probe(). gst_pad_is_blocked()
// can be used to check if a block probe is installed on the pad.
// gst_pad_is_blocking() checks if the blocking probe is currently blocking the
// pad. gst_pad_remove_probe() is used to remove a previously installed probe
// and unblock blocking probes if any.
//
// Pad have an offset that can be retrieved with gst_pad_get_offset(). This
// offset will be applied to the running_time of all data passing over the pad.
// gst_pad_set_offset() can be used to change the offset.
//
// Convenience functions exist to start, pause and stop the task on a pad
// with gst_pad_start_task(), gst_pad_pause_task() and gst_pad_stop_task()
// respectively.
type Pad struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*Pad)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Pad, *PadClass, PadOverrides](
		GTypePad,
		initPadClass,
		wrapPad,
		defaultPadOverrides,
	)
}

func initPadClass(gclass unsafe.Pointer, overrides PadOverrides, classInitFunc func(*PadClass)) {
	pclass := (*C.GstPadClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypePad))))

	if overrides.Linked != nil {
		pclass.linked = (*[0]byte)(C._gotk4_gst1_PadClass_linked)
	}

	if overrides.Unlinked != nil {
		pclass.unlinked = (*[0]byte)(C._gotk4_gst1_PadClass_unlinked)
	}

	if classInitFunc != nil {
		class := (*PadClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapPad(obj *coreglib.Object) *Pad {
	return &Pad{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalPad(p uintptr) (interface{}, error) {
	return wrapPad(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectLinked signals that a pad has been linked to the peer pad.
func (pad *Pad) ConnectLinked(f func(peer *Pad)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(pad, "linked", false, unsafe.Pointer(C._gotk4_gst1_Pad_ConnectLinked), f)
}

// ConnectUnlinked signals that a pad has been unlinked from the peer pad.
func (pad *Pad) ConnectUnlinked(f func(peer *Pad)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(pad, "unlinked", false, unsafe.Pointer(C._gotk4_gst1_Pad_ConnectUnlinked), f)
}

// NewPad creates a new pad with the given name in the given direction.
// If name is NULL, a guaranteed unique name (across all pads) will be assigned.
// This function makes a copy of the name so you can safely free the name.
//
// The function takes the following parameters:
//
//   - name (optional) of the new pad.
//   - direction of the pad.
//
// The function returns the following values:
//
//   - pad: new Pad.
//
//     MT safe.
func NewPad(name string, direction PadDirection) *Pad {
	var _arg1 *C.gchar          // out
	var _arg2 C.GstPadDirection // out
	var _cret *C.GstPad         // in

	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = C.GstPadDirection(direction)

	_cret = C.gst_pad_new(_arg1, _arg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(direction)

	var _pad *Pad // out

	_pad = wrapPad(coreglib.Take(unsafe.Pointer(_cret)))

	return _pad
}

// NewPadFromStaticTemplate creates a new pad with the given name from the given
// static template. If name is NULL, a guaranteed unique name (across all pads)
// will be assigned. This function makes a copy of the name so you can safely
// free the name.
//
// The function takes the following parameters:
//
//   - templ to use.
//   - name of the pad.
//
// The function returns the following values:
//
//   - pad: new Pad.
func NewPadFromStaticTemplate(templ *StaticPadTemplate, name string) *Pad {
	var _arg1 *C.GstStaticPadTemplate // out
	var _arg2 *C.gchar                // out
	var _cret *C.GstPad               // in

	_arg1 = (*C.GstStaticPadTemplate)(gextras.StructNative(unsafe.Pointer(templ)))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_pad_new_from_static_template(_arg1, _arg2)
	runtime.KeepAlive(templ)
	runtime.KeepAlive(name)

	var _pad *Pad // out

	_pad = wrapPad(coreglib.Take(unsafe.Pointer(_cret)))

	return _pad
}

// NewPadFromTemplate creates a new pad with the given name from the given
// template. If name is NULL, a guaranteed unique name (across all pads) will be
// assigned. This function makes a copy of the name so you can safely free the
// name.
//
// The function takes the following parameters:
//
//   - templ: pad template to use.
//   - name (optional) of the pad.
//
// The function returns the following values:
//
//   - pad: new Pad.
func NewPadFromTemplate(templ *PadTemplate, name string) *Pad {
	var _arg1 *C.GstPadTemplate // out
	var _arg2 *C.gchar          // out
	var _cret *C.GstPad         // in

	_arg1 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(templ).Native()))
	if name != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gst_pad_new_from_template(_arg1, _arg2)
	runtime.KeepAlive(templ)
	runtime.KeepAlive(name)

	var _pad *Pad // out

	_pad = wrapPad(coreglib.Take(unsafe.Pointer(_cret)))

	return _pad
}

// ActivateMode activates or deactivates the given pad in mode via dispatching
// to the pad's activatemodefunc. For use from within pad activation functions
// only.
//
// If you don't know what this is, you probably don't want to call it.
//
// The function takes the following parameters:
//
//   - mode: requested activation mode.
//   - active: whether or not the pad should be active.
//
// The function returns the following values:
//
//   - ok: TRUE if the operation was successful.
//
//     MT safe.
func (pad *Pad) ActivateMode(mode PadMode, active bool) bool {
	var _arg0 *C.GstPad    // out
	var _arg1 C.GstPadMode // out
	var _arg2 C.gboolean   // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.GstPadMode(mode)
	if active {
		_arg2 = C.TRUE
	}

	_cret = C.gst_pad_activate_mode(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(mode)
	runtime.KeepAlive(active)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AddProbe: be notified of different states of pads. The provided callback is
// called for every state that matches mask.
//
// Probes are called in groups: First GST_PAD_PROBE_TYPE_BLOCK probes are
// called, then others, then finally GST_PAD_PROBE_TYPE_IDLE. The only exception
// here are GST_PAD_PROBE_TYPE_IDLE probes that are called immediately if the
// pad is already idle while calling gst_pad_add_probe(). In each of the groups,
// probes are called in the order in which they were added.
//
// The function takes the following parameters:
//
//   - mask: probe mask.
//   - callback that will be called with notifications of the pad state.
//
// The function returns the following values:
//
//   - gulong: id or 0 if no probe is pending. The id can be used to remove the
//     probe with gst_pad_remove_probe(). When using GST_PAD_PROBE_TYPE_IDLE it
//     can happen that the probe can be run immediately and if the probe returns
//     GST_PAD_PROBE_REMOVE this functions returns 0.
//
//     MT safe.
func (pad *Pad) AddProbe(mask PadProbeType, callback PadProbeCallback) uint32 {
	var _arg0 *C.GstPad             // out
	var _arg1 C.GstPadProbeType     // out
	var _arg2 C.GstPadProbeCallback // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify
	var _cret C.gulong // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.GstPadProbeType(mask)
	_arg2 = (*[0]byte)(C._gotk4_gst1_PadProbeCallback)
	_arg3 = C.gpointer(gbox.Assign(callback))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.gst_pad_add_probe(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(mask)
	runtime.KeepAlive(callback)

	var _gulong uint32 // out

	_gulong = uint32(_cret)

	return _gulong
}

// CanLink checks if the source pad and the sink pad are compatible so they can
// be linked.
//
// The function takes the following parameters:
//
//   - sinkpad: sink Pad.
//
// The function returns the following values:
//
//   - ok: TRUE if the pads can be linked.
func (srcpad *Pad) CanLink(sinkpad *Pad) bool {
	var _arg0 *C.GstPad  // out
	var _arg1 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(srcpad).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(sinkpad).Native()))

	_cret = C.gst_pad_can_link(_arg0, _arg1)
	runtime.KeepAlive(srcpad)
	runtime.KeepAlive(sinkpad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Chain a buffer to pad.
//
// The function returns T_FLOW_FLUSHING if the pad was flushing.
//
// If the buffer type is not acceptable for pad (as negotiated with a preceding
// GST_EVENT_CAPS event), this function returns T_FLOW_NOT_NEGOTIATED.
//
// The function proceeds calling the chain function installed on pad (see
// gst_pad_set_chain_function()) and the return value of that function is
// returned to the caller. T_FLOW_NOT_SUPPORTED is returned if pad has no chain
// function.
//
// In all cases, success or failure, the caller loses its reference to buffer
// after calling this function.
//
// The function takes the following parameters:
//
//   - buffer to send, return GST_FLOW_ERROR if not.
//
// The function returns the following values:
//
//   - flowReturn from the pad.
//
//     MT safe.
func (pad *Pad) Chain(buffer *Buffer) FlowReturn {
	var _arg0 *C.GstPad       // out
	var _arg1 *C.GstBuffer    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	_cret = C.gst_pad_chain(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(buffer)

	var _flowReturn FlowReturn // out

	_flowReturn = FlowReturn(_cret)

	return _flowReturn
}

// ChainList: chain a bufferlist to pad.
//
// The function returns T_FLOW_FLUSHING if the pad was flushing.
//
// If pad was not negotiated properly with a CAPS event, this function returns
// T_FLOW_NOT_NEGOTIATED.
//
// The function proceeds calling the chainlist function installed on pad (see
// gst_pad_set_chain_list_function()) and the return value of that function
// is returned to the caller. T_FLOW_NOT_SUPPORTED is returned if pad has no
// chainlist function.
//
// In all cases, success or failure, the caller loses its reference to list
// after calling this function.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - list to send, return GST_FLOW_ERROR if not.
//
// The function returns the following values:
//
//   - flowReturn from the pad.
func (pad *Pad) ChainList(list *BufferList) FlowReturn {
	var _arg0 *C.GstPad        // out
	var _arg1 *C.GstBufferList // out
	var _cret C.GstFlowReturn  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(list)), nil)

	_cret = C.gst_pad_chain_list(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(list)

	var _flowReturn FlowReturn // out

	_flowReturn = FlowReturn(_cret)

	return _flowReturn
}

// CheckReconfigure: check and clear the T_PAD_FLAG_NEED_RECONFIGURE flag on pad
// and return TRUE if the flag was set.
//
// The function returns the following values:
//
//   - ok: TRUE is the GST_PAD_FLAG_NEED_RECONFIGURE flag was set on pad.
func (pad *Pad) CheckReconfigure() bool {
	var _arg0 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_check_reconfigure(_arg0)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CreateStreamID creates a stream-id for the source Pad pad by combining the
// upstream information with the optional stream_id of the stream of pad. pad
// must have a parent Element and which must have zero or one sinkpad. stream_id
// can only be NULL if the parent element of pad has only a single source pad.
//
// This function generates an unique stream-id by getting the upstream
// stream-start event stream ID and appending stream_id to it. If the element
// has no sinkpad it will generate an upstream stream-id by doing an URI
// query on the element and in the worst case just uses a random number.
// Source elements that don't implement the URI handler interface should ideally
// generate a unique, deterministic stream-id manually instead.
//
// Since stream IDs are sorted alphabetically, any numbers in the stream ID
// should be printed with a fixed number of characters, preceded by 0's, such as
// by using the format \03u instead of \u.
//
// The function takes the following parameters:
//
//   - parent: parent Element of pad.
//   - streamId (optional): stream-id.
//
// The function returns the following values:
//
//   - utf8: stream-id for pad. g_free() after usage.
func (pad *Pad) CreateStreamID(parent Elementer, streamId string) string {
	var _arg0 *C.GstPad     // out
	var _arg1 *C.GstElement // out
	var _arg2 *C.gchar      // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	if streamId != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(streamId)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gst_pad_create_stream_id(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(streamId)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// EventDefault invokes the default event handler for the given pad.
//
// The EOS event will pause the task associated with pad before it is forwarded
// to all internally linked pads,
//
// The event is sent to all pads internally linked to pad. This function takes
// ownership of event.
//
// The function takes the following parameters:
//
//   - parent (optional) of pad or NULL.
//   - event to handle.
//
// The function returns the following values:
//
//   - ok: TRUE if the event was sent successfully.
func (pad *Pad) EventDefault(parent GstObjector, event *Event) bool {
	var _arg0 *C.GstPad    // out
	var _arg1 *C.GstObject // out
	var _arg2 *C.GstEvent  // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if parent != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	_arg2 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(event)), nil)

	_cret = C.gst_pad_event_default(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Forward calls forward for all internally linked pads of pad. This function
// deals with dynamically changing internal pads and will make sure that the
// forward function is only called once for each pad.
//
// When forward returns TRUE, no further pads will be processed.
//
// The function takes the following parameters:
//
//   - forward: PadForwardFunction.
//
// The function returns the following values:
//
//   - ok: TRUE if one of the dispatcher functions returned TRUE.
func (pad *Pad) Forward(forward PadForwardFunction) bool {
	var _arg0 *C.GstPad               // out
	var _arg1 C.GstPadForwardFunction // out
	var _arg2 C.gpointer
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gst1_PadForwardFunction)
	_arg2 = C.gpointer(gbox.Assign(forward))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.gst_pad_forward(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(forward)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AllowedCaps gets the capabilities of the allowed media types that can flow
// through pad and its peer.
//
// The allowed capabilities is calculated as the intersection of the results of
// calling gst_pad_query_caps() on pad and its peer. The caller owns a reference
// on the resulting caps.
//
// The function returns the following values:
//
//   - caps (optional): allowed Caps of the pad link. Unref the caps when you no
//     longer need it. This function returns NULL when pad has no peer.
//
//     MT safe.
func (pad *Pad) AllowedCaps() *Caps {
	var _arg0 *C.GstPad  // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_allowed_caps(_arg0)
	runtime.KeepAlive(pad)

	var _caps *Caps // out

	if _cret != nil {
		_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_caps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _caps
}

// CurrentCaps gets the capabilities currently configured on pad with the last
// T_EVENT_CAPS event.
//
// The function returns the following values:
//
//   - caps (optional): current caps of the pad with incremented ref-count or
//     NULL when pad has no caps. Unref after usage.
func (pad *Pad) CurrentCaps() *Caps {
	var _arg0 *C.GstPad  // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_current_caps(_arg0)
	runtime.KeepAlive(pad)

	var _caps *Caps // out

	if _cret != nil {
		_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_caps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _caps
}

// Direction gets the direction of the pad. The direction of the pad is decided
// at construction time so this function does not take the LOCK.
//
// The function returns the following values:
//
//   - padDirection of the pad.
//
//     MT safe.
func (pad *Pad) Direction() PadDirection {
	var _arg0 *C.GstPad         // out
	var _cret C.GstPadDirection // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_direction(_arg0)
	runtime.KeepAlive(pad)

	var _padDirection PadDirection // out

	_padDirection = PadDirection(_cret)

	return _padDirection
}

// ElementPrivate gets the private data of a pad. No locking is performed in
// this function.
//
// The function returns the following values:
//
//   - gpointer (optional) to the private data.
func (pad *Pad) ElementPrivate() unsafe.Pointer {
	var _arg0 *C.GstPad  // out
	var _cret C.gpointer // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_element_private(_arg0)
	runtime.KeepAlive(pad)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// LastFlowReturn gets the FlowReturn return from the last data passed by this
// pad.
func (pad *Pad) LastFlowReturn() FlowReturn {
	var _arg0 *C.GstPad       // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_last_flow_return(_arg0)
	runtime.KeepAlive(pad)

	var _flowReturn FlowReturn // out

	_flowReturn = FlowReturn(_cret)

	return _flowReturn
}

// Offset: get the offset applied to the running time of pad. pad has to be a
// source pad.
//
// The function returns the following values:
//
//   - gint64: offset.
func (pad *Pad) Offset() int64 {
	var _arg0 *C.GstPad // out
	var _cret C.gint64  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_offset(_arg0)
	runtime.KeepAlive(pad)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// PadTemplate gets the template for pad.
//
// The function returns the following values:
//
//   - padTemplate (optional) from which this pad was instantiated, or NULL if
//     this pad has no template. Unref after usage.
func (pad *Pad) PadTemplate() *PadTemplate {
	var _arg0 *C.GstPad         // out
	var _cret *C.GstPadTemplate // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_pad_template(_arg0)
	runtime.KeepAlive(pad)

	var _padTemplate *PadTemplate // out

	if _cret != nil {
		_padTemplate = wrapPadTemplate(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _padTemplate
}

// PadTemplateCaps gets the capabilities for pad's template.
//
// The function returns the following values:
//
//   - caps of this pad template. Unref after usage.
func (pad *Pad) PadTemplateCaps() *Caps {
	var _arg0 *C.GstPad  // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_pad_template_caps(_arg0)
	runtime.KeepAlive(pad)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// ParentElement gets the parent of pad, cast to a Element. If a pad has no
// parent or its parent is not an element, return NULL.
//
// The function returns the following values:
//
//   - element (optional): parent of the pad. The caller has a reference on the
//     parent, so unref when you're finished with it.
//
//     MT safe.
func (pad *Pad) ParentElement() Elementer {
	var _arg0 *C.GstPad     // out
	var _cret *C.GstElement // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_parent_element(_arg0)
	runtime.KeepAlive(pad)

	var _element Elementer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Elementer)
				return ok
			})
			rv, ok := casted.(Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_element = rv
		}
	}

	return _element
}

// Peer gets the peer of pad. This function refs the peer pad so you need to
// unref it after use.
//
// The function returns the following values:
//
//   - ret (optional): peer Pad. Unref after usage.
//
//     MT safe.
func (pad *Pad) Peer() *Pad {
	var _arg0 *C.GstPad // out
	var _cret *C.GstPad // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_peer(_arg0)
	runtime.KeepAlive(pad)

	var _ret *Pad // out

	if _cret != nil {
		_ret = wrapPad(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _ret
}

// Range: when pad is flushing this function returns T_FLOW_FLUSHING immediately
// and buffer is NULL.
//
// Calls the getrange function of pad, see PadGetRangeFunction for a description
// of a getrange function. If pad has no getrange function installed (see
// gst_pad_set_getrange_function()) this function returns T_FLOW_NOT_SUPPORTED.
//
// If buffer points to a variable holding NULL, a valid new Buffer will be
// placed in buffer when this function returns T_FLOW_OK. The new buffer must be
// freed with gst_buffer_unref() after usage.
//
// When buffer points to a variable that points to a valid Buffer, the buffer
// will be filled with the result data when this function returns T_FLOW_OK.
// If the provided buffer is larger than size, only size bytes will be filled in
// the result buffer and its size will be updated accordingly.
//
// Note that less than size bytes can be returned in buffer when, for example,
// an EOS condition is near or when buffer is not large enough to hold size
// bytes. The caller should check the result buffer size to get the result size.
//
// When this function returns any other result value than T_FLOW_OK, buffer will
// be unchanged.
//
// This is a lowlevel function. Usually gst_pad_pull_range() is used.
//
// The function takes the following parameters:
//
//   - offset: start offset of the buffer.
//   - size: length of the buffer.
//
// The function returns the following values:
//
//   - buffer: pointer to hold the Buffer, returns T_FLOW_ERROR if NULL.
//
//   - flowReturn from the pad.
//
//     MT safe.
func (pad *Pad) Range(offset uint64, size uint) (*Buffer, FlowReturn) {
	var _arg0 *C.GstPad       // out
	var _arg1 C.guint64       // out
	var _arg2 C.guint         // out
	var _arg3 *C.GstBuffer    // in
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.guint64(offset)
	_arg2 = C.guint(size)

	_cret = C.gst_pad_get_range(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _buffer *Buffer        // out
	var _flowReturn FlowReturn // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	_flowReturn = FlowReturn(_cret)

	return _buffer, _flowReturn
}

// SingleInternalLink: if there is a single internal link of the given pad,
// this function will return it. Otherwise, it will return NULL.
//
// The function returns the following values:
//
//   - ret (optional) or NULL if pad has none or more than one internal links.
//     Unref returned pad with gst_object_unref().
func (pad *Pad) SingleInternalLink() *Pad {
	var _arg0 *C.GstPad // out
	var _cret *C.GstPad // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_single_internal_link(_arg0)
	runtime.KeepAlive(pad)

	var _ret *Pad // out

	if _cret != nil {
		_ret = wrapPad(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _ret
}

// StickyEvent returns a new reference of the sticky event of type event_type
// from the event.
//
// The function takes the following parameters:
//
//   - eventType that should be retrieved.
//   - idx: index of the event.
//
// The function returns the following values:
//
//   - event (optional) of type event_type or NULL when no event of event_type
//     was on pad. Unref after usage.
func (pad *Pad) StickyEvent(eventType EventType, idx uint) *Event {
	var _arg0 *C.GstPad      // out
	var _arg1 C.GstEventType // out
	var _arg2 C.guint        // out
	var _cret *C.GstEvent    // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.GstEventType(eventType)
	_arg2 = C.guint(idx)

	_cret = C.gst_pad_get_sticky_event(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(eventType)
	runtime.KeepAlive(idx)

	var _event *Event // out

	if _cret != nil {
		_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_event)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _event
}

// Stream returns the current Stream for the pad, or NULL if none has been set
// yet, i.e. the pad has not received a stream-start event yet.
//
// This is a convenience wrapper around gst_pad_get_sticky_event() and
// gst_event_parse_stream().
//
// The function returns the following values:
//
//   - stream (optional): current Stream for pad, or NULL. unref the returned
//     stream when no longer needed.
func (pad *Pad) Stream() *Stream {
	var _arg0 *C.GstPad    // out
	var _cret *C.GstStream // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_stream(_arg0)
	runtime.KeepAlive(pad)

	var _stream *Stream // out

	if _cret != nil {
		_stream = wrapStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _stream
}

// StreamID returns the current stream-id for the pad, or NULL if none has been
// set yet, i.e. the pad has not received a stream-start event yet.
//
// This is a convenience wrapper around gst_pad_get_sticky_event() and
// gst_event_parse_stream_start().
//
// The returned stream-id string should be treated as an opaque string,
// its contents should not be interpreted.
//
// The function returns the following values:
//
//   - utf8 (optional): newly-allocated copy of the stream-id for pad, or NULL.
//     g_free() the returned string when no longer needed.
func (pad *Pad) StreamID() string {
	var _arg0 *C.GstPad // out
	var _cret *C.gchar  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_stream_id(_arg0)
	runtime.KeepAlive(pad)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// TaskState: get pad task state. If no task is currently set, T_TASK_STOPPED is
// returned.
//
// The function returns the following values:
//
//   - taskState: current state of pad's task.
func (pad *Pad) TaskState() TaskState {
	var _arg0 *C.GstPad      // out
	var _cret C.GstTaskState // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_get_task_state(_arg0)
	runtime.KeepAlive(pad)

	var _taskState TaskState // out

	_taskState = TaskState(_cret)

	return _taskState
}

// HasCurrentCaps: check if pad has caps set on it with a T_EVENT_CAPS event.
//
// The function returns the following values:
//
//   - ok: TRUE when pad has caps associated with it.
func (pad *Pad) HasCurrentCaps() bool {
	var _arg0 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_has_current_caps(_arg0)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsActive: query if a pad is active.
//
// The function returns the following values:
//
//   - ok: TRUE if the pad is active.
//
//     MT safe.
func (pad *Pad) IsActive() bool {
	var _arg0 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_is_active(_arg0)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsBlocked checks if the pad is blocked or not. This function returns the
// last requested state of the pad. It is not certain that the pad is actually
// blocking at this point (see gst_pad_is_blocking()).
//
// The function returns the following values:
//
//   - ok: TRUE if the pad is blocked.
//
//     MT safe.
func (pad *Pad) IsBlocked() bool {
	var _arg0 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_is_blocked(_arg0)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsBlocking checks if the pad is blocking or not. This is a guaranteed state
// of whether the pad is actually blocking on a Buffer or a Event.
//
// The function returns the following values:
//
//   - ok: TRUE if the pad is blocking.
//
//     MT safe.
func (pad *Pad) IsBlocking() bool {
	var _arg0 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_is_blocking(_arg0)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsLinked checks if a pad is linked to another pad or not.
//
// The function returns the following values:
//
//   - ok: TRUE if the pad is linked, FALSE otherwise.
//
//     MT safe.
func (pad *Pad) IsLinked() bool {
	var _arg0 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_is_linked(_arg0)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterateInternalLinks gets an iterator for the pads to which the given pad is
// linked to inside of the parent element.
//
// Each Pad element yielded by the iterator will have its refcount increased,
// so unref after use.
//
// Free-function: gst_iterator_free.
//
// The function returns the following values:
//
//   - iterator (optional): new Iterator of Pad or NULL when the pad does not
//     have an iterator function configured. Use gst_iterator_free() after
//     usage.
func (pad *Pad) IterateInternalLinks() *Iterator {
	var _arg0 *C.GstPad      // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_iterate_internal_links(_arg0)
	runtime.KeepAlive(pad)

	var _iterator *Iterator // out

	if _cret != nil {
		_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_iterator)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_iterator_free((*C.GstIterator)(intern.C))
			},
		)
	}

	return _iterator
}

// IterateInternalLinksDefault: iterate the list of pads to which the given
// pad is linked to inside of the parent element. This is the default handler,
// and thus returns an iterator of all of the pads inside the parent element
// with opposite direction.
//
// The caller must free this iterator after use with gst_iterator_free().
//
// The function takes the following parameters:
//
//   - parent (optional) of pad or NULL.
//
// The function returns the following values:
//
//   - iterator (optional) of Pad, or NULL if pad has no parent. Unref each
//     returned pad with gst_object_unref().
func (pad *Pad) IterateInternalLinksDefault(parent GstObjector) *Iterator {
	var _arg0 *C.GstPad      // out
	var _arg1 *C.GstObject   // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if parent != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}

	_cret = C.gst_pad_iterate_internal_links_default(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(parent)

	var _iterator *Iterator // out

	if _cret != nil {
		_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_iterator)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_iterator_free((*C.GstIterator)(intern.C))
			},
		)
	}

	return _iterator
}

// Link links the source pad and the sink pad.
//
// The function takes the following parameters:
//
//   - sinkpad: sink Pad to link.
//
// The function returns the following values:
//
//   - padLinkReturn: result code indicating if the connection worked or what
//     went wrong.
//
//     MT Safe.
func (srcpad *Pad) Link(sinkpad *Pad) PadLinkReturn {
	var _arg0 *C.GstPad          // out
	var _arg1 *C.GstPad          // out
	var _cret C.GstPadLinkReturn // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(srcpad).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(sinkpad).Native()))

	_cret = C.gst_pad_link(_arg0, _arg1)
	runtime.KeepAlive(srcpad)
	runtime.KeepAlive(sinkpad)

	var _padLinkReturn PadLinkReturn // out

	_padLinkReturn = PadLinkReturn(_cret)

	return _padLinkReturn
}

// LinkFull links the source pad and the sink pad.
//
// This variant of #gst_pad_link provides a more granular control on the checks
// being done when linking. While providing some considerable speedups the
// caller of this method must be aware that wrong usage of those flags can
// cause severe issues. Refer to the documentation of PadLinkCheck for more
// information.
//
// MT Safe.
//
// The function takes the following parameters:
//
//   - sinkpad: sink Pad to link.
//   - flags checks to validate when linking.
//
// The function returns the following values:
//
//   - padLinkReturn: result code indicating if the connection worked or what
//     went wrong.
func (srcpad *Pad) LinkFull(sinkpad *Pad, flags PadLinkCheck) PadLinkReturn {
	var _arg0 *C.GstPad          // out
	var _arg1 *C.GstPad          // out
	var _arg2 C.GstPadLinkCheck  // out
	var _cret C.GstPadLinkReturn // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(srcpad).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(sinkpad).Native()))
	_arg2 = C.GstPadLinkCheck(flags)

	_cret = C.gst_pad_link_full(_arg0, _arg1, _arg2)
	runtime.KeepAlive(srcpad)
	runtime.KeepAlive(sinkpad)
	runtime.KeepAlive(flags)

	var _padLinkReturn PadLinkReturn // out

	_padLinkReturn = PadLinkReturn(_cret)

	return _padLinkReturn
}

// LinkMaybeGhosting links src to sink, creating any GhostPad's in between as
// necessary.
//
// This is a convenience function to save having to create and add intermediate
// GhostPad's as required for linking across Bin boundaries.
//
// If src or sink pads don't have parent elements or do not share a common
// ancestor, the link will fail.
//
// The function takes the following parameters:
//
//   - sink: Pad.
//
// The function returns the following values:
//
//   - ok: whether the link succeeded.
func (src *Pad) LinkMaybeGhosting(sink *Pad) bool {
	var _arg0 *C.GstPad  // out
	var _arg1 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(sink).Native()))

	_cret = C.gst_pad_link_maybe_ghosting(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(sink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LinkMaybeGhostingFull links src to sink, creating any GhostPad's in between
// as necessary.
//
// This is a convenience function to save having to create and add intermediate
// GhostPad's as required for linking across Bin boundaries.
//
// If src or sink pads don't have parent elements or do not share a common
// ancestor, the link will fail.
//
// Calling gst_pad_link_maybe_ghosting_full() with flags ==
// GST_PAD_LINK_CHECK_DEFAULT is the recommended way of linking pads with safety
// checks applied.
//
// The function takes the following parameters:
//
//   - sink: Pad.
//   - flags: some PadLinkCheck flags.
//
// The function returns the following values:
//
//   - ok: whether the link succeeded.
func (src *Pad) LinkMaybeGhostingFull(sink *Pad, flags PadLinkCheck) bool {
	var _arg0 *C.GstPad         // out
	var _arg1 *C.GstPad         // out
	var _arg2 C.GstPadLinkCheck // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(sink).Native()))
	_arg2 = C.GstPadLinkCheck(flags)

	_cret = C.gst_pad_link_maybe_ghosting_full(_arg0, _arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(sink)
	runtime.KeepAlive(flags)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MarkReconfigure: mark a pad for needing reconfiguration. The next call to
// gst_pad_check_reconfigure() will return TRUE after this call.
func (pad *Pad) MarkReconfigure() {
	var _arg0 *C.GstPad // out

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	C.gst_pad_mark_reconfigure(_arg0)
	runtime.KeepAlive(pad)
}

// NeedsReconfigure: check the T_PAD_FLAG_NEED_RECONFIGURE flag on pad and
// return TRUE if the flag was set.
//
// The function returns the following values:
//
//   - ok: TRUE is the GST_PAD_FLAG_NEED_RECONFIGURE flag is set on pad.
func (pad *Pad) NeedsReconfigure() bool {
	var _arg0 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_needs_reconfigure(_arg0)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PauseTask: pause the task of pad. This function will also wait until the
// function executed by the task is finished if this function is not called from
// the task function.
//
// The function returns the following values:
//
//   - ok: TRUE if the task could be paused or FALSE when the pad has no task.
func (pad *Pad) PauseTask() bool {
	var _arg0 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_pause_task(_arg0)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PeerQuery performs gst_pad_query() on the peer of pad.
//
// The caller is responsible for both the allocation and deallocation of the
// query structure.
//
// The function takes the following parameters:
//
//   - query to perform.
//
// The function returns the following values:
//
//   - ok: TRUE if the query could be performed. This function returns FALSE if
//     pad has no peer.
func (pad *Pad) PeerQuery(query *Query) bool {
	var _arg0 *C.GstPad   // out
	var _arg1 *C.GstQuery // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_pad_peer_query(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PeerQueryAcceptCaps: check if the peer of pad accepts caps. If pad has no
// peer, this function returns TRUE.
//
// The function takes the following parameters:
//
//   - caps to check on the pad.
//
// The function returns the following values:
//
//   - ok: TRUE if the peer of pad can accept the caps or pad has no peer.
func (pad *Pad) PeerQueryAcceptCaps(caps *Caps) bool {
	var _arg0 *C.GstPad  // out
	var _arg1 *C.GstCaps // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_pad_peer_query_accept_caps(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PeerQueryCaps gets the capabilities of the peer connected to this pad.
// Similar to gst_pad_query_caps().
//
// When called on srcpads filter contains the caps that upstream could produce
// in the order preferred by upstream. When called on sinkpads filter contains
// the caps accepted by downstream in the preferred order. filter might be NULL
// but if it is not NULL the returned caps will be a subset of filter.
//
// The function takes the following parameters:
//
//   - filter (optional) filter, or NULL.
//
// The function returns the following values:
//
//   - caps of the peer pad with incremented ref-count. When there is no peer
//     pad, this function returns filter or, when filter is NULL, ANY caps.
func (pad *Pad) PeerQueryCaps(filter *Caps) *Caps {
	var _arg0 *C.GstPad  // out
	var _arg1 *C.GstCaps // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if filter != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))
	}

	_cret = C.gst_pad_peer_query_caps(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(filter)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// PeerQueryConvert queries the peer pad of a given sink pad to convert src_val
// in src_format to dest_format.
//
// The function takes the following parameters:
//
//   - srcFormat to convert from.
//   - srcVal: value to convert.
//   - destFormat to convert to.
//
// The function returns the following values:
//
//   - destVal: pointer to the result.
//   - ok: TRUE if the query could be performed.
func (pad *Pad) PeerQueryConvert(srcFormat Format, srcVal int64, destFormat Format) (int64, bool) {
	var _arg0 *C.GstPad   // out
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // out
	var _arg3 C.GstFormat // out
	var _arg4 C.gint64    // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.GstFormat(srcFormat)
	_arg2 = C.gint64(srcVal)
	_arg3 = C.GstFormat(destFormat)

	_cret = C.gst_pad_peer_query_convert(_arg0, _arg1, _arg2, _arg3, &_arg4)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(srcFormat)
	runtime.KeepAlive(srcVal)
	runtime.KeepAlive(destFormat)

	var _destVal int64 // out
	var _ok bool       // out

	_destVal = int64(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _destVal, _ok
}

// PeerQueryDuration queries the peer pad of a given sink pad for the total
// stream duration.
//
// The function takes the following parameters:
//
//   - format: Format requested.
//
// The function returns the following values:
//
//   - duration (optional): location in which to store the total duration,
//     or NULL.
//   - ok: TRUE if the query could be performed.
func (pad *Pad) PeerQueryDuration(format Format) (int64, bool) {
	var _arg0 *C.GstPad   // out
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.GstFormat(format)

	_cret = C.gst_pad_peer_query_duration(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(format)

	var _duration int64 // out
	var _ok bool        // out

	_duration = int64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _duration, _ok
}

// PeerQueryPosition queries the peer of a given sink pad for the stream
// position.
//
// The function takes the following parameters:
//
//   - format: Format requested.
//
// The function returns the following values:
//
//   - cur (optional): location in which to store the current position, or NULL.
//   - ok: TRUE if the query could be performed.
func (pad *Pad) PeerQueryPosition(format Format) (int64, bool) {
	var _arg0 *C.GstPad   // out
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.GstFormat(format)

	_cret = C.gst_pad_peer_query_position(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(format)

	var _cur int64 // out
	var _ok bool   // out

	_cur = int64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _cur, _ok
}

// ProxyQueryAcceptCaps checks if all internally linked pads of pad accepts the
// caps in query and returns the intersection of the results.
//
// This function is useful as a default accept caps query function for an
// element that can handle any stream format, but requires caps that are
// acceptable for all opposite pads.
//
// The function takes the following parameters:
//
//   - query: ACCEPT_CAPS Query.
//
// The function returns the following values:
//
//   - ok: TRUE if query could be executed.
func (pad *Pad) ProxyQueryAcceptCaps(query *Query) bool {
	var _arg0 *C.GstPad   // out
	var _arg1 *C.GstQuery // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_pad_proxy_query_accept_caps(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ProxyQueryCaps calls gst_pad_query_caps() for all internally linked pads of
// pad and returns the intersection of the results.
//
// This function is useful as a default caps query function for an element that
// can handle any stream format, but requires all its pads to have the same
// caps. Two such elements are tee and adder.
//
// The function takes the following parameters:
//
//   - query: CAPS Query.
//
// The function returns the following values:
//
//   - ok: TRUE if query could be executed.
func (pad *Pad) ProxyQueryCaps(query *Query) bool {
	var _arg0 *C.GstPad   // out
	var _arg1 *C.GstQuery // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_pad_proxy_query_caps(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PullRange pulls a buffer from the peer pad or fills up a provided buffer.
//
// This function will first trigger the pad block signal if it was installed.
//
// When pad is not linked T_FLOW_NOT_LINKED is returned else this
// function returns the result of gst_pad_get_range() on the peer pad. See
// gst_pad_get_range() for a list of return values and for the semantics of the
// arguments of this function.
//
// If buffer points to a variable holding NULL, a valid new Buffer will be
// placed in buffer when this function returns T_FLOW_OK. The new buffer must
// be freed with gst_buffer_unref() after usage. When this function returns any
// other result value, buffer will still point to NULL.
//
// When buffer points to a variable that points to a valid Buffer, the buffer
// will be filled with the result data when this function returns T_FLOW_OK.
// When this function returns any other result value, buffer will be unchanged.
// If the provided buffer is larger than size, only size bytes will be filled in
// the result buffer and its size will be updated accordingly.
//
// Note that less than size bytes can be returned in buffer when, for example,
// an EOS condition is near or when buffer is not large enough to hold size
// bytes. The caller should check the result buffer size to get the result size.
//
// The function takes the following parameters:
//
//   - offset: start offset of the buffer.
//   - size: length of the buffer.
//
// The function returns the following values:
//
//   - buffer: pointer to hold the Buffer, returns GST_FLOW_ERROR if NULL.
//
//   - flowReturn from the peer pad.
//
//     MT safe.
func (pad *Pad) PullRange(offset uint64, size uint) (*Buffer, FlowReturn) {
	var _arg0 *C.GstPad       // out
	var _arg1 C.guint64       // out
	var _arg2 C.guint         // out
	var _arg3 *C.GstBuffer    // in
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.guint64(offset)
	_arg2 = C.guint(size)

	_cret = C.gst_pad_pull_range(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _buffer *Buffer        // out
	var _flowReturn FlowReturn // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	_flowReturn = FlowReturn(_cret)

	return _buffer, _flowReturn
}

// Push pushes a buffer to the peer of pad.
//
// This function will call installed block probes before triggering any
// installed data probes.
//
// The function proceeds calling gst_pad_chain() on the peer pad and returns
// the value from that function. If pad has no peer, T_FLOW_NOT_LINKED will be
// returned.
//
// In all cases, success or failure, the caller loses its reference to buffer
// after calling this function.
//
// The function takes the following parameters:
//
//   - buffer to push returns GST_FLOW_ERROR if not.
//
// The function returns the following values:
//
//   - flowReturn from the peer pad.
//
//     MT safe.
func (pad *Pad) Push(buffer *Buffer) FlowReturn {
	var _arg0 *C.GstPad       // out
	var _arg1 *C.GstBuffer    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	_cret = C.gst_pad_push(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(buffer)

	var _flowReturn FlowReturn // out

	_flowReturn = FlowReturn(_cret)

	return _flowReturn
}

// PushEvent sends the event to the peer of the given pad. This function is
// mainly used by elements to send events to their peer elements.
//
// This function takes ownership of the provided event so you should
// gst_event_ref() it if you want to reuse the event after this call.
//
// The function takes the following parameters:
//
//   - event to send to the pad.
//
// The function returns the following values:
//
//   - ok: TRUE if the event was handled.
//
//     MT safe.
func (pad *Pad) PushEvent(event *Event) bool {
	var _arg0 *C.GstPad   // out
	var _arg1 *C.GstEvent // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(event)), nil)

	_cret = C.gst_pad_push_event(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PushList pushes a buffer list to the peer of pad.
//
// This function will call installed block probes before triggering any
// installed data probes.
//
// The function proceeds calling the chain function on the peer pad and returns
// the value from that function. If pad has no peer, T_FLOW_NOT_LINKED will be
// returned. If the peer pad does not have any installed chainlist function
// every group buffer of the list will be merged into a normal Buffer and
// chained via gst_pad_chain().
//
// In all cases, success or failure, the caller loses its reference to list
// after calling this function.
//
// The function takes the following parameters:
//
//   - list to push returns GST_FLOW_ERROR if not.
//
// The function returns the following values:
//
//   - flowReturn from the peer pad.
//
//     MT safe.
func (pad *Pad) PushList(list *BufferList) FlowReturn {
	var _arg0 *C.GstPad        // out
	var _arg1 *C.GstBufferList // out
	var _cret C.GstFlowReturn  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(list)), nil)

	_cret = C.gst_pad_push_list(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(list)

	var _flowReturn FlowReturn // out

	_flowReturn = FlowReturn(_cret)

	return _flowReturn
}

// Query dispatches a query to a pad. The query should have been allocated by
// the caller via one of the type-specific allocation functions. The element
// that the pad belongs to is responsible for filling the query with an
// appropriate response, which should then be parsed with a type-specific query
// parsing function.
//
// Again, the caller is responsible for both the allocation and deallocation of
// the query structure.
//
// Please also note that some queries might need a running pipeline to work.
//
// The function takes the following parameters:
//
//   - query to perform.
//
// The function returns the following values:
//
//   - ok: TRUE if the query could be performed.
func (pad *Pad) Query(query *Query) bool {
	var _arg0 *C.GstPad   // out
	var _arg1 *C.GstQuery // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_pad_query(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QueryAcceptCaps: check if the given pad accepts the caps.
//
// The function takes the following parameters:
//
//   - caps to check on the pad.
//
// The function returns the following values:
//
//   - ok: TRUE if the pad can accept the caps.
func (pad *Pad) QueryAcceptCaps(caps *Caps) bool {
	var _arg0 *C.GstPad  // out
	var _arg1 *C.GstCaps // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_pad_query_accept_caps(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QueryCaps gets the capabilities this pad can produce or consume.
// Note that this method doesn't necessarily return the caps set by sending
// a gst_event_new_caps() - use gst_pad_get_current_caps() for that instead.
// gst_pad_query_caps returns all possible caps a pad can operate with, using
// the pad's CAPS query function, If the query fails, this function will return
// filter, if not NULL, otherwise ANY.
//
// When called on sinkpads filter contains the caps that upstream could produce
// in the order preferred by upstream. When called on srcpads filter contains
// the caps accepted by downstream in the preferred order. filter might be NULL
// but if it is not NULL the returned caps will be a subset of filter.
//
// Note that this function does not return writable Caps, use
// gst_caps_make_writable() before modifying the caps.
//
// The function takes the following parameters:
//
//   - filter (optional): suggested Caps, or NULL.
//
// The function returns the following values:
//
//   - caps of the pad with incremented ref-count.
func (pad *Pad) QueryCaps(filter *Caps) *Caps {
	var _arg0 *C.GstPad  // out
	var _arg1 *C.GstCaps // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if filter != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))
	}

	_cret = C.gst_pad_query_caps(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(filter)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// QueryConvert queries a pad to convert src_val in src_format to dest_format.
//
// The function takes the following parameters:
//
//   - srcFormat to convert from.
//   - srcVal: value to convert.
//   - destFormat to convert to.
//
// The function returns the following values:
//
//   - destVal: pointer to the result.
//   - ok: TRUE if the query could be performed.
func (pad *Pad) QueryConvert(srcFormat Format, srcVal int64, destFormat Format) (int64, bool) {
	var _arg0 *C.GstPad   // out
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // out
	var _arg3 C.GstFormat // out
	var _arg4 C.gint64    // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.GstFormat(srcFormat)
	_arg2 = C.gint64(srcVal)
	_arg3 = C.GstFormat(destFormat)

	_cret = C.gst_pad_query_convert(_arg0, _arg1, _arg2, _arg3, &_arg4)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(srcFormat)
	runtime.KeepAlive(srcVal)
	runtime.KeepAlive(destFormat)

	var _destVal int64 // out
	var _ok bool       // out

	_destVal = int64(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _destVal, _ok
}

// QueryDefault invokes the default query handler for the given pad. The query
// is sent to all pads internally linked to pad. Note that if there are many
// possible sink pads that are internally linked to pad, only one will be sent
// the query. Multi-sinkpad elements should implement custom query handlers.
//
// The function takes the following parameters:
//
//   - parent (optional) of pad or NULL.
//   - query to handle.
//
// The function returns the following values:
//
//   - ok: TRUE if the query was performed successfully.
func (pad *Pad) QueryDefault(parent GstObjector, query *Query) bool {
	var _arg0 *C.GstPad    // out
	var _arg1 *C.GstObject // out
	var _arg2 *C.GstQuery  // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if parent != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	_arg2 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_pad_query_default(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QueryDuration queries a pad for the total stream duration.
//
// The function takes the following parameters:
//
//   - format: Format requested.
//
// The function returns the following values:
//
//   - duration (optional): location in which to store the total duration,
//     or NULL.
//   - ok: TRUE if the query could be performed.
func (pad *Pad) QueryDuration(format Format) (int64, bool) {
	var _arg0 *C.GstPad   // out
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.GstFormat(format)

	_cret = C.gst_pad_query_duration(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(format)

	var _duration int64 // out
	var _ok bool        // out

	_duration = int64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _duration, _ok
}

// QueryPosition queries a pad for the stream position.
//
// The function takes the following parameters:
//
//   - format: Format requested.
//
// The function returns the following values:
//
//   - cur (optional): location in which to store the current position, or NULL.
//   - ok: TRUE if the query could be performed.
func (pad *Pad) QueryPosition(format Format) (int64, bool) {
	var _arg0 *C.GstPad   // out
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.GstFormat(format)

	_cret = C.gst_pad_query_position(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(format)

	var _cur int64 // out
	var _ok bool   // out

	_cur = int64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _cur, _ok
}

// RemoveProbe: remove the probe with id from pad.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - id: probe id to remove.
func (pad *Pad) RemoveProbe(id uint32) {
	var _arg0 *C.GstPad // out
	var _arg1 C.gulong  // out

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.gulong(id)

	C.gst_pad_remove_probe(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(id)
}

// SendEvent sends the event to the pad. This function can be used by
// applications to send events in the pipeline.
//
// If pad is a source pad, event should be an upstream event. If pad is a sink
// pad, event should be a downstream event. For example, you would not send a
// T_EVENT_EOS on a src pad; EOS events only propagate downstream. Furthermore,
// some downstream events have to be serialized with data flow, like EOS, while
// some can travel out-of-band, like T_EVENT_FLUSH_START. If the event needs to
// be serialized with data flow, this function will take the pad's stream lock
// while calling its event function.
//
// To find out whether an event type is upstream, downstream, or downstream
// and serialized, see EventTypeFlags, gst_event_type_get_flags(),
// T_EVENT_IS_UPSTREAM, T_EVENT_IS_DOWNSTREAM, and T_EVENT_IS_SERIALIZED. Note
// that in practice that an application or plugin doesn't need to bother itself
// with this information; the core handles all necessary locks and checks.
//
// This function takes ownership of the provided event so you should
// gst_event_ref() it if you want to reuse the event after this call.
//
// The function takes the following parameters:
//
//   - event to send to the pad.
//
// The function returns the following values:
//
//   - ok: TRUE if the event was handled.
func (pad *Pad) SendEvent(event *Event) bool {
	var _arg0 *C.GstPad   // out
	var _arg1 *C.GstEvent // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(event)), nil)

	_cret = C.gst_pad_send_event(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetActive activates or deactivates the given pad. Normally called from within
// core state change functions.
//
// If active, makes sure the pad is active. If it is already active, either in
// push or pull mode, just return. Otherwise dispatches to the pad's activate
// function to perform the actual activation.
//
// If not active, calls gst_pad_activate_mode() with the pad's current mode and
// a FALSE argument.
//
// The function takes the following parameters:
//
//   - active: whether or not the pad should be active.
//
// The function returns the following values:
//
//   - ok: TRUE if the operation was successful.
//
//     MT safe.
func (pad *Pad) SetActive(active bool) bool {
	var _arg0 *C.GstPad  // out
	var _arg1 C.gboolean // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if active {
		_arg1 = C.TRUE
	}

	_cret = C.gst_pad_set_active(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(active)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetElementPrivate: set the given private data gpointer on the pad. This
// function can only be used by the element that owns the pad. No locking is
// performed in this function.
//
// The function takes the following parameters:
//
//   - priv (optional): private data to attach to the pad.
func (pad *Pad) SetElementPrivate(priv unsafe.Pointer) {
	var _arg0 *C.GstPad  // out
	var _arg1 C.gpointer // out

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(priv))

	C.gst_pad_set_element_private(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(priv)
}

// SetOffset: set the offset that will be applied to the running time of pad.
//
// The function takes the following parameters:
//
//   - offset: offset.
func (pad *Pad) SetOffset(offset int64) {
	var _arg0 *C.GstPad // out
	var _arg1 C.gint64  // out

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = C.gint64(offset)

	C.gst_pad_set_offset(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(offset)
}

// StartTask starts a task that repeatedly calls func with user_data. This
// function is mostly used in pad activation functions to start the dataflow.
// The T_PAD_STREAM_LOCK of pad will automatically be acquired before func is
// called.
//
// The function takes the following parameters:
//
//   - fn: task function to call.
//
// The function returns the following values:
//
//   - ok: TRUE if the task could be started.
func (pad *Pad) StartTask(fn TaskFunction) bool {
	var _arg0 *C.GstPad         // out
	var _arg1 C.GstTaskFunction // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gst1_TaskFunction)
	_arg2 = C.gpointer(gbox.Assign(fn))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.gst_pad_start_task(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(fn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StickyEventsForEach iterates all sticky events on pad and calls foreach_func
// for every event. If foreach_func returns FALSE the iteration is immediately
// stopped.
//
// The function takes the following parameters:
//
//   - foreachFunc that should be called for every event.
func (pad *Pad) StickyEventsForEach(foreachFunc PadStickyEventsForEachFunction) {
	var _arg0 *C.GstPad                           // out
	var _arg1 C.GstPadStickyEventsForeachFunction // out
	var _arg2 C.gpointer

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gst1_PadStickyEventsForEachFunction)
	_arg2 = C.gpointer(gbox.Assign(foreachFunc))
	defer gbox.Delete(uintptr(_arg2))

	C.gst_pad_sticky_events_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(foreachFunc)
}

// StopTask: stop the task of pad. This function will also make sure that the
// function executed by the task will effectively stop if not called from the
// GstTaskFunction.
//
// This function will deadlock if called from the GstTaskFunction of the task.
// Use gst_task_pause() instead.
//
// Regardless of whether the pad has a task, the stream lock is acquired and
// released so as to ensure that streaming through this pad has finished.
//
// The function returns the following values:
//
//   - ok: TRUE if the task could be stopped or FALSE on error.
func (pad *Pad) StopTask() bool {
	var _arg0 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_pad_stop_task(_arg0)
	runtime.KeepAlive(pad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StoreStickyEvent: store the sticky event on pad.
//
// The function takes the following parameters:
//
//   - event: Event.
//
// The function returns the following values:
//
//   - flowReturn on success, T_FLOW_FLUSHING when the pad was flushing or
//     T_FLOW_EOS when the pad was EOS.
func (pad *Pad) StoreStickyEvent(event *Event) FlowReturn {
	var _arg0 *C.GstPad       // out
	var _arg1 *C.GstEvent     // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_pad_store_sticky_event(_arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(event)

	var _flowReturn FlowReturn // out

	_flowReturn = FlowReturn(_cret)

	return _flowReturn
}

// Unlink unlinks the source pad from the sink pad. Will emit the Pad::unlinked
// signal on both pads.
//
// The function takes the following parameters:
//
//   - sinkpad: sink Pad to unlink.
//
// The function returns the following values:
//
//   - ok: TRUE if the pads were unlinked. This function returns FALSE if the
//     pads were not linked together.
//
//     MT safe.
func (srcpad *Pad) Unlink(sinkpad *Pad) bool {
	var _arg0 *C.GstPad  // out
	var _arg1 *C.GstPad  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(srcpad).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(sinkpad).Native()))

	_cret = C.gst_pad_unlink(_arg0, _arg1)
	runtime.KeepAlive(srcpad)
	runtime.KeepAlive(sinkpad)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UseFixedCaps: helper function you can use that sets the FIXED_CAPS flag This
// way the default CAPS query will always return the negotiated caps or in case
// the pad is not negotiated, the padtemplate caps.
//
// The negotiated caps are the caps of the last CAPS event that passed on the
// pad. Use this function on a pad that, once it negotiated to a CAPS, cannot be
// renegotiated to something else.
func (pad *Pad) UseFixedCaps() {
	var _arg0 *C.GstPad // out

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	C.gst_pad_use_fixed_caps(_arg0)
	runtime.KeepAlive(pad)
}

func (pad *Pad) linked(peer *Pad) {
	gclass := (*C.GstPadClass)(coreglib.PeekParentClass(pad))
	fnarg := gclass.linked

	var _arg0 *C.GstPad // out
	var _arg1 *C.GstPad // out

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(peer).Native()))

	C._gotk4_gst1_Pad_virtual_linked(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(peer)
}

func (pad *Pad) unlinked(peer *Pad) {
	gclass := (*C.GstPadClass)(coreglib.PeekParentClass(pad))
	fnarg := gclass.unlinked

	var _arg0 *C.GstPad // out
	var _arg1 *C.GstPad // out

	_arg0 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(peer).Native()))

	C._gotk4_gst1_Pad_virtual_unlinked(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(peer)
}

// PadLinkGetName gets a string representing the given pad-link return.
//
// The function takes the following parameters:
//
//   - ret to get the name of.
//
// The function returns the following values:
//
//   - utf8: static string with the name of the pad-link return.
func PadLinkGetName(ret PadLinkReturn) string {
	var _arg1 C.GstPadLinkReturn // out
	var _cret *C.gchar           // in

	_arg1 = C.GstPadLinkReturn(ret)

	_cret = C.gst_pad_link_get_name(_arg1)
	runtime.KeepAlive(ret)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// PadTemplateOverrides contains methods that are overridable.
type PadTemplateOverrides struct {
	// PadCreated: emit the pad-created signal for this template when created by
	// this pad.
	//
	// The function takes the following parameters:
	//
	//   - pad that created it.
	PadCreated func(pad *Pad)
}

func defaultPadTemplateOverrides(v *PadTemplate) PadTemplateOverrides {
	return PadTemplateOverrides{
		PadCreated: v.padCreated,
	}
}

// PadTemplate padtemplates describe the possible media types a pad or an
// elementfactory can handle. This allows for both inspection of handled types
// before loading the element plugin as well as identifying pads on elements
// that are not yet created (request or sometimes pads).
//
// Pad and PadTemplates have Caps attached to it to describe the media
// type they are capable of dealing with. gst_pad_template_get_caps() or
// GST_PAD_TEMPLATE_CAPS() are used to get the caps of a padtemplate. It's not
// possible to modify the caps of a padtemplate after creation.
//
// PadTemplates have a PadPresence property which identifies the lifetime
// of the pad and that can be retrieved with GST_PAD_TEMPLATE_PRESENCE().
// Also the direction of the pad can be retrieved from the PadTemplate with
// GST_PAD_TEMPLATE_DIRECTION().
//
// The GST_PAD_TEMPLATE_NAME_TEMPLATE () is important for GST_PAD_REQUEST pads
// because it has to be used as the name in the gst_element_request_pad_simple()
// call to instantiate a pad from this template.
//
// Padtemplates can be created with gst_pad_template_new() or with
// gst_static_pad_template_get (), which creates a PadTemplate
// from a StaticPadTemplate that can be filled with the convenient
// GST_STATIC_PAD_TEMPLATE() macro.
//
// A padtemplate can be used to create a pad (see gst_pad_new_from_template()
// or gst_pad_new_from_static_template ()) or to add to an element class (see
// gst_element_class_add_static_pad_template ()).
//
// The following code example shows the code to create a pad from a padtemplate.
//
//	static void
//	my_element_class_init (GstMyElementClass *klass)
//	{
//	  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);
//
//	  gst_element_class_add_static_pad_template (gstelement_class, &my_template);
//	}.
type PadTemplate struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*PadTemplate)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*PadTemplate, *PadTemplateClass, PadTemplateOverrides](
		GTypePadTemplate,
		initPadTemplateClass,
		wrapPadTemplate,
		defaultPadTemplateOverrides,
	)
}

func initPadTemplateClass(gclass unsafe.Pointer, overrides PadTemplateOverrides, classInitFunc func(*PadTemplateClass)) {
	pclass := (*C.GstPadTemplateClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypePadTemplate))))

	if overrides.PadCreated != nil {
		pclass.pad_created = (*[0]byte)(C._gotk4_gst1_PadTemplateClass_pad_created)
	}

	if classInitFunc != nil {
		class := (*PadTemplateClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapPadTemplate(obj *coreglib.Object) *PadTemplate {
	return &PadTemplate{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalPadTemplate(p uintptr) (interface{}, error) {
	return wrapPadTemplate(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectPadCreated: this signal is fired when an element creates a pad from
// this template.
func (templ *PadTemplate) ConnectPadCreated(f func(pad *Pad)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(templ, "pad-created", false, unsafe.Pointer(C._gotk4_gst1_PadTemplate_ConnectPadCreated), f)
}

// NewPadTemplate creates a new pad template with a name according to the given
// template and with the given arguments.
//
// The function takes the following parameters:
//
//   - nameTemplate: name template.
//   - direction of the template.
//   - presence of the pad.
//   - caps set for the template.
//
// The function returns the following values:
//
//   - padTemplate (optional): new PadTemplate.
func NewPadTemplate(nameTemplate string, direction PadDirection, presence PadPresence, caps *Caps) *PadTemplate {
	var _arg1 *C.gchar          // out
	var _arg2 C.GstPadDirection // out
	var _arg3 C.GstPadPresence  // out
	var _arg4 *C.GstCaps        // out
	var _cret *C.GstPadTemplate // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(nameTemplate)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GstPadDirection(direction)
	_arg3 = C.GstPadPresence(presence)
	_arg4 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_pad_template_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(nameTemplate)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(presence)
	runtime.KeepAlive(caps)

	var _padTemplate *PadTemplate // out

	if _cret != nil {
		_padTemplate = wrapPadTemplate(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _padTemplate
}

// NewPadTemplateFromStaticPadTemplateWithGType converts a StaticPadTemplate
// into a PadTemplate with a type.
//
// The function takes the following parameters:
//
//   - padTemplate: static pad template.
//   - padType of the pad to create.
//
// The function returns the following values:
//
//   - padTemplate (optional): new PadTemplate.
func NewPadTemplateFromStaticPadTemplateWithGType(padTemplate *StaticPadTemplate, padType coreglib.Type) *PadTemplate {
	var _arg1 *C.GstStaticPadTemplate // out
	var _arg2 C.GType                 // out
	var _cret *C.GstPadTemplate       // in

	_arg1 = (*C.GstStaticPadTemplate)(gextras.StructNative(unsafe.Pointer(padTemplate)))
	_arg2 = C.GType(padType)

	_cret = C.gst_pad_template_new_from_static_pad_template_with_gtype(_arg1, _arg2)
	runtime.KeepAlive(padTemplate)
	runtime.KeepAlive(padType)

	var _padTemplate *PadTemplate // out

	if _cret != nil {
		_padTemplate = wrapPadTemplate(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _padTemplate
}

// NewPadTemplateWithGType creates a new pad template with a name according to
// the given template and with the given arguments.
//
// The function takes the following parameters:
//
//   - nameTemplate: name template.
//   - direction of the template.
//   - presence of the pad.
//   - caps set for the template.
//   - padType of the pad to create.
//
// The function returns the following values:
//
//   - padTemplate (optional): new PadTemplate.
func NewPadTemplateWithGType(nameTemplate string, direction PadDirection, presence PadPresence, caps *Caps, padType coreglib.Type) *PadTemplate {
	var _arg1 *C.gchar          // out
	var _arg2 C.GstPadDirection // out
	var _arg3 C.GstPadPresence  // out
	var _arg4 *C.GstCaps        // out
	var _arg5 C.GType           // out
	var _cret *C.GstPadTemplate // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(nameTemplate)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GstPadDirection(direction)
	_arg3 = C.GstPadPresence(presence)
	_arg4 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg5 = C.GType(padType)

	_cret = C.gst_pad_template_new_with_gtype(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(nameTemplate)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(presence)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(padType)

	var _padTemplate *PadTemplate // out

	if _cret != nil {
		_padTemplate = wrapPadTemplate(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _padTemplate
}

// Caps gets the capabilities of the pad template.
//
// The function returns the following values:
//
//   - caps of the pad template. Unref after usage.
func (templ *PadTemplate) Caps() *Caps {
	var _arg0 *C.GstPadTemplate // out
	var _cret *C.GstCaps        // in

	_arg0 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(templ).Native()))

	_cret = C.gst_pad_template_get_caps(_arg0)
	runtime.KeepAlive(templ)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// DocumentationCaps: see gst_pad_template_set_documentation_caps().
//
// The function returns the following values:
//
//   - caps to document. For convenience, this will return
//     gst_pad_template_get_caps() when no documentation caps were set.
func (templ *PadTemplate) DocumentationCaps() *Caps {
	var _arg0 *C.GstPadTemplate // out
	var _cret *C.GstCaps        // in

	_arg0 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(templ).Native()))

	_cret = C.gst_pad_template_get_documentation_caps(_arg0)
	runtime.KeepAlive(templ)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// PadCreated: emit the pad-created signal for this template when created by
// this pad.
//
// The function takes the following parameters:
//
//   - pad that created it.
func (templ *PadTemplate) PadCreated(pad *Pad) {
	var _arg0 *C.GstPadTemplate // out
	var _arg1 *C.GstPad         // out

	_arg0 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(templ).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	C.gst_pad_template_pad_created(_arg0, _arg1)
	runtime.KeepAlive(templ)
	runtime.KeepAlive(pad)
}

// SetDocumentationCaps: certain elements will dynamically construct the caps
// of their pad templates. In order not to let environment-specific information
// into the documentation, element authors should use this method to expose
// "stable" caps to the reader.
//
// The function takes the following parameters:
//
//   - caps: documented capabilities.
func (templ *PadTemplate) SetDocumentationCaps(caps *Caps) {
	var _arg0 *C.GstPadTemplate // out
	var _arg1 *C.GstCaps        // out

	_arg0 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(templ).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	C.gst_pad_template_set_documentation_caps(_arg0, _arg1)
	runtime.KeepAlive(templ)
	runtime.KeepAlive(caps)
}

// padCreated: emit the pad-created signal for this template when created by
// this pad.
//
// The function takes the following parameters:
//
//   - pad that created it.
func (templ *PadTemplate) padCreated(pad *Pad) {
	gclass := (*C.GstPadTemplateClass)(coreglib.PeekParentClass(templ))
	fnarg := gclass.pad_created

	var _arg0 *C.GstPadTemplate // out
	var _arg1 *C.GstPad         // out

	_arg0 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(templ).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	C._gotk4_gst1_PadTemplate_virtual_pad_created(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(templ)
	runtime.KeepAlive(pad)
}

// PipelineOverrides contains methods that are overridable.
type PipelineOverrides struct {
}

func defaultPipelineOverrides(v *Pipeline) PipelineOverrides {
	return PipelineOverrides{}
}

// Pipeline is a special Bin used as the toplevel container for the filter
// graph. The Pipeline will manage the selection and distribution of a global
// Clock as well as provide a Bus to the application.
//
// gst_pipeline_new() is used to create a pipeline. when you are done with the
// pipeline, use gst_object_unref() to free its resources including all added
// Element objects (if not otherwise referenced).
//
// Elements are added and removed from the pipeline using the Bin methods like
// gst_bin_add() and gst_bin_remove() (see Bin).
//
// Before changing the state of the Pipeline (see Element) a Bus should be
// retrieved with gst_pipeline_get_bus(). This Bus should then be used to
// receive Message from the elements in the pipeline. Listening to the Bus is
// necessary for retrieving error messages from the Pipeline and otherwise the
// Pipeline might stop without any indication, why. Furthermore, the Pipeline
// posts messages even if nobody listens on the Bus, which will pile up and use
// up memory.
//
// By default, a Pipeline will automatically flush the pending Bus messages
// when going to the NULL state to ensure that no circular references exist
// when no messages are read from the Bus. This behaviour can be changed with
// gst_pipeline_set_auto_flush_bus().
//
// When the Pipeline performs the PAUSED to PLAYING state change it will select
// a clock for the elements. The clock selection algorithm will by default
// select a clock provided by an element that is most upstream (closest to the
// source). For live pipelines (ones that return T_STATE_CHANGE_NO_PREROLL
// from the gst_element_set_state() call) this will select the clock provided
// by the live source. For normal pipelines this will select a clock provided
// by the sinks (most likely the audio sink). If no element provides a clock,
// a default SystemClock is used.
//
// The clock selection can be controlled with the gst_pipeline_use_clock()
// method, which will enforce a given clock on the pipeline. With
// gst_pipeline_auto_clock() the default clock selection algorithm can be
// restored.
//
// A Pipeline maintains a running time for the elements. The running time is
// defined as the difference between the current clock time and the base time.
// When the pipeline goes to READY or a flushing seek is performed on it, the
// running time is reset to 0. When the pipeline is set from PLAYING to PAUSED,
// the current clock time is sampled and used to configure the base time for
// the elements when the pipeline is set to PLAYING again. The effect is that
// the running time (as the difference between the clock time and the base
// time) will count how much time was spent in the PLAYING state. This default
// behaviour can be changed with the gst_element_set_start_time() method.
type Pipeline struct {
	_ [0]func() // equal guard
	Bin
}

var (
	_ Elementer = (*Pipeline)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Pipeline, *PipelineClass, PipelineOverrides](
		GTypePipeline,
		initPipelineClass,
		wrapPipeline,
		defaultPipelineOverrides,
	)
}

func initPipelineClass(gclass unsafe.Pointer, overrides PipelineOverrides, classInitFunc func(*PipelineClass)) {
	if classInitFunc != nil {
		class := (*PipelineClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapPipeline(obj *coreglib.Object) *Pipeline {
	return &Pipeline{
		Bin: Bin{
			Element: Element{
				GstObject: GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
			ChildProxy: ChildProxy{
				Object: obj,
			},
		},
	}
}

func marshalPipeline(p uintptr) (interface{}, error) {
	return wrapPipeline(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewPipeline: create a new pipeline with the given name.
//
// The function takes the following parameters:
//
//   - name (optional) of new pipeline.
//
// The function returns the following values:
//
//   - pipeline: newly created GstPipeline
//
//     MT safe.
func NewPipeline(name string) *Pipeline {
	var _arg1 *C.gchar      // out
	var _cret *C.GstElement // in

	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_pipeline_new(_arg1)
	runtime.KeepAlive(name)

	var _pipeline *Pipeline // out

	_pipeline = wrapPipeline(coreglib.Take(unsafe.Pointer(_cret)))

	return _pipeline
}

// AutoClock: let pipeline select a clock automatically. This is the default
// behaviour.
//
// Use this function if you previous forced a fixed clock with
// gst_pipeline_use_clock() and want to restore the default pipeline clock
// selection algorithm.
//
// MT safe.
func (pipeline *Pipeline) AutoClock() {
	var _arg0 *C.GstPipeline // out

	_arg0 = (*C.GstPipeline)(unsafe.Pointer(coreglib.InternObject(pipeline).Native()))

	C.gst_pipeline_auto_clock(_arg0)
	runtime.KeepAlive(pipeline)
}

// AutoFlushBus: check if pipeline will automatically flush messages when going
// to the NULL state.
//
// The function returns the following values:
//
//   - ok: whether the pipeline will automatically flush its bus when going from
//     READY to NULL state or not.
//
//     MT safe.
func (pipeline *Pipeline) AutoFlushBus() bool {
	var _arg0 *C.GstPipeline // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstPipeline)(unsafe.Pointer(coreglib.InternObject(pipeline).Native()))

	_cret = C.gst_pipeline_get_auto_flush_bus(_arg0)
	runtime.KeepAlive(pipeline)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Bus gets the Bus of pipeline. The bus allows applications to receive Message
// packets.
//
// The function returns the following values:
//
//   - bus unref after usage.
//
//     MT safe.
func (pipeline *Pipeline) Bus() *Bus {
	var _arg0 *C.GstPipeline // out
	var _cret *C.GstBus      // in

	_arg0 = (*C.GstPipeline)(unsafe.Pointer(coreglib.InternObject(pipeline).Native()))

	_cret = C.gst_pipeline_get_bus(_arg0)
	runtime.KeepAlive(pipeline)

	var _bus *Bus // out

	_bus = wrapBus(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _bus
}

// ConfiguredLatency: return the configured latency on pipeline.
//
// The function returns the following values:
//
//   - clockTime: pipeline configured latency, or GST_CLOCK_TIME_NONE if none
//     has been configured because pipeline did not reach the PLAYING state yet.
//
//     MT safe.
func (pipeline *Pipeline) ConfiguredLatency() ClockTime {
	var _arg0 *C.GstPipeline // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstPipeline)(unsafe.Pointer(coreglib.InternObject(pipeline).Native()))

	_cret = C.gst_pipeline_get_configured_latency(_arg0)
	runtime.KeepAlive(pipeline)

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// Delay: get the configured delay (see gst_pipeline_set_delay()).
//
// The function returns the following values:
//
//   - clockTime: configured delay.
//
//     MT safe.
func (pipeline *Pipeline) Delay() ClockTime {
	var _arg0 *C.GstPipeline // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstPipeline)(unsafe.Pointer(coreglib.InternObject(pipeline).Native()))

	_cret = C.gst_pipeline_get_delay(_arg0)
	runtime.KeepAlive(pipeline)

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// Latency gets the latency that should be configured on the pipeline.
// See gst_pipeline_set_latency().
//
// The function returns the following values:
//
//   - clockTime: latency to configure on the pipeline or GST_CLOCK_TIME_NONE.
func (pipeline *Pipeline) Latency() ClockTime {
	var _arg0 *C.GstPipeline // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstPipeline)(unsafe.Pointer(coreglib.InternObject(pipeline).Native()))

	_cret = C.gst_pipeline_get_latency(_arg0)
	runtime.KeepAlive(pipeline)

	var _clockTime ClockTime // out

	_clockTime = ClockTime(_cret)

	return _clockTime
}

// PipelineClock gets the current clock used by pipeline.
//
// Unlike gst_element_get_clock(), this function will always return a clock,
// even if the pipeline is not in the PLAYING state.
//
// The function returns the following values:
//
//   - clock unref after usage.
func (pipeline *Pipeline) PipelineClock() Clocker {
	var _arg0 *C.GstPipeline // out
	var _cret *C.GstClock    // in

	_arg0 = (*C.GstPipeline)(unsafe.Pointer(coreglib.InternObject(pipeline).Native()))

	_cret = C.gst_pipeline_get_pipeline_clock(_arg0)
	runtime.KeepAlive(pipeline)

	var _clock Clocker // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gst.Clocker is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Clocker)
			return ok
		})
		rv, ok := casted.(Clocker)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Clocker")
		}
		_clock = rv
	}

	return _clock
}

// IsLive: check if pipeline is live.
//
// The function returns the following values:
//
//   - ok: TRUE if pipeline is live, FALSE if not or if it did not reach the
//     PAUSED state yet.
//
//     MT safe.
func (pipeline *Pipeline) IsLive() bool {
	var _arg0 *C.GstPipeline // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstPipeline)(unsafe.Pointer(coreglib.InternObject(pipeline).Native()))

	_cret = C.gst_pipeline_is_live(_arg0)
	runtime.KeepAlive(pipeline)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAutoFlushBus: usually, when a pipeline goes from READY to NULL state,
// it automatically flushes all pending messages on the bus, which is done for
// refcounting purposes, to break circular references.
//
// This means that applications that update state using (async) bus messages
// (e.g. do certain things when a pipeline goes from PAUSED to READY) might not
// get to see messages when the pipeline is shut down, because they might be
// flushed before they can be dispatched in the main thread. This behaviour can
// be disabled using this function.
//
// It is important that all messages on the bus are handled when the automatic
// flushing is disabled else memory leaks will be introduced.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - autoFlush: whether or not to automatically flush the bus when the
//     pipeline goes from READY to NULL state.
func (pipeline *Pipeline) SetAutoFlushBus(autoFlush bool) {
	var _arg0 *C.GstPipeline // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GstPipeline)(unsafe.Pointer(coreglib.InternObject(pipeline).Native()))
	if autoFlush {
		_arg1 = C.TRUE
	}

	C.gst_pipeline_set_auto_flush_bus(_arg0, _arg1)
	runtime.KeepAlive(pipeline)
	runtime.KeepAlive(autoFlush)
}

// SetDelay: set the expected delay needed for all elements to perform the
// PAUSED to PLAYING state change. delay will be added to the base time of the
// elements so that they wait an additional delay amount of time before starting
// to process buffers and cannot be T_CLOCK_TIME_NONE.
//
// This option is used for tuning purposes and should normally not be used.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - delay: delay.
func (pipeline *Pipeline) SetDelay(delay ClockTime) {
	var _arg0 *C.GstPipeline // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstPipeline)(unsafe.Pointer(coreglib.InternObject(pipeline).Native()))
	_arg1 = C.GstClockTime(delay)

	C.gst_pipeline_set_delay(_arg0, _arg1)
	runtime.KeepAlive(pipeline)
	runtime.KeepAlive(delay)
}

// SetLatency sets the latency that should be configured on the pipeline.
// Setting GST_CLOCK_TIME_NONE will restore the default behaviour of using the
// minimum latency from the LATENCY query. Setting this is usually not required
// and the pipeline will figure out an appropriate latency automatically.
//
// Setting a too low latency, especially lower than the minimum latency from the
// LATENCY query, will most likely cause the pipeline to fail.
//
// The function takes the following parameters:
//
//   - latency to configure.
func (pipeline *Pipeline) SetLatency(latency ClockTime) {
	var _arg0 *C.GstPipeline // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstPipeline)(unsafe.Pointer(coreglib.InternObject(pipeline).Native()))
	_arg1 = C.GstClockTime(latency)

	C.gst_pipeline_set_latency(_arg0, _arg1)
	runtime.KeepAlive(pipeline)
	runtime.KeepAlive(latency)
}

// UseClock: force pipeline to use the given clock. The pipeline will always use
// the given clock even if new clock providers are added to this pipeline.
//
// If clock is NULL all clocking will be disabled which will make the pipeline
// run as fast as possible.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - clock (optional) to use.
func (pipeline *Pipeline) UseClock(clock Clocker) {
	var _arg0 *C.GstPipeline // out
	var _arg1 *C.GstClock    // out

	_arg0 = (*C.GstPipeline)(unsafe.Pointer(coreglib.InternObject(pipeline).Native()))
	if clock != nil {
		_arg1 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	}

	C.gst_pipeline_use_clock(_arg0, _arg1)
	runtime.KeepAlive(pipeline)
	runtime.KeepAlive(clock)
}

// Plugin: GStreamer is extensible, so Element instances can be loaded at
// runtime. A plugin system can provide one or more of the basic GStreamer
// PluginFeature subclasses.
//
// A plugin should export a symbol gst_plugin_desc that is a struct of type
// PluginDesc. the plugin loader will check the version of the core library the
// plugin was linked against and will create a new Plugin. It will then call the
// PluginInitFunc function that was provided in the gst_plugin_desc.
//
// Once you have a handle to a Plugin (e.g. from the Registry), you can add any
// object that subclasses PluginFeature.
//
// Usually plugins are always automatically loaded so you don't need to call
// gst_plugin_load() explicitly to bring it into memory. There are options to
// statically link plugins to an app or even use GStreamer without a plugin
// repository in which case gst_plugin_load() can be needed to bring the plugin
// into memory.
type Plugin struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*Plugin)(nil)
)

func wrapPlugin(obj *coreglib.Object) *Plugin {
	return &Plugin{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalPlugin(p uintptr) (interface{}, error) {
	return wrapPlugin(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// AddDependency: make GStreamer aware of external dependencies which affect the
// feature set of this plugin (ie. the elements or typefinders associated with
// it).
//
// GStreamer will re-inspect plugins with external dependencies whenever any
// of the external dependencies change. This is useful for plugins which wrap
// other plugin systems, e.g. a plugin which wraps a plugin-based visualisation
// library and makes visualisations available as GStreamer elements, or a codec
// loader which exposes elements and/or caps dependent on what external codec
// libraries are currently installed.
//
// The function takes the following parameters:
//
//   - envVars (optional): NULL-terminated array of environment variables
//     affecting the feature set of the plugin (e.g. an environment variable
//     containing paths where to look for additional modules/plugins of a
//     library), or NULL. Environment variable names may be followed by a path
//     component which will be added to the content of the environment variable,
//     e.g. "HOME/.mystuff/plugins".
//   - paths (optional): NULL-terminated array of directories/paths where
//     dependent files may be, or NULL.
//   - names (optional): NULL-terminated array of file names (or file name
//     suffixes, depending on flags) to be used in combination with the paths
//     from paths and/or the paths extracted from the environment variables in
//     env_vars, or NULL.
//   - flags: optional flags, or T_PLUGIN_DEPENDENCY_FLAG_NONE.
func (plugin *Plugin) AddDependency(envVars, paths, names []string, flags PluginDependencyFlags) {
	var _arg0 *C.GstPlugin               // out
	var _arg1 **C.gchar                  // out
	var _arg2 **C.gchar                  // out
	var _arg3 **C.gchar                  // out
	var _arg4 C.GstPluginDependencyFlags // out

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))
	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(envVars) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(envVars)+1)
			var zero *C.gchar
			out[len(envVars)] = zero
			for i := range envVars {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(envVars[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	{
		_arg2 = (**C.gchar)(C.calloc(C.size_t((len(paths) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice(_arg2, len(paths)+1)
			var zero *C.gchar
			out[len(paths)] = zero
			for i := range paths {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(paths[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	{
		_arg3 = (**C.gchar)(C.calloc(C.size_t((len(names) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg3))
		{
			out := unsafe.Slice(_arg3, len(names)+1)
			var zero *C.gchar
			out[len(names)] = zero
			for i := range names {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(names[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	_arg4 = C.GstPluginDependencyFlags(flags)

	C.gst_plugin_add_dependency(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(plugin)
	runtime.KeepAlive(envVars)
	runtime.KeepAlive(paths)
	runtime.KeepAlive(names)
	runtime.KeepAlive(flags)
}

// AddDependencySimple: make GStreamer aware of external dependencies which
// affect the feature set of this plugin (ie. the elements or typefinders
// associated with it).
//
// GStreamer will re-inspect plugins with external dependencies whenever any
// of the external dependencies change. This is useful for plugins which wrap
// other plugin systems, e.g. a plugin which wraps a plugin-based visualisation
// library and makes visualisations available as GStreamer elements, or a codec
// loader which exposes elements and/or caps dependent on what external codec
// libraries are currently installed.
//
// Convenience wrapper function for gst_plugin_add_dependency() which takes
// simple strings as arguments instead of string arrays, with multiple arguments
// separated by predefined delimiters (see above).
//
// The function takes the following parameters:
//
//   - envVars (optional): one or more environment variables (separated by ':',
//     ';' or ','), or NULL. Environment variable names may be followed by a
//     path component which will be added to the content of the environment
//     variable, e.g. "HOME/.mystuff/plugins:MYSTUFF_PLUGINS_PATH".
//   - paths (optional): one ore more directory paths (separated by ':' or ';'
//     or ','), or NULL. Example: "/usr/lib/mystuff/plugins".
//   - names (optional): one or more file names or file name suffixes (separated
//     by commas), or NULL.
//   - flags: optional flags, or T_PLUGIN_DEPENDENCY_FLAG_NONE.
func (plugin *Plugin) AddDependencySimple(envVars, paths, names string, flags PluginDependencyFlags) {
	var _arg0 *C.GstPlugin               // out
	var _arg1 *C.gchar                   // out
	var _arg2 *C.gchar                   // out
	var _arg3 *C.gchar                   // out
	var _arg4 C.GstPluginDependencyFlags // out

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))
	if envVars != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(envVars)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if paths != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(paths)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if names != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(names)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	_arg4 = C.GstPluginDependencyFlags(flags)

	C.gst_plugin_add_dependency_simple(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(plugin)
	runtime.KeepAlive(envVars)
	runtime.KeepAlive(paths)
	runtime.KeepAlive(names)
	runtime.KeepAlive(flags)
}

// The function takes the following parameters:
//
//   - message status error message.
func (plugin *Plugin) AddStatusError(message string) {
	var _arg0 *C.GstPlugin // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_plugin_add_status_error(_arg0, _arg1)
	runtime.KeepAlive(plugin)
	runtime.KeepAlive(message)
}

// The function takes the following parameters:
//
//   - message status info message.
func (plugin *Plugin) AddStatusInfo(message string) {
	var _arg0 *C.GstPlugin // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_plugin_add_status_info(_arg0, _arg1)
	runtime.KeepAlive(plugin)
	runtime.KeepAlive(message)
}

// The function takes the following parameters:
//
//   - message status warning message.
func (plugin *Plugin) AddStatusWarning(message string) {
	var _arg0 *C.GstPlugin // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_plugin_add_status_warning(_arg0, _arg1)
	runtime.KeepAlive(plugin)
	runtime.KeepAlive(message)
}

// CacheData gets the plugin specific data cache. If it is NULL there is no
// cached data stored. This is the case when the registry is getting rebuilt.
//
// The function returns the following values:
//
//   - structure (optional): cached data as a Structure or NULL.
func (plugin *Plugin) CacheData() *Structure {
	var _arg0 *C.GstPlugin    // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_cache_data(_arg0)
	runtime.KeepAlive(plugin)

	var _structure *Structure // out

	if _cret != nil {
		_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _structure
}

// Description: get the long descriptive name of the plugin.
//
// The function returns the following values:
//
//   - utf8: long name of the plugin.
func (plugin *Plugin) Description() string {
	var _arg0 *C.GstPlugin // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_description(_arg0)
	runtime.KeepAlive(plugin)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Filename: get the filename of the plugin.
//
// The function returns the following values:
//
//   - filename (optional) of the plugin.
func (plugin *Plugin) Filename() string {
	var _arg0 *C.GstPlugin // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_filename(_arg0)
	runtime.KeepAlive(plugin)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _filename
}

// License: get the license of the plugin.
//
// The function returns the following values:
//
//   - utf8: license of the plugin.
func (plugin *Plugin) License() string {
	var _arg0 *C.GstPlugin // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_license(_arg0)
	runtime.KeepAlive(plugin)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Name: get the short name of the plugin.
//
// The function returns the following values:
//
//   - utf8: name of the plugin.
func (plugin *Plugin) Name() string {
	var _arg0 *C.GstPlugin // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_name(_arg0)
	runtime.KeepAlive(plugin)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Origin: get the URL where the plugin comes from.
//
// The function returns the following values:
//
//   - utf8: origin of the plugin.
func (plugin *Plugin) Origin() string {
	var _arg0 *C.GstPlugin // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_origin(_arg0)
	runtime.KeepAlive(plugin)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Package: get the package the plugin belongs to.
//
// The function returns the following values:
//
//   - utf8: package of the plugin.
func (plugin *Plugin) Package() string {
	var _arg0 *C.GstPlugin // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_package(_arg0)
	runtime.KeepAlive(plugin)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ReleaseDateString: get the release date (and possibly time) in form of a
// string, if available.
//
// For normal GStreamer plugin releases this will usually just be a date in the
// form of "YYYY-MM-DD", while pre-releases and builds from git may contain
// a time component after the date as well, in which case the string will be
// formatted like "YYYY-MM-DDTHH:MMZ" (e.g. "2012-04-30T09:30Z").
//
// There may be plugins that do not have a valid release date set on them.
//
// The function returns the following values:
//
//   - utf8 (optional): date string of the plugin, or NULL if not available.
func (plugin *Plugin) ReleaseDateString() string {
	var _arg0 *C.GstPlugin // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_release_date_string(_arg0)
	runtime.KeepAlive(plugin)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Source: get the source module the plugin belongs to.
//
// The function returns the following values:
//
//   - utf8: source of the plugin.
func (plugin *Plugin) Source() string {
	var _arg0 *C.GstPlugin // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_source(_arg0)
	runtime.KeepAlive(plugin)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
//   - utf8s (optional): array of plugin status error messages, or NULL.
func (plugin *Plugin) StatusErrors() []string {
	var _arg0 *C.GstPlugin // out
	var _cret **C.gchar    // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_status_errors(_arg0)
	runtime.KeepAlive(plugin)

	var _utf8s []string // out

	if _cret != nil {
		defer C.free(unsafe.Pointer(_cret))
		{
			var i int
			var z *C.gchar
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
				defer C.free(unsafe.Pointer(src[i]))
			}
		}
	}

	return _utf8s
}

// The function returns the following values:
//
//   - utf8s (optional): array of plugin status info messages, or NULL.
func (plugin *Plugin) StatusInfos() []string {
	var _arg0 *C.GstPlugin // out
	var _cret **C.gchar    // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_status_infos(_arg0)
	runtime.KeepAlive(plugin)

	var _utf8s []string // out

	if _cret != nil {
		defer C.free(unsafe.Pointer(_cret))
		{
			var i int
			var z *C.gchar
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
				defer C.free(unsafe.Pointer(src[i]))
			}
		}
	}

	return _utf8s
}

// The function returns the following values:
//
//   - utf8s (optional): array of plugin status warning messages, or NULL.
func (plugin *Plugin) StatusWarnings() []string {
	var _arg0 *C.GstPlugin // out
	var _cret **C.gchar    // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_status_warnings(_arg0)
	runtime.KeepAlive(plugin)

	var _utf8s []string // out

	if _cret != nil {
		defer C.free(unsafe.Pointer(_cret))
		{
			var i int
			var z *C.gchar
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
				defer C.free(unsafe.Pointer(src[i]))
			}
		}
	}

	return _utf8s
}

// Version: get the version of the plugin.
//
// The function returns the following values:
//
//   - utf8: version of the plugin.
func (plugin *Plugin) Version() string {
	var _arg0 *C.GstPlugin // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_get_version(_arg0)
	runtime.KeepAlive(plugin)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// IsLoaded queries if the plugin is loaded into memory.
//
// The function returns the following values:
//
//   - ok: TRUE is loaded, FALSE otherwise.
func (plugin *Plugin) IsLoaded() bool {
	var _arg0 *C.GstPlugin // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_is_loaded(_arg0)
	runtime.KeepAlive(plugin)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Load loads plugin. Note that the *return value* is the loaded plugin;
// plugin is untouched. The normal use pattern of this function goes like this:
//
//	GstPlugin *loaded_plugin;
//	loaded_plugin = gst_plugin_load (plugin);
//	// presumably, we're no longer interested in the potentially-unloaded plugin
//	gst_object_unref (plugin);
//	plugin = loaded_plugin;.
//
// The function returns the following values:
//
//   - ret (optional): reference to a loaded plugin, or NULL on error.
func (plugin *Plugin) Load() *Plugin {
	var _arg0 *C.GstPlugin // out
	var _cret *C.GstPlugin // in

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_plugin_load(_arg0)
	runtime.KeepAlive(plugin)

	var _ret *Plugin // out

	if _cret != nil {
		_ret = wrapPlugin(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _ret
}

// SetCacheData adds plugin specific data to cache. Passes the ownership of the
// structure to the plugin.
//
// The cache is flushed every time the registry is rebuilt.
//
// The function takes the following parameters:
//
//   - cacheData: structure containing the data to cache.
func (plugin *Plugin) SetCacheData(cacheData *Structure) {
	var _arg0 *C.GstPlugin    // out
	var _arg1 *C.GstStructure // out

	_arg0 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(cacheData)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(cacheData)), nil)

	C.gst_plugin_set_cache_data(_arg0, _arg1)
	runtime.KeepAlive(plugin)
	runtime.KeepAlive(cacheData)
}

// PluginLoadByName: load the named plugin. Refs the plugin.
//
// The function takes the following parameters:
//
//   - name of plugin to load.
//
// The function returns the following values:
//
//   - plugin (optional): reference to a loaded plugin, or NULL on error.
func PluginLoadByName(name string) *Plugin {
	var _arg1 *C.gchar     // out
	var _cret *C.GstPlugin // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_plugin_load_by_name(_arg1)
	runtime.KeepAlive(name)

	var _plugin *Plugin // out

	if _cret != nil {
		_plugin = wrapPlugin(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _plugin
}

// PluginLoadFile loads the given plugin and refs it. Caller needs to unref
// after use.
//
// The function takes the following parameters:
//
//   - filename: plugin filename to load.
//
// The function returns the following values:
//
//   - plugin: reference to the existing loaded GstPlugin, a reference to the
//     newly-loaded GstPlugin, or NULL if an error occurred.
func PluginLoadFile(filename string) (*Plugin, error) {
	var _arg1 *C.gchar     // out
	var _cret *C.GstPlugin // in
	var _cerr *C.GError    // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_plugin_load_file(_arg1, &_cerr)
	runtime.KeepAlive(filename)

	var _plugin *Plugin // out
	var _goerr error    // out

	_plugin = wrapPlugin(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _plugin, _goerr
}

// PluginRegisterStaticFull registers a static plugin, ie. a plugin which is
// private to an application or library and contained within the application
// or library (as opposed to being shipped as a separate module file) with
// a PluginInitFullFunc which allows user data to be passed to the callback
// function (useful for bindings).
//
// You must make sure that GStreamer has been initialised (with gst_init() or
// via gst_init_get_option_group()) before calling this function.
//
// The function takes the following parameters:
//
//   - majorVersion: major version number of the GStreamer core that the plugin
//     was compiled for, you can just use GST_VERSION_MAJOR here.
//   - minorVersion: minor version number of the GStreamer core that the plugin
//     was compiled for, you can just use GST_VERSION_MINOR here.
//   - name: unique name of the plugin (ideally prefixed with an application-
//     or library-specific namespace prefix in order to avoid name conflicts in
//     case a similar plugin with the same name ever gets added to GStreamer).
//   - description of the plugin.
//   - initFullFunc: pointer to the init function with user data of this plugin.
//   - version string of the plugin.
//   - license: effective license of plugin. Must be one of the approved
//     licenses (see PluginDesc above) or the plugin will not be registered.
//   - source module plugin belongs to.
//   - pkg: shipped package plugin belongs to.
//   - origin: URL to provider of plugin.
//
// The function returns the following values:
//
//   - ok: TRUE if the plugin was registered correctly, otherwise FALSE.
func PluginRegisterStaticFull(majorVersion, minorVersion int, name, description string, initFullFunc PluginInitFullFunc, version, license, source, pkg, origin string) bool {
	var _arg1 C.gint                  // out
	var _arg2 C.gint                  // out
	var _arg3 *C.gchar                // out
	var _arg4 *C.gchar                // out
	var _arg5 C.GstPluginInitFullFunc // out
	var _arg11 C.gpointer
	var _arg6 *C.gchar   // out
	var _arg7 *C.gchar   // out
	var _arg8 *C.gchar   // out
	var _arg9 *C.gchar   // out
	var _arg10 *C.gchar  // out
	var _cret C.gboolean // in

	_arg1 = C.gint(majorVersion)
	_arg2 = C.gint(minorVersion)
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*[0]byte)(C._gotk4_gst1_PluginInitFullFunc)
	_arg11 = C.gpointer(gbox.Assign(initFullFunc))
	defer gbox.Delete(uintptr(_arg11))
	_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(version)))
	defer C.free(unsafe.Pointer(_arg6))
	_arg7 = (*C.gchar)(unsafe.Pointer(C.CString(license)))
	defer C.free(unsafe.Pointer(_arg7))
	_arg8 = (*C.gchar)(unsafe.Pointer(C.CString(source)))
	defer C.free(unsafe.Pointer(_arg8))
	_arg9 = (*C.gchar)(unsafe.Pointer(C.CString(pkg)))
	defer C.free(unsafe.Pointer(_arg9))
	_arg10 = (*C.gchar)(unsafe.Pointer(C.CString(origin)))
	defer C.free(unsafe.Pointer(_arg10))

	_cret = C.gst_plugin_register_static_full(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11)
	runtime.KeepAlive(majorVersion)
	runtime.KeepAlive(minorVersion)
	runtime.KeepAlive(name)
	runtime.KeepAlive(description)
	runtime.KeepAlive(initFullFunc)
	runtime.KeepAlive(version)
	runtime.KeepAlive(license)
	runtime.KeepAlive(source)
	runtime.KeepAlive(pkg)
	runtime.KeepAlive(origin)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PluginFeature: this is a base class for anything that can be added to a
// Plugin.
type PluginFeature struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*PluginFeature)(nil)
)

// PluginFeaturer describes types inherited from class PluginFeature.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type PluginFeaturer interface {
	coreglib.Objector
	basePluginFeature() *PluginFeature
}

var _ PluginFeaturer = (*PluginFeature)(nil)

func wrapPluginFeature(obj *coreglib.Object) *PluginFeature {
	return &PluginFeature{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalPluginFeature(p uintptr) (interface{}, error) {
	return wrapPluginFeature(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (feature *PluginFeature) basePluginFeature() *PluginFeature {
	return feature
}

// BasePluginFeature returns the underlying base object.
func BasePluginFeature(obj PluginFeaturer) *PluginFeature {
	return obj.basePluginFeature()
}

// CheckVersion checks whether the given plugin feature is at least the required
// version.
//
// Note: Since version 1.24 this function no longer returns TRUE if the version
// is a git development version (e.g. 1.23.0.1) and the check is for the "next"
// micro version, that is it will no longer return TRUE for e.g. 1.23.0.1 if the
// check is for 1.23.1. It is still possible to parse the nano version from the
// string and do this check that way if needed.
//
// The function takes the following parameters:
//
//   - minMajor: minimum required major version.
//   - minMinor: minimum required minor version.
//   - minMicro: minimum required micro version.
//
// The function returns the following values:
//
//   - ok: TRUE if the plugin feature has at least the required version,
//     otherwise FALSE.
func (feature *PluginFeature) CheckVersion(minMajor, minMinor, minMicro uint) bool {
	var _arg0 *C.GstPluginFeature // out
	var _arg1 C.guint             // out
	var _arg2 C.guint             // out
	var _arg3 C.guint             // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstPluginFeature)(unsafe.Pointer(coreglib.InternObject(feature).Native()))
	_arg1 = C.guint(minMajor)
	_arg2 = C.guint(minMinor)
	_arg3 = C.guint(minMicro)

	_cret = C.gst_plugin_feature_check_version(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(feature)
	runtime.KeepAlive(minMajor)
	runtime.KeepAlive(minMinor)
	runtime.KeepAlive(minMicro)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Plugin: get the plugin that provides this feature.
//
// The function returns the following values:
//
//   - plugin (optional) that provides this feature, or NULL. Unref with
//     gst_object_unref() when no longer needed.
func (feature *PluginFeature) Plugin() *Plugin {
	var _arg0 *C.GstPluginFeature // out
	var _cret *C.GstPlugin        // in

	_arg0 = (*C.GstPluginFeature)(unsafe.Pointer(coreglib.InternObject(feature).Native()))

	_cret = C.gst_plugin_feature_get_plugin(_arg0)
	runtime.KeepAlive(feature)

	var _plugin *Plugin // out

	if _cret != nil {
		_plugin = wrapPlugin(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _plugin
}

// PluginName: get the name of the plugin that provides this feature.
//
// The function returns the following values:
//
//   - utf8 (optional): name of the plugin that provides this feature, or NULL
//     if the feature is not associated with a plugin.
func (feature *PluginFeature) PluginName() string {
	var _arg0 *C.GstPluginFeature // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GstPluginFeature)(unsafe.Pointer(coreglib.InternObject(feature).Native()))

	_cret = C.gst_plugin_feature_get_plugin_name(_arg0)
	runtime.KeepAlive(feature)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Rank gets the rank of a plugin feature.
//
// The function returns the following values:
//
//   - guint: rank of the feature.
func (feature *PluginFeature) Rank() uint {
	var _arg0 *C.GstPluginFeature // out
	var _cret C.guint             // in

	_arg0 = (*C.GstPluginFeature)(unsafe.Pointer(coreglib.InternObject(feature).Native()))

	_cret = C.gst_plugin_feature_get_rank(_arg0)
	runtime.KeepAlive(feature)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Load loads the plugin containing feature if it's not already loaded. feature
// is unaffected; use the return value instead.
//
// Normally this function is used like this:
//
//	GstPluginFeature *loaded_feature;
//
//	loaded_feature = gst_plugin_feature_load (feature);
//	// presumably, we're no longer interested in the potentially-unloaded feature
//	gst_object_unref (feature);
//	feature = loaded_feature;.
//
// The function returns the following values:
//
//   - pluginFeature (optional): reference to the loaded feature, or NULL on
//     error.
func (feature *PluginFeature) Load() PluginFeaturer {
	var _arg0 *C.GstPluginFeature // out
	var _cret *C.GstPluginFeature // in

	_arg0 = (*C.GstPluginFeature)(unsafe.Pointer(coreglib.InternObject(feature).Native()))

	_cret = C.gst_plugin_feature_load(_arg0)
	runtime.KeepAlive(feature)

	var _pluginFeature PluginFeaturer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(PluginFeaturer)
				return ok
			})
			rv, ok := casted.(PluginFeaturer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.PluginFeaturer")
			}
			_pluginFeature = rv
		}
	}

	return _pluginFeature
}

// SetRank specifies a rank for a plugin feature, so that autoplugging uses the
// most appropriate feature.
//
// The function takes the following parameters:
//
//   - rank value - higher number means more priority rank.
func (feature *PluginFeature) SetRank(rank uint) {
	var _arg0 *C.GstPluginFeature // out
	var _arg1 C.guint             // out

	_arg0 = (*C.GstPluginFeature)(unsafe.Pointer(coreglib.InternObject(feature).Native()))
	_arg1 = C.guint(rank)

	C.gst_plugin_feature_set_rank(_arg0, _arg1)
	runtime.KeepAlive(feature)
	runtime.KeepAlive(rank)
}

// PluginFeatureListCopy copies the list of features. Caller should call
// gst_plugin_feature_list_free when done with the list.
//
// The function takes the following parameters:
//
//   - list: list of PluginFeature.
//
// The function returns the following values:
//
//   - ret: copy of list, with each feature's reference count incremented.
func PluginFeatureListCopy(list []PluginFeaturer) []PluginFeaturer {
	var _arg1 *C.GList // out
	var _cret *C.GList // in

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.GstPluginFeature // out
		dst = (*C.GstPluginFeature)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg1)

	_cret = C.gst_plugin_feature_list_copy(_arg1)
	runtime.KeepAlive(list)

	var _ret []PluginFeaturer // out

	_ret = make([]PluginFeaturer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstPluginFeature)(v)
		var dst PluginFeaturer // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gst.PluginFeaturer is nil")
			}

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(PluginFeaturer)
				return ok
			})
			rv, ok := casted.(PluginFeaturer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.PluginFeaturer")
			}
			dst = rv
		}
		_ret = append(_ret, dst)
	})

	return _ret
}

// PluginFeatureListDebug: debug the plugin feature names in list.
//
// The function takes the following parameters:
//
//   - list of plugin features.
func PluginFeatureListDebug(list []PluginFeaturer) {
	var _arg1 *C.GList // out

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.GstPluginFeature // out
		dst = (*C.GstPluginFeature)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg1)

	C.gst_plugin_feature_list_debug(_arg1)
	runtime.KeepAlive(list)
}

// PluginFeatureRankCompareFunc compares the two given PluginFeature instances.
// This function can be used as a Func when sorting by rank and then by name.
//
// The function takes the following parameters:
//
//   - p1 (optional): PluginFeature.
//   - p2 (optional): PluginFeature.
//
// The function returns the following values:
//
//   - gint: negative value if the rank of p1 > the rank of p2 or the ranks are
//     equal but the name of p1 comes before the name of p2; zero if the rank
//     and names are equal; positive value if the rank of p1 < the rank of p2 or
//     the ranks are equal but the name of p2 comes before the name of p1.
func PluginFeatureRankCompareFunc(p1, p2 unsafe.Pointer) int {
	var _arg1 C.gconstpointer // out
	var _arg2 C.gconstpointer // out
	var _cret C.gint          // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(p1))
	_arg2 = (C.gconstpointer)(unsafe.Pointer(p2))

	_cret = C.gst_plugin_feature_rank_compare_func(_arg1, _arg2)
	runtime.KeepAlive(p1)
	runtime.KeepAlive(p2)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ProxyPadOverrides contains methods that are overridable.
type ProxyPadOverrides struct {
}

func defaultProxyPadOverrides(v *ProxyPad) ProxyPadOverrides {
	return ProxyPadOverrides{}
}

type ProxyPad struct {
	_ [0]func() // equal guard
	Pad
}

var (
	_ GstObjector = (*ProxyPad)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ProxyPad, *ProxyPadClass, ProxyPadOverrides](
		GTypeProxyPad,
		initProxyPadClass,
		wrapProxyPad,
		defaultProxyPadOverrides,
	)
}

func initProxyPadClass(gclass unsafe.Pointer, overrides ProxyPadOverrides, classInitFunc func(*ProxyPadClass)) {
	if classInitFunc != nil {
		class := (*ProxyPadClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapProxyPad(obj *coreglib.Object) *ProxyPad {
	return &ProxyPad{
		Pad: Pad{
			GstObject: GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalProxyPad(p uintptr) (interface{}, error) {
	return wrapProxyPad(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Internal: get the internal pad of pad. Unref target pad after usage.
//
// The internal pad of a GhostPad is the internally used pad of opposite
// direction, which is used to link to the target.
//
// The function returns the following values:
//
//   - proxyPad (optional): target ProxyPad, can be NULL. Unref target pad after
//     usage.
func (pad *ProxyPad) Internal() *ProxyPad {
	var _arg0 *C.GstProxyPad // out
	var _cret *C.GstProxyPad // in

	_arg0 = (*C.GstProxyPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))

	_cret = C.gst_proxy_pad_get_internal(_arg0)
	runtime.KeepAlive(pad)

	var _proxyPad *ProxyPad // out

	if _cret != nil {
		_proxyPad = wrapProxyPad(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _proxyPad
}

// ProxyPadChainDefault: invoke the default chain function of the proxy pad.
//
// The function takes the following parameters:
//
//   - pad: sink Pad, returns GST_FLOW_ERROR if not.
//   - parent (optional) of pad or NULL.
//   - buffer to send, return GST_FLOW_ERROR if not.
//
// The function returns the following values:
//
//   - flowReturn from the pad.
func ProxyPadChainDefault(pad *Pad, parent GstObjector, buffer *Buffer) FlowReturn {
	var _arg1 *C.GstPad       // out
	var _arg2 *C.GstObject    // out
	var _arg3 *C.GstBuffer    // out
	var _cret C.GstFlowReturn // in

	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if parent != nil {
		_arg2 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	_arg3 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	_cret = C.gst_proxy_pad_chain_default(_arg1, _arg2, _arg3)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(buffer)

	var _flowReturn FlowReturn // out

	_flowReturn = FlowReturn(_cret)

	return _flowReturn
}

// ProxyPadChainListDefault: invoke the default chain list function of the proxy
// pad.
//
// The function takes the following parameters:
//
//   - pad: sink Pad, returns GST_FLOW_ERROR if not.
//   - parent (optional) of pad or NULL.
//   - list to send, return GST_FLOW_ERROR if not.
//
// The function returns the following values:
//
//   - flowReturn from the pad.
func ProxyPadChainListDefault(pad *Pad, parent GstObjector, list *BufferList) FlowReturn {
	var _arg1 *C.GstPad        // out
	var _arg2 *C.GstObject     // out
	var _arg3 *C.GstBufferList // out
	var _cret C.GstFlowReturn  // in

	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if parent != nil {
		_arg2 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	_arg3 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(list)), nil)

	_cret = C.gst_proxy_pad_chain_list_default(_arg1, _arg2, _arg3)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(list)

	var _flowReturn FlowReturn // out

	_flowReturn = FlowReturn(_cret)

	return _flowReturn
}

// ProxyPadGetrangeDefault: invoke the default getrange function of the proxy
// pad.
//
// The function takes the following parameters:
//
//   - pad: src Pad, returns T_FLOW_ERROR if not.
//   - parent of pad.
//   - offset: start offset of the buffer.
//   - size: length of the buffer.
//
// The function returns the following values:
//
//   - buffer: pointer to hold the Buffer, returns T_FLOW_ERROR if NULL.
//   - flowReturn from the pad.
func ProxyPadGetrangeDefault(pad *Pad, parent GstObjector, offset uint64, size uint) (*Buffer, FlowReturn) {
	var _arg1 *C.GstPad       // out
	var _arg2 *C.GstObject    // out
	var _arg3 C.guint64       // out
	var _arg4 C.guint         // out
	var _arg5 *C.GstBuffer    // in
	var _cret C.GstFlowReturn // in

	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	_arg2 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	_arg3 = C.guint64(offset)
	_arg4 = C.guint(size)

	_cret = C.gst_proxy_pad_getrange_default(_arg1, _arg2, _arg3, _arg4, &_arg5)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _buffer *Buffer        // out
	var _flowReturn FlowReturn // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg5)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	_flowReturn = FlowReturn(_cret)

	return _buffer, _flowReturn
}

// ProxyPadIterateInternalLinksDefault: invoke the default iterate internal
// links function of the proxy pad.
//
// The function takes the following parameters:
//
//   - pad to get the internal links of.
//   - parent (optional) of pad or NULL.
//
// The function returns the following values:
//
//   - iterator (optional) of Pad, or NULL if pad has no parent. Unref each
//     returned pad with gst_object_unref().
func ProxyPadIterateInternalLinksDefault(pad *Pad, parent GstObjector) *Iterator {
	var _arg1 *C.GstPad      // out
	var _arg2 *C.GstObject   // out
	var _cret *C.GstIterator // in

	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	if parent != nil {
		_arg2 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}

	_cret = C.gst_proxy_pad_iterate_internal_links_default(_arg1, _arg2)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(parent)

	var _iterator *Iterator // out

	if _cret != nil {
		_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_iterator)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_iterator_free((*C.GstIterator)(intern.C))
			},
		)
	}

	return _iterator
}

// RegistryOverrides contains methods that are overridable.
type RegistryOverrides struct {
}

func defaultRegistryOverrides(v *Registry) RegistryOverrides {
	return RegistryOverrides{}
}

// Registry: one registry holds the metadata of a set of plugins.
//
// <emphasis role="bold">Design:</emphasis>
//
// The Registry object is a list of plugins and some functions for dealing with
// them. Each Plugin is matched 1-1 with a file on disk, and may or may not be
// loaded at a given time.
//
// The primary source, at all times, of plugin information is each plugin
// file itself. Thus, if an application wants information about a particular
// plugin, or wants to search for a feature that satisfies given criteria,
// the primary means of doing so is to load every plugin and look at the
// resulting information that is gathered in the default registry. Clearly, this
// is a time consuming process, so we cache information in the registry file.
// The format and location of the cache file is internal to gstreamer.
//
// On startup, plugins are searched for in the plugin search path. The following
// locations are checked in this order:
//
// * location from --gst-plugin-path commandline option. * the GST_PLUGIN_PATH
// environment variable. * the GST_PLUGIN_SYSTEM_PATH environment variable.
// * default locations (if GST_PLUGIN_SYSTEM_PATH is not set). Those default
// locations are: $XDG_DATA_HOME/gstreamer-$GST_API_VERSION/plugins/
// and $prefix/libs/gstreamer-$GST_API_VERSION/. $XDG_DATA_HOME
// (http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html)
// defaults to $HOME/.local/share.
//
// The registry cache file is loaded from
// $XDG_CACHE_HOME/gstreamer-$GST_API_VERSION/registry-$ARCH.bin (where
// $XDG_CACHE_HOME defaults to $HOME/.cache) or the file listed in the
// GST_REGISTRY env var. One reason to change the registry location is for
// testing.
//
// For each plugin that is found in the plugin search path, there could be 3
// possibilities for cached information:
//
//   - the cache may not contain information about a given file.
//   - the cache may have stale information.
//   - the cache may have current information.
//
// In the first two cases, the plugin is loaded and the cache updated.
// In addition to these cases, the cache may have entries for plugins that are
// not relevant to the current process. These are marked as not available to the
// current process. If the cache is updated for whatever reason, it is marked
// dirty.
//
// A dirty cache is written out at the end of initialization. Each entry is
// checked to make sure the information is minimally valid. If not, the entry is
// simply dropped.
//
// Implementation notes:
//
// The "cache" and "registry" are different concepts and can represent different
// sets of plugins. For various reasons, at init time, the cache is stored in
// the default registry, and plugins not relevant to the current process are
// marked with the GST_PLUGIN_FLAG_CACHED bit. These plugins are removed at the
// end of initialization.
type Registry struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*Registry)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Registry, *RegistryClass, RegistryOverrides](
		GTypeRegistry,
		initRegistryClass,
		wrapRegistry,
		defaultRegistryOverrides,
	)
}

func initRegistryClass(gclass unsafe.Pointer, overrides RegistryOverrides, classInitFunc func(*RegistryClass)) {
	if classInitFunc != nil {
		class := (*RegistryClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapRegistry(obj *coreglib.Object) *Registry {
	return &Registry{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalRegistry(p uintptr) (interface{}, error) {
	return wrapRegistry(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectFeatureAdded signals that a feature has been added to the registry
// (possibly replacing a previously-added one by the same name).
func (registry *Registry) ConnectFeatureAdded(f func(feature PluginFeaturer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(registry, "feature-added", false, unsafe.Pointer(C._gotk4_gst1_Registry_ConnectFeatureAdded), f)
}

// ConnectPluginAdded signals that a plugin has been added to the registry
// (possibly replacing a previously-added one by the same name).
func (registry *Registry) ConnectPluginAdded(f func(plugin *Plugin)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(registry, "plugin-added", false, unsafe.Pointer(C._gotk4_gst1_Registry_ConnectPluginAdded), f)
}

// AddFeature: add the feature to the registry. The feature-added signal will be
// emitted.
//
// feature's reference count will be incremented, and any floating reference
// will be removed (see gst_object_ref_sink()).
//
// The function takes the following parameters:
//
//   - feature to add.
//
// The function returns the following values:
//
//   - ok: TRUE on success.
//
//     MT safe.
func (registry *Registry) AddFeature(feature PluginFeaturer) bool {
	var _arg0 *C.GstRegistry      // out
	var _arg1 *C.GstPluginFeature // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*C.GstPluginFeature)(unsafe.Pointer(coreglib.InternObject(feature).Native()))

	_cret = C.gst_registry_add_feature(_arg0, _arg1)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(feature)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AddPlugin: add the plugin to the registry. The plugin-added signal will be
// emitted.
//
// plugin's reference count will be incremented, and any floating reference will
// be removed (see gst_object_ref_sink()).
//
// The function takes the following parameters:
//
//   - plugin to add.
//
// The function returns the following values:
//
//   - ok: TRUE on success.
//
//     MT safe.
func (registry *Registry) AddPlugin(plugin *Plugin) bool {
	var _arg0 *C.GstRegistry // out
	var _arg1 *C.GstPlugin   // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	_cret = C.gst_registry_add_plugin(_arg0, _arg1)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(plugin)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CheckFeatureVersion checks whether a plugin feature by the given name exists
// in registry and whether its version is at least the version required.
//
// The function takes the following parameters:
//
//   - featureName: name of the feature (e.g. "oggdemux").
//   - minMajor: minimum major version number.
//   - minMinor: minimum minor version number.
//   - minMicro: minimum micro version number.
//
// The function returns the following values:
//
//   - ok: TRUE if the feature could be found and the version is the same as the
//     required version or newer, and FALSE otherwise.
func (registry *Registry) CheckFeatureVersion(featureName string, minMajor, minMinor, minMicro uint) bool {
	var _arg0 *C.GstRegistry // out
	var _arg1 *C.gchar       // out
	var _arg2 C.guint        // out
	var _arg3 C.guint        // out
	var _arg4 C.guint        // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(featureName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(minMajor)
	_arg3 = C.guint(minMinor)
	_arg4 = C.guint(minMicro)

	_cret = C.gst_registry_check_feature_version(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(featureName)
	runtime.KeepAlive(minMajor)
	runtime.KeepAlive(minMinor)
	runtime.KeepAlive(minMicro)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FeatureFilter runs a filter against all features of the plugins in the
// registry and returns a GList with the results. If the first flag is set,
// only the first match is returned (as a list with a single object).
//
// The function takes the following parameters:
//
//   - filter to use.
//   - first: only return first match.
//
// The function returns the following values:
//
//   - list of PluginFeature. Use gst_plugin_feature_list_free() after usage.
//
//     MT safe.
func (registry *Registry) FeatureFilter(filter PluginFeatureFilter, first bool) []PluginFeaturer {
	var _arg0 *C.GstRegistry           // out
	var _arg1 C.GstPluginFeatureFilter // out
	var _arg3 C.gpointer
	var _arg2 C.gboolean // out
	var _cret *C.GList   // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gst1_PluginFeatureFilter)
	_arg3 = C.gpointer(gbox.Assign(filter))
	defer gbox.Delete(uintptr(_arg3))
	if first {
		_arg2 = C.TRUE
	}

	_cret = C.gst_registry_feature_filter(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(first)

	var _list []PluginFeaturer // out

	_list = make([]PluginFeaturer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstPluginFeature)(v)
		var dst PluginFeaturer // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gst.PluginFeaturer is nil")
			}

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(PluginFeaturer)
				return ok
			})
			rv, ok := casted.(PluginFeaturer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.PluginFeaturer")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// FindFeature: find the pluginfeature with the given name and type in the
// registry.
//
// The function takes the following parameters:
//
//   - name: pluginfeature name to find.
//   - typ: pluginfeature type to find.
//
// The function returns the following values:
//
//   - pluginFeature (optional): pluginfeature with the given name and type or
//     NULL if the plugin was not found. gst_object_unref() after usage.
//
//     MT safe.
func (registry *Registry) FindFeature(name string, typ coreglib.Type) PluginFeaturer {
	var _arg0 *C.GstRegistry      // out
	var _arg1 *C.gchar            // out
	var _arg2 C.GType             // out
	var _cret *C.GstPluginFeature // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GType(typ)

	_cret = C.gst_registry_find_feature(_arg0, _arg1, _arg2)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(name)
	runtime.KeepAlive(typ)

	var _pluginFeature PluginFeaturer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(PluginFeaturer)
				return ok
			})
			rv, ok := casted.(PluginFeaturer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.PluginFeaturer")
			}
			_pluginFeature = rv
		}
	}

	return _pluginFeature
}

// FindPlugin: find the plugin with the given name in the registry. The plugin
// will be reffed; caller is responsible for unreffing.
//
// The function takes the following parameters:
//
//   - name: plugin name to find.
//
// The function returns the following values:
//
//   - plugin (optional) with the given name or NULL if the plugin was not
//     found. gst_object_unref() after usage.
//
//     MT safe.
func (registry *Registry) FindPlugin(name string) *Plugin {
	var _arg0 *C.GstRegistry // out
	var _arg1 *C.gchar       // out
	var _cret *C.GstPlugin   // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_registry_find_plugin(_arg0, _arg1)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(name)

	var _plugin *Plugin // out

	if _cret != nil {
		_plugin = wrapPlugin(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _plugin
}

// FeatureList retrieves a #GList of PluginFeature of type.
//
// The function takes the following parameters:
//
//   - typ: #GType.
//
// The function returns the following values:
//
//   - list of PluginFeature of type. Use gst_plugin_feature_list_free() after
//     use
//
//     MT safe.
func (registry *Registry) FeatureList(typ coreglib.Type) []PluginFeaturer {
	var _arg0 *C.GstRegistry // out
	var _arg1 C.GType        // out
	var _cret *C.GList       // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = C.GType(typ)

	_cret = C.gst_registry_get_feature_list(_arg0, _arg1)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(typ)

	var _list []PluginFeaturer // out

	_list = make([]PluginFeaturer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstPluginFeature)(v)
		var dst PluginFeaturer // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gst.PluginFeaturer is nil")
			}

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(PluginFeaturer)
				return ok
			})
			rv, ok := casted.(PluginFeaturer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.PluginFeaturer")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// FeatureListByPlugin retrieves a #GList of features of the plugin with name
// name.
//
// The function takes the following parameters:
//
//   - name: plugin name.
//
// The function returns the following values:
//
//   - list of PluginFeature. Use gst_plugin_feature_list_free() after usage.
func (registry *Registry) FeatureListByPlugin(name string) []PluginFeaturer {
	var _arg0 *C.GstRegistry // out
	var _arg1 *C.gchar       // out
	var _cret *C.GList       // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_registry_get_feature_list_by_plugin(_arg0, _arg1)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(name)

	var _list []PluginFeaturer // out

	_list = make([]PluginFeaturer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstPluginFeature)(v)
		var dst PluginFeaturer // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gst.PluginFeaturer is nil")
			}

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(PluginFeaturer)
				return ok
			})
			rv, ok := casted.(PluginFeaturer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.PluginFeaturer")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// FeatureListCookie returns the registry's feature list cookie. This changes
// every time a feature is added or removed from the registry.
//
// The function returns the following values:
//
//   - guint32: feature list cookie.
func (registry *Registry) FeatureListCookie() uint32 {
	var _arg0 *C.GstRegistry // out
	var _cret C.guint32      // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))

	_cret = C.gst_registry_get_feature_list_cookie(_arg0)
	runtime.KeepAlive(registry)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// PluginList: get a copy of all plugins registered in the given registry.
// The refcount of each element in the list in incremented.
//
// The function returns the following values:
//
//   - list of Plugin. Use gst_plugin_list_free() after usage.
//
//     MT safe.
func (registry *Registry) PluginList() []*Plugin {
	var _arg0 *C.GstRegistry // out
	var _cret *C.GList       // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))

	_cret = C.gst_registry_get_plugin_list(_arg0)
	runtime.KeepAlive(registry)

	var _list []*Plugin // out

	_list = make([]*Plugin, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstPlugin)(v)
		var dst *Plugin // out
		dst = wrapPlugin(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// Lookup: look up a plugin in the given registry with the given filename.
// If found, plugin is reffed.
//
// The function takes the following parameters:
//
//   - filename: name of the file to look up.
//
// The function returns the following values:
//
//   - plugin (optional) if found, or NULL if not. gst_object_unref() after
//     usage.
func (registry *Registry) Lookup(filename string) *Plugin {
	var _arg0 *C.GstRegistry // out
	var _arg1 *C.char        // out
	var _cret *C.GstPlugin   // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_registry_lookup(_arg0, _arg1)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(filename)

	var _plugin *Plugin // out

	if _cret != nil {
		_plugin = wrapPlugin(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _plugin
}

// LookupFeature: find a PluginFeature with name in registry.
//
// The function takes the following parameters:
//
//   - name: PluginFeature name.
//
// The function returns the following values:
//
//   - pluginFeature (optional) with its refcount incremented, use
//     gst_object_unref() after usage.
//
//     MT safe.
func (registry *Registry) LookupFeature(name string) PluginFeaturer {
	var _arg0 *C.GstRegistry      // out
	var _arg1 *C.char             // out
	var _cret *C.GstPluginFeature // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_registry_lookup_feature(_arg0, _arg1)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(name)

	var _pluginFeature PluginFeaturer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(PluginFeaturer)
				return ok
			})
			rv, ok := casted.(PluginFeaturer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.PluginFeaturer")
			}
			_pluginFeature = rv
		}
	}

	return _pluginFeature
}

// PluginFilter runs a filter against all plugins in the registry and returns
// a #GList with the results. If the first flag is set, only the first match
// is returned (as a list with a single object). Every plugin is reffed;
// use gst_plugin_list_free() after use, which will unref again.
//
// The function takes the following parameters:
//
//   - filter to use.
//   - first: only return first match.
//
// The function returns the following values:
//
//   - list of Plugin. Use gst_plugin_list_free() after usage.
//
//     MT safe.
func (registry *Registry) PluginFilter(filter PluginFilter, first bool) []*Plugin {
	var _arg0 *C.GstRegistry    // out
	var _arg1 C.GstPluginFilter // out
	var _arg3 C.gpointer
	var _arg2 C.gboolean // out
	var _cret *C.GList   // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gst1_PluginFilter)
	_arg3 = C.gpointer(gbox.Assign(filter))
	defer gbox.Delete(uintptr(_arg3))
	if first {
		_arg2 = C.TRUE
	}

	_cret = C.gst_registry_plugin_filter(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(first)

	var _list []*Plugin // out

	_list = make([]*Plugin, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstPlugin)(v)
		var dst *Plugin // out
		dst = wrapPlugin(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// RemoveFeature: remove the feature from the registry.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - feature to remove.
func (registry *Registry) RemoveFeature(feature PluginFeaturer) {
	var _arg0 *C.GstRegistry      // out
	var _arg1 *C.GstPluginFeature // out

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*C.GstPluginFeature)(unsafe.Pointer(coreglib.InternObject(feature).Native()))

	C.gst_registry_remove_feature(_arg0, _arg1)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(feature)
}

// RemovePlugin: remove the plugin from the registry.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - plugin to remove.
func (registry *Registry) RemovePlugin(plugin *Plugin) {
	var _arg0 *C.GstRegistry // out
	var _arg1 *C.GstPlugin   // out

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))

	C.gst_registry_remove_plugin(_arg0, _arg1)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(plugin)
}

// ScanPath: scan the given path for plugins to add to the registry. The syntax
// of the path is specific to the registry.
//
// The function takes the following parameters:
//
//   - path to scan.
//
// The function returns the following values:
//
//   - ok: TRUE if registry changed.
func (registry *Registry) ScanPath(path string) bool {
	var _arg0 *C.GstRegistry // out
	var _arg1 *C.gchar       // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstRegistry)(unsafe.Pointer(coreglib.InternObject(registry).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_registry_scan_path(_arg0, _arg1)
	runtime.KeepAlive(registry)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RegistryForkIsEnabled: by default GStreamer will perform scanning and
// rebuilding of the registry file using a helper child process.
//
// Applications might want to disable this behaviour with the
// gst_registry_fork_set_enabled() function, in which case new plugins are
// scanned (and loaded) into the application process.
//
// The function returns the following values:
//
//   - ok: TRUE if GStreamer will use the child helper process when rebuilding
//     the registry.
func RegistryForkIsEnabled() bool {
	var _cret C.gboolean // in

	_cret = C.gst_registry_fork_is_enabled()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RegistryForkSetEnabled applications might want to disable/enable
// spawning of a child helper process when rebuilding the registry. See
// gst_registry_fork_is_enabled() for more information.
//
// The function takes the following parameters:
//
//   - enabled: whether rebuilding the registry can use a temporary child helper
//     process.
func RegistryForkSetEnabled(enabled bool) {
	var _arg1 C.gboolean // out

	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_registry_fork_set_enabled(_arg1)
	runtime.KeepAlive(enabled)
}

// RegistryGet retrieves the singleton plugin registry. The caller does not
// own a reference on the registry, as it is alive as long as GStreamer is
// initialized.
//
// The function returns the following values:
//
//   - registry: Registry.
func RegistryGet() *Registry {
	var _cret *C.GstRegistry // in

	_cret = C.gst_registry_get()

	var _registry *Registry // out

	_registry = wrapRegistry(coreglib.Take(unsafe.Pointer(_cret)))

	return _registry
}

// StreamOverrides contains methods that are overridable.
type StreamOverrides struct {
}

func defaultStreamOverrides(v *Stream) StreamOverrides {
	return StreamOverrides{}
}

// Stream: high-level object representing a single stream. It might be backed,
// or not, by an actual flow of data in a pipeline (Pad).
//
// A Stream does not care about data changes (such as decoding, encoding,
// parsing,...) as long as the underlying data flow corresponds to the same
// high-level flow (ex: a certain audio track).
//
// A Stream contains all the information pertinent to a stream, such as
// stream-id, tags, caps, type, ...
//
// Elements can subclass a Stream for internal usage (to contain information
// pertinent to streams of data).
type Stream struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*Stream)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Stream, *StreamClass, StreamOverrides](
		GTypeStream,
		initStreamClass,
		wrapStream,
		defaultStreamOverrides,
	)
}

func initStreamClass(gclass unsafe.Pointer, overrides StreamOverrides, classInitFunc func(*StreamClass)) {
	if classInitFunc != nil {
		class := (*StreamClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapStream(obj *coreglib.Object) *Stream {
	return &Stream{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalStream(p uintptr) (interface{}, error) {
	return wrapStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewStream: create a new Stream for the given stream_id, caps, type and flags.
//
// The function takes the following parameters:
//
//   - streamId (optional): id for the new stream. If NULL, a new one will be
//     automatically generated.
//   - caps (optional) of the stream.
//   - typ of the stream.
//   - flags of the stream.
//
// The function returns the following values:
//
//   - stream: new Stream.
func NewStream(streamId string, caps *Caps, typ StreamType, flags StreamFlags) *Stream {
	var _arg1 *C.gchar         // out
	var _arg2 *C.GstCaps       // out
	var _arg3 C.GstStreamType  // out
	var _arg4 C.GstStreamFlags // out
	var _cret *C.GstStream     // in

	if streamId != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(streamId)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if caps != nil {
		_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}
	_arg3 = C.GstStreamType(typ)
	_arg4 = C.GstStreamFlags(flags)

	_cret = C.gst_stream_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(streamId)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(flags)

	var _stream *Stream // out

	_stream = wrapStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _stream
}

// Caps: retrieve the caps for stream, if any.
//
// The function returns the following values:
//
//   - caps (optional) for stream.
func (stream *Stream) Caps() *Caps {
	var _arg0 *C.GstStream // out
	var _cret *C.GstCaps   // in

	_arg0 = (*C.GstStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.gst_stream_get_caps(_arg0)
	runtime.KeepAlive(stream)

	var _caps *Caps // out

	if _cret != nil {
		_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_caps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _caps
}

// StreamFlags: retrieve the current stream flags for stream.
//
// The function returns the following values:
//
//   - streamFlags for stream.
func (stream *Stream) StreamFlags() StreamFlags {
	var _arg0 *C.GstStream     // out
	var _cret C.GstStreamFlags // in

	_arg0 = (*C.GstStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.gst_stream_get_stream_flags(_arg0)
	runtime.KeepAlive(stream)

	var _streamFlags StreamFlags // out

	_streamFlags = StreamFlags(_cret)

	return _streamFlags
}

// StreamID returns the stream ID of stream.
//
// The function returns the following values:
//
//   - utf8 (optional): stream ID of stream. Only valid during the lifetime of
//     stream.
func (stream *Stream) StreamID() string {
	var _arg0 *C.GstStream // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.gst_stream_get_stream_id(_arg0)
	runtime.KeepAlive(stream)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// StreamType: retrieve the stream type for stream.
//
// The function returns the following values:
//
//   - streamType for stream.
func (stream *Stream) StreamType() StreamType {
	var _arg0 *C.GstStream    // out
	var _cret C.GstStreamType // in

	_arg0 = (*C.GstStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.gst_stream_get_stream_type(_arg0)
	runtime.KeepAlive(stream)

	var _streamType StreamType // out

	_streamType = StreamType(_cret)

	return _streamType
}

// Tags: retrieve the tags for stream, if any.
//
// The function returns the following values:
//
//   - tagList (optional) for stream.
func (stream *Stream) Tags() *TagList {
	var _arg0 *C.GstStream  // out
	var _cret *C.GstTagList // in

	_arg0 = (*C.GstStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.gst_stream_get_tags(_arg0)
	runtime.KeepAlive(stream)

	var _tagList *TagList // out

	if _cret != nil {
		_tagList = (*TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_tagList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _tagList
}

// SetCaps: set the caps for the Stream.
//
// The function takes the following parameters:
//
//   - caps (optional): Caps.
func (stream *Stream) SetCaps(caps *Caps) {
	var _arg0 *C.GstStream // out
	var _arg1 *C.GstCaps   // out

	_arg0 = (*C.GstStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	if caps != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}

	C.gst_stream_set_caps(_arg0, _arg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(caps)
}

// SetStreamFlags: set the flags for the stream.
//
// The function takes the following parameters:
//
//   - flags to set on stream.
func (stream *Stream) SetStreamFlags(flags StreamFlags) {
	var _arg0 *C.GstStream     // out
	var _arg1 C.GstStreamFlags // out

	_arg0 = (*C.GstStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = C.GstStreamFlags(flags)

	C.gst_stream_set_stream_flags(_arg0, _arg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(flags)
}

// SetStreamType: set the stream type of stream.
//
// The function takes the following parameters:
//
//   - streamType: type to set on stream.
func (stream *Stream) SetStreamType(streamType StreamType) {
	var _arg0 *C.GstStream    // out
	var _arg1 C.GstStreamType // out

	_arg0 = (*C.GstStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = C.GstStreamType(streamType)

	C.gst_stream_set_stream_type(_arg0, _arg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(streamType)
}

// SetTags: set the tags for the Stream.
//
// The function takes the following parameters:
//
//   - tags (optional): TagList.
func (stream *Stream) SetTags(tags *TagList) {
	var _arg0 *C.GstStream  // out
	var _arg1 *C.GstTagList // out

	_arg0 = (*C.GstStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	if tags != nil {
		_arg1 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(tags)))
	}

	C.gst_stream_set_tags(_arg0, _arg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(tags)
}

// StreamCollectionOverrides contains methods that are overridable.
type StreamCollectionOverrides struct {
}

func defaultStreamCollectionOverrides(v *StreamCollection) StreamCollectionOverrides {
	return StreamCollectionOverrides{}
}

// StreamCollection: collection of Stream that are available.
//
// A StreamCollection will be provided by elements that can make those streams
// available. Applications can use the collection to show the user what streams
// are available by using gst_stream_collection_get_stream()
//
// Once posted, a StreamCollection is immutable. Updates are made by sending a
// new StreamCollection message, which may or may not share some of the Stream
// objects from the collection it replaces. The receiver can check the sender of
// a stream collection message to know which collection is obsoleted.
//
// Several elements in a pipeline can provide StreamCollection.
//
// Applications can activate streams from a collection by using the
// T_EVENT_SELECT_STREAMS event on a pipeline, bin or element.
type StreamCollection struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*StreamCollection)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*StreamCollection, *StreamCollectionClass, StreamCollectionOverrides](
		GTypeStreamCollection,
		initStreamCollectionClass,
		wrapStreamCollection,
		defaultStreamCollectionOverrides,
	)
}

func initStreamCollectionClass(gclass unsafe.Pointer, overrides StreamCollectionOverrides, classInitFunc func(*StreamCollectionClass)) {
	if classInitFunc != nil {
		class := (*StreamCollectionClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapStreamCollection(obj *coreglib.Object) *StreamCollection {
	return &StreamCollection{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalStreamCollection(p uintptr) (interface{}, error) {
	return wrapStreamCollection(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewStreamCollection: create a new StreamCollection.
//
// The function takes the following parameters:
//
//   - upstreamId (optional): stream id of the parent stream.
//
// The function returns the following values:
//
//   - streamCollection: new StreamCollection.
func NewStreamCollection(upstreamId string) *StreamCollection {
	var _arg1 *C.gchar               // out
	var _cret *C.GstStreamCollection // in

	if upstreamId != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(upstreamId)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_stream_collection_new(_arg1)
	runtime.KeepAlive(upstreamId)

	var _streamCollection *StreamCollection // out

	_streamCollection = wrapStreamCollection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _streamCollection
}

// AddStream: add the given stream to the collection.
//
// The function takes the following parameters:
//
//   - stream to add.
//
// The function returns the following values:
//
//   - ok: TRUE if the stream was properly added, else FALSE.
func (collection *StreamCollection) AddStream(stream *Stream) bool {
	var _arg0 *C.GstStreamCollection // out
	var _arg1 *C.GstStream           // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GstStreamCollection)(unsafe.Pointer(coreglib.InternObject(collection).Native()))
	_arg1 = (*C.GstStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(stream).Native()))

	_cret = C.gst_stream_collection_add_stream(_arg0, _arg1)
	runtime.KeepAlive(collection)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Size: get the number of streams this collection contains.
//
// The function returns the following values:
//
//   - guint: number of streams that collection contains.
func (collection *StreamCollection) Size() uint {
	var _arg0 *C.GstStreamCollection // out
	var _cret C.guint                // in

	_arg0 = (*C.GstStreamCollection)(unsafe.Pointer(coreglib.InternObject(collection).Native()))

	_cret = C.gst_stream_collection_get_size(_arg0)
	runtime.KeepAlive(collection)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Stream: retrieve the Stream with index index from the collection.
//
// The caller should not modify the returned Stream.
//
// The function takes the following parameters:
//
//   - index: index of the stream to retrieve.
//
// The function returns the following values:
//
//   - stream (optional): Stream.
func (collection *StreamCollection) Stream(index uint) *Stream {
	var _arg0 *C.GstStreamCollection // out
	var _arg1 C.guint                // out
	var _cret *C.GstStream           // in

	_arg0 = (*C.GstStreamCollection)(unsafe.Pointer(coreglib.InternObject(collection).Native()))
	_arg1 = C.guint(index)

	_cret = C.gst_stream_collection_get_stream(_arg0, _arg1)
	runtime.KeepAlive(collection)
	runtime.KeepAlive(index)

	var _stream *Stream // out

	if _cret != nil {
		_stream = wrapStream(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _stream
}

// UpstreamID returns the upstream id of the collection.
//
// The function returns the following values:
//
//   - utf8 (optional): upstream id.
func (collection *StreamCollection) UpstreamID() string {
	var _arg0 *C.GstStreamCollection // out
	var _cret *C.gchar               // in

	_arg0 = (*C.GstStreamCollection)(unsafe.Pointer(coreglib.InternObject(collection).Native()))

	_cret = C.gst_stream_collection_get_upstream_id(_arg0)
	runtime.KeepAlive(collection)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// SystemClockOverrides contains methods that are overridable.
type SystemClockOverrides struct {
}

func defaultSystemClockOverrides(v *SystemClock) SystemClockOverrides {
	return SystemClockOverrides{}
}

// SystemClock: GStreamer core provides a GstSystemClock based on the system
// time. Asynchronous callbacks are scheduled from an internal thread.
//
// Clock implementors are encouraged to subclass this systemclock as it
// implements the async notification.
//
// Subclasses can however override all of the important methods for sync and
// async notifications to implement their own callback methods or blocking wait
// operations.
type SystemClock struct {
	_ [0]func() // equal guard
	Clock
}

var (
	_ Clocker = (*SystemClock)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*SystemClock, *SystemClockClass, SystemClockOverrides](
		GTypeSystemClock,
		initSystemClockClass,
		wrapSystemClock,
		defaultSystemClockOverrides,
	)
}

func initSystemClockClass(gclass unsafe.Pointer, overrides SystemClockOverrides, classInitFunc func(*SystemClockClass)) {
	if classInitFunc != nil {
		class := (*SystemClockClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSystemClock(obj *coreglib.Object) *SystemClock {
	return &SystemClock{
		Clock: Clock{
			GstObject: GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalSystemClock(p uintptr) (interface{}, error) {
	return wrapSystemClock(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// SystemClockObtain: get a handle to the default system clock. The refcount of
// the clock will be increased so you need to unref the clock after usage.
//
// The function returns the following values:
//
//   - clock: default clock.
//
//     MT safe.
func SystemClockObtain() Clocker {
	var _cret *C.GstClock // in

	_cret = C.gst_system_clock_obtain()

	var _clock Clocker // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gst.Clocker is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Clocker)
			return ok
		})
		rv, ok := casted.(Clocker)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Clocker")
		}
		_clock = rv
	}

	return _clock
}

// SystemClockSetDefault sets the default system clock that can be obtained with
// gst_system_clock_obtain().
//
// This is mostly used for testing and debugging purposes when you want to have
// control over the time reported by the default system clock.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - newClock (optional): Clock.
func SystemClockSetDefault(newClock Clocker) {
	var _arg1 *C.GstClock // out

	if newClock != nil {
		_arg1 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(newClock).Native()))
	}

	C.gst_system_clock_set_default(_arg1)
	runtime.KeepAlive(newClock)
}

// TaskOverrides contains methods that are overridable.
type TaskOverrides struct {
}

func defaultTaskOverrides(v *Task) TaskOverrides {
	return TaskOverrides{}
}

// Task is used by Element and Pad to provide the data passing threads in a
// Pipeline.
//
// A Pad will typically start a Task to push or pull data to/from the peer pads.
// Most source elements start a Task to push data. In some cases a demuxer
// element can start a Task to pull data from a peer element. This is typically
// done when the demuxer can perform random access on the upstream peer element
// for improved performance.
//
// Although convenience functions exist on Pad to start/pause/stop tasks,
// it might sometimes be needed to create a Task manually if it is not related
// to a Pad.
//
// Before the Task can be run, it needs a Mutex that can be set with
// gst_task_set_lock().
//
// The task can be started, paused and stopped with gst_task_start(),
// gst_task_pause() and gst_task_stop() respectively or with the
// gst_task_set_state() function.
//
// A Task will repeatedly call the TaskFunction with the user data that was
// provided when creating the task with gst_task_new(). While calling the
// function it will acquire the provided lock. The provided lock is released
// when the task pauses or stops.
//
// Stopping a task with gst_task_stop() will not immediately make sure the
// task is not running anymore. Use gst_task_join() to make sure the task is
// completely stopped and the thread is stopped.
//
// After creating a Task, use gst_object_unref() to free its resources. This can
// only be done when the task is not running anymore.
//
// Task functions can send a Message to send out-of-band data to the
// application. The application can receive messages from the Bus in its
// mainloop.
//
// For debugging purposes, the task will configure its object name as the
// thread name on Linux. Please note that the object name should be configured
// before the task is started; changing the object name after the task has been
// started, has no effect on the thread name.
type Task struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*Task)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Task, *TaskClass, TaskOverrides](
		GTypeTask,
		initTaskClass,
		wrapTask,
		defaultTaskOverrides,
	)
}

func initTaskClass(gclass unsafe.Pointer, overrides TaskOverrides, classInitFunc func(*TaskClass)) {
	if classInitFunc != nil {
		class := (*TaskClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTask(obj *coreglib.Object) *Task {
	return &Task{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalTask(p uintptr) (interface{}, error) {
	return wrapTask(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewTask: create a new Task that will repeatedly call the provided func with
// user_data as a parameter. Typically the task will run in a new thread.
//
// The function cannot be changed after the task has been created. You must
// create a new Task to change the function.
//
// This function will not yet create and start a thread. Use gst_task_start() or
// gst_task_pause() to create and start the GThread.
//
// Before the task can be used, a Mutex must be configured using the
// gst_task_set_lock() function. This lock will always be acquired while func is
// called.
//
// The function takes the following parameters:
//
//   - fn to use.
//
// The function returns the following values:
//
//   - task: new Task.
//
//     MT safe.
func NewTask(fn TaskFunction) *Task {
	var _arg1 C.GstTaskFunction // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify
	var _cret *C.GstTask // in

	_arg1 = (*[0]byte)(C._gotk4_gst1_TaskFunction)
	_arg2 = C.gpointer(gbox.Assign(fn))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.gst_task_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(fn)

	var _task *Task // out

	_task = wrapTask(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _task
}

// State: get the current state of the task.
//
// The function returns the following values:
//
//   - taskState of the task
//
//     MT safe.
func (task *Task) State() TaskState {
	var _arg0 *C.GstTask     // out
	var _cret C.GstTaskState // in

	_arg0 = (*C.GstTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.gst_task_get_state(_arg0)
	runtime.KeepAlive(task)

	var _taskState TaskState // out

	_taskState = TaskState(_cret)

	return _taskState
}

// Join joins task. After this call, it is safe to unref the task and clean up
// the lock set with gst_task_set_lock().
//
// The task will automatically be stopped with this call.
//
// This function cannot be called from within a task function as this would
// cause a deadlock. The function will detect this and print a g_warning.
//
// The function returns the following values:
//
//   - ok: TRUE if the task could be joined.
//
//     MT safe.
func (task *Task) Join() bool {
	var _arg0 *C.GstTask // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.gst_task_join(_arg0)
	runtime.KeepAlive(task)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Pause pauses task. This method can also be called on a task in the stopped
// state, in which case a thread will be started and will remain in the paused
// state. This function does not wait for the task to complete the paused state.
//
// The function returns the following values:
//
//   - ok: TRUE if the task could be paused.
//
//     MT safe.
func (task *Task) Pause() bool {
	var _arg0 *C.GstTask // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.gst_task_pause(_arg0)
	runtime.KeepAlive(task)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Resume task in case it was paused. If the task was stopped, it will remain in
// that state and this function will return FALSE.
//
// The function returns the following values:
//
//   - ok: TRUE if the task could be resumed.
//
//     MT safe.
func (task *Task) Resume() bool {
	var _arg0 *C.GstTask // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.gst_task_resume(_arg0)
	runtime.KeepAlive(task)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetState sets the state of task to state.
//
// The task must have a lock associated with it using gst_task_set_lock() when
// going to GST_TASK_STARTED or GST_TASK_PAUSED or this function will return
// FALSE.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - state: new task state.
//
// The function returns the following values:
//
//   - ok: TRUE if the state could be changed.
func (task *Task) SetState(state TaskState) bool {
	var _arg0 *C.GstTask     // out
	var _arg1 C.GstTaskState // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))
	_arg1 = C.GstTaskState(state)

	_cret = C.gst_task_set_state(_arg0, _arg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(state)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Start starts task. The task must have a lock associated with it using
// gst_task_set_lock() or this function will return FALSE.
//
// The function returns the following values:
//
//   - ok: TRUE if the task could be started.
//
//     MT safe.
func (task *Task) Start() bool {
	var _arg0 *C.GstTask // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.gst_task_start(_arg0)
	runtime.KeepAlive(task)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Stop stops task. This method merely schedules the task to stop and will not
// wait for the task to have completely stopped. Use gst_task_join() to stop and
// wait for completion.
//
// The function returns the following values:
//
//   - ok: TRUE if the task could be stopped.
//
//     MT safe.
func (task *Task) Stop() bool {
	var _arg0 *C.GstTask // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	_cret = C.gst_task_stop(_arg0)
	runtime.KeepAlive(task)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TaskCleanupAll: wait for all tasks to be stopped. This is mainly used
// internally to ensure proper cleanup of internal data structures in test
// suites.
//
// MT safe.
func TaskCleanupAll() {
	C.gst_task_cleanup_all()
}

// TracerOverrides contains methods that are overridable.
type TracerOverrides struct {
}

func defaultTracerOverrides(v *Tracer) TracerOverrides {
	return TracerOverrides{}
}

// Tracer: tracing modules will subclass Tracer and register through
// gst_tracer_register(). Modules can attach to various hook-types - see
// gst_tracing_register_hook(). When invoked they receive hook specific
// contextual data, which they must not modify.
type Tracer struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*Tracer)(nil)
)

// Tracerer describes types inherited from class Tracer.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Tracerer interface {
	coreglib.Objector
	baseTracer() *Tracer
}

var _ Tracerer = (*Tracer)(nil)

func init() {
	coreglib.RegisterClassInfo[*Tracer, *TracerClass, TracerOverrides](
		GTypeTracer,
		initTracerClass,
		wrapTracer,
		defaultTracerOverrides,
	)
}

func initTracerClass(gclass unsafe.Pointer, overrides TracerOverrides, classInitFunc func(*TracerClass)) {
	if classInitFunc != nil {
		class := (*TracerClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTracer(obj *coreglib.Object) *Tracer {
	return &Tracer{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalTracer(p uintptr) (interface{}, error) {
	return wrapTracer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *Tracer) baseTracer() *Tracer {
	return v
}

// BaseTracer returns the underlying base object.
func BaseTracer(obj Tracerer) *Tracer {
	return obj.baseTracer()
}

// TracerRegister: create a new tracer-factory capable of instantiating objects
// of the type and add the factory to plugin.
//
// The function takes the following parameters:
//
//   - plugin (optional) or NULL for a static typefind function.
//   - name for registering.
//   - typ: GType of tracer to register.
//
// The function returns the following values:
//
//   - ok: TRUE, if the registering succeeded, FALSE on error.
func TracerRegister(plugin *Plugin, name string, typ coreglib.Type) bool {
	var _arg1 *C.GstPlugin // out
	var _arg2 *C.gchar     // out
	var _arg3 C.GType      // out
	var _cret C.gboolean   // in

	if plugin != nil {
		_arg1 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.GType(typ)

	_cret = C.gst_tracer_register(_arg1, _arg2, _arg3)
	runtime.KeepAlive(plugin)
	runtime.KeepAlive(name)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TracerFactory: use gst_tracer_factory_get_list() to get a list of tracer
// factories known to GStreamer.
type TracerFactory struct {
	_ [0]func() // equal guard
	PluginFeature
}

var (
	_ PluginFeaturer = (*TracerFactory)(nil)
)

func wrapTracerFactory(obj *coreglib.Object) *TracerFactory {
	return &TracerFactory{
		PluginFeature: PluginFeature{
			GstObject: GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalTracerFactory(p uintptr) (interface{}, error) {
	return wrapTracerFactory(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// TracerType: get the #GType for elements managed by this factory. The type can
// only be retrieved if the element factory is loaded, which can be assured with
// gst_plugin_feature_load().
//
// The function returns the following values:
//
//   - gType for tracers managed by this factory or 0 if the factory is not
//     loaded.
func (factory *TracerFactory) TracerType() coreglib.Type {
	var _arg0 *C.GstTracerFactory // out
	var _cret C.GType             // in

	_arg0 = (*C.GstTracerFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))

	_cret = C.gst_tracer_factory_get_tracer_type(_arg0)
	runtime.KeepAlive(factory)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// TracerFactoryGetList gets the list of all registered tracer factories.
// You must free the list using gst_plugin_feature_list_free().
//
// The returned factories are sorted by factory name.
//
// Free-function: gst_plugin_feature_list_free.
//
// The function returns the following values:
//
//   - list of all registered TracerFactory.
func TracerFactoryGetList() []*TracerFactory {
	var _cret *C.GList // in

	_cret = C.gst_tracer_factory_get_list()

	var _list []*TracerFactory // out

	_list = make([]*TracerFactory, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstTracerFactory)(v)
		var dst *TracerFactory // out
		dst = wrapTracerFactory(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// TracerRecord: tracing modules will create instances of this class to announce
// the data they will log and create a log formatter.
type TracerRecord struct {
	_ [0]func() // equal guard
	GstObject
}

var (
	_ GstObjector = (*TracerRecord)(nil)
)

func wrapTracerRecord(obj *coreglib.Object) *TracerRecord {
	return &TracerRecord{
		GstObject: GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalTracerRecord(p uintptr) (interface{}, error) {
	return wrapTracerRecord(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// TypeFindFactory: these functions allow querying information about registered
// typefind functions. How to create and register these functions is described
// in the section <link linkend="gstreamer-Writing-typefind-functions"> "Writing
// typefind functions"</link>.
//
// The following example shows how to write a very simple typefinder that
// identifies the given data. You can get quite a bit more complicated than that
// though.
//
//	typedef struct {
//	  guint8 *data;
//	  guint size;
//	  guint probability;
//	  GstCaps *data;
//	} MyTypeFind;
//	static void
//	my_peek (gpointer data, gint64 offset, guint size)
//	{
//	  MyTypeFind *find = (MyTypeFind *) data;
//	  if (offset >= 0 && offset + size <= find->size) {
//	    return find->data + offset;
//	  }
//	  return NULL;
//	}
//	static void
//	my_suggest (gpointer data, guint probability, GstCaps *caps)
//	{
//	  MyTypeFind *find = (MyTypeFind *) data;
//	  if (probability > find->probability) {
//	    find->probability = probability;
//	    gst_caps_replace (&find->caps, caps);
//	  }
//	}
//	static GstCaps *
//	find_type (guint8 *data, guint size)
//	{
//	  GList *walk, *type_list;
//	  MyTypeFind find = {data, size, 0, NULL};
//	  GstTypeFind gst_find = {my_peek, my_suggest, &find, };
//	  walk = type_list = gst_type_find_factory_get_list ();
//	  while (walk) {
//	    GstTypeFindFactory *factory = GST_TYPE_FIND_FACTORY (walk->data);
//	    walk = g_list_next (walk)
//	    gst_type_find_factory_call_function (factory, &gst_find);
//	  }
//	  g_list_free (type_list);
//	  return find.caps;
//	};.
type TypeFindFactory struct {
	_ [0]func() // equal guard
	PluginFeature
}

var (
	_ PluginFeaturer = (*TypeFindFactory)(nil)
)

func wrapTypeFindFactory(obj *coreglib.Object) *TypeFindFactory {
	return &TypeFindFactory{
		PluginFeature: PluginFeature{
			GstObject: GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalTypeFindFactory(p uintptr) (interface{}, error) {
	return wrapTypeFindFactory(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// CallFunction calls the TypeFindFunction associated with this factory.
//
// The function takes the following parameters:
//
//   - find: properly setup TypeFind entry. The get_data and suggest_type
//     members must be set.
func (factory *TypeFindFactory) CallFunction(find *TypeFind) {
	var _arg0 *C.GstTypeFindFactory // out
	var _arg1 *C.GstTypeFind        // out

	_arg0 = (*C.GstTypeFindFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	_arg1 = (*C.GstTypeFind)(gextras.StructNative(unsafe.Pointer(find)))

	C.gst_type_find_factory_call_function(_arg0, _arg1)
	runtime.KeepAlive(factory)
	runtime.KeepAlive(find)
}

// Caps gets the Caps associated with a typefind factory.
//
// The function returns the following values:
//
//   - caps (optional) associated with this factory.
func (factory *TypeFindFactory) Caps() *Caps {
	var _arg0 *C.GstTypeFindFactory // out
	var _cret *C.GstCaps            // in

	_arg0 = (*C.GstTypeFindFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))

	_cret = C.gst_type_find_factory_get_caps(_arg0)
	runtime.KeepAlive(factory)

	var _caps *Caps // out

	if _cret != nil {
		_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _caps
}

// Extensions gets the extensions associated with a TypeFindFactory. The
// returned array should not be changed. If you need to change stuff in it, you
// should copy it using g_strdupv(). This function may return NULL to indicate a
// 0-length list.
//
// The function returns the following values:
//
//   - utf8s (optional): a NULL-terminated array of extensions associated with
//     this factory.
func (factory *TypeFindFactory) Extensions() []string {
	var _arg0 *C.GstTypeFindFactory // out
	var _cret **C.gchar             // in

	_arg0 = (*C.GstTypeFindFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))

	_cret = C.gst_type_find_factory_get_extensions(_arg0)
	runtime.KeepAlive(factory)

	var _utf8s []string // out

	if _cret != nil {
		{
			var i int
			var z *C.gchar
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			}
		}
	}

	return _utf8s
}

// HasFunction: check whether the factory has a typefind function. Typefind
// factories without typefind functions are a last-effort fallback mechanism to
// e.g. assume a certain media type based on the file extension.
//
// The function returns the following values:
//
//   - ok: TRUE if the factory has a typefind functions set, otherwise FALSE.
func (factory *TypeFindFactory) HasFunction() bool {
	var _arg0 *C.GstTypeFindFactory // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstTypeFindFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))

	_cret = C.gst_type_find_factory_has_function(_arg0)
	runtime.KeepAlive(factory)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TypeFindFactoryGetList gets the list of all registered typefind factories.
// You must free the list using gst_plugin_feature_list_free().
//
// The returned factories are sorted by highest rank first, and then by factory
// name.
//
// Free-function: gst_plugin_feature_list_free.
//
// The function returns the following values:
//
//   - list of all registered TypeFindFactory.
func TypeFindFactoryGetList() []*TypeFindFactory {
	var _cret *C.GList // in

	_cret = C.gst_type_find_factory_get_list()

	var _list []*TypeFindFactory // out

	_list = make([]*TypeFindFactory, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstTypeFindFactory)(v)
		var dst *TypeFindFactory // out
		dst = wrapTypeFindFactory(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// ValueArray: fundamental type that describes an ordered list of #GValue.
type ValueArray struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ValueArray)(nil)
)

func wrapValueArray(obj *coreglib.Object) *ValueArray {
	return &ValueArray{
		Object: obj,
	}
}

func marshalValueArray(p uintptr) (interface{}, error) {
	return wrapValueArray(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ValueArrayAppendAndTakeValue appends append_value to the GstValueArray in
// value.
//
// The function takes the following parameters:
//
//   - value of type T_TYPE_ARRAY.
//   - appendValue: value to append.
func ValueArrayAppendAndTakeValue(value, appendValue *coreglib.Value) {
	var _arg1 *C.GValue // out
	var _arg2 *C.GValue // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(appendValue.Native()))

	C.gst_value_array_append_and_take_value(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(appendValue)
}

// ValueArrayAppendValue appends append_value to the GstValueArray in value.
//
// The function takes the following parameters:
//
//   - value of type T_TYPE_ARRAY.
//   - appendValue: value to append.
func ValueArrayAppendValue(value, appendValue *coreglib.Value) {
	var _arg1 *C.GValue // out
	var _arg2 *C.GValue // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(appendValue.Native()))

	C.gst_value_array_append_value(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(appendValue)
}

// ValueArrayGetSize gets the number of values contained in value.
//
// The function takes the following parameters:
//
//   - value of type T_TYPE_ARRAY.
//
// The function returns the following values:
//
//   - guint: number of values.
func ValueArrayGetSize(value *coreglib.Value) uint {
	var _arg1 *C.GValue // out
	var _cret C.guint   // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_array_get_size(_arg1)
	runtime.KeepAlive(value)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ValueArrayGetValue gets the value that is a member of the array contained in
// value and has the index index.
//
// The function takes the following parameters:
//
//   - value of type T_TYPE_ARRAY.
//   - index of value to get from the array.
//
// The function returns the following values:
//
//   - ret: value at the given index.
func ValueArrayGetValue(value *coreglib.Value, index uint) *coreglib.Value {
	var _arg1 *C.GValue // out
	var _arg2 C.guint   // out
	var _cret *C.GValue // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.guint(index)

	_cret = C.gst_value_array_get_value(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(index)

	var _ret *coreglib.Value // out

	_ret = coreglib.ValueFromNative(unsafe.Pointer(_cret))

	return _ret
}

// ValueArrayInit initializes and pre-allocates a #GValue of type T_TYPE_ARRAY.
//
// The function takes the following parameters:
//
//   - value: zero-filled (uninitialized) #GValue structure.
//   - prealloc: number of entries to pre-allocate in the array.
//
// The function returns the following values:
//
//   - ret structure that has been passed in.
func ValueArrayInit(value *coreglib.Value, prealloc uint) *coreglib.Value {
	var _arg1 *C.GValue // out
	var _arg2 C.guint   // out
	var _cret *C.GValue // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.guint(prealloc)

	_cret = C.gst_value_array_init(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(prealloc)

	var _ret *coreglib.Value // out

	_ret = coreglib.ValueFromNative(unsafe.Pointer(_cret))

	return _ret
}

// ValueArrayPrependValue prepends prepend_value to the GstValueArray in value.
//
// The function takes the following parameters:
//
//   - value of type T_TYPE_ARRAY.
//   - prependValue: value to prepend.
func ValueArrayPrependValue(value, prependValue *coreglib.Value) {
	var _arg1 *C.GValue // out
	var _arg2 *C.GValue // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(prependValue.Native()))

	C.gst_value_array_prepend_value(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(prependValue)
}

// ValueList: fundamental type that describes an unordered list of #GValue.
type ValueList struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ValueList)(nil)
)

func wrapValueList(obj *coreglib.Object) *ValueList {
	return &ValueList{
		Object: obj,
	}
}

func marshalValueList(p uintptr) (interface{}, error) {
	return wrapValueList(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ValueListAppendAndTakeValue appends append_value to the GstValueList in
// value.
//
// The function takes the following parameters:
//
//   - value of type T_TYPE_LIST.
//   - appendValue: value to append.
func ValueListAppendAndTakeValue(value, appendValue *coreglib.Value) {
	var _arg1 *C.GValue // out
	var _arg2 *C.GValue // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(appendValue.Native()))

	C.gst_value_list_append_and_take_value(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(appendValue)
}

// ValueListAppendValue appends append_value to the GstValueList in value.
//
// The function takes the following parameters:
//
//   - value of type T_TYPE_LIST.
//   - appendValue: value to append.
func ValueListAppendValue(value, appendValue *coreglib.Value) {
	var _arg1 *C.GValue // out
	var _arg2 *C.GValue // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(appendValue.Native()))

	C.gst_value_list_append_value(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(appendValue)
}

// ValueListConcat concatenates copies of value1 and value2 into a list.
// Values that are not of type T_TYPE_LIST are treated as if they were lists of
// length 1. dest will be initialized to the type T_TYPE_LIST.
//
// The function takes the following parameters:
//
//   - value1: #GValue.
//   - value2: #GValue.
//
// The function returns the following values:
//
//   - dest: uninitialized #GValue to take the result.
func ValueListConcat(value1, value2 *coreglib.Value) coreglib.Value {
	var _arg1 C.GValue  // in
	var _arg2 *C.GValue // out
	var _arg3 *C.GValue // out

	_arg2 = (*C.GValue)(unsafe.Pointer(value1.Native()))
	_arg3 = (*C.GValue)(unsafe.Pointer(value2.Native()))

	C.gst_value_list_concat(&_arg1, _arg2, _arg3)
	runtime.KeepAlive(value1)
	runtime.KeepAlive(value2)

	var _dest coreglib.Value // out

	_dest = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))

	return _dest
}

// ValueListGetSize gets the number of values contained in value.
//
// The function takes the following parameters:
//
//   - value of type T_TYPE_LIST.
//
// The function returns the following values:
//
//   - guint: number of values.
func ValueListGetSize(value *coreglib.Value) uint {
	var _arg1 *C.GValue // out
	var _cret C.guint   // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_value_list_get_size(_arg1)
	runtime.KeepAlive(value)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ValueListGetValue gets the value that is a member of the list contained in
// value and has the index index.
//
// The function takes the following parameters:
//
//   - value of type T_TYPE_LIST.
//   - index of value to get from the list.
//
// The function returns the following values:
//
//   - ret: value at the given index.
func ValueListGetValue(value *coreglib.Value, index uint) *coreglib.Value {
	var _arg1 *C.GValue // out
	var _arg2 C.guint   // out
	var _cret *C.GValue // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.guint(index)

	_cret = C.gst_value_list_get_value(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(index)

	var _ret *coreglib.Value // out

	_ret = coreglib.ValueFromNative(unsafe.Pointer(_cret))

	return _ret
}

// ValueListInit initializes and pre-allocates a #GValue of type T_TYPE_LIST.
//
// The function takes the following parameters:
//
//   - value: zero-filled (uninitialized) #GValue structure.
//   - prealloc: number of entries to pre-allocate in the list.
//
// The function returns the following values:
//
//   - ret structure that has been passed in.
func ValueListInit(value *coreglib.Value, prealloc uint) *coreglib.Value {
	var _arg1 *C.GValue // out
	var _arg2 C.guint   // out
	var _cret *C.GValue // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.guint(prealloc)

	_cret = C.gst_value_list_init(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(prealloc)

	var _ret *coreglib.Value // out

	_ret = coreglib.ValueFromNative(unsafe.Pointer(_cret))

	return _ret
}

// ValueListMerge merges copies of value1 and value2. Values that are not of
// type T_TYPE_LIST are treated as if they were lists of length 1.
//
// The result will be put into dest and will either be a list that will not
// contain any duplicates, or a non-list type (if value1 and value2 were equal).
//
// The function takes the following parameters:
//
//   - value1: #GValue.
//   - value2: #GValue.
//
// The function returns the following values:
//
//   - dest: uninitialized #GValue to take the result.
func ValueListMerge(value1, value2 *coreglib.Value) coreglib.Value {
	var _arg1 C.GValue  // in
	var _arg2 *C.GValue // out
	var _arg3 *C.GValue // out

	_arg2 = (*C.GValue)(unsafe.Pointer(value1.Native()))
	_arg3 = (*C.GValue)(unsafe.Pointer(value2.Native()))

	C.gst_value_list_merge(&_arg1, _arg2, _arg3)
	runtime.KeepAlive(value1)
	runtime.KeepAlive(value2)

	var _dest coreglib.Value // out

	_dest = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))

	return _dest
}

// ValueListPrependValue prepends prepend_value to the GstValueList in value.
//
// The function takes the following parameters:
//
//   - value of type T_TYPE_LIST.
//   - prependValue: value to prepend.
func ValueListPrependValue(value, prependValue *coreglib.Value) {
	var _arg1 *C.GValue // out
	var _arg2 *C.GValue // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(prependValue.Native()))

	C.gst_value_list_prepend_value(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(prependValue)
}

// AllocationParams parameters to control the allocation of memory
//
// An instance of this type is always passed by reference.
type AllocationParams struct {
	*allocationParams
}

// allocationParams is the struct that's finalized.
type allocationParams struct {
	native *C.GstAllocationParams
}

func marshalAllocationParams(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &AllocationParams{&allocationParams{(*C.GstAllocationParams)(b)}}, nil
}

// NewAllocationParams constructs a struct AllocationParams.
func NewAllocationParams() *AllocationParams {
	var _cret *C.GstAllocationParams // in

	_cret = C.gst_allocation_params_new()

	var _allocationParams *AllocationParams // out

	_allocationParams = (*AllocationParams)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_allocationParams)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_allocation_params_free((*C.GstAllocationParams)(intern.C))
		},
	)

	return _allocationParams
}

// Flags flags to control allocation.
func (a *AllocationParams) Flags() MemoryFlags {
	valptr := &a.native.flags
	var _v MemoryFlags // out
	_v = MemoryFlags(*valptr)
	return _v
}

// Align: desired alignment of the memory.
func (a *AllocationParams) Align() uint {
	valptr := &a.native.align
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Prefix: desired prefix.
func (a *AllocationParams) Prefix() uint {
	valptr := &a.native.prefix
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Padding: desired padding.
func (a *AllocationParams) Padding() uint {
	valptr := &a.native.padding
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Align: desired alignment of the memory.
func (a *AllocationParams) SetAlign(align uint) {
	valptr := &a.native.align
	*valptr = C.gsize(align)
}

// Prefix: desired prefix.
func (a *AllocationParams) SetPrefix(prefix uint) {
	valptr := &a.native.prefix
	*valptr = C.gsize(prefix)
}

// Padding: desired padding.
func (a *AllocationParams) SetPadding(padding uint) {
	valptr := &a.native.padding
	*valptr = C.gsize(padding)
}

// Copy: create a copy of params.
//
// The function returns the following values:
//
//   - allocationParams (optional): new AllocationParams.
func (params *AllocationParams) Copy() *AllocationParams {
	var _arg0 *C.GstAllocationParams // out
	var _cret *C.GstAllocationParams // in

	if params != nil {
		_arg0 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	_cret = C.gst_allocation_params_copy(_arg0)
	runtime.KeepAlive(params)

	var _allocationParams *AllocationParams // out

	if _cret != nil {
		_allocationParams = (*AllocationParams)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_allocationParams)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_allocation_params_free((*C.GstAllocationParams)(intern.C))
			},
		)
	}

	return _allocationParams
}

// Init: initialize params to its default values.
func (params *AllocationParams) Init() {
	var _arg0 *C.GstAllocationParams // out

	_arg0 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))

	C.gst_allocation_params_init(_arg0)
	runtime.KeepAlive(params)
}

// AllocatorClass is used to create new memory.
//
// An instance of this type is always passed by reference.
type AllocatorClass struct {
	*allocatorClass
}

// allocatorClass is the struct that's finalized.
type allocatorClass struct {
	native *C.GstAllocatorClass
}

// ObjectClass: object parent class.
func (a *AllocatorClass) ObjectClass() *ObjectClass {
	valptr := &a.native.object_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// AtomicQueue object implements a queue that can be used from multiple threads
// without performing any blocking operations.
//
// An instance of this type is always passed by reference.
type AtomicQueue struct {
	*atomicQueue
}

// atomicQueue is the struct that's finalized.
type atomicQueue struct {
	native *C.GstAtomicQueue
}

func marshalAtomicQueue(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &AtomicQueue{&atomicQueue{(*C.GstAtomicQueue)(b)}}, nil
}

// NewAtomicQueue constructs a struct AtomicQueue.
func NewAtomicQueue(initialSize uint) *AtomicQueue {
	var _arg1 C.guint           // out
	var _cret *C.GstAtomicQueue // in

	_arg1 = C.guint(initialSize)

	_cret = C.gst_atomic_queue_new(_arg1)
	runtime.KeepAlive(initialSize)

	var _atomicQueue *AtomicQueue // out

	_atomicQueue = (*AtomicQueue)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_atomicQueue)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_atomic_queue_unref((*C.GstAtomicQueue)(intern.C))
		},
	)

	return _atomicQueue
}

// Length: get the amount of items in the queue.
//
// The function returns the following values:
//
//   - guint: number of elements in the queue.
func (queue *AtomicQueue) Length() uint {
	var _arg0 *C.GstAtomicQueue // out
	var _cret C.guint           // in

	_arg0 = (*C.GstAtomicQueue)(gextras.StructNative(unsafe.Pointer(queue)))

	_cret = C.gst_atomic_queue_length(_arg0)
	runtime.KeepAlive(queue)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Peek the head element of the queue without removing it from the queue.
//
// The function returns the following values:
//
//   - gpointer (optional): head element of queue or NULL when the queue is
//     empty.
func (queue *AtomicQueue) Peek() unsafe.Pointer {
	var _arg0 *C.GstAtomicQueue // out
	var _cret C.gpointer        // in

	_arg0 = (*C.GstAtomicQueue)(gextras.StructNative(unsafe.Pointer(queue)))

	_cret = C.gst_atomic_queue_peek(_arg0)
	runtime.KeepAlive(queue)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// Pop: get the head element of the queue.
//
// The function returns the following values:
//
//   - gpointer (optional): head element of queue or NULL when the queue is
//     empty.
func (queue *AtomicQueue) Pop() unsafe.Pointer {
	var _arg0 *C.GstAtomicQueue // out
	var _cret C.gpointer        // in

	_arg0 = (*C.GstAtomicQueue)(gextras.StructNative(unsafe.Pointer(queue)))

	_cret = C.gst_atomic_queue_pop(_arg0)
	runtime.KeepAlive(queue)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// Push: append data to the tail of the queue.
//
// The function takes the following parameters:
//
//   - data (optional): data.
func (queue *AtomicQueue) Push(data unsafe.Pointer) {
	var _arg0 *C.GstAtomicQueue // out
	var _arg1 C.gpointer        // out

	_arg0 = (*C.GstAtomicQueue)(gextras.StructNative(unsafe.Pointer(queue)))
	_arg1 = (C.gpointer)(unsafe.Pointer(data))

	C.gst_atomic_queue_push(_arg0, _arg1)
	runtime.KeepAlive(queue)
	runtime.KeepAlive(data)
}

// BinClass subclasses can override BinClass::add_element and
// BinClass::remove_element to update the list of children in the bin.
//
// The BinClass::handle_message method can be overridden to implement custom
// message handling.
//
// BinClass::deep_element_added will be called when a new element has been
// added to any bin inside this bin, so it will also be called if a new child
// was added to a sub-bin of this bin. Bin implementations that override
// this message should chain up to the parent class implementation so the
// Bin::deep-element-added signal is emitted on all parents.
//
// An instance of this type is always passed by reference.
type BinClass struct {
	*binClass
}

// binClass is the struct that's finalized.
type binClass struct {
	native *C.GstBinClass
}

// ParentClass: bin parent class.
func (b *BinClass) ParentClass() *ElementClass {
	valptr := &b.native.parent_class
	var _v *ElementClass // out
	_v = (*ElementClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Buffer buffers are the basic unit of data transfer in GStreamer. They contain
// the timing and offset along with other arbitrary metadata that is associated
// with the Memory blocks that the buffer contains.
//
// Buffers are usually created with gst_buffer_new(). After a buffer has been
// created one will typically allocate memory for it and add it to the buffer.
// The following example creates a buffer that can hold a given video frame with
// a given width, height and bits per plane.
//
//	C   GstBuffer *buffer;   GstMemory *memory;   gint size, width, height, bpp;   ...   size = width * height * bpp;   buffer = gst_buffer_new ();   memory = gst_allocator_alloc (NULL, size, NULL);   gst_buffer_insert_memory (buffer, -1, memory);   ...
//
// Alternatively, use gst_buffer_new_allocate() to create a buffer with
// preallocated data of a given size.
//
// Buffers can contain a list of Memory objects. You can retrieve how many
// memory objects with gst_buffer_n_memory() and you can get a pointer to memory
// with gst_buffer_peek_memory()
//
// A buffer will usually have timestamps, and a duration, but neither of these
// are guaranteed (they may be set to T_CLOCK_TIME_NONE). Whenever a meaningful
// value can be given for these, they should be set. The timestamps and duration
// are measured in nanoseconds (they are ClockTime values).
//
// The buffer DTS refers to the timestamp when the buffer should be decoded and
// is usually monotonically increasing. The buffer PTS refers to the timestamp
// when the buffer content should be presented to the user and is not always
// monotonically increasing.
//
// A buffer can also have one or both of a start and an end offset. These are
// media-type specific. For video buffers, the start offset will generally
// be the frame number. For audio buffers, it will be the number of samples
// produced so far. For compressed data, it could be the byte offset in a source
// or destination file. Likewise, the end offset will be the offset of the end
// of the buffer. These can only be meaningfully interpreted if you know the
// media type of the buffer (the preceding CAPS event). Either or both can be
// set to T_BUFFER_OFFSET_NONE.
//
// gst_buffer_ref() is used to increase the refcount of a buffer. This must be
// done when you want to keep a handle to the buffer after pushing it to the
// next element. The buffer refcount determines the writability of the buffer,
// a buffer is only writable when the refcount is exactly 1, i.e. when the
// caller has the only reference to the buffer.
//
// To efficiently create a smaller buffer out of an existing one, you can use
// gst_buffer_copy_region(). This method tries to share the memory objects
// between the two buffers.
//
// If a plug-in wants to modify the buffer data or metadata in-place,
// it should first obtain a buffer that is safe to modify by using
// gst_buffer_make_writable(). This function is optimized so that a copy will
// only be made when it is necessary.
//
// Several flags of the buffer can be set and unset with the
// GST_BUFFER_FLAG_SET() and GST_BUFFER_FLAG_UNSET() macros. Use
// GST_BUFFER_FLAG_IS_SET() to test if a certain BufferFlags flag is set.
//
// Buffers can be efficiently merged into a larger buffer with
// gst_buffer_append(). Copying of memory will only be done when absolutely
// needed.
//
// Arbitrary extra metadata can be set on a buffer with gst_buffer_add_meta().
// Metadata can be retrieved with gst_buffer_get_meta(). See also Meta.
//
// An element should either unref the buffer or push it out on a src pad using
// gst_pad_push() (see Pad).
//
// Buffers are usually freed by unreffing them with gst_buffer_unref(). When
// the refcount drops to 0, any memory and metadata pointed to by the buffer is
// unreffed as well. Buffers allocated from a BufferPool will be returned to the
// pool when the refcount drops to 0.
//
// The ParentBufferMeta is a meta which can be attached to a Buffer to hold a
// reference to another buffer that is only released when the child Buffer is
// released.
//
// Typically, ParentBufferMeta is used when the child buffer is directly using
// the Memory of the parent buffer, and wants to prevent the parent buffer from
// being returned to a buffer pool until the Memory is available for re-use.
// (Since: 1.6)
//
// An instance of this type is always passed by reference.
type Buffer struct {
	*buffer
}

// buffer is the struct that's finalized.
type buffer struct {
	native *C.GstBuffer
}

func marshalBuffer(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Buffer{&buffer{(*C.GstBuffer)(b)}}, nil
}

// NewBuffer constructs a struct Buffer.
func NewBuffer() *Buffer {
	var _cret *C.GstBuffer // in

	_cret = C.gst_buffer_new()

	var _buffer *Buffer // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// NewBufferAllocate constructs a struct Buffer.
func NewBufferAllocate(allocator Allocatorrer, size uint, params *AllocationParams) *Buffer {
	var _arg1 *C.GstAllocator        // out
	var _arg2 C.gsize                // out
	var _arg3 *C.GstAllocationParams // out
	var _cret *C.GstBuffer           // in

	if allocator != nil {
		_arg1 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	}
	_arg2 = C.gsize(size)
	if params != nil {
		_arg3 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	_cret = C.gst_buffer_new_allocate(_arg1, _arg2, _arg3)
	runtime.KeepAlive(allocator)
	runtime.KeepAlive(size)
	runtime.KeepAlive(params)

	var _buffer *Buffer // out

	if _cret != nil {
		_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_buffer)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _buffer
}

// NewBufferMemdup constructs a struct Buffer.
func NewBufferMemdup(data []byte) *Buffer {
	var _arg1 C.gconstpointer // out
	var _arg2 C.gsize
	var _cret *C.GstBuffer // in

	_arg2 = (C.gsize)(len(data))
	if len(data) > 0 {
		_arg1 = (C.gconstpointer)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_buffer_new_memdup(_arg1, _arg2)
	runtime.KeepAlive(data)

	var _buffer *Buffer // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// NewBufferWrapped constructs a struct Buffer.
func NewBufferWrapped(data []byte) *Buffer {
	var _arg1 C.gpointer // out
	var _arg2 C.gsize
	var _cret *C.GstBuffer // in

	_arg2 = (C.gsize)(len(data))
	_arg1 = (C.gpointer)(C.calloc(C.size_t(len(data)), C.size_t(C.sizeof_guint8)))
	copy(unsafe.Slice((*byte)(_arg1), len(data)), data)

	_cret = C.gst_buffer_new_wrapped(_arg1, _arg2)
	runtime.KeepAlive(data)

	var _buffer *Buffer // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// NewBufferWrappedBytes constructs a struct Buffer.
func NewBufferWrappedBytes(bytes *glib.Bytes) *Buffer {
	var _arg1 *C.GBytes    // out
	var _cret *C.GstBuffer // in

	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))

	_cret = C.gst_buffer_new_wrapped_bytes(_arg1)
	runtime.KeepAlive(bytes)

	var _buffer *Buffer // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// MiniObject: parent structure.
func (b *Buffer) MiniObject() *MiniObject {
	valptr := &b.native.mini_object
	var _v *MiniObject // out
	_v = (*MiniObject)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Pool: pointer to the pool owner of the buffer.
func (b *Buffer) Pool() *BufferPool {
	valptr := &b.native.pool
	var _v *BufferPool // out
	_v = wrapBufferPool(coreglib.Take(unsafe.Pointer(*valptr)))
	return _v
}

// Pts: presentation timestamp of the buffer, can be T_CLOCK_TIME_NONE when the
// pts is not known or relevant. The pts contains the timestamp when the media
// should be presented to the user.
func (b *Buffer) Pts() ClockTime {
	valptr := &b.native.pts
	var _v ClockTime // out
	_v = ClockTime(*valptr)
	return _v
}

// Dts: decoding timestamp of the buffer, can be T_CLOCK_TIME_NONE when the
// dts is not known or relevant. The dts contains the timestamp when the media
// should be processed.
func (b *Buffer) Dts() ClockTime {
	valptr := &b.native.dts
	var _v ClockTime // out
	_v = ClockTime(*valptr)
	return _v
}

// Duration: duration in time of the buffer data, can be T_CLOCK_TIME_NONE when
// the duration is not known or relevant.
func (b *Buffer) Duration() ClockTime {
	valptr := &b.native.duration
	var _v ClockTime // out
	_v = ClockTime(*valptr)
	return _v
}

// Offset: media specific offset for the buffer data. For video frames, this is
// the frame number of this buffer. For audio samples, this is the offset of the
// first sample in this buffer. For file data or compressed data this is the
// byte offset of the first byte in this buffer.
func (b *Buffer) Offset() uint64 {
	valptr := &b.native.offset
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// OffsetEnd: last offset contained in this buffer. It has the same format as
// offset.
func (b *Buffer) OffsetEnd() uint64 {
	valptr := &b.native.offset_end
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Offset: media specific offset for the buffer data. For video frames, this is
// the frame number of this buffer. For audio samples, this is the offset of the
// first sample in this buffer. For file data or compressed data this is the
// byte offset of the first byte in this buffer.
func (b *Buffer) SetOffset(offset uint64) {
	valptr := &b.native.offset
	*valptr = C.guint64(offset)
}

// OffsetEnd: last offset contained in this buffer. It has the same format as
// offset.
func (b *Buffer) SetOffsetEnd(offsetEnd uint64) {
	valptr := &b.native.offset_end
	*valptr = C.guint64(offsetEnd)
}

// AddCustomMeta creates and adds a CustomMeta for the desired name. name must
// have been successfully registered with gst_meta_register_custom().
//
// The function takes the following parameters:
//
//   - name: registered name of the desired custom meta.
//
// The function returns the following values:
//
//   - customMeta (optional) that was added to the buffer.
func (buffer *Buffer) AddCustomMeta(name string) *CustomMeta {
	var _arg0 *C.GstBuffer     // out
	var _arg1 *C.gchar         // out
	var _cret *C.GstCustomMeta // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_buffer_add_custom_meta(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)

	var _customMeta *CustomMeta // out

	if _cret != nil {
		_customMeta = (*CustomMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _customMeta
}

// AddMeta adds metadata for info to buffer using the parameters in params.
//
// The function takes the following parameters:
//
//   - info: MetaInfo.
//   - params (optional) for info.
//
// The function returns the following values:
//
//   - meta (optional): metadata for the api in info on buffer.
func (buffer *Buffer) AddMeta(info *MetaInfo, params unsafe.Pointer) *Meta {
	var _arg0 *C.GstBuffer   // out
	var _arg1 *C.GstMetaInfo // out
	var _arg2 C.gpointer     // out
	var _cret *C.GstMeta     // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*C.GstMetaInfo)(gextras.StructNative(unsafe.Pointer(info)))
	_arg2 = (C.gpointer)(unsafe.Pointer(params))

	_cret = C.gst_buffer_add_meta(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(info)
	runtime.KeepAlive(params)

	var _meta *Meta // out

	if _cret != nil {
		_meta = (*Meta)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _meta
}

// AddParentBufferMeta adds a ParentBufferMeta to buffer that holds a reference
// on ref until the buffer is freed.
//
// The function takes the following parameters:
//
//   - ref to ref.
//
// The function returns the following values:
//
//   - parentBufferMeta (optional) that was added to the buffer.
func (buffer *Buffer) AddParentBufferMeta(ref *Buffer) *ParentBufferMeta {
	var _arg0 *C.GstBuffer           // out
	var _arg1 *C.GstBuffer           // out
	var _cret *C.GstParentBufferMeta // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(ref)))

	_cret = C.gst_buffer_add_parent_buffer_meta(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(ref)

	var _parentBufferMeta *ParentBufferMeta // out

	if _cret != nil {
		_parentBufferMeta = (*ParentBufferMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _parentBufferMeta
}

// AddProtectionMeta attaches protection metadata to a Buffer.
//
// The function takes the following parameters:
//
//   - info holding cryptographic information relating to the sample contained
//     in buffer. This function takes ownership of info.
//
// The function returns the following values:
//
//   - protectionMeta: pointer to the added ProtectionMeta if successful.
func (buffer *Buffer) AddProtectionMeta(info *Structure) *ProtectionMeta {
	var _arg0 *C.GstBuffer         // out
	var _arg1 *C.GstStructure      // out
	var _cret *C.GstProtectionMeta // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(info)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(info)), nil)

	_cret = C.gst_buffer_add_protection_meta(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(info)

	var _protectionMeta *ProtectionMeta // out

	_protectionMeta = (*ProtectionMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _protectionMeta
}

// AddReferenceTimestampMeta adds a ReferenceTimestampMeta to buffer that holds
// a timestamp and optionally duration based on a specific timestamp reference.
// See the documentation of ReferenceTimestampMeta for details.
//
// The function takes the following parameters:
//
//   - reference: identifier for the timestamp reference.
//   - timestamp: timestamp.
//   - duration: duration, or GST_CLOCK_TIME_NONE.
//
// The function returns the following values:
//
//   - referenceTimestampMeta (optional) that was added to the buffer.
func (buffer *Buffer) AddReferenceTimestampMeta(reference *Caps, timestamp ClockTime, duration ClockTime) *ReferenceTimestampMeta {
	var _arg0 *C.GstBuffer                 // out
	var _arg1 *C.GstCaps                   // out
	var _arg2 C.GstClockTime               // out
	var _arg3 C.GstClockTime               // out
	var _cret *C.GstReferenceTimestampMeta // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(reference)))
	_arg2 = C.GstClockTime(timestamp)
	_arg3 = C.GstClockTime(duration)

	_cret = C.gst_buffer_add_reference_timestamp_meta(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(reference)
	runtime.KeepAlive(timestamp)
	runtime.KeepAlive(duration)

	var _referenceTimestampMeta *ReferenceTimestampMeta // out

	if _cret != nil {
		_referenceTimestampMeta = (*ReferenceTimestampMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _referenceTimestampMeta
}

// Append appends all the memory from buf2 to buf1. The result buffer will
// contain a concatenation of the memory of buf1 and buf2.
//
// The function takes the following parameters:
//
//   - buf2: second source Buffer to append.
//
// The function returns the following values:
//
//   - buffer: new Buffer that contains the memory of the two source buffers.
func (buf1 *Buffer) Append(buf2 *Buffer) *Buffer {
	var _arg0 *C.GstBuffer // out
	var _arg1 *C.GstBuffer // out
	var _cret *C.GstBuffer // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buf1)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buf1)), nil)
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buf2)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buf2)), nil)

	_cret = C.gst_buffer_append(_arg0, _arg1)
	runtime.KeepAlive(buf1)
	runtime.KeepAlive(buf2)

	var _buffer *Buffer // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// AppendMemory appends the memory block mem to buffer. This function takes
// ownership of mem and thus doesn't increase its refcount.
//
// This function is identical to gst_buffer_insert_memory() with an index of -1.
// See gst_buffer_insert_memory() for more details.
//
// The function takes the following parameters:
//
//   - mem: Memory.
func (buffer *Buffer) AppendMemory(mem *Memory) {
	var _arg0 *C.GstBuffer // out
	var _arg1 *C.GstMemory // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(mem)), nil)

	C.gst_buffer_append_memory(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mem)
}

// AppendRegion appends size bytes at offset from buf2 to buf1. The result
// buffer will contain a concatenation of the memory of buf1 and the requested
// region of buf2.
//
// The function takes the following parameters:
//
//   - buf2: second source Buffer to append.
//   - offset in buf2.
//   - size or -1 of buf2.
//
// The function returns the following values:
//
//   - buffer: new Buffer that contains the memory of the two source buffers.
func (buf1 *Buffer) AppendRegion(buf2 *Buffer, offset int, size int) *Buffer {
	var _arg0 *C.GstBuffer // out
	var _arg1 *C.GstBuffer // out
	var _arg2 C.gssize     // out
	var _arg3 C.gssize     // out
	var _cret *C.GstBuffer // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buf1)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buf1)), nil)
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buf2)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buf2)), nil)
	_arg2 = C.gssize(offset)
	_arg3 = C.gssize(size)

	_cret = C.gst_buffer_append_region(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buf1)
	runtime.KeepAlive(buf2)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _buffer *Buffer // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _buffer
}

// CopyDeep creates a copy of the given buffer. This will make a newly allocated
// copy of the data the source buffer contains.
//
// The function returns the following values:
//
//   - buffer (optional): new copy of buf if the copy succeeded, NULL otherwise.
func (buf *Buffer) CopyDeep() *Buffer {
	var _arg0 *C.GstBuffer // out
	var _cret *C.GstBuffer // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buf)))

	_cret = C.gst_buffer_copy_deep(_arg0)
	runtime.KeepAlive(buf)

	var _buffer *Buffer // out

	if _cret != nil {
		_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_buffer)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _buffer
}

// CopyInto copies the information from src into dest.
//
// If dest already contains memory and flags contains GST_BUFFER_COPY_MEMORY,
// the memory from src will be appended to dest.
//
// flags indicate which fields will be copied.
//
// The function takes the following parameters:
//
//   - src: source Buffer.
//   - flags indicating what metadata fields should be copied.
//   - offset to copy from.
//   - size: total size to copy. If -1, all data is copied.
//
// The function returns the following values:
//
//   - ok: TRUE if the copying succeeded, FALSE otherwise.
func (dest *Buffer) CopyInto(src *Buffer, flags BufferCopyFlagsType, offset uint, size uint) bool {
	var _arg0 *C.GstBuffer         // out
	var _arg1 *C.GstBuffer         // out
	var _arg2 C.GstBufferCopyFlags // out
	var _arg3 C.gsize              // out
	var _arg4 C.gsize              // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(dest)))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(src)))
	_arg2 = C.GstBufferCopyFlags(flags)
	_arg3 = C.gsize(offset)
	_arg4 = C.gsize(size)

	_cret = C.gst_buffer_copy_into(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(src)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CopyRegion creates a sub-buffer from parent at offset and size. This
// sub-buffer uses the actual memory space of the parent buffer. This function
// will copy the offset and timestamp fields when the offset is 0. If not,
// they will be set to T_CLOCK_TIME_NONE and T_BUFFER_OFFSET_NONE. If offset
// equals 0 and size equals the total size of buffer, the duration and offset
// end fields are also copied. If not they will be set to T_CLOCK_TIME_NONE and
// T_BUFFER_OFFSET_NONE.
//
// The function takes the following parameters:
//
//   - flags: BufferCopyFlags.
//   - offset into parent Buffer at which the new sub-buffer begins.
//   - size of the new Buffer sub-buffer, in bytes. If -1, all data is copied.
//
// The function returns the following values:
//
//   - buffer (optional): new Buffer or NULL if copying failed.
func (parent *Buffer) CopyRegion(flags BufferCopyFlagsType, offset uint, size uint) *Buffer {
	var _arg0 *C.GstBuffer         // out
	var _arg1 C.GstBufferCopyFlags // out
	var _arg2 C.gsize              // out
	var _arg3 C.gsize              // out
	var _cret *C.GstBuffer         // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(parent)))
	_arg1 = C.GstBufferCopyFlags(flags)
	_arg2 = C.gsize(offset)
	_arg3 = C.gsize(size)

	_cret = C.gst_buffer_copy_region(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _buffer *Buffer // out

	if _cret != nil {
		_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_buffer)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _buffer
}

// ExtractDup extracts a copy of at most size bytes the data at offset into
// newly-allocated memory. dest must be freed using g_free() when done.
//
// The function takes the following parameters:
//
//   - offset to extract.
//   - size to extract.
//
// The function returns the following values:
//
//   - dest: pointer where the destination array will be written. Might be NULL
//     if the size is 0.
func (buffer *Buffer) ExtractDup(offset uint, size uint) []byte {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.gsize      // out
	var _arg2 C.gsize      // out
	var _arg3 C.gpointer   // in
	var _arg4 C.gsize      // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.gsize(offset)
	_arg2 = C.gsize(size)

	C.gst_buffer_extract_dup(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _dest []byte // out

	defer C.free(unsafe.Pointer(_arg3))
	_dest = make([]byte, _arg4)
	copy(_dest, unsafe.Slice((*byte)(unsafe.Pointer(_arg3)), _arg4))

	return _dest
}

// Fill copies size bytes from src to buffer at offset.
//
// The function takes the following parameters:
//
//   - offset to fill.
//   - src: source address.
//
// The function returns the following values:
//
//   - gsize: amount of bytes copied. This value can be lower than size when
//     buffer did not contain enough data.
func (buffer *Buffer) Fill(offset uint, src []byte) uint {
	var _arg0 *C.GstBuffer    // out
	var _arg1 C.gsize         // out
	var _arg2 C.gconstpointer // out
	var _arg3 C.gsize
	var _cret C.gsize // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.gsize(offset)
	_arg3 = (C.gsize)(len(src))
	if len(src) > 0 {
		_arg2 = (C.gconstpointer)(unsafe.Pointer(&src[0]))
	}

	_cret = C.gst_buffer_fill(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(src)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// FindMemory finds the memory blocks that span size bytes starting from offset
// in buffer.
//
// When this function returns TRUE, idx will contain the index of the first
// memory block where the byte for offset can be found and length contains the
// number of memory blocks containing the size remaining bytes. skip contains
// the number of bytes to skip in the memory block at idx to get to the byte for
// offset.
//
// size can be -1 to get all the memory blocks after idx.
//
// The function takes the following parameters:
//
//   - offset: offset.
//   - size: size.
//
// The function returns the following values:
//
//   - idx: pointer to index.
//   - length: pointer to length.
//   - skip: pointer to skip.
//   - ok: TRUE when size bytes starting from offset could be found in buffer
//     and idx, length and skip will be filled.
func (buffer *Buffer) FindMemory(offset uint, size uint) (idx uint, length uint, skip uint, ok bool) {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.gsize      // out
	var _arg2 C.gsize      // out
	var _arg3 C.guint      // in
	var _arg4 C.guint      // in
	var _arg5 C.gsize      // in
	var _cret C.gboolean   // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.gsize(offset)
	_arg2 = C.gsize(size)

	_cret = C.gst_buffer_find_memory(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_arg5)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _idx uint    // out
	var _length uint // out
	var _skip uint   // out
	var _ok bool     // out

	_idx = uint(_arg3)
	_length = uint(_arg4)
	_skip = uint(_arg5)
	if _cret != 0 {
		_ok = true
	}

	return _idx, _length, _skip, _ok
}

// ForEachMeta calls func with user_data for each meta in buffer.
//
// func can modify the passed meta pointer or its contents. The return value of
// func defines if this function returns or if the remaining metadata items in
// the buffer should be skipped.
//
// The function takes the following parameters:
//
//   - fn to call.
//
// The function returns the following values:
//
//   - ok: FALSE when func returned FALSE for one of the metadata.
func (buffer *Buffer) ForEachMeta(fn BufferForEachMetaFunc) bool {
	var _arg0 *C.GstBuffer               // out
	var _arg1 C.GstBufferForeachMetaFunc // out
	var _arg2 C.gpointer
	var _cret C.gboolean // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*[0]byte)(C._gotk4_gst1_BufferForEachMetaFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.gst_buffer_foreach_meta(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(fn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AllMemory gets all the memory blocks in buffer. The memory blocks will be
// merged into one large Memory.
//
// The function returns the following values:
//
//   - memory (optional) that contains the merged memory.
func (buffer *Buffer) AllMemory() *Memory {
	var _arg0 *C.GstBuffer // out
	var _cret *C.GstMemory // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_buffer_get_all_memory(_arg0)
	runtime.KeepAlive(buffer)

	var _memory *Memory // out

	if _cret != nil {
		_memory = (*Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_memory)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _memory
}

// CustomMeta finds the first CustomMeta on buffer for the desired name.
//
// The function takes the following parameters:
//
//   - name: registered name of the custom meta to retrieve.
//
// The function returns the following values:
//
//   - customMeta (optional): CustomMeta.
func (buffer *Buffer) CustomMeta(name string) *CustomMeta {
	var _arg0 *C.GstBuffer     // out
	var _arg1 *C.gchar         // out
	var _cret *C.GstCustomMeta // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_buffer_get_custom_meta(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)

	var _customMeta *CustomMeta // out

	if _cret != nil {
		_customMeta = (*CustomMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _customMeta
}

// Flags gets the BufferFlags flags set on this buffer.
//
// The function returns the following values:
//
//   - bufferFlags flags set on this buffer.
func (buffer *Buffer) Flags() BufferFlags {
	var _arg0 *C.GstBuffer     // out
	var _cret C.GstBufferFlags // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_buffer_get_flags(_arg0)
	runtime.KeepAlive(buffer)

	var _bufferFlags BufferFlags // out

	_bufferFlags = BufferFlags(_cret)

	return _bufferFlags
}

// Memory gets the memory block at index idx in buffer.
//
// The function takes the following parameters:
//
//   - idx: index.
//
// The function returns the following values:
//
//   - memory (optional) that contains the data of the memory block at idx.
func (buffer *Buffer) Memory(idx uint) *Memory {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.guint      // out
	var _cret *C.GstMemory // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.guint(idx)

	_cret = C.gst_buffer_get_memory(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)

	var _memory *Memory // out

	if _cret != nil {
		_memory = (*Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_memory)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _memory
}

// MemoryRange gets length memory blocks in buffer starting at idx. The memory
// blocks will be merged into one large Memory.
//
// If length is -1, all memory starting from idx is merged.
//
// The function takes the following parameters:
//
//   - idx: index.
//   - length: length.
//
// The function returns the following values:
//
//   - memory (optional) that contains the merged data of length blocks starting
//     at idx.
func (buffer *Buffer) MemoryRange(idx uint, length int) *Memory {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.guint      // out
	var _arg2 C.gint       // out
	var _cret *C.GstMemory // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.guint(idx)
	_arg2 = C.gint(length)

	_cret = C.gst_buffer_get_memory_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(length)

	var _memory *Memory // out

	if _cret != nil {
		_memory = (*Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_memory)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _memory
}

// Meta gets the metadata for api on buffer. When there is no such metadata,
// NULL is returned. If multiple metadata with the given api are attached to
// this buffer only the first one is returned. To handle multiple metadata
// with a given API use gst_buffer_iterate_meta() or gst_buffer_foreach_meta()
// instead and check the meta->info.api member for the API type.
//
// The function takes the following parameters:
//
//   - api of an API.
//
// The function returns the following values:
//
//   - meta (optional): metadata for api on buffer.
func (buffer *Buffer) Meta(api coreglib.Type) *Meta {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.GType      // out
	var _cret *C.GstMeta   // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.GType(api)

	_cret = C.gst_buffer_get_meta(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(api)

	var _meta *Meta // out

	if _cret != nil {
		_meta = (*Meta)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _meta
}

// The function takes the following parameters:
//
//   - apiType of an API.
//
// The function returns the following values:
//
//   - guint: number of metas of type api_type on buffer.
func (buffer *Buffer) NMeta(apiType coreglib.Type) uint {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.GType      // out
	var _cret C.guint      // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.GType(apiType)

	_cret = C.gst_buffer_get_n_meta(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(apiType)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ReferenceTimestampMeta finds the first ReferenceTimestampMeta on buffer
// that conforms to reference. Conformance is tested by checking if the meta's
// reference is a subset of reference.
//
// Buffers can contain multiple ReferenceTimestampMeta metadata items.
//
// The function takes the following parameters:
//
//   - reference (optional) Caps.
//
// The function returns the following values:
//
//   - referenceTimestampMeta (optional) or NULL when there is no such metadata
//     on buffer.
func (buffer *Buffer) ReferenceTimestampMeta(reference *Caps) *ReferenceTimestampMeta {
	var _arg0 *C.GstBuffer                 // out
	var _arg1 *C.GstCaps                   // out
	var _cret *C.GstReferenceTimestampMeta // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	if reference != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(reference)))
	}

	_cret = C.gst_buffer_get_reference_timestamp_meta(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(reference)

	var _referenceTimestampMeta *ReferenceTimestampMeta // out

	if _cret != nil {
		_referenceTimestampMeta = (*ReferenceTimestampMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _referenceTimestampMeta
}

// Size gets the total size of the memory blocks in buffer.
//
// The function returns the following values:
//
//   - gsize: total size of the memory blocks in buffer.
func (buffer *Buffer) Size() uint {
	var _arg0 *C.GstBuffer // out
	var _cret C.gsize      // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_buffer_get_size(_arg0)
	runtime.KeepAlive(buffer)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Sizes gets the total size of the memory blocks in buffer.
//
// When not NULL, offset will contain the offset of the data in the first memory
// block in buffer and maxsize will contain the sum of the size and offset and
// the amount of extra padding on the last memory block. offset and maxsize can
// be used to resize the buffer memory blocks with gst_buffer_resize().
//
// The function returns the following values:
//
//   - offset (optional): pointer to the offset.
//   - maxsize (optional): pointer to the maxsize.
//   - gsize: total size of the memory blocks in buffer.
func (buffer *Buffer) Sizes() (offset uint, maxsize uint, gsize uint) {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.gsize      // in
	var _arg2 C.gsize      // in
	var _cret C.gsize      // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_buffer_get_sizes(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(buffer)

	var _offset uint  // out
	var _maxsize uint // out
	var _gsize uint   // out

	_offset = uint(_arg1)
	_maxsize = uint(_arg2)
	_gsize = uint(_cret)

	return _offset, _maxsize, _gsize
}

// SizesRange gets the total size of length memory blocks stating from idx in
// buffer.
//
// When not NULL, offset will contain the offset of the data in the memory block
// in buffer at idx and maxsize will contain the sum of the size and offset
// and the amount of extra padding on the memory block at idx + length -1.
// offset and maxsize can be used to resize the buffer memory blocks with
// gst_buffer_resize_range().
//
// The function takes the following parameters:
//
//   - idx: index.
//   - length: length.
//
// The function returns the following values:
//
//   - offset (optional): pointer to the offset.
//   - maxsize (optional): pointer to the maxsize.
//   - gsize: total size of length memory blocks starting at idx in buffer.
func (buffer *Buffer) SizesRange(idx uint, length int) (offset uint, maxsize uint, gsize uint) {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.guint      // out
	var _arg2 C.gint       // out
	var _arg3 C.gsize      // in
	var _arg4 C.gsize      // in
	var _cret C.gsize      // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.guint(idx)
	_arg2 = C.gint(length)

	_cret = C.gst_buffer_get_sizes_range(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(length)

	var _offset uint  // out
	var _maxsize uint // out
	var _gsize uint   // out

	_offset = uint(_arg3)
	_maxsize = uint(_arg4)
	_gsize = uint(_cret)

	return _offset, _maxsize, _gsize
}

// HasFlags gives the status of a specific flag on a buffer.
//
// The function takes the following parameters:
//
//   - flags flag to check.
//
// The function returns the following values:
//
//   - ok: TRUE if all flags in flags are found on buffer.
func (buffer *Buffer) HasFlags(flags BufferFlags) bool {
	var _arg0 *C.GstBuffer     // out
	var _arg1 C.GstBufferFlags // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.GstBufferFlags(flags)

	_cret = C.gst_buffer_has_flags(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(flags)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsertMemory inserts the memory block mem into buffer at idx. This function
// takes ownership of mem and thus doesn't increase its refcount.
//
// Only gst_buffer_get_max_memory() can be added to a buffer. If more memory is
// added, existing memory blocks will automatically be merged to make room for
// the new memory.
//
// The function takes the following parameters:
//
//   - idx: index to add the memory at, or -1 to append it to the end.
//   - mem: Memory.
func (buffer *Buffer) InsertMemory(idx int, mem *Memory) {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.gint       // out
	var _arg2 *C.GstMemory // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.gint(idx)
	_arg2 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(mem)), nil)

	C.gst_buffer_insert_memory(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(mem)
}

// IsAllMemoryWritable checks if all memory blocks in buffer are writable.
//
// Note that this function does not check if buffer is writable, use
// gst_buffer_is_writable() to check that if needed.
//
// The function returns the following values:
//
//   - ok: TRUE if all memory blocks in buffer are writable.
func (buffer *Buffer) IsAllMemoryWritable() bool {
	var _arg0 *C.GstBuffer // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_buffer_is_all_memory_writable(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsMemoryRangeWritable checks if length memory blocks in buffer starting from
// idx are writable.
//
// length can be -1 to check all the memory blocks after idx.
//
// Note that this function does not check if buffer is writable, use
// gst_buffer_is_writable() to check that if needed.
//
// The function takes the following parameters:
//
//   - idx: index.
//   - length: length, should not be 0.
//
// The function returns the following values:
//
//   - ok: TRUE if the memory range is writable.
func (buffer *Buffer) IsMemoryRangeWritable(idx uint, length int) bool {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.guint      // out
	var _arg2 C.gint       // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.guint(idx)
	_arg2 = C.gint(length)

	_cret = C.gst_buffer_is_memory_range_writable(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(length)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Map fills info with the MapInfo of all merged memory blocks in buffer.
//
// flags describe the desired access of the memory. When flags is T_MAP_WRITE,
// buffer should be writable (as returned from gst_buffer_is_writable()).
//
// When buffer is writable but the memory isn't, a writable copy will
// automatically be created and returned. The readonly copy of the buffer memory
// will then also be replaced with this writable copy.
//
// The memory in info should be unmapped with gst_buffer_unmap() after usage.
//
// The function takes the following parameters:
//
//   - flags for the mapping.
//
// The function returns the following values:
//
//   - info about the mapping.
//   - ok: TRUE if the map succeeded and info contains valid data.
func (buffer *Buffer) Map(flags MapFlags) (*MapInfo, bool) {
	var _arg0 *C.GstBuffer  // out
	var _arg1 C.GstMapInfo  // in
	var _arg2 C.GstMapFlags // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = C.GstMapFlags(flags)

	_cret = C.gst_buffer_map(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(flags)

	var _info *MapInfo // out
	var _ok bool       // out

	_info = (*MapInfo)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _info, _ok
}

// MapRange fills info with the MapInfo of length merged memory blocks starting
// at idx in buffer. When length is -1, all memory blocks starting from idx are
// merged and mapped.
//
// flags describe the desired access of the memory. When flags is T_MAP_WRITE,
// buffer should be writable (as returned from gst_buffer_is_writable()).
//
// When buffer is writable but the memory isn't, a writable copy will
// automatically be created and returned. The readonly copy of the buffer memory
// will then also be replaced with this writable copy.
//
// The memory in info should be unmapped with gst_buffer_unmap() after usage.
//
// The function takes the following parameters:
//
//   - idx: index.
//   - length: length.
//   - flags for the mapping.
//
// The function returns the following values:
//
//   - info about the mapping.
//   - ok: TRUE if the map succeeded and info contains valid data.
func (buffer *Buffer) MapRange(idx uint, length int, flags MapFlags) (*MapInfo, bool) {
	var _arg0 *C.GstBuffer  // out
	var _arg1 C.guint       // out
	var _arg2 C.gint        // out
	var _arg3 C.GstMapInfo  // in
	var _arg4 C.GstMapFlags // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.guint(idx)
	_arg2 = C.gint(length)
	_arg4 = C.GstMapFlags(flags)

	_cret = C.gst_buffer_map_range(_arg0, _arg1, _arg2, &_arg3, _arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(length)
	runtime.KeepAlive(flags)

	var _info *MapInfo // out
	var _ok bool       // out

	_info = (*MapInfo)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))
	if _cret != 0 {
		_ok = true
	}

	return _info, _ok
}

// Memcmp compares size bytes starting from offset in buffer with the memory in
// mem.
//
// The function takes the following parameters:
//
//   - offset in buffer.
//   - mem: memory to compare.
//
// The function returns the following values:
//
//   - gint: 0 if the memory is equal.
func (buffer *Buffer) Memcmp(offset uint, mem []byte) int {
	var _arg0 *C.GstBuffer    // out
	var _arg1 C.gsize         // out
	var _arg2 C.gconstpointer // out
	var _arg3 C.gsize
	var _cret C.gint // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.gsize(offset)
	_arg3 = (C.gsize)(len(mem))
	if len(mem) > 0 {
		_arg2 = (C.gconstpointer)(unsafe.Pointer(&mem[0]))
	}

	_cret = C.gst_buffer_memcmp(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(mem)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Memset fills buf with size bytes with val starting from offset.
//
// The function takes the following parameters:
//
//   - offset in buffer.
//   - val: value to set.
//   - size to set.
//
// The function returns the following values:
//
//   - gsize: amount of bytes filled. This value can be lower than size when
//     buffer did not contain enough data.
func (buffer *Buffer) Memset(offset uint, val byte, size uint) uint {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.gsize      // out
	var _arg2 C.guint8     // out
	var _arg3 C.gsize      // out
	var _cret C.gsize      // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.gsize(offset)
	_arg2 = C.guint8(val)
	_arg3 = C.gsize(size)

	_cret = C.gst_buffer_memset(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(val)
	runtime.KeepAlive(size)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// NMemory gets the amount of memory blocks that this buffer has. This amount is
// never larger than what gst_buffer_get_max_memory() returns.
//
// The function returns the following values:
//
//   - guint: number of memory blocks this buffer is made of.
func (buffer *Buffer) NMemory() uint {
	var _arg0 *C.GstBuffer // out
	var _cret C.guint      // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_buffer_n_memory(_arg0)
	runtime.KeepAlive(buffer)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// PeekMemory gets the memory block at idx in buffer. The memory block stays
// valid until the memory block in buffer is removed, replaced or merged,
// typically with any call that modifies the memory in buffer.
//
// The function takes the following parameters:
//
//   - idx: index.
//
// The function returns the following values:
//
//   - memory (optional) at idx.
func (buffer *Buffer) PeekMemory(idx uint) *Memory {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.guint      // out
	var _cret *C.GstMemory // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.guint(idx)

	_cret = C.gst_buffer_peek_memory(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)

	var _memory *Memory // out

	if _cret != nil {
		_memory = (*Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _memory
}

// PrependMemory prepends the memory block mem to buffer. This function takes
// ownership of mem and thus doesn't increase its refcount.
//
// This function is identical to gst_buffer_insert_memory() with an index of 0.
// See gst_buffer_insert_memory() for more details.
//
// The function takes the following parameters:
//
//   - mem: Memory.
func (buffer *Buffer) PrependMemory(mem *Memory) {
	var _arg0 *C.GstBuffer // out
	var _arg1 *C.GstMemory // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(mem)), nil)

	C.gst_buffer_prepend_memory(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mem)
}

// RemoveAllMemory removes all the memory blocks in buffer.
func (buffer *Buffer) RemoveAllMemory() {
	var _arg0 *C.GstBuffer // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	C.gst_buffer_remove_all_memory(_arg0)
	runtime.KeepAlive(buffer)
}

// RemoveMemory removes the memory block in b at index i.
//
// The function takes the following parameters:
//
//   - idx: index.
func (buffer *Buffer) RemoveMemory(idx uint) {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.guint      // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.guint(idx)

	C.gst_buffer_remove_memory(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)
}

// RemoveMemoryRange removes length memory blocks in buffer starting from idx.
//
// length can be -1, in which case all memory starting from idx is removed.
//
// The function takes the following parameters:
//
//   - idx: index.
//   - length: length.
func (buffer *Buffer) RemoveMemoryRange(idx uint, length int) {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.guint      // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.guint(idx)
	_arg2 = C.gint(length)

	C.gst_buffer_remove_memory_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(length)
}

// RemoveMeta removes the metadata for meta on buffer.
//
// The function takes the following parameters:
//
//   - meta: Meta.
//
// The function returns the following values:
//
//   - ok: TRUE if the metadata existed and was removed, FALSE if no such
//     metadata was on buffer.
func (buffer *Buffer) RemoveMeta(meta *Meta) bool {
	var _arg0 *C.GstBuffer // out
	var _arg1 *C.GstMeta   // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*C.GstMeta)(gextras.StructNative(unsafe.Pointer(meta)))

	_cret = C.gst_buffer_remove_meta(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(meta)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReplaceAllMemory replaces all memory in buffer with mem.
//
// The function takes the following parameters:
//
//   - mem: Memory.
func (buffer *Buffer) ReplaceAllMemory(mem *Memory) {
	var _arg0 *C.GstBuffer // out
	var _arg1 *C.GstMemory // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(mem)), nil)

	C.gst_buffer_replace_all_memory(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mem)
}

// ReplaceMemory replaces the memory block at index idx in buffer with mem.
//
// The function takes the following parameters:
//
//   - idx: index.
//   - mem: Memory.
func (buffer *Buffer) ReplaceMemory(idx uint, mem *Memory) {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.guint      // out
	var _arg2 *C.GstMemory // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.guint(idx)
	_arg2 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(mem)), nil)

	C.gst_buffer_replace_memory(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(mem)
}

// ReplaceMemoryRange replaces length memory blocks in buffer starting at idx
// with mem.
//
// If length is -1, all memory starting from idx will be removed and replaced
// with mem.
//
// buffer should be writable.
//
// The function takes the following parameters:
//
//   - idx: index.
//   - length: length, should not be 0.
//   - mem: Memory.
func (buffer *Buffer) ReplaceMemoryRange(idx uint, length int, mem *Memory) {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.guint      // out
	var _arg2 C.gint       // out
	var _arg3 *C.GstMemory // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.guint(idx)
	_arg2 = C.gint(length)
	_arg3 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(mem)), nil)

	C.gst_buffer_replace_memory_range(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(length)
	runtime.KeepAlive(mem)
}

// Resize sets the offset and total size of the memory blocks in buffer.
//
// The function takes the following parameters:
//
//   - offset adjustment.
//   - size: new size or -1 to just adjust the offset.
func (buffer *Buffer) Resize(offset int, size int) {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.gssize     // out
	var _arg2 C.gssize     // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.gssize(offset)
	_arg2 = C.gssize(size)

	C.gst_buffer_resize(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)
}

// ResizeRange sets the total size of the length memory blocks starting at idx
// in buffer.
//
// The function takes the following parameters:
//
//   - idx: index.
//   - length: length.
//   - offset adjustment.
//   - size: new size or -1 to just adjust the offset.
//
// The function returns the following values:
//
//   - ok: TRUE if resizing succeeded, FALSE otherwise.
func (buffer *Buffer) ResizeRange(idx uint, length int, offset int, size int) bool {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.guint      // out
	var _arg2 C.gint       // out
	var _arg3 C.gssize     // out
	var _arg4 C.gssize     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.guint(idx)
	_arg2 = C.gint(length)
	_arg3 = C.gssize(offset)
	_arg4 = C.gssize(size)

	_cret = C.gst_buffer_resize_range(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(length)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetFlags sets one or more buffer flags on a buffer.
//
// The function takes the following parameters:
//
//   - flags to set.
//
// The function returns the following values:
//
//   - ok: TRUE if flags were successfully set on buffer.
func (buffer *Buffer) SetFlags(flags BufferFlags) bool {
	var _arg0 *C.GstBuffer     // out
	var _arg1 C.GstBufferFlags // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.GstBufferFlags(flags)

	_cret = C.gst_buffer_set_flags(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(flags)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSize sets the total size of the memory blocks in buffer.
//
// The function takes the following parameters:
//
//   - size: new size.
func (buffer *Buffer) SetSize(size int) {
	var _arg0 *C.GstBuffer // out
	var _arg1 C.gssize     // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.gssize(size)

	C.gst_buffer_set_size(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(size)
}

// Unmap releases the memory previously mapped with gst_buffer_map().
//
// The function takes the following parameters:
//
//   - info: MapInfo.
func (buffer *Buffer) Unmap(info *MapInfo) {
	var _arg0 *C.GstBuffer  // out
	var _arg1 *C.GstMapInfo // out

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = (*C.GstMapInfo)(gextras.StructNative(unsafe.Pointer(info)))

	C.gst_buffer_unmap(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(info)
}

// UnsetFlags clears one or more buffer flags.
//
// The function takes the following parameters:
//
//   - flags to clear.
//
// The function returns the following values:
//
//   - ok: true if flags is successfully cleared from buffer.
func (buffer *Buffer) UnsetFlags(flags BufferFlags) bool {
	var _arg0 *C.GstBuffer     // out
	var _arg1 C.GstBufferFlags // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg1 = C.GstBufferFlags(flags)

	_cret = C.gst_buffer_unset_flags(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(flags)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BufferGetMaxMemory gets the maximum amount of memory blocks that a buffer can
// hold. This is a compile time constant that can be queried with the function.
//
// When more memory blocks are added, existing memory blocks will be merged
// together to make room for the new block.
//
// The function returns the following values:
//
//   - guint: maximum amount of memory blocks that a buffer can hold.
func BufferGetMaxMemory() uint {
	var _cret C.guint // in

	_cret = C.gst_buffer_get_max_memory()

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// BufferList: buffer lists are an object containing a list of buffers.
//
// Buffer lists are created with gst_buffer_list_new() and filled with data
// using gst_buffer_list_insert().
//
// Buffer lists can be pushed on a srcpad with gst_pad_push_list(). This is
// interesting when multiple buffers need to be pushed in one go because it can
// reduce the amount of overhead for pushing each buffer individually.
//
// An instance of this type is always passed by reference.
type BufferList struct {
	*bufferList
}

// bufferList is the struct that's finalized.
type bufferList struct {
	native *C.GstBufferList
}

func marshalBufferList(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &BufferList{&bufferList{(*C.GstBufferList)(b)}}, nil
}

// NewBufferList constructs a struct BufferList.
func NewBufferList() *BufferList {
	var _cret *C.GstBufferList // in

	_cret = C.gst_buffer_list_new()

	var _bufferList *BufferList // out

	_bufferList = (*BufferList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bufferList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _bufferList
}

// NewBufferListSized constructs a struct BufferList.
func NewBufferListSized(size uint) *BufferList {
	var _arg1 C.guint          // out
	var _cret *C.GstBufferList // in

	_arg1 = C.guint(size)

	_cret = C.gst_buffer_list_new_sized(_arg1)
	runtime.KeepAlive(size)

	var _bufferList *BufferList // out

	_bufferList = (*BufferList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bufferList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _bufferList
}

// CalculateSize calculates the size of the data contained in list by adding the
// size of all buffers.
//
// The function returns the following values:
//
//   - gsize: size of the data contained in list in bytes.
func (list *BufferList) CalculateSize() uint {
	var _arg0 *C.GstBufferList // out
	var _cret C.gsize          // in

	_arg0 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))

	_cret = C.gst_buffer_list_calculate_size(_arg0)
	runtime.KeepAlive(list)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// CopyDeep creates a copy of the given buffer list. This will make a newly
// allocated copy of the buffers that the source buffer list contains.
//
// The function returns the following values:
//
//   - bufferList: new copy of list.
func (list *BufferList) CopyDeep() *BufferList {
	var _arg0 *C.GstBufferList // out
	var _cret *C.GstBufferList // in

	_arg0 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))

	_cret = C.gst_buffer_list_copy_deep(_arg0)
	runtime.KeepAlive(list)

	var _bufferList *BufferList // out

	_bufferList = (*BufferList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bufferList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _bufferList
}

// ForEach calls func with data for each buffer in list.
//
// func can modify the passed buffer pointer or its contents. The return value
// of func defines if this function returns or if the remaining buffers in the
// list should be skipped.
//
// The function takes the following parameters:
//
//   - fn to call.
//
// The function returns the following values:
//
//   - ok: TRUE when func returned TRUE for each buffer in list or when list is
//     empty.
func (list *BufferList) ForEach(fn BufferListFunc) bool {
	var _arg0 *C.GstBufferList    // out
	var _arg1 C.GstBufferListFunc // out
	var _arg2 C.gpointer
	var _cret C.gboolean // in

	_arg0 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*[0]byte)(C._gotk4_gst1_BufferListFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.gst_buffer_list_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(fn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Get gets the buffer at idx.
//
// You must make sure that idx does not exceed the number of buffers available.
//
// The function takes the following parameters:
//
//   - idx: index.
//
// The function returns the following values:
//
//   - buffer (optional) at idx in group or NULL when there is no buffer. The
//     buffer remains valid as long as list is valid and buffer is not removed
//     from the list.
func (list *BufferList) Get(idx uint) *Buffer {
	var _arg0 *C.GstBufferList // out
	var _arg1 C.guint          // out
	var _cret *C.GstBuffer     // in

	_arg0 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = C.guint(idx)

	_cret = C.gst_buffer_list_get(_arg0, _arg1)
	runtime.KeepAlive(list)
	runtime.KeepAlive(idx)

	var _buffer *Buffer // out

	if _cret != nil {
		_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _buffer
}

// Writable gets the buffer at idx, ensuring it is a writable buffer.
//
// You must make sure that idx does not exceed the number of buffers available.
//
// The function takes the following parameters:
//
//   - idx: index.
//
// The function returns the following values:
//
//   - buffer (optional) at idx in group. The returned buffer remains valid as
//     long as list is valid and the buffer is not removed from the list.
func (list *BufferList) Writable(idx uint) *Buffer {
	var _arg0 *C.GstBufferList // out
	var _arg1 C.guint          // out
	var _cret *C.GstBuffer     // in

	_arg0 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = C.guint(idx)

	_cret = C.gst_buffer_list_get_writable(_arg0, _arg1)
	runtime.KeepAlive(list)
	runtime.KeepAlive(idx)

	var _buffer *Buffer // out

	if _cret != nil {
		_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _buffer
}

// Insert inserts buffer at idx in list. Other buffers are moved to make room
// for this new buffer.
//
// A -1 value for idx will append the buffer at the end.
//
// The function takes the following parameters:
//
//   - idx: index.
//   - buffer: Buffer.
func (list *BufferList) Insert(idx int, buffer *Buffer) {
	var _arg0 *C.GstBufferList // out
	var _arg1 C.gint           // out
	var _arg2 *C.GstBuffer     // out

	_arg0 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = C.gint(idx)
	_arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	C.gst_buffer_list_insert(_arg0, _arg1, _arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(buffer)
}

// Length returns the number of buffers in list.
//
// The function returns the following values:
//
//   - guint: number of buffers in the buffer list.
func (list *BufferList) Length() uint {
	var _arg0 *C.GstBufferList // out
	var _cret C.guint          // in

	_arg0 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))

	_cret = C.gst_buffer_list_length(_arg0)
	runtime.KeepAlive(list)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Remove removes length buffers starting from idx in list. The following
// buffers are moved to close the gap.
//
// The function takes the following parameters:
//
//   - idx: index.
//   - length: amount to remove.
func (list *BufferList) Remove(idx uint, length uint) {
	var _arg0 *C.GstBufferList // out
	var _arg1 C.guint          // out
	var _arg2 C.guint          // out

	_arg0 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = C.guint(idx)
	_arg2 = C.guint(length)

	C.gst_buffer_list_remove(_arg0, _arg1, _arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(length)
}

// BufferPoolAcquireParams parameters passed to the
// gst_buffer_pool_acquire_buffer() function to control the allocation of the
// buffer.
//
// The default implementation ignores the start and stop members but other
// implementations can use this extra information to decide what buffer to
// return.
//
// An instance of this type is always passed by reference.
type BufferPoolAcquireParams struct {
	*bufferPoolAcquireParams
}

// bufferPoolAcquireParams is the struct that's finalized.
type bufferPoolAcquireParams struct {
	native *C.GstBufferPoolAcquireParams
}

// Format: format of start and stop.
func (b *BufferPoolAcquireParams) Format() Format {
	valptr := &b.native.format
	var _v Format // out
	_v = Format(*valptr)
	return _v
}

// Start: start position.
func (b *BufferPoolAcquireParams) Start() int64 {
	valptr := &b.native.start
	var _v int64 // out
	_v = int64(*valptr)
	return _v
}

// Stop: stop position.
func (b *BufferPoolAcquireParams) Stop() int64 {
	valptr := &b.native.stop
	var _v int64 // out
	_v = int64(*valptr)
	return _v
}

// Flags: additional flags.
func (b *BufferPoolAcquireParams) Flags() BufferPoolAcquireFlags {
	valptr := &b.native.flags
	var _v BufferPoolAcquireFlags // out
	_v = BufferPoolAcquireFlags(*valptr)
	return _v
}

// Start: start position.
func (b *BufferPoolAcquireParams) SetStart(start int64) {
	valptr := &b.native.start
	*valptr = C.gint64(start)
}

// Stop: stop position.
func (b *BufferPoolAcquireParams) SetStop(stop int64) {
	valptr := &b.native.stop
	*valptr = C.gint64(stop)
}

// BufferPoolClass class.
//
// An instance of this type is always passed by reference.
type BufferPoolClass struct {
	*bufferPoolClass
}

// bufferPoolClass is the struct that's finalized.
type bufferPoolClass struct {
	native *C.GstBufferPoolClass
}

// ObjectClass: object parent class.
func (b *BufferPoolClass) ObjectClass() *ObjectClass {
	valptr := &b.native.object_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// BusClass: GStreamer bus class.
//
// An instance of this type is always passed by reference.
type BusClass struct {
	*busClass
}

// busClass is the struct that's finalized.
type busClass struct {
	native *C.GstBusClass
}

// ParentClass: parent class structure.
func (b *BusClass) ParentClass() *ObjectClass {
	valptr := &b.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ByteArrayInterface: interface for an array of bytes. It is expected to be
// subclassed to implement resize virtual method using language native array
// implementation, such as GLib's Array, C++'s std::vector<uint8_t> or Rust's
// Vec<u8>.
//
// resize implementation could allocate more than requested to avoid repeated
// reallocations. It can return FALSE, or be set to NULL, in the case the array
// cannot grow.
//
// An instance of this type is always passed by reference.
type ByteArrayInterface struct {
	*byteArrayInterface
}

// byteArrayInterface is the struct that's finalized.
type byteArrayInterface struct {
	native *C.GstByteArrayInterface
}

// Data: pointer to an array of bytes.
func (b *ByteArrayInterface) Data() *byte {
	valptr := &b.native.data
	var _v *byte // out
	_v = (*byte)(unsafe.Pointer(*valptr))
	return _v
}

// Len: number of bytes in data.
func (b *ByteArrayInterface) Len() uint {
	valptr := &b.native.len
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Len: number of bytes in data.
func (b *ByteArrayInterface) SetLen(len uint) {
	valptr := &b.native.len
	*valptr = C.gsize(len)
}

// Caps (capabilities) are lightweight refcounted objects describing media
// types. They are composed of an array of Structure.
//
// Caps are exposed on PadTemplate to describe all possible types a given pad
// can handle. They are also stored in the Registry along with a description of
// the Element.
//
// Caps are exposed on the element pads using the gst_pad_query_caps() pad
// function. This function describes the possible types that the pad can handle
// or produce at runtime.
//
// A Caps can be constructed with the following code fragment:
//
//	C   GstCaps *caps = gst_caps_new_simple ("video/x-raw",      "format", G_TYPE_STRING, "I420",      "framerate", GST_TYPE_FRACTION, 25, 1,      "pixel-aspect-ratio", GST_TYPE_FRACTION, 1, 1,      "width", G_TYPE_INT, 320,      "height", G_TYPE_INT, 240,      NULL);
//
// A Caps is fixed when it has no fields with ranges or lists. Use
// gst_caps_is_fixed() to test for fixed caps. Fixed caps can be used in a caps
// event to notify downstream elements of the current media type.
//
// Various methods exist to work with the media types such as subtracting or
// intersecting.
//
// Be aware that until 1.20 the Caps / Structure serialization into string
// had limited support for nested Caps / Structure fields. It could only
// support one level of nesting. Using more levels would lead to unexpected
// behavior when using serialization features, such as gst_caps_to_string() or
// gst_value_serialize() and their counterparts.
//
// An instance of this type is always passed by reference.
type Caps struct {
	*caps
}

// caps is the struct that's finalized.
type caps struct {
	native *C.GstCaps
}

func marshalCaps(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Caps{&caps{(*C.GstCaps)(b)}}, nil
}

// NewCapsAny constructs a struct Caps.
func NewCapsAny() *Caps {
	var _cret *C.GstCaps // in

	_cret = C.gst_caps_new_any()

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// NewCapsEmpty constructs a struct Caps.
func NewCapsEmpty() *Caps {
	var _cret *C.GstCaps // in

	_cret = C.gst_caps_new_empty()

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// NewCapsEmptySimple constructs a struct Caps.
func NewCapsEmptySimple(mediaType string) *Caps {
	var _arg1 *C.char    // out
	var _cret *C.GstCaps // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(mediaType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_caps_new_empty_simple(_arg1)
	runtime.KeepAlive(mediaType)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// MiniObject: parent type.
func (c *Caps) MiniObject() *MiniObject {
	valptr := &c.native.mini_object
	var _v *MiniObject // out
	_v = (*MiniObject)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Append appends the structures contained in caps2 to caps1. The structures
// in caps2 are not copied -- they are transferred to caps1, and then caps2 is
// freed. If either caps is ANY, the resulting caps will be ANY.
//
// The function takes the following parameters:
//
//   - caps2 to append.
func (caps1 *Caps) Append(caps2 *Caps) {
	var _arg0 *C.GstCaps // out
	var _arg1 *C.GstCaps // out

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps1)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps2)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps2)), nil)

	C.gst_caps_append(_arg0, _arg1)
	runtime.KeepAlive(caps1)
	runtime.KeepAlive(caps2)
}

// AppendStructure appends structure to caps. The structure is not copied;
// caps becomes the owner of structure.
//
// The function takes the following parameters:
//
//   - structure to append.
func (caps *Caps) AppendStructure(structure *Structure) {
	var _arg0 *C.GstCaps      // out
	var _arg1 *C.GstStructure // out

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(structure)), nil)

	C.gst_caps_append_structure(_arg0, _arg1)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(structure)
}

// AppendStructureFull appends structure with features to caps. The structure is
// not copied; caps becomes the owner of structure.
//
// The function takes the following parameters:
//
//   - structure to append.
//   - features (optional) to append.
func (caps *Caps) AppendStructureFull(structure *Structure, features *CapsFeatures) {
	var _arg0 *C.GstCaps         // out
	var _arg1 *C.GstStructure    // out
	var _arg2 *C.GstCapsFeatures // out

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(structure)), nil)
	if features != nil {
		_arg2 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(features)), nil)
	}

	C.gst_caps_append_structure_full(_arg0, _arg1, _arg2)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(features)
}

// CanIntersect tries intersecting caps1 and caps2 and reports whether the
// result would not be empty.
//
// The function takes the following parameters:
//
//   - caps2 to intersect.
//
// The function returns the following values:
//
//   - ok: TRUE if intersection would be not empty.
func (caps1 *Caps) CanIntersect(caps2 *Caps) bool {
	var _arg0 *C.GstCaps // out
	var _arg1 *C.GstCaps // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps1)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps2)))

	_cret = C.gst_caps_can_intersect(_arg0, _arg1)
	runtime.KeepAlive(caps1)
	runtime.KeepAlive(caps2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Copy creates a new Caps as a copy of the old caps. The new caps will have a
// refcount of 1, owned by the caller. The structures are copied as well.
//
// Note that this function is the semantic equivalent of a gst_caps_ref()
// followed by a gst_caps_make_writable(). If you only want to hold on to a
// reference to the data, you should use gst_caps_ref().
//
// The function returns the following values:
//
//   - ret: new Caps.
func (caps *Caps) Copy() *Caps {
	var _arg0 *C.GstCaps // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_caps_copy(_arg0)
	runtime.KeepAlive(caps)

	var _ret *Caps // out

	_ret = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// CopyNth creates a new Caps and appends a copy of the nth structure contained
// in caps.
//
// The function takes the following parameters:
//
//   - nth structure to copy.
//
// The function returns the following values:
//
//   - ret: new Caps.
func (caps *Caps) CopyNth(nth uint) *Caps {
	var _arg0 *C.GstCaps // out
	var _arg1 C.guint    // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = C.guint(nth)

	_cret = C.gst_caps_copy_nth(_arg0, _arg1)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(nth)

	var _ret *Caps // out

	_ret = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// FilterAndMapInPlace calls the provided function once for each structure and
// caps feature in the Caps. In contrast to gst_caps_foreach(), the function may
// modify the structure and features. In contrast to gst_caps_map_in_place(),
// the structure and features are removed from the caps if FALSE is returned
// from the function. The caps must be mutable.
//
// The function takes the following parameters:
//
//   - fn: function to call for each field.
func (caps *Caps) FilterAndMapInPlace(fn CapsFilterMapFunc) {
	var _arg0 *C.GstCaps             // out
	var _arg1 C.GstCapsFilterMapFunc // out
	var _arg2 C.gpointer

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = (*[0]byte)(C._gotk4_gst1_CapsFilterMapFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.gst_caps_filter_and_map_in_place(_arg0, _arg1, _arg2)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(fn)
}

// Fixate modifies the given caps into a representation with only fixed values.
// First the caps will be truncated and then the first structure will be fixated
// with gst_structure_fixate().
//
// This function takes ownership of caps and will call gst_caps_make_writable()
// on it so you must not use caps afterwards unless you keep an additional
// reference to it with gst_caps_ref().
//
// Note that it is not guaranteed that the returned caps have exactly one
// structure. If caps are empty caps then the returned caps will be the empty
// too and contain no structure at all.
//
// Calling this function with ANY caps is not allowed.
//
// The function returns the following values:
//
//   - ret: fixated caps.
func (caps *Caps) Fixate() *Caps {
	var _arg0 *C.GstCaps // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)

	_cret = C.gst_caps_fixate(_arg0)
	runtime.KeepAlive(caps)

	var _ret *Caps // out

	_ret = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// ForEach calls the provided function once for each structure and caps
// feature in the Caps. The function must not modify the fields. Also see
// gst_caps_map_in_place() and gst_caps_filter_and_map_in_place().
//
// The function takes the following parameters:
//
//   - fn: function to call for each field.
//
// The function returns the following values:
//
//   - ok: TRUE if the supplied function returns TRUE for each call, FALSE
//     otherwise.
func (caps *Caps) ForEach(fn CapsForEachFunc) bool {
	var _arg0 *C.GstCaps           // out
	var _arg1 C.GstCapsForeachFunc // out
	var _arg2 C.gpointer
	var _cret C.gboolean // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = (*[0]byte)(C._gotk4_gst1_CapsForEachFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.gst_caps_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(fn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Features finds the features in caps at index, and returns it.
//
// WARNING: This function takes a const GstCaps *, but returns a non-const
// GstCapsFeatures *. This is for programming convenience -- the caller should
// be aware that features inside a constant Caps should not be modified.
// However, if you know the caps are writable, either because you have just
// copied them or made them writable with gst_caps_make_writable(), you may
// modify the features returned in the usual way, e.g. with functions like
// gst_caps_features_add().
//
// The function takes the following parameters:
//
//   - index of the structure.
//
// The function returns the following values:
//
//   - capsFeatures (optional): pointer to the CapsFeatures corresponding to
//     index.
func (caps *Caps) Features(index uint) *CapsFeatures {
	var _arg0 *C.GstCaps         // out
	var _arg1 C.guint            // out
	var _cret *C.GstCapsFeatures // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = C.guint(index)

	_cret = C.gst_caps_get_features(_arg0, _arg1)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(index)

	var _capsFeatures *CapsFeatures // out

	if _cret != nil {
		_capsFeatures = (*CapsFeatures)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _capsFeatures
}

// Size gets the number of structures contained in caps.
//
// The function returns the following values:
//
//   - guint: number of structures that caps contains.
func (caps *Caps) Size() uint {
	var _arg0 *C.GstCaps // out
	var _cret C.guint    // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_caps_get_size(_arg0)
	runtime.KeepAlive(caps)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Structure finds the structure in caps at index, and returns it.
//
// WARNING: This function takes a const GstCaps *, but returns a non-const
// GstStructure *. This is for programming convenience -- the caller should
// be aware that structures inside a constant Caps should not be modified.
// However, if you know the caps are writable, either because you have just
// copied them or made them writable with gst_caps_make_writable(), you may
// modify the structure returned in the usual way, e.g. with functions like
// gst_structure_set().
//
// The function takes the following parameters:
//
//   - index of the structure.
//
// The function returns the following values:
//
//   - structure: pointer to the Structure corresponding to index.
func (caps *Caps) Structure(index uint) *Structure {
	var _arg0 *C.GstCaps      // out
	var _arg1 C.guint         // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = C.guint(index)

	_cret = C.gst_caps_get_structure(_arg0, _arg1)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(index)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _structure
}

// Intersect creates a new Caps that contains all the formats that are common to
// both caps1 and caps2. Defaults to GST_CAPS_INTERSECT_ZIG_ZAG mode.
//
// The function takes the following parameters:
//
//   - caps2 to intersect.
//
// The function returns the following values:
//
//   - caps: new Caps.
func (caps1 *Caps) Intersect(caps2 *Caps) *Caps {
	var _arg0 *C.GstCaps // out
	var _arg1 *C.GstCaps // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps1)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps2)))

	_cret = C.gst_caps_intersect(_arg0, _arg1)
	runtime.KeepAlive(caps1)
	runtime.KeepAlive(caps2)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// IntersectFull creates a new Caps that contains all the formats that are
// common to both caps1 and caps2, the order is defined by the CapsIntersectMode
// used.
//
// The function takes the following parameters:
//
//   - caps2 to intersect.
//   - mode: intersection algorithm/mode to use.
//
// The function returns the following values:
//
//   - caps: new Caps.
func (caps1 *Caps) IntersectFull(caps2 *Caps, mode CapsIntersectMode) *Caps {
	var _arg0 *C.GstCaps             // out
	var _arg1 *C.GstCaps             // out
	var _arg2 C.GstCapsIntersectMode // out
	var _cret *C.GstCaps             // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps1)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps2)))
	_arg2 = C.GstCapsIntersectMode(mode)

	_cret = C.gst_caps_intersect_full(_arg0, _arg1, _arg2)
	runtime.KeepAlive(caps1)
	runtime.KeepAlive(caps2)
	runtime.KeepAlive(mode)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// IsAlwaysCompatible: given Caps structure is always compatible with another
// if every media format that is in the first is also contained in the second.
// That is, caps1 is a subset of caps2.
//
// The function takes the following parameters:
//
//   - caps2 to test.
//
// The function returns the following values:
//
//   - ok: TRUE if caps1 is a subset of caps2.
func (caps1 *Caps) IsAlwaysCompatible(caps2 *Caps) bool {
	var _arg0 *C.GstCaps // out
	var _arg1 *C.GstCaps // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps1)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps2)))

	_cret = C.gst_caps_is_always_compatible(_arg0, _arg1)
	runtime.KeepAlive(caps1)
	runtime.KeepAlive(caps2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsAny determines if caps represents any media format.
//
// The function returns the following values:
//
//   - ok: TRUE if caps represents any format.
func (caps *Caps) IsAny() bool {
	var _arg0 *C.GstCaps // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_caps_is_any(_arg0)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEmpty determines if caps represents no media formats.
//
// The function returns the following values:
//
//   - ok: TRUE if caps represents no formats.
func (caps *Caps) IsEmpty() bool {
	var _arg0 *C.GstCaps // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_caps_is_empty(_arg0)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEqual checks if the given caps represent the same set of caps.
//
// The function takes the following parameters:
//
//   - caps2: another Caps.
//
// The function returns the following values:
//
//   - ok: TRUE if both caps are equal.
func (caps1 *Caps) IsEqual(caps2 *Caps) bool {
	var _arg0 *C.GstCaps // out
	var _arg1 *C.GstCaps // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps1)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps2)))

	_cret = C.gst_caps_is_equal(_arg0, _arg1)
	runtime.KeepAlive(caps1)
	runtime.KeepAlive(caps2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEqualFixed tests if two Caps are equal. This function only works on fixed
// Caps.
//
// The function takes the following parameters:
//
//   - caps2 to test.
//
// The function returns the following values:
//
//   - ok: TRUE if the arguments represent the same format.
func (caps1 *Caps) IsEqualFixed(caps2 *Caps) bool {
	var _arg0 *C.GstCaps // out
	var _arg1 *C.GstCaps // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps1)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps2)))

	_cret = C.gst_caps_is_equal_fixed(_arg0, _arg1)
	runtime.KeepAlive(caps1)
	runtime.KeepAlive(caps2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFixed: fixed Caps describe exactly one format, that is, they have exactly
// one structure, and each field in the structure describes a fixed type.
// Examples of non-fixed types are GST_TYPE_INT_RANGE and GST_TYPE_LIST.
//
// The function returns the following values:
//
//   - ok: TRUE if caps is fixed.
func (caps *Caps) IsFixed() bool {
	var _arg0 *C.GstCaps // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_caps_is_fixed(_arg0)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsStrictlyEqual checks if the given caps are exactly the same set of caps.
//
// The function takes the following parameters:
//
//   - caps2: another Caps.
//
// The function returns the following values:
//
//   - ok: TRUE if both caps are strictly equal.
func (caps1 *Caps) IsStrictlyEqual(caps2 *Caps) bool {
	var _arg0 *C.GstCaps // out
	var _arg1 *C.GstCaps // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps1)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps2)))

	_cret = C.gst_caps_is_strictly_equal(_arg0, _arg1)
	runtime.KeepAlive(caps1)
	runtime.KeepAlive(caps2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSubset checks if all caps represented by subset are also represented by
// superset.
//
// The function takes the following parameters:
//
//   - superset: potentially greater Caps.
//
// The function returns the following values:
//
//   - ok: TRUE if subset is a subset of superset.
func (subset *Caps) IsSubset(superset *Caps) bool {
	var _arg0 *C.GstCaps // out
	var _arg1 *C.GstCaps // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(subset)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(superset)))

	_cret = C.gst_caps_is_subset(_arg0, _arg1)
	runtime.KeepAlive(subset)
	runtime.KeepAlive(superset)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSubsetStructure checks if structure is a subset of caps. See
// gst_caps_is_subset() for more information.
//
// The function takes the following parameters:
//
//   - structure: potential Structure subset of caps.
//
// The function returns the following values:
//
//   - ok: TRUE if structure is a subset of caps.
func (caps *Caps) IsSubsetStructure(structure *Structure) bool {
	var _arg0 *C.GstCaps      // out
	var _arg1 *C.GstStructure // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))

	_cret = C.gst_caps_is_subset_structure(_arg0, _arg1)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(structure)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSubsetStructureFull checks if structure is a subset of caps. See
// gst_caps_is_subset() for more information.
//
// The function takes the following parameters:
//
//   - structure: potential Structure subset of caps.
//   - features (optional) for structure.
//
// The function returns the following values:
//
//   - ok: TRUE if structure is a subset of caps.
func (caps *Caps) IsSubsetStructureFull(structure *Structure, features *CapsFeatures) bool {
	var _arg0 *C.GstCaps         // out
	var _arg1 *C.GstStructure    // out
	var _arg2 *C.GstCapsFeatures // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	if features != nil {
		_arg2 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
	}

	_cret = C.gst_caps_is_subset_structure_full(_arg0, _arg1, _arg2)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(features)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MapInPlace calls the provided function once for each structure and caps
// feature in the Caps. In contrast to gst_caps_foreach(), the function may
// modify but not delete the structures and features. The caps must be mutable.
//
// The function takes the following parameters:
//
//   - fn: function to call for each field.
//
// The function returns the following values:
//
//   - ok: TRUE if the supplied function returns TRUE for each call, FALSE
//     otherwise.
func (caps *Caps) MapInPlace(fn CapsMapFunc) bool {
	var _arg0 *C.GstCaps       // out
	var _arg1 C.GstCapsMapFunc // out
	var _arg2 C.gpointer
	var _cret C.gboolean // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = (*[0]byte)(C._gotk4_gst1_CapsMapFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.gst_caps_map_in_place(_arg0, _arg1, _arg2)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(fn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Merge appends the structures contained in caps2 to caps1 if they are not
// yet expressed by caps1. The structures in caps2 are not copied -- they are
// transferred to a writable copy of caps1, and then caps2 is freed. If either
// caps is ANY, the resulting caps will be ANY.
//
// The function takes the following parameters:
//
//   - caps2 to merge in.
//
// The function returns the following values:
//
//   - caps: merged caps.
func (caps1 *Caps) Merge(caps2 *Caps) *Caps {
	var _arg0 *C.GstCaps // out
	var _arg1 *C.GstCaps // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps1)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps1)), nil)
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps2)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps2)), nil)

	_cret = C.gst_caps_merge(_arg0, _arg1)
	runtime.KeepAlive(caps1)
	runtime.KeepAlive(caps2)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// MergeStructure appends structure to caps if it is not already expressed by
// caps.
//
// The function takes the following parameters:
//
//   - structure to merge.
//
// The function returns the following values:
//
//   - ret: merged caps.
func (caps *Caps) MergeStructure(structure *Structure) *Caps {
	var _arg0 *C.GstCaps      // out
	var _arg1 *C.GstStructure // out
	var _cret *C.GstCaps      // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(structure)), nil)

	_cret = C.gst_caps_merge_structure(_arg0, _arg1)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(structure)

	var _ret *Caps // out

	_ret = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// MergeStructureFull appends structure with features to caps if its not already
// expressed by caps.
//
// The function takes the following parameters:
//
//   - structure to merge.
//   - features (optional) to merge.
//
// The function returns the following values:
//
//   - ret: merged caps.
func (caps *Caps) MergeStructureFull(structure *Structure, features *CapsFeatures) *Caps {
	var _arg0 *C.GstCaps         // out
	var _arg1 *C.GstStructure    // out
	var _arg2 *C.GstCapsFeatures // out
	var _cret *C.GstCaps         // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(structure)), nil)
	if features != nil {
		_arg2 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(features)), nil)
	}

	_cret = C.gst_caps_merge_structure_full(_arg0, _arg1, _arg2)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(features)

	var _ret *Caps // out

	_ret = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// Normalize returns a Caps that represents the same set of formats as caps,
// but contains no lists. Each list is expanded into separate Structure.
//
// This function takes ownership of caps and will call gst_caps_make_writable()
// on it so you must not use caps afterwards unless you keep an additional
// reference to it with gst_caps_ref().
//
// The function returns the following values:
//
//   - ret: normalized Caps.
func (caps *Caps) Normalize() *Caps {
	var _arg0 *C.GstCaps // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)

	_cret = C.gst_caps_normalize(_arg0)
	runtime.KeepAlive(caps)

	var _ret *Caps // out

	_ret = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// RemoveStructure removes the structure with the given index from the list of
// structures contained in caps.
//
// The function takes the following parameters:
//
//   - idx: index of the structure to remove.
func (caps *Caps) RemoveStructure(idx uint) {
	var _arg0 *C.GstCaps // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = C.guint(idx)

	C.gst_caps_remove_structure(_arg0, _arg1)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(idx)
}

// Serialize converts caps to a string representation. This string
// representation can be converted back to a Caps by gst_caps_from_string().
//
// This prints the caps in human readable form.
//
// This version of the caps serialization function introduces support for
// nested structures and caps but the resulting strings won't be parsable with
// GStreamer prior to 1.20 unless T_SERIALIZE_FLAG_BACKWARD_COMPAT is passed as
// flag.
//
// The function takes the following parameters:
//
//   - flags: SerializeFlags.
//
// The function returns the following values:
//
//   - utf8: newly allocated string representing caps.
func (caps *Caps) Serialize(flags SerializeFlags) string {
	var _arg0 *C.GstCaps          // out
	var _arg1 C.GstSerializeFlags // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = C.GstSerializeFlags(flags)

	_cret = C.gst_caps_serialize(_arg0, _arg1)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(flags)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// SetFeatures sets the features for the structure at index.
//
// The function takes the following parameters:
//
//   - index of the structure.
//   - features (optional) to set.
func (caps *Caps) SetFeatures(index uint, features *CapsFeatures) {
	var _arg0 *C.GstCaps         // out
	var _arg1 C.guint            // out
	var _arg2 *C.GstCapsFeatures // out

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = C.guint(index)
	if features != nil {
		_arg2 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(features)), nil)
	}

	C.gst_caps_set_features(_arg0, _arg1, _arg2)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(index)
	runtime.KeepAlive(features)
}

// SetFeaturesSimple sets the features for all the structures of caps.
//
// The function takes the following parameters:
//
//   - features (optional) to set.
func (caps *Caps) SetFeaturesSimple(features *CapsFeatures) {
	var _arg0 *C.GstCaps         // out
	var _arg1 *C.GstCapsFeatures // out

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	if features != nil {
		_arg1 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(features)), nil)
	}

	C.gst_caps_set_features_simple(_arg0, _arg1)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(features)
}

// SetValue sets the given field on all structures of caps to the given value.
// This is a convenience function for calling gst_structure_set_value() on all
// structures of caps.
//
// The function takes the following parameters:
//
//   - field: name of the field to set.
//   - value to set the field to.
func (caps *Caps) SetValue(field string, value *coreglib.Value) {
	var _arg0 *C.GstCaps // out
	var _arg1 *C.char    // out
	var _arg2 *C.GValue  // out

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(field)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gst_caps_set_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(field)
	runtime.KeepAlive(value)
}

// Simplify converts the given caps into a representation that represents the
// same set of formats, but in a simpler form. Component structures that are
// identical are merged. Component structures that have values that can be
// merged are also merged.
//
// This function takes ownership of caps and will call gst_caps_make_writable()
// on it if necessary, so you must not use caps afterwards unless you keep an
// additional reference to it with gst_caps_ref().
//
// This method does not preserve the original order of caps.
//
// The function returns the following values:
//
//   - ret: simplified caps.
func (caps *Caps) Simplify() *Caps {
	var _arg0 *C.GstCaps // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)

	_cret = C.gst_caps_simplify(_arg0)
	runtime.KeepAlive(caps)

	var _ret *Caps // out

	_ret = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// StealStructure retrieves the structure with the given index from the list of
// structures contained in caps. The caller becomes the owner of the returned
// structure.
//
// The function takes the following parameters:
//
//   - index: index of the structure to retrieve.
//
// The function returns the following values:
//
//   - structure (optional): pointer to the Structure corresponding to index.
func (caps *Caps) StealStructure(index uint) *Structure {
	var _arg0 *C.GstCaps      // out
	var _arg1 C.guint         // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg1 = C.guint(index)

	_cret = C.gst_caps_steal_structure(_arg0, _arg1)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(index)

	var _structure *Structure // out

	if _cret != nil {
		_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_structure)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_structure_free((*C.GstStructure)(intern.C))
			},
		)
	}

	return _structure
}

// Subtract subtracts the subtrahend from the minuend. > This function does not
// work reliably if optional properties for caps > are included on one caps and
// omitted on the other.
//
// The function takes the following parameters:
//
//   - subtrahend to subtract.
//
// The function returns the following values:
//
//   - caps: resulting caps.
func (minuend *Caps) Subtract(subtrahend *Caps) *Caps {
	var _arg0 *C.GstCaps // out
	var _arg1 *C.GstCaps // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(minuend)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(subtrahend)))

	_cret = C.gst_caps_subtract(_arg0, _arg1)
	runtime.KeepAlive(minuend)
	runtime.KeepAlive(subtrahend)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// String converts caps to a string representation. This string representation
// can be converted back to a Caps by gst_caps_from_string().
//
// For debugging purposes its easier to do something like this:
//
//	C GST_LOG ("caps are %" GST_PTR_FORMAT, caps);
//
// This prints the caps in human readable form.
//
// The implementation of serialization up to 1.20 would lead to unexpected
// results when there were nested Caps / Structure deeper than one level.
//
// The function returns the following values:
//
//   - utf8: newly allocated string representing caps.
func (caps *Caps) String() string {
	var _arg0 *C.GstCaps // out
	var _cret *C.gchar   // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_caps_to_string(_arg0)
	runtime.KeepAlive(caps)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Truncate discards all but the first structure from caps. Useful when
// fixating.
//
// This function takes ownership of caps and will call gst_caps_make_writable()
// on it if necessary, so you must not use caps afterwards unless you keep an
// additional reference to it with gst_caps_ref().
//
// Note that it is not guaranteed that the returned caps have exactly one
// structure. If caps is any or empty caps then the returned caps will be the
// same and contain no structure at all.
//
// The function returns the following values:
//
//   - ret: truncated caps.
func (caps *Caps) Truncate() *Caps {
	var _arg0 *C.GstCaps // out
	var _cret *C.GstCaps // in

	_arg0 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)

	_cret = C.gst_caps_truncate(_arg0)
	runtime.KeepAlive(caps)

	var _ret *Caps // out

	_ret = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// CapsFromString converts caps from a string representation.
//
// The implementation of serialization up to 1.20 would lead to unexpected
// results when there were nested Caps / Structure deeper than one level.
//
// The function takes the following parameters:
//
//   - str: string to convert to Caps.
//
// The function returns the following values:
//
//   - caps (optional): newly allocated Caps.
func CapsFromString(str string) *Caps {
	var _arg1 *C.gchar   // out
	var _cret *C.GstCaps // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_caps_from_string(_arg1)
	runtime.KeepAlive(str)

	var _caps *Caps // out

	if _cret != nil {
		_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_caps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _caps
}

// CapsFeatures can optionally be set on a Caps to add requirements for
// additional features for a specific Structure. Caps structures with the same
// name but with a non-equal set of caps features are not compatible. If a pad
// supports multiple sets of features it has to add multiple equal structures
// with different feature sets to the caps.
//
// Empty CapsFeatures are equivalent with the CapsFeatures that only contain
// T_CAPS_FEATURE_MEMORY_SYSTEM_MEMORY. ANY CapsFeatures as created by
// gst_caps_features_new_any() are equal to any other CapsFeatures and can be
// used to specify that any CapsFeatures would be supported, e.g. for elements
// that don't touch buffer memory. Caps with ANY CapsFeatures are considered
// non-fixed and during negotiation some CapsFeatures have to be selected.
//
// Examples for caps features would be the requirement of a specific Memory
// types or the requirement of having a specific Meta on the buffer.
// Features are given as a string of the format memory:GstMemoryTypeName or
// meta:GstMetaAPIName.
//
// An instance of this type is always passed by reference.
type CapsFeatures struct {
	*capsFeatures
}

// capsFeatures is the struct that's finalized.
type capsFeatures struct {
	native *C.GstCapsFeatures
}

func marshalCapsFeatures(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &CapsFeatures{&capsFeatures{(*C.GstCapsFeatures)(b)}}, nil
}

// NewCapsFeaturesAny constructs a struct CapsFeatures.
func NewCapsFeaturesAny() *CapsFeatures {
	var _cret *C.GstCapsFeatures // in

	_cret = C.gst_caps_features_new_any()

	var _capsFeatures *CapsFeatures // out

	_capsFeatures = (*CapsFeatures)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_capsFeatures)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_caps_features_free((*C.GstCapsFeatures)(intern.C))
		},
	)

	return _capsFeatures
}

// NewCapsFeaturesEmpty constructs a struct CapsFeatures.
func NewCapsFeaturesEmpty() *CapsFeatures {
	var _cret *C.GstCapsFeatures // in

	_cret = C.gst_caps_features_new_empty()

	var _capsFeatures *CapsFeatures // out

	_capsFeatures = (*CapsFeatures)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_capsFeatures)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_caps_features_free((*C.GstCapsFeatures)(intern.C))
		},
	)

	return _capsFeatures
}

// NewCapsFeaturesSingle constructs a struct CapsFeatures.
func NewCapsFeaturesSingle(feature string) *CapsFeatures {
	var _arg1 *C.gchar           // out
	var _cret *C.GstCapsFeatures // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(feature)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_caps_features_new_single(_arg1)
	runtime.KeepAlive(feature)

	var _capsFeatures *CapsFeatures // out

	_capsFeatures = (*CapsFeatures)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_capsFeatures)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_caps_features_free((*C.GstCapsFeatures)(intern.C))
		},
	)

	return _capsFeatures
}

// Add adds feature to features.
//
// The function takes the following parameters:
//
//   - feature: feature.
func (features *CapsFeatures) Add(feature string) {
	var _arg0 *C.GstCapsFeatures // out
	var _arg1 *C.gchar           // out

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(feature)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_caps_features_add(_arg0, _arg1)
	runtime.KeepAlive(features)
	runtime.KeepAlive(feature)
}

// AddID adds feature to features.
//
// The function takes the following parameters:
//
//   - feature: feature.
func (features *CapsFeatures) AddID(feature glib.Quark) {
	var _arg0 *C.GstCapsFeatures // out
	var _arg1 C.GQuark           // out

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
	_arg1 = C.GQuark(feature)

	C.gst_caps_features_add_id(_arg0, _arg1)
	runtime.KeepAlive(features)
	runtime.KeepAlive(feature)
}

// Contains checks if features contains feature.
//
// The function takes the following parameters:
//
//   - feature: feature.
//
// The function returns the following values:
//
//   - ok: TRUE if features contains feature.
func (features *CapsFeatures) Contains(feature string) bool {
	var _arg0 *C.GstCapsFeatures // out
	var _arg1 *C.gchar           // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(feature)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_caps_features_contains(_arg0, _arg1)
	runtime.KeepAlive(features)
	runtime.KeepAlive(feature)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ContainsID checks if features contains feature.
//
// The function takes the following parameters:
//
//   - feature: feature.
//
// The function returns the following values:
//
//   - ok: TRUE if features contains feature.
func (features *CapsFeatures) ContainsID(feature glib.Quark) bool {
	var _arg0 *C.GstCapsFeatures // out
	var _arg1 C.GQuark           // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
	_arg1 = C.GQuark(feature)

	_cret = C.gst_caps_features_contains_id(_arg0, _arg1)
	runtime.KeepAlive(features)
	runtime.KeepAlive(feature)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Copy duplicates a CapsFeatures and all its values.
//
// The function returns the following values:
//
//   - capsFeatures: new CapsFeatures.
func (features *CapsFeatures) Copy() *CapsFeatures {
	var _arg0 *C.GstCapsFeatures // out
	var _cret *C.GstCapsFeatures // in

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))

	_cret = C.gst_caps_features_copy(_arg0)
	runtime.KeepAlive(features)

	var _capsFeatures *CapsFeatures // out

	_capsFeatures = (*CapsFeatures)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_capsFeatures)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_caps_features_free((*C.GstCapsFeatures)(intern.C))
		},
	)

	return _capsFeatures
}

// Nth returns the i-th feature of features.
//
// The function takes the following parameters:
//
//   - i: index of the feature.
//
// The function returns the following values:
//
//   - utf8 (optional): i-th feature of features.
func (features *CapsFeatures) Nth(i uint) string {
	var _arg0 *C.GstCapsFeatures // out
	var _arg1 C.guint            // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
	_arg1 = C.guint(i)

	_cret = C.gst_caps_features_get_nth(_arg0, _arg1)
	runtime.KeepAlive(features)
	runtime.KeepAlive(i)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// NthID returns the i-th feature of features.
//
// The function takes the following parameters:
//
//   - i: index of the feature.
//
// The function returns the following values:
//
//   - quark: i-th feature of features.
func (features *CapsFeatures) NthID(i uint) glib.Quark {
	var _arg0 *C.GstCapsFeatures // out
	var _arg1 C.guint            // out
	var _cret C.GQuark           // in

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
	_arg1 = C.guint(i)

	_cret = C.gst_caps_features_get_nth_id(_arg0, _arg1)
	runtime.KeepAlive(features)
	runtime.KeepAlive(i)

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// Size returns the number of features in features.
//
// The function returns the following values:
//
//   - guint: number of features in features.
func (features *CapsFeatures) Size() uint {
	var _arg0 *C.GstCapsFeatures // out
	var _cret C.guint            // in

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))

	_cret = C.gst_caps_features_get_size(_arg0)
	runtime.KeepAlive(features)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IsAny checks if features is GST_CAPS_FEATURES_ANY.
//
// The function returns the following values:
//
//   - ok: TRUE if features is GST_CAPS_FEATURES_ANY.
func (features *CapsFeatures) IsAny() bool {
	var _arg0 *C.GstCapsFeatures // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))

	_cret = C.gst_caps_features_is_any(_arg0)
	runtime.KeepAlive(features)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEqual checks if features1 and features2 are equal.
//
// The function takes the following parameters:
//
//   - features2: CapsFeatures.
//
// The function returns the following values:
//
//   - ok: TRUE if features1 and features2 are equal.
func (features1 *CapsFeatures) IsEqual(features2 *CapsFeatures) bool {
	var _arg0 *C.GstCapsFeatures // out
	var _arg1 *C.GstCapsFeatures // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features1)))
	_arg1 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features2)))

	_cret = C.gst_caps_features_is_equal(_arg0, _arg1)
	runtime.KeepAlive(features1)
	runtime.KeepAlive(features2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Remove removes feature from features.
//
// The function takes the following parameters:
//
//   - feature: feature.
func (features *CapsFeatures) Remove(feature string) {
	var _arg0 *C.GstCapsFeatures // out
	var _arg1 *C.gchar           // out

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(feature)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_caps_features_remove(_arg0, _arg1)
	runtime.KeepAlive(features)
	runtime.KeepAlive(feature)
}

// RemoveID removes feature from features.
//
// The function takes the following parameters:
//
//   - feature: feature.
func (features *CapsFeatures) RemoveID(feature glib.Quark) {
	var _arg0 *C.GstCapsFeatures // out
	var _arg1 C.GQuark           // out

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
	_arg1 = C.GQuark(feature)

	C.gst_caps_features_remove_id(_arg0, _arg1)
	runtime.KeepAlive(features)
	runtime.KeepAlive(feature)
}

// SetParentRefcount sets the parent_refcount field of CapsFeatures.
// This field is used to determine whether a caps features is mutable or not.
// This function should only be called by code implementing parent objects
// of CapsFeatures, as described in the MT refcounting design document
// (additional/design/MT-refcounting.md).
//
// The function takes the following parameters:
//
//   - refcount: pointer to the parent's refcount.
//
// The function returns the following values:
//
//   - ok: TRUE if the parent refcount could be set.
func (features *CapsFeatures) SetParentRefcount(refcount *int) bool {
	var _arg0 *C.GstCapsFeatures // out
	var _arg1 *C.gint            // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))
	_arg1 = (*C.gint)(unsafe.Pointer(refcount))

	_cret = C.gst_caps_features_set_parent_refcount(_arg0, _arg1)
	runtime.KeepAlive(features)
	runtime.KeepAlive(refcount)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// String converts features to a human-readable string representation.
//
// For debugging purposes its easier to do something like this:
//
//	C GST_LOG ("features is %" GST_PTR_FORMAT, features);
//
// This prints the features in human readable form.
//
// The function returns the following values:
//
//   - utf8: pointer to string allocated by g_malloc().
func (features *CapsFeatures) String() string {
	var _arg0 *C.GstCapsFeatures // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GstCapsFeatures)(gextras.StructNative(unsafe.Pointer(features)))

	_cret = C.gst_caps_features_to_string(_arg0)
	runtime.KeepAlive(features)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// CapsFeaturesFromString creates a CapsFeatures from a string representation.
//
// The function takes the following parameters:
//
//   - features: string representation of a CapsFeatures.
//
// The function returns the following values:
//
//   - capsFeatures (optional): new CapsFeatures or NULL when the string could
//     not be parsed.
func CapsFeaturesFromString(features string) *CapsFeatures {
	var _arg1 *C.gchar           // out
	var _cret *C.GstCapsFeatures // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(features)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_caps_features_from_string(_arg1)
	runtime.KeepAlive(features)

	var _capsFeatures *CapsFeatures // out

	if _cret != nil {
		_capsFeatures = (*CapsFeatures)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_capsFeatures)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_caps_features_free((*C.GstCapsFeatures)(intern.C))
			},
		)
	}

	return _capsFeatures
}

// ChildProxyInterface interface.
//
// An instance of this type is always passed by reference.
type ChildProxyInterface struct {
	*childProxyInterface
}

// childProxyInterface is the struct that's finalized.
type childProxyInterface struct {
	native *C.GstChildProxyInterface
}

// ClockClass: GStreamer clock class. Override the vmethods to implement the
// clock functionality.
//
// An instance of this type is always passed by reference.
type ClockClass struct {
	*clockClass
}

// clockClass is the struct that's finalized.
type clockClass struct {
	native *C.GstClockClass
}

// ParentClass: parent class structure.
func (c *ClockClass) ParentClass() *ObjectClass {
	valptr := &c.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ClockEntry: all pending timeouts or periodic notifies are converted into an
// entry. Note that GstClockEntry should be treated as an opaque structure.
// It must not be extended or allocated using a custom allocator.
//
// An instance of this type is always passed by reference.
type ClockEntry struct {
	*clockEntry
}

// clockEntry is the struct that's finalized.
type clockEntry struct {
	native *C.GstClockEntry
}

// Refcount: reference counter (read-only).
func (c *ClockEntry) Refcount() int {
	valptr := &c.native.refcount
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Refcount: reference counter (read-only).
func (c *ClockEntry) SetRefcount(refcount int) {
	valptr := &c.native.refcount
	*valptr = C.gint(refcount)
}

// Context is a container object used to store contexts like a device context,
// a display server connection and similar concepts that should be shared
// between multiple elements.
//
// Applications can set a context on a complete pipeline by using
// gst_element_set_context(), which will then be propagated to all child
// elements. Elements can handle these in ElementClass::set_context and merge
// them with the context information they already have.
//
// When an element needs a context it will do the following actions in this
// order until one step succeeds:
//
// 1. Check if the element already has a context 2. Query downstream with
// GST_QUERY_CONTEXT for the context 3. Query upstream with GST_QUERY_CONTEXT
// for the context 4. Post a GST_MESSAGE_NEED_CONTEXT message on the bus with
// the required context types and afterwards check if a usable context was set
// now 5. Create a context by itself and post a GST_MESSAGE_HAVE_CONTEXT message
// on the bus.
//
// Bins will catch GST_MESSAGE_NEED_CONTEXT messages and will set any previously
// known context on the element that asks for it if possible. Otherwise the
// application should provide one if it can.
//
// Context can be persistent. A persistent Context is kept in elements when
// they reach GST_STATE_NULL, non-persistent ones will be removed. Also,
// a non-persistent context won't override a previous persistent context set to
// an element.
//
// An instance of this type is always passed by reference.
type Context struct {
	*context
}

// context is the struct that's finalized.
type context struct {
	native *C.GstContext
}

func marshalContext(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Context{&context{(*C.GstContext)(b)}}, nil
}

// NewContext constructs a struct Context.
func NewContext(contextType string, persistent bool) *Context {
	var _arg1 *C.gchar      // out
	var _arg2 C.gboolean    // out
	var _cret *C.GstContext // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(contextType)))
	defer C.free(unsafe.Pointer(_arg1))
	if persistent {
		_arg2 = C.TRUE
	}

	_cret = C.gst_context_new(_arg1, _arg2)
	runtime.KeepAlive(contextType)
	runtime.KeepAlive(persistent)

	var _context *Context // out

	_context = (*Context)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_context)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _context
}

// ContextType gets the type of context.
//
// The function returns the following values:
//
//   - utf8: type of the context.
func (context *Context) ContextType() string {
	var _arg0 *C.GstContext // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GstContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.gst_context_get_context_type(_arg0)
	runtime.KeepAlive(context)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Structure accesses the structure of the context.
//
// The function returns the following values:
//
//   - structure of the context. The structure is still owned by the context,
//     which means that you should not modify it, free it and that the pointer
//     becomes invalid when you free the context.
func (context *Context) Structure() *Structure {
	var _arg0 *C.GstContext   // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.gst_context_get_structure(_arg0)
	runtime.KeepAlive(context)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _structure
}

// HasContextType checks if context has context_type.
//
// The function takes the following parameters:
//
//   - contextType: context type to check.
//
// The function returns the following values:
//
//   - ok: TRUE if context has context_type.
func (context *Context) HasContextType(contextType string) bool {
	var _arg0 *C.GstContext // out
	var _arg1 *C.gchar      // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstContext)(gextras.StructNative(unsafe.Pointer(context)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(contextType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_context_has_context_type(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(contextType)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsPersistent checks if context is persistent.
//
// The function returns the following values:
//
//   - ok: TRUE if the context is persistent.
func (context *Context) IsPersistent() bool {
	var _arg0 *C.GstContext // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.gst_context_is_persistent(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WritableStructure gets a writable version of the structure.
//
// The function returns the following values:
//
//   - structure of the context. The structure is still owned by the context,
//     which means that you should not free it and that the pointer becomes
//     invalid when you free the context. This function checks if context is
//     writable.
func (context *Context) WritableStructure() *Structure {
	var _arg0 *C.GstContext   // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.gst_context_writable_structure(_arg0)
	runtime.KeepAlive(context)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _structure
}

// ControlBindingClass class structure of ControlBinding.
//
// An instance of this type is always passed by reference.
type ControlBindingClass struct {
	*controlBindingClass
}

// controlBindingClass is the struct that's finalized.
type controlBindingClass struct {
	native *C.GstControlBindingClass
}

// ParentClass: parent class.
func (c *ControlBindingClass) ParentClass() *ObjectClass {
	valptr := &c.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ControlSourceClass class structure of ControlSource.
//
// An instance of this type is always passed by reference.
type ControlSourceClass struct {
	*controlSourceClass
}

// controlSourceClass is the struct that's finalized.
type controlSourceClass struct {
	native *C.GstControlSourceClass
}

// ParentClass: parent class.
func (c *ControlSourceClass) ParentClass() *ObjectClass {
	valptr := &c.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// CustomMeta: extra custom metadata. The structure field is the same as
// returned by gst_custom_meta_get_structure().
//
// Since 1.24 it can be serialized using gst_meta_serialize() and
// gst_meta_deserialize(), but only if the Structure does not contain any fields
// that cannot be serialized, see GST_SERIALIZE_FLAG_STRICT.
//
// An instance of this type is always passed by reference.
type CustomMeta struct {
	*customMeta
}

// customMeta is the struct that's finalized.
type customMeta struct {
	native *C.GstCustomMeta
}

// Meta: parent Meta.
func (c *CustomMeta) Meta() *Meta {
	valptr := &c.native.meta
	var _v *Meta // out
	_v = (*Meta)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Structure: retrieve the Structure backing a custom meta, the structure's
// mutability is conditioned to the writability of the Buffer meta is attached
// to.
//
// The function returns the following values:
//
//   - structure backing meta.
func (meta *CustomMeta) Structure() *Structure {
	var _arg0 *C.GstCustomMeta // out
	var _cret *C.GstStructure  // in

	_arg0 = (*C.GstCustomMeta)(gextras.StructNative(unsafe.Pointer(meta)))

	_cret = C.gst_custom_meta_get_structure(_arg0)
	runtime.KeepAlive(meta)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _structure
}

// HasName checks whether the name of the custom meta is name.
//
// The function returns the following values:
//
//   - ok: whether name is the name of the custom meta.
func (meta *CustomMeta) HasName(name string) bool {
	var _arg0 *C.GstCustomMeta // out
	var _arg1 *C.gchar         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstCustomMeta)(gextras.StructNative(unsafe.Pointer(meta)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_custom_meta_has_name(_arg0, _arg1)
	runtime.KeepAlive(meta)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DateTime: struct to store date, time and timezone information altogether.
// DateTime is refcounted and immutable.
//
// Date information is handled using the proleptic Gregorian calendar.
//
// Provides basic creation functions and accessor functions to its fields.
//
// An instance of this type is always passed by reference.
type DateTime struct {
	*dateTime
}

// dateTime is the struct that's finalized.
type dateTime struct {
	native *C.GstDateTime
}

func marshalDateTime(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DateTime{&dateTime{(*C.GstDateTime)(b)}}, nil
}

// NewDateTime constructs a struct DateTime.
func NewDateTime(tzoffset float32, year int, month int, day int, hour int, minute int, seconds float64) *DateTime {
	var _arg1 C.gfloat       // out
	var _arg2 C.gint         // out
	var _arg3 C.gint         // out
	var _arg4 C.gint         // out
	var _arg5 C.gint         // out
	var _arg6 C.gint         // out
	var _arg7 C.gdouble      // out
	var _cret *C.GstDateTime // in

	_arg1 = C.gfloat(tzoffset)
	_arg2 = C.gint(year)
	_arg3 = C.gint(month)
	_arg4 = C.gint(day)
	_arg5 = C.gint(hour)
	_arg6 = C.gint(minute)
	_arg7 = C.gdouble(seconds)

	_cret = C.gst_date_time_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(tzoffset)
	runtime.KeepAlive(year)
	runtime.KeepAlive(month)
	runtime.KeepAlive(day)
	runtime.KeepAlive(hour)
	runtime.KeepAlive(minute)
	runtime.KeepAlive(seconds)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeFromGDateTime constructs a struct DateTime.
func NewDateTimeFromGDateTime(dt *glib.DateTime) *DateTime {
	var _arg1 *C.GDateTime   // out
	var _cret *C.GstDateTime // in

	if dt != nil {
		_arg1 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(dt)))
	}

	_cret = C.gst_date_time_new_from_g_date_time(_arg1)
	runtime.KeepAlive(dt)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeFromISO8601String constructs a struct DateTime.
func NewDateTimeFromISO8601String(str string) *DateTime {
	var _arg1 *C.gchar       // out
	var _cret *C.GstDateTime // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_date_time_new_from_iso8601_string(_arg1)
	runtime.KeepAlive(str)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeFromUnixEpochLocalTime constructs a struct DateTime.
func NewDateTimeFromUnixEpochLocalTime(secs int64) *DateTime {
	var _arg1 C.gint64       // out
	var _cret *C.GstDateTime // in

	_arg1 = C.gint64(secs)

	_cret = C.gst_date_time_new_from_unix_epoch_local_time(_arg1)
	runtime.KeepAlive(secs)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeFromUnixEpochLocalTimeUsecs constructs a struct DateTime.
func NewDateTimeFromUnixEpochLocalTimeUsecs(usecs int64) *DateTime {
	var _arg1 C.gint64       // out
	var _cret *C.GstDateTime // in

	_arg1 = C.gint64(usecs)

	_cret = C.gst_date_time_new_from_unix_epoch_local_time_usecs(_arg1)
	runtime.KeepAlive(usecs)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeFromUnixEpochUTC constructs a struct DateTime.
func NewDateTimeFromUnixEpochUTC(secs int64) *DateTime {
	var _arg1 C.gint64       // out
	var _cret *C.GstDateTime // in

	_arg1 = C.gint64(secs)

	_cret = C.gst_date_time_new_from_unix_epoch_utc(_arg1)
	runtime.KeepAlive(secs)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeFromUnixEpochUTCUsecs constructs a struct DateTime.
func NewDateTimeFromUnixEpochUTCUsecs(usecs int64) *DateTime {
	var _arg1 C.gint64       // out
	var _cret *C.GstDateTime // in

	_arg1 = C.gint64(usecs)

	_cret = C.gst_date_time_new_from_unix_epoch_utc_usecs(_arg1)
	runtime.KeepAlive(usecs)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeLocalTime constructs a struct DateTime.
func NewDateTimeLocalTime(year int, month int, day int, hour int, minute int, seconds float64) *DateTime {
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _arg3 C.gint         // out
	var _arg4 C.gint         // out
	var _arg5 C.gint         // out
	var _arg6 C.gdouble      // out
	var _cret *C.GstDateTime // in

	_arg1 = C.gint(year)
	_arg2 = C.gint(month)
	_arg3 = C.gint(day)
	_arg4 = C.gint(hour)
	_arg5 = C.gint(minute)
	_arg6 = C.gdouble(seconds)

	_cret = C.gst_date_time_new_local_time(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(year)
	runtime.KeepAlive(month)
	runtime.KeepAlive(day)
	runtime.KeepAlive(hour)
	runtime.KeepAlive(minute)
	runtime.KeepAlive(seconds)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeNowLocalTime constructs a struct DateTime.
func NewDateTimeNowLocalTime() *DateTime {
	var _cret *C.GstDateTime // in

	_cret = C.gst_date_time_new_now_local_time()

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeNowUTC constructs a struct DateTime.
func NewDateTimeNowUTC() *DateTime {
	var _cret *C.GstDateTime // in

	_cret = C.gst_date_time_new_now_utc()

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeY constructs a struct DateTime.
func NewDateTimeY(year int) *DateTime {
	var _arg1 C.gint         // out
	var _cret *C.GstDateTime // in

	_arg1 = C.gint(year)

	_cret = C.gst_date_time_new_y(_arg1)
	runtime.KeepAlive(year)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeYM constructs a struct DateTime.
func NewDateTimeYM(year int, month int) *DateTime {
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _cret *C.GstDateTime // in

	_arg1 = C.gint(year)
	_arg2 = C.gint(month)

	_cret = C.gst_date_time_new_ym(_arg1, _arg2)
	runtime.KeepAlive(year)
	runtime.KeepAlive(month)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// NewDateTimeYmd constructs a struct DateTime.
func NewDateTimeYmd(year int, month int, day int) *DateTime {
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _arg3 C.gint         // out
	var _cret *C.GstDateTime // in

	_arg1 = C.gint(year)
	_arg2 = C.gint(month)
	_arg3 = C.gint(day)

	_cret = C.gst_date_time_new_ymd(_arg1, _arg2, _arg3)
	runtime.KeepAlive(year)
	runtime.KeepAlive(month)
	runtime.KeepAlive(day)

	var _dateTime *DateTime // out

	if _cret != nil {
		_dateTime = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_date_time_unref((*C.GstDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// Day returns the day of the month of this DateTime.
//
// The function returns the following values:
//
//   - gint: day of this DateTime, or -1 if none is set.
func (datetime *DateTime) Day() int {
	var _arg0 *C.GstDateTime // out
	var _cret C.gint         // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_get_day(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Hour retrieves the hour of the day represented by datetime in the gregorian
// calendar. The return is in the range of 0 to 23.
//
// The function returns the following values:
//
//   - gint: hour of the day, or -1 if none is set.
func (datetime *DateTime) Hour() int {
	var _arg0 *C.GstDateTime // out
	var _cret C.gint         // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_get_hour(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Microsecond retrieves the fractional part of the seconds in microseconds
// represented by datetime in the gregorian calendar.
//
// The function returns the following values:
//
//   - gint: microsecond of the second, or -1 if none is set.
func (datetime *DateTime) Microsecond() int {
	var _arg0 *C.GstDateTime // out
	var _cret C.gint         // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_get_microsecond(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Minute retrieves the minute of the hour represented by datetime in the
// gregorian calendar.
//
// The function returns the following values:
//
//   - gint: minute of the hour, or -1 if none is set.
func (datetime *DateTime) Minute() int {
	var _arg0 *C.GstDateTime // out
	var _cret C.gint         // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_get_minute(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Month returns the month of this DateTime. January is 1, February is 2, etc..
//
// The function returns the following values:
//
//   - gint: month of this DateTime, or -1 if none is set.
func (datetime *DateTime) Month() int {
	var _arg0 *C.GstDateTime // out
	var _cret C.gint         // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_get_month(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Second retrieves the second of the minute represented by datetime in the
// gregorian calendar.
//
// The function returns the following values:
//
//   - gint: second represented by datetime, or -1 if none is set.
func (datetime *DateTime) Second() int {
	var _arg0 *C.GstDateTime // out
	var _cret C.gint         // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_get_second(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// TimeZoneOffset retrieves the offset from UTC in hours that the timezone
// specified by datetime represents. Timezones ahead (to the east) of UTC have
// positive values, timezones before (to the west) of UTC have negative values.
// If datetime represents UTC time, then the offset is zero.
//
// The function returns the following values:
//
//   - gfloat: offset from UTC in hours, or G_MAXFLOAT if none is set.
func (datetime *DateTime) TimeZoneOffset() float32 {
	var _arg0 *C.GstDateTime // out
	var _cret C.gfloat       // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_get_time_zone_offset(_arg0)
	runtime.KeepAlive(datetime)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Year returns the year of this DateTime. Call gst_date_time_has_year() before,
// to avoid warnings.
//
// The function returns the following values:
//
//   - gint: year of this DateTime.
func (datetime *DateTime) Year() int {
	var _arg0 *C.GstDateTime // out
	var _cret C.gint         // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_get_year(_arg0)
	runtime.KeepAlive(datetime)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
//   - ok: TRUE if datetime<!-- -->'s day field is set, otherwise FALSE.
func (datetime *DateTime) HasDay() bool {
	var _arg0 *C.GstDateTime // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_has_day(_arg0)
	runtime.KeepAlive(datetime)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - ok: TRUE if datetime<!-- -->'s month field is set, otherwise FALSE.
func (datetime *DateTime) HasMonth() bool {
	var _arg0 *C.GstDateTime // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_has_month(_arg0)
	runtime.KeepAlive(datetime)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - ok: TRUE if datetime<!-- -->'s second field is set, otherwise FALSE.
func (datetime *DateTime) HasSecond() bool {
	var _arg0 *C.GstDateTime // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_has_second(_arg0)
	runtime.KeepAlive(datetime)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - ok: TRUE if datetime<!-- -->'s hour and minute fields are set, otherwise
//     FALSE.
func (datetime *DateTime) HasTime() bool {
	var _arg0 *C.GstDateTime // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_has_time(_arg0)
	runtime.KeepAlive(datetime)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - ok: TRUE if datetime<!-- -->'s year field is set (which should always be
//     the case), otherwise FALSE.
func (datetime *DateTime) HasYear() bool {
	var _arg0 *C.GstDateTime // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_has_year(_arg0)
	runtime.KeepAlive(datetime)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ToGDateTime creates a new Time from a fully defined DateTime object.
//
// The function returns the following values:
//
//   - dateTime (optional): newly created Time, or NULL on error or if datetime
//     does not have a year, month, day, hour, minute and second.
func (datetime *DateTime) ToGDateTime() *glib.DateTime {
	var _arg0 *C.GstDateTime // out
	var _cret *C.GDateTime   // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_to_g_date_time(_arg0)
	runtime.KeepAlive(datetime)

	var _dateTime *glib.DateTime // out

	if _cret != nil {
		_dateTime = (*glib.DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dateTime)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_date_time_unref((*C.GDateTime)(intern.C))
			},
		)
	}

	return _dateTime
}

// ToISO8601String: create a minimal string compatible with ISO-8601.
// Possible output formats are (for example): 2012, 2012-06, 2012-06-23,
// 2012-06-23T23:30Z, 2012-06-23T23:30+0100, 2012-06-23T23:30:59Z,
// 2012-06-23T23:30:59+0100.
//
// The function returns the following values:
//
//   - utf8 (optional): newly allocated string formatted according to ISO 8601
//     and only including the datetime fields that are valid, or NULL in case
//     there was an error.
func (datetime *DateTime) ToISO8601String() string {
	var _arg0 *C.GstDateTime // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GstDateTime)(gextras.StructNative(unsafe.Pointer(datetime)))

	_cret = C.gst_date_time_to_iso8601_string(_arg0)
	runtime.KeepAlive(datetime)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// DebugCategory: this is the struct that describes the categories. Once
// initialized with T_DEBUG_CATEGORY_INIT, its values can't be changed anymore.
//
// An instance of this type is always passed by reference.
type DebugCategory struct {
	*debugCategory
}

// debugCategory is the struct that's finalized.
type debugCategory struct {
	native *C.GstDebugCategory
}

// Color returns the color of a debug category used when printing output in this
// category.
//
// The function returns the following values:
//
//   - guint: color of the category.
func (category *DebugCategory) Color() uint {
	var _arg0 *C.GstDebugCategory // out
	var _cret C.guint             // in

	_arg0 = (*C.GstDebugCategory)(gextras.StructNative(unsafe.Pointer(category)))

	_cret = C.gst_debug_category_get_color(_arg0)
	runtime.KeepAlive(category)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Description returns the description of a debug category.
//
// The function returns the following values:
//
//   - utf8: description of the category.
func (category *DebugCategory) Description() string {
	var _arg0 *C.GstDebugCategory // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GstDebugCategory)(gextras.StructNative(unsafe.Pointer(category)))

	_cret = C.gst_debug_category_get_description(_arg0)
	runtime.KeepAlive(category)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Name returns the name of a debug category.
//
// The function returns the following values:
//
//   - utf8: name of the category.
func (category *DebugCategory) Name() string {
	var _arg0 *C.GstDebugCategory // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GstDebugCategory)(gextras.StructNative(unsafe.Pointer(category)))

	_cret = C.gst_debug_category_get_name(_arg0)
	runtime.KeepAlive(category)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Threshold returns the threshold of a DebugCategory.
//
// The function returns the following values:
//
//   - debugLevel that is used as threshold.
func (category *DebugCategory) Threshold() DebugLevel {
	var _arg0 *C.GstDebugCategory // out
	var _cret C.GstDebugLevel     // in

	_arg0 = (*C.GstDebugCategory)(gextras.StructNative(unsafe.Pointer(category)))

	_cret = C.gst_debug_category_get_threshold(_arg0)
	runtime.KeepAlive(category)

	var _debugLevel DebugLevel // out

	_debugLevel = DebugLevel(_cret)

	return _debugLevel
}

// ResetThreshold resets the threshold of the category to the default level.
// Debug information will only be output if the threshold is lower or equal to
// the level of the debugging message. Use this function to set the threshold
// back to where it was after using gst_debug_category_set_threshold().
func (category *DebugCategory) ResetThreshold() {
	var _arg0 *C.GstDebugCategory // out

	_arg0 = (*C.GstDebugCategory)(gextras.StructNative(unsafe.Pointer(category)))

	C.gst_debug_category_reset_threshold(_arg0)
	runtime.KeepAlive(category)
}

// SetThreshold sets the threshold of the category to the given level.
// Debug information will only be output if the threshold is lower or equal to
// the level of the debugging message. > Do not use this function in production
// code, because other functions may > change the threshold of categories as
// side effect. It is however a nice > function to use when debugging (even from
// gdb).
//
// The function takes the following parameters:
//
//   - level threshold to set.
func (category *DebugCategory) SetThreshold(level DebugLevel) {
	var _arg0 *C.GstDebugCategory // out
	var _arg1 C.GstDebugLevel     // out

	_arg0 = (*C.GstDebugCategory)(gextras.StructNative(unsafe.Pointer(category)))
	_arg1 = C.GstDebugLevel(level)

	C.gst_debug_category_set_threshold(_arg0, _arg1)
	runtime.KeepAlive(category)
	runtime.KeepAlive(level)
}

// DeviceClass class structure for a Device object.
//
// An instance of this type is always passed by reference.
type DeviceClass struct {
	*deviceClass
}

// deviceClass is the struct that's finalized.
type deviceClass struct {
	native *C.GstDeviceClass
}

// ParentClass: parent ObjectClass structure.
func (d *DeviceClass) ParentClass() *ObjectClass {
	valptr := &d.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// DeviceMonitorClass: opaque device monitor class structure.
//
// An instance of this type is always passed by reference.
type DeviceMonitorClass struct {
	*deviceMonitorClass
}

// deviceMonitorClass is the struct that's finalized.
type deviceMonitorClass struct {
	native *C.GstDeviceMonitorClass
}

// ParentClass: parent ObjectClass structure.
func (d *DeviceMonitorClass) ParentClass() *ObjectClass {
	valptr := &d.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// DeviceProviderClass: structure of the base DeviceProviderClass
//
// An instance of this type is always passed by reference.
type DeviceProviderClass struct {
	*deviceProviderClass
}

// deviceProviderClass is the struct that's finalized.
type deviceProviderClass struct {
	native *C.GstDeviceProviderClass
}

// ParentClass: parent ObjectClass structure.
func (d *DeviceProviderClass) ParentClass() *ObjectClass {
	valptr := &d.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Factory: pointer to the DeviceProviderFactory that creates this provider.
func (d *DeviceProviderClass) Factory() *DeviceProviderFactory {
	valptr := &d.native.factory
	var _v *DeviceProviderFactory // out
	_v = wrapDeviceProviderFactory(coreglib.Take(unsafe.Pointer(*valptr)))
	return _v
}

// AddMetadata: set key with value as metadata in klass.
//
// The function takes the following parameters:
//
//   - key to set.
//   - value to set.
func (klass *DeviceProviderClass) AddMetadata(key string, value string) {
	var _arg0 *C.GstDeviceProviderClass // out
	var _arg1 *C.gchar                  // out
	var _arg2 *C.gchar                  // out

	_arg0 = (*C.GstDeviceProviderClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gst_device_provider_class_add_metadata(_arg0, _arg1, _arg2)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// AddStaticMetadata: set key with value as metadata in klass.
//
// Same as gst_device_provider_class_add_metadata(), but value must be a static
// string or an inlined string, as it will not be copied. (GStreamer plugins
// will be made resident once loaded, so this function can be used even from
// dynamically loaded plugins.).
//
// The function takes the following parameters:
//
//   - key to set.
//   - value to set.
func (klass *DeviceProviderClass) AddStaticMetadata(key string, value string) {
	var _arg0 *C.GstDeviceProviderClass // out
	var _arg1 *C.gchar                  // out
	var _arg2 *C.gchar                  // out

	_arg0 = (*C.GstDeviceProviderClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(value)))

	C.gst_device_provider_class_add_static_metadata(_arg0, _arg1, _arg2)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// Metadata: get metadata with key in klass.
//
// The function takes the following parameters:
//
//   - key to get.
//
// The function returns the following values:
//
//   - utf8 (optional): metadata for key.
func (klass *DeviceProviderClass) Metadata(key string) string {
	var _arg0 *C.GstDeviceProviderClass // out
	var _arg1 *C.gchar                  // out
	var _cret *C.gchar                  // in

	_arg0 = (*C.GstDeviceProviderClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_device_provider_class_get_metadata(_arg0, _arg1)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(key)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// SetMetadata sets the detailed information for a DeviceProviderClass.
//
// > This function is for use in _class_init functions only.
//
// The function takes the following parameters:
//
//   - longname: long English name of the device provider. E.g. "File Sink".
//   - classification: string describing the type of device provider, as an
//     unordered list separated with slashes ('/'). See draft-klass.txt of the
//     design docs for more details and common types. E.g: "Sink/File".
//   - description: sentence describing the purpose of the device provider. E.g:
//     "Write stream to a file".
//   - author: name and contact details of the author(s). Use \n to separate
//     multiple author metadata. E.g: "Joe Bloggs &lt;joe.blogs at foo.com&gt;".
func (klass *DeviceProviderClass) SetMetadata(longname string, classification string, description string, author string) {
	var _arg0 *C.GstDeviceProviderClass // out
	var _arg1 *C.gchar                  // out
	var _arg2 *C.gchar                  // out
	var _arg3 *C.gchar                  // out
	var _arg4 *C.gchar                  // out

	_arg0 = (*C.GstDeviceProviderClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(longname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(classification)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(author)))
	defer C.free(unsafe.Pointer(_arg4))

	C.gst_device_provider_class_set_metadata(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(longname)
	runtime.KeepAlive(classification)
	runtime.KeepAlive(description)
	runtime.KeepAlive(author)
}

// SetStaticMetadata sets the detailed information for a DeviceProviderClass.
//
// > This function is for use in _class_init functions only.
//
// Same as gst_device_provider_class_set_metadata(), but longname,
// classification, description, and author must be static strings or inlined
// strings, as they will not be copied. (GStreamer plugins will be made resident
// once loaded, so this function can be used even from dynamically loaded
// plugins.).
//
// The function takes the following parameters:
//
//   - longname: long English name of the element. E.g. "File Sink".
//   - classification: string describing the type of element, as an unordered
//     list separated with slashes ('/'). See draft-klass.txt of the design docs
//     for more details and common types. E.g: "Sink/File".
//   - description: sentence describing the purpose of the element. E.g:
//     "Write stream to a file".
//   - author: name and contact details of the author(s). Use \n to separate
//     multiple author metadata. E.g: "Joe Bloggs &lt;joe.blogs at foo.com&gt;".
func (klass *DeviceProviderClass) SetStaticMetadata(longname string, classification string, description string, author string) {
	var _arg0 *C.GstDeviceProviderClass // out
	var _arg1 *C.gchar                  // out
	var _arg2 *C.gchar                  // out
	var _arg3 *C.gchar                  // out
	var _arg4 *C.gchar                  // out

	_arg0 = (*C.GstDeviceProviderClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(longname)))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(classification)))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(author)))

	C.gst_device_provider_class_set_static_metadata(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(longname)
	runtime.KeepAlive(classification)
	runtime.KeepAlive(description)
	runtime.KeepAlive(author)
}

// ElementClass: GStreamer element class. Override the vmethods to implement the
// element functionality.
//
// An instance of this type is always passed by reference.
type ElementClass struct {
	*elementClass
}

// elementClass is the struct that's finalized.
type elementClass struct {
	native *C.GstElementClass
}

// ParentClass: parent class structure.
func (e *ElementClass) ParentClass() *ObjectClass {
	valptr := &e.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Elementfactory that creates these elements.
func (e *ElementClass) Elementfactory() *ElementFactory {
	valptr := &e.native.elementfactory
	var _v *ElementFactory // out
	_v = wrapElementFactory(coreglib.Take(unsafe.Pointer(*valptr)))
	return _v
}

// Numpadtemplates: number of padtemplates.
func (e *ElementClass) Numpadtemplates() int {
	valptr := &e.native.numpadtemplates
	var _v int // out
	_v = int(*valptr)
	return _v
}

// PadTemplCookie: changed whenever the padtemplates change.
func (e *ElementClass) PadTemplCookie() uint32 {
	valptr := &e.native.pad_templ_cookie
	var _v uint32 // out
	_v = uint32(*valptr)
	return _v
}

// AddMetadata: set key with value as metadata in klass.
//
// The function takes the following parameters:
//
//   - key to set.
//   - value to set.
func (klass *ElementClass) AddMetadata(key string, value string) {
	var _arg0 *C.GstElementClass // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out

	_arg0 = (*C.GstElementClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gst_element_class_add_metadata(_arg0, _arg1, _arg2)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// AddPadTemplate adds a padtemplate to an element class. This is mainly used in
// the _class_init functions of classes. If a pad template with the same name as
// an already existing one is added the old one is replaced by the new one.
//
// templ's reference count will be incremented, and any floating reference will
// be removed (see gst_object_ref_sink()).
//
// The function takes the following parameters:
//
//   - templ to add to the element class.
func (klass *ElementClass) AddPadTemplate(templ *PadTemplate) {
	var _arg0 *C.GstElementClass // out
	var _arg1 *C.GstPadTemplate  // out

	_arg0 = (*C.GstElementClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.InternObject(templ).Native()))

	C.gst_element_class_add_pad_template(_arg0, _arg1)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(templ)
}

// AddStaticMetadata: set key with value as metadata in klass.
//
// Same as gst_element_class_add_metadata(), but value must be a static string
// or an inlined string, as it will not be copied. (GStreamer plugins will be
// made resident once loaded, so this function can be used even from dynamically
// loaded plugins.).
//
// The function takes the following parameters:
//
//   - key to set.
//   - value to set.
func (klass *ElementClass) AddStaticMetadata(key string, value string) {
	var _arg0 *C.GstElementClass // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out

	_arg0 = (*C.GstElementClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gst_element_class_add_static_metadata(_arg0, _arg1, _arg2)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// AddStaticPadTemplate adds a pad template to an element class based on the
// static pad template templ. This is mainly used in the _class_init functions
// of element implementations. If a pad template with the same name already
// exists, the old one is replaced by the new one.
//
// The function takes the following parameters:
//
//   - staticTempl to add as pad template to the element class.
func (klass *ElementClass) AddStaticPadTemplate(staticTempl *StaticPadTemplate) {
	var _arg0 *C.GstElementClass      // out
	var _arg1 *C.GstStaticPadTemplate // out

	_arg0 = (*C.GstElementClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.GstStaticPadTemplate)(gextras.StructNative(unsafe.Pointer(staticTempl)))

	C.gst_element_class_add_static_pad_template(_arg0, _arg1)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(staticTempl)
}

// AddStaticPadTemplateWithGType adds a pad template to an element class based
// on the static pad template templ. This is mainly used in the _class_init
// functions of element implementations. If a pad template with the same name
// already exists, the old one is replaced by the new one.
//
// The function takes the following parameters:
//
//   - staticTempl to add as pad template to the element class.
//   - padType of the pad to create.
func (klass *ElementClass) AddStaticPadTemplateWithGType(staticTempl *StaticPadTemplate, padType coreglib.Type) {
	var _arg0 *C.GstElementClass      // out
	var _arg1 *C.GstStaticPadTemplate // out
	var _arg2 C.GType                 // out

	_arg0 = (*C.GstElementClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.GstStaticPadTemplate)(gextras.StructNative(unsafe.Pointer(staticTempl)))
	_arg2 = C.GType(padType)

	C.gst_element_class_add_static_pad_template_with_gtype(_arg0, _arg1, _arg2)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(staticTempl)
	runtime.KeepAlive(padType)
}

// Metadata: get metadata with key in klass.
//
// The function takes the following parameters:
//
//   - key to get.
//
// The function returns the following values:
//
//   - utf8: metadata for key.
func (klass *ElementClass) Metadata(key string) string {
	var _arg0 *C.GstElementClass // out
	var _arg1 *C.gchar           // out
	var _cret *C.gchar           // in

	_arg0 = (*C.GstElementClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_class_get_metadata(_arg0, _arg1)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(key)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// PadTemplate retrieves a padtemplate from element_class with the given name.
// > If you use this function in the GInstanceInitFunc of an object class
// > that has subclasses, make sure to pass the g_class parameter of the >
// GInstanceInitFunc here.
//
// The function takes the following parameters:
//
//   - name of the PadTemplate to get.
//
// The function returns the following values:
//
//   - padTemplate (optional) with the given name, or NULL if none was found.
//     No unreferencing is necessary.
func (elementClass *ElementClass) PadTemplate(name string) *PadTemplate {
	var _arg0 *C.GstElementClass // out
	var _arg1 *C.gchar           // out
	var _cret *C.GstPadTemplate  // in

	_arg0 = (*C.GstElementClass)(gextras.StructNative(unsafe.Pointer(elementClass)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_element_class_get_pad_template(_arg0, _arg1)
	runtime.KeepAlive(elementClass)
	runtime.KeepAlive(name)

	var _padTemplate *PadTemplate // out

	if _cret != nil {
		_padTemplate = wrapPadTemplate(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _padTemplate
}

// PadTemplateList retrieves a list of the pad templates associated with
// element_class. The list must not be modified by the calling code.
// > If you use this function in the GInstanceInitFunc of an object class
// > that has subclasses, make sure to pass the g_class parameter of the >
// GInstanceInitFunc here.
//
// The function returns the following values:
//
//   - list of pad templates.
func (elementClass *ElementClass) PadTemplateList() []*PadTemplate {
	var _arg0 *C.GstElementClass // out
	var _cret *C.GList           // in

	_arg0 = (*C.GstElementClass)(gextras.StructNative(unsafe.Pointer(elementClass)))

	_cret = C.gst_element_class_get_pad_template_list(_arg0)
	runtime.KeepAlive(elementClass)

	var _list []*PadTemplate // out

	_list = make([]*PadTemplate, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstPadTemplate)(v)
		var dst *PadTemplate // out
		dst = wrapPadTemplate(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// SetMetadata sets the detailed information for a ElementClass. > This function
// is for use in _class_init functions only.
//
// The function takes the following parameters:
//
//   - longname: long English name of the element. E.g. "File Sink".
//   - classification: string describing the type of element, as an unordered
//     list separated with slashes ('/'). See draft-klass.txt of the design docs
//     for more details and common types. E.g: "Sink/File".
//   - description: sentence describing the purpose of the element. E.g:
//     "Write stream to a file".
//   - author: name and contact details of the author(s). Use \n to separate
//     multiple author metadata. E.g: "Joe Bloggs &lt;joe.blogs at foo.com&gt;".
func (klass *ElementClass) SetMetadata(longname string, classification string, description string, author string) {
	var _arg0 *C.GstElementClass // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out

	_arg0 = (*C.GstElementClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(longname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(classification)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(author)))
	defer C.free(unsafe.Pointer(_arg4))

	C.gst_element_class_set_metadata(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(longname)
	runtime.KeepAlive(classification)
	runtime.KeepAlive(description)
	runtime.KeepAlive(author)
}

// SetStaticMetadata sets the detailed information for a ElementClass.
//
// > This function is for use in _class_init functions only.
//
// Same as gst_element_class_set_metadata(), but longname, classification,
// description, and author must be static strings or inlined strings, as they
// will not be copied. (GStreamer plugins will be made resident once loaded,
// so this function can be used even from dynamically loaded plugins.).
//
// The function takes the following parameters:
//
//   - longname: long English name of the element. E.g. "File Sink".
//   - classification: string describing the type of element, as an unordered
//     list separated with slashes ('/'). See draft-klass.txt of the design docs
//     for more details and common types. E.g: "Sink/File".
//   - description: sentence describing the purpose of the element. E.g:
//     "Write stream to a file".
//   - author: name and contact details of the author(s). Use \n to separate
//     multiple author metadata. E.g: "Joe Bloggs &lt;joe.blogs at foo.com&gt;".
func (klass *ElementClass) SetStaticMetadata(longname string, classification string, description string, author string) {
	var _arg0 *C.GstElementClass // out
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _arg3 *C.gchar           // out
	var _arg4 *C.gchar           // out

	_arg0 = (*C.GstElementClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(longname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(classification)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(author)))
	defer C.free(unsafe.Pointer(_arg4))

	C.gst_element_class_set_static_metadata(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(longname)
	runtime.KeepAlive(classification)
	runtime.KeepAlive(description)
	runtime.KeepAlive(author)
}

// Event: event class provides factory methods to construct events for sending
// and functions to query (parse) received events.
//
// Events are usually created with gst_event_new_*() which takes event-type
// specific parameters as arguments. To send an event application will usually
// use gst_element_send_event() and elements will use gst_pad_send_event() or
// gst_pad_push_event(). The event should be unreffed with gst_event_unref() if
// it has not been sent.
//
// Events that have been received can be parsed with their respective
// gst_event_parse_*() functions. It is valid to pass NULL for unwanted details.
//
// Events are passed between elements in parallel to the data stream. Some
// events are serialized with buffers, others are not. Some events only travel
// downstream, others only upstream. Some events can travel both upstream and
// downstream.
//
// The events are used to signal special conditions in the datastream such as
// EOS (end of stream) or the start of a new stream-segment. Events are also
// used to flush the pipeline of any pending data.
//
// Most of the event API is used inside plugins. Applications usually only
// construct and use seek events. To do that gst_event_new_seek() is used to
// create a seek event. It takes the needed parameters to specify seeking time
// and mode.
//
//	GstEvent *event;
//	gboolean result;
//	...
//	// construct a seek event to play the media from second 2 to 5, flush
//	// the pipeline to decrease latency.
//	event = gst_event_new_seek (1.0,
//	   GST_FORMAT_TIME,
//	   GST_SEEK_FLAG_FLUSH,
//	   GST_SEEK_TYPE_SET, 2 * GST_SECOND,
//	   GST_SEEK_TYPE_SET, 5 * GST_SECOND);
//	...
//	result = gst_element_send_event (pipeline, event);
//	if (!result)
//	  g_warning ("seek failed");
//	...
//
// An instance of this type is always passed by reference.
type Event struct {
	*event
}

// event is the struct that's finalized.
type event struct {
	native *C.GstEvent
}

func marshalEvent(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Event{&event{(*C.GstEvent)(b)}}, nil
}

// NewEventBufferSize constructs a struct Event.
func NewEventBufferSize(format Format, minsize int64, maxsize int64, async bool) *Event {
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // out
	var _arg3 C.gint64    // out
	var _arg4 C.gboolean  // out
	var _cret *C.GstEvent // in

	_arg1 = C.GstFormat(format)
	_arg2 = C.gint64(minsize)
	_arg3 = C.gint64(maxsize)
	if async {
		_arg4 = C.TRUE
	}

	_cret = C.gst_event_new_buffer_size(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(format)
	runtime.KeepAlive(minsize)
	runtime.KeepAlive(maxsize)
	runtime.KeepAlive(async)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventCaps constructs a struct Event.
func NewEventCaps(caps *Caps) *Event {
	var _arg1 *C.GstCaps  // out
	var _cret *C.GstEvent // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_event_new_caps(_arg1)
	runtime.KeepAlive(caps)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventCustom constructs a struct Event.
func NewEventCustom(typ EventType, structure *Structure) *Event {
	var _arg1 C.GstEventType  // out
	var _arg2 *C.GstStructure // out
	var _cret *C.GstEvent     // in

	_arg1 = C.GstEventType(typ)
	_arg2 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(structure)), nil)

	_cret = C.gst_event_new_custom(_arg1, _arg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(structure)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventEos constructs a struct Event.
func NewEventEos() *Event {
	var _cret *C.GstEvent // in

	_cret = C.gst_event_new_eos()

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventFlushStart constructs a struct Event.
func NewEventFlushStart() *Event {
	var _cret *C.GstEvent // in

	_cret = C.gst_event_new_flush_start()

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventFlushStop constructs a struct Event.
func NewEventFlushStop(resetTime bool) *Event {
	var _arg1 C.gboolean  // out
	var _cret *C.GstEvent // in

	if resetTime {
		_arg1 = C.TRUE
	}

	_cret = C.gst_event_new_flush_stop(_arg1)
	runtime.KeepAlive(resetTime)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventGap constructs a struct Event.
func NewEventGap(timestamp ClockTime, duration ClockTime) *Event {
	var _arg1 C.GstClockTime // out
	var _arg2 C.GstClockTime // out
	var _cret *C.GstEvent    // in

	_arg1 = C.GstClockTime(timestamp)
	_arg2 = C.GstClockTime(duration)

	_cret = C.gst_event_new_gap(_arg1, _arg2)
	runtime.KeepAlive(timestamp)
	runtime.KeepAlive(duration)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventInstantRateChange constructs a struct Event.
func NewEventInstantRateChange(rateMultiplier float64, newFlags SegmentFlags) *Event {
	var _arg1 C.gdouble         // out
	var _arg2 C.GstSegmentFlags // out
	var _cret *C.GstEvent       // in

	_arg1 = C.gdouble(rateMultiplier)
	_arg2 = C.GstSegmentFlags(newFlags)

	_cret = C.gst_event_new_instant_rate_change(_arg1, _arg2)
	runtime.KeepAlive(rateMultiplier)
	runtime.KeepAlive(newFlags)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventInstantRateSyncTime constructs a struct Event.
func NewEventInstantRateSyncTime(rateMultiplier float64, runningTime ClockTime, upstreamRunningTime ClockTime) *Event {
	var _arg1 C.gdouble      // out
	var _arg2 C.GstClockTime // out
	var _arg3 C.GstClockTime // out
	var _cret *C.GstEvent    // in

	_arg1 = C.gdouble(rateMultiplier)
	_arg2 = C.GstClockTime(runningTime)
	_arg3 = C.GstClockTime(upstreamRunningTime)

	_cret = C.gst_event_new_instant_rate_sync_time(_arg1, _arg2, _arg3)
	runtime.KeepAlive(rateMultiplier)
	runtime.KeepAlive(runningTime)
	runtime.KeepAlive(upstreamRunningTime)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventLatency constructs a struct Event.
func NewEventLatency(latency ClockTime) *Event {
	var _arg1 C.GstClockTime // out
	var _cret *C.GstEvent    // in

	_arg1 = C.GstClockTime(latency)

	_cret = C.gst_event_new_latency(_arg1)
	runtime.KeepAlive(latency)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventNavigation constructs a struct Event.
func NewEventNavigation(structure *Structure) *Event {
	var _arg1 *C.GstStructure // out
	var _cret *C.GstEvent     // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(structure)), nil)

	_cret = C.gst_event_new_navigation(_arg1)
	runtime.KeepAlive(structure)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventProtection constructs a struct Event.
func NewEventProtection(systemId string, data *Buffer, origin string) *Event {
	var _arg1 *C.gchar     // out
	var _arg2 *C.GstBuffer // out
	var _arg3 *C.gchar     // out
	var _cret *C.GstEvent  // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(systemId)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(data)))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(origin)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gst_event_new_protection(_arg1, _arg2, _arg3)
	runtime.KeepAlive(systemId)
	runtime.KeepAlive(data)
	runtime.KeepAlive(origin)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventQos constructs a struct Event.
func NewEventQos(typ QOSType, proportion float64, diff ClockTimeDiff, timestamp ClockTime) *Event {
	var _arg1 C.GstQOSType       // out
	var _arg2 C.gdouble          // out
	var _arg3 C.GstClockTimeDiff // out
	var _arg4 C.GstClockTime     // out
	var _cret *C.GstEvent        // in

	_arg1 = C.GstQOSType(typ)
	_arg2 = C.gdouble(proportion)
	_arg3 = C.GstClockTimeDiff(diff)
	_arg4 = C.GstClockTime(timestamp)

	_cret = C.gst_event_new_qos(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(proportion)
	runtime.KeepAlive(diff)
	runtime.KeepAlive(timestamp)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventReconfigure constructs a struct Event.
func NewEventReconfigure() *Event {
	var _cret *C.GstEvent // in

	_cret = C.gst_event_new_reconfigure()

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventSeek constructs a struct Event.
func NewEventSeek(rate float64, format Format, flags SeekFlags, startType SeekType, start int64, stopType SeekType, stop int64) *Event {
	var _arg1 C.gdouble      // out
	var _arg2 C.GstFormat    // out
	var _arg3 C.GstSeekFlags // out
	var _arg4 C.GstSeekType  // out
	var _arg5 C.gint64       // out
	var _arg6 C.GstSeekType  // out
	var _arg7 C.gint64       // out
	var _cret *C.GstEvent    // in

	_arg1 = C.gdouble(rate)
	_arg2 = C.GstFormat(format)
	_arg3 = C.GstSeekFlags(flags)
	_arg4 = C.GstSeekType(startType)
	_arg5 = C.gint64(start)
	_arg6 = C.GstSeekType(stopType)
	_arg7 = C.gint64(stop)

	_cret = C.gst_event_new_seek(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(rate)
	runtime.KeepAlive(format)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(startType)
	runtime.KeepAlive(start)
	runtime.KeepAlive(stopType)
	runtime.KeepAlive(stop)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventSegment constructs a struct Event.
func NewEventSegment(segment *Segment) *Event {
	var _arg1 *C.GstSegment // out
	var _cret *C.GstEvent   // in

	_arg1 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))

	_cret = C.gst_event_new_segment(_arg1)
	runtime.KeepAlive(segment)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventSegmentDone constructs a struct Event.
func NewEventSegmentDone(format Format, position int64) *Event {
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // out
	var _cret *C.GstEvent // in

	_arg1 = C.GstFormat(format)
	_arg2 = C.gint64(position)

	_cret = C.gst_event_new_segment_done(_arg1, _arg2)
	runtime.KeepAlive(format)
	runtime.KeepAlive(position)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventSelectStreams constructs a struct Event.
func NewEventSelectStreams(streams []string) *Event {
	var _arg1 *C.GList    // out
	var _cret *C.GstEvent // in

	for i := len(streams) - 1; i >= 0; i-- {
		src := streams[i]
		var dst *C.gchar // out
		dst = (*C.gchar)(unsafe.Pointer(C.CString(src)))
		defer C.free(unsafe.Pointer(dst))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg1)

	_cret = C.gst_event_new_select_streams(_arg1)
	runtime.KeepAlive(streams)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventSinkMessage constructs a struct Event.
func NewEventSinkMessage(name string, msg *Message) *Event {
	var _arg1 *C.gchar      // out
	var _arg2 *C.GstMessage // out
	var _cret *C.GstEvent   // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(msg)))

	_cret = C.gst_event_new_sink_message(_arg1, _arg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(msg)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventStep constructs a struct Event.
func NewEventStep(format Format, amount uint64, rate float64, flush bool, intermediate bool) *Event {
	var _arg1 C.GstFormat // out
	var _arg2 C.guint64   // out
	var _arg3 C.gdouble   // out
	var _arg4 C.gboolean  // out
	var _arg5 C.gboolean  // out
	var _cret *C.GstEvent // in

	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(amount)
	_arg3 = C.gdouble(rate)
	if flush {
		_arg4 = C.TRUE
	}
	if intermediate {
		_arg5 = C.TRUE
	}

	_cret = C.gst_event_new_step(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(format)
	runtime.KeepAlive(amount)
	runtime.KeepAlive(rate)
	runtime.KeepAlive(flush)
	runtime.KeepAlive(intermediate)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventStreamCollection constructs a struct Event.
func NewEventStreamCollection(collection *StreamCollection) *Event {
	var _arg1 *C.GstStreamCollection // out
	var _cret *C.GstEvent            // in

	_arg1 = (*C.GstStreamCollection)(unsafe.Pointer(coreglib.InternObject(collection).Native()))

	_cret = C.gst_event_new_stream_collection(_arg1)
	runtime.KeepAlive(collection)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventStreamGroupDone constructs a struct Event.
func NewEventStreamGroupDone(groupId uint) *Event {
	var _arg1 C.guint     // out
	var _cret *C.GstEvent // in

	_arg1 = C.guint(groupId)

	_cret = C.gst_event_new_stream_group_done(_arg1)
	runtime.KeepAlive(groupId)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventStreamStart constructs a struct Event.
func NewEventStreamStart(streamId string) *Event {
	var _arg1 *C.gchar    // out
	var _cret *C.GstEvent // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(streamId)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_event_new_stream_start(_arg1)
	runtime.KeepAlive(streamId)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventTag constructs a struct Event.
func NewEventTag(taglist *TagList) *Event {
	var _arg1 *C.GstTagList // out
	var _cret *C.GstEvent   // in

	_arg1 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(taglist)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(taglist)), nil)

	_cret = C.gst_event_new_tag(_arg1)
	runtime.KeepAlive(taglist)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventToc constructs a struct Event.
func NewEventToc(toc *Toc, updated bool) *Event {
	var _arg1 *C.GstToc   // out
	var _arg2 C.gboolean  // out
	var _cret *C.GstEvent // in

	_arg1 = (*C.GstToc)(gextras.StructNative(unsafe.Pointer(toc)))
	if updated {
		_arg2 = C.TRUE
	}

	_cret = C.gst_event_new_toc(_arg1, _arg2)
	runtime.KeepAlive(toc)
	runtime.KeepAlive(updated)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// NewEventTocSelect constructs a struct Event.
func NewEventTocSelect(uid string) *Event {
	var _arg1 *C.gchar    // out
	var _cret *C.GstEvent // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uid)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_event_new_toc_select(_arg1)
	runtime.KeepAlive(uid)

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _event
}

// MiniObject: parent structure.
func (e *Event) MiniObject() *MiniObject {
	valptr := &e.native.mini_object
	var _v *MiniObject // out
	_v = (*MiniObject)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Type of the event.
func (e *Event) Type() EventType {
	valptr := &e.native._type
	var _v EventType // out
	_v = EventType(*valptr)
	return _v
}

// Timestamp: timestamp of the event.
func (e *Event) Timestamp() uint64 {
	valptr := &e.native.timestamp
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Timestamp: timestamp of the event.
func (e *Event) SetTimestamp(timestamp uint64) {
	valptr := &e.native.timestamp
	*valptr = C.guint64(timestamp)
}

// CopySegment parses a segment event and copies the Segment into the location
// given by segment.
//
// The function takes the following parameters:
//
//   - segment: pointer to a Segment.
func (event *Event) CopySegment(segment *Segment) {
	var _arg0 *C.GstEvent   // out
	var _arg1 *C.GstSegment // out

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	_arg1 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))

	C.gst_event_copy_segment(_arg0, _arg1)
	runtime.KeepAlive(event)
	runtime.KeepAlive(segment)
}

// RunningTimeOffset: retrieve the accumulated running time offset of the event.
//
// Events passing through Pads that have a running time offset set via
// gst_pad_set_offset() will get their offset adjusted according to the pad's
// offset.
//
// If the event contains any information that related to the running time,
// this information will need to be updated before usage with this offset.
//
// The function returns the following values:
//
//   - gint64 event's running time offset
//
//     MT safe.
func (event *Event) RunningTimeOffset() int64 {
	var _arg0 *C.GstEvent // out
	var _cret C.gint64    // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_event_get_running_time_offset(_arg0)
	runtime.KeepAlive(event)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// Seqnum: retrieve the sequence number of a event.
//
// Events have ever-incrementing sequence numbers, which may also be set
// explicitly via gst_event_set_seqnum(). Sequence numbers are typically used to
// indicate that a event corresponds to some other set of events or messages,
// for example an EOS event corresponding to a SEEK event. It is considered
// good practice to make this correspondence when possible, though it is not
// required.
//
// Note that events and messages share the same sequence number incrementor;
// two events or messages will never have the same sequence number unless that
// correspondence was made explicitly.
//
// The function returns the following values:
//
//   - guint32 event's sequence number.
//
//     MT safe.
func (event *Event) Seqnum() uint32 {
	var _arg0 *C.GstEvent // out
	var _cret C.guint32   // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_event_get_seqnum(_arg0)
	runtime.KeepAlive(event)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// Structure access the structure of the event.
//
// The function returns the following values:
//
//   - structure (optional) of the event. The structure is still owned by the
//     event, which means that you should not free it and that the pointer
//     becomes invalid when you free the event.
//
//     MT safe.
func (event *Event) Structure() *Structure {
	var _arg0 *C.GstEvent     // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_event_get_structure(_arg0)
	runtime.KeepAlive(event)

	var _structure *Structure // out

	if _cret != nil {
		_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _structure
}

// HasName checks if event has the given name. This function is usually used to
// check the name of a custom event.
//
// The function takes the following parameters:
//
//   - name to check.
//
// The function returns the following values:
//
//   - ok: TRUE if name matches the name of the event structure.
func (event *Event) HasName(name string) bool {
	var _arg0 *C.GstEvent // out
	var _arg1 *C.gchar    // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_event_has_name(_arg0, _arg1)
	runtime.KeepAlive(event)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasNameID checks if event has the given name. This function is usually used
// to check the name of a custom event.
//
// The function takes the following parameters:
//
//   - name to check as a GQuark.
//
// The function returns the following values:
//
//   - ok: TRUE if name matches the name of the event structure.
func (event *Event) HasNameID(name glib.Quark) bool {
	var _arg0 *C.GstEvent // out
	var _arg1 C.GQuark    // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	_arg1 = C.GQuark(name)

	_cret = C.gst_event_has_name_id(_arg0, _arg1)
	runtime.KeepAlive(event)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ParseBufferSize: get the format, minsize, maxsize and async-flag in the
// buffersize event.
//
// The function returns the following values:
//
//   - format (optional): pointer to store the format in.
//   - minsize (optional): pointer to store the minsize in.
//   - maxsize (optional): pointer to store the maxsize in.
//   - async (optional): pointer to store the async-flag in.
func (event *Event) ParseBufferSize() (format Format, minsize int64, maxsize int64, async bool) {
	var _arg0 *C.GstEvent // out
	var _arg1 C.GstFormat // in
	var _arg2 C.gint64    // in
	var _arg3 C.gint64    // in
	var _arg4 C.gboolean  // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_buffer_size(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(event)

	var _format Format // out
	var _minsize int64 // out
	var _maxsize int64 // out
	var _async bool    // out

	_format = Format(_arg1)
	_minsize = int64(_arg2)
	_maxsize = int64(_arg3)
	if _arg4 != 0 {
		_async = true
	}

	return _format, _minsize, _maxsize, _async
}

// ParseCaps: get the caps from event. The caps remains valid as long as event
// remains valid.
//
// The function returns the following values:
//
//   - caps (optional): pointer to the caps.
func (event *Event) ParseCaps() *Caps {
	var _arg0 *C.GstEvent // out
	var _arg1 *C.GstCaps  // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_caps(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _caps *Caps // out

	if _arg1 != nil {
		_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
	}

	return _caps
}

// ParseFlushStop: parse the FLUSH_STOP event and retrieve the reset_time
// member.
//
// The function returns the following values:
//
//   - resetTime (optional): if time should be reset.
func (event *Event) ParseFlushStop() bool {
	var _arg0 *C.GstEvent // out
	var _arg1 C.gboolean  // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_flush_stop(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _resetTime bool // out

	if _arg1 != 0 {
		_resetTime = true
	}

	return _resetTime
}

// ParseGap: extract timestamp and duration from a new GAP event.
//
// The function returns the following values:
//
//   - timestamp (optional): location where to store the start time (pts) of the
//     gap, or NULL.
//   - duration (optional): location where to store the duration of the gap,
//     or NULL.
func (event *Event) ParseGap() (timestamp ClockTime, duration ClockTime) {
	var _arg0 *C.GstEvent    // out
	var _arg1 C.GstClockTime // in
	var _arg2 C.GstClockTime // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_gap(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(event)

	var _timestamp ClockTime // out
	var _duration ClockTime  // out

	_timestamp = ClockTime(_arg1)
	_duration = ClockTime(_arg2)

	return _timestamp, _duration
}

// ParseGapFlags: retrieve the gap flags that may have been set on a gap event
// with gst_event_set_gap_flags().
//
// The function returns the following values:
//
//   - flags (optional) or NULL.
func (event *Event) ParseGapFlags() GapFlags {
	var _arg0 *C.GstEvent   // out
	var _arg1 C.GstGapFlags // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_gap_flags(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _flags GapFlags // out

	_flags = GapFlags(_arg1)

	return _flags
}

// The function returns the following values:
//
//   - groupId (optional) address of variable where to store the group id.
//   - ok: TRUE if a group id was set on the event and could be parsed, FALSE
//     otherwise.
func (event *Event) ParseGroupID() (uint, bool) {
	var _arg0 *C.GstEvent // out
	var _arg1 C.guint     // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_event_parse_group_id(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _groupId uint // out
	var _ok bool      // out

	_groupId = uint(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _groupId, _ok
}

// ParseInstantRateChange: extract rate and flags from an instant-rate-change
// event.
//
// The function returns the following values:
//
//   - rateMultiplier (optional): location in which to store the rate multiplier
//     of the instant-rate-change event, or NULL.
//   - newFlags (optional): location in which to store the new segment flags of
//     the instant-rate-change event, or NULL.
func (event *Event) ParseInstantRateChange() (float64, SegmentFlags) {
	var _arg0 *C.GstEvent       // out
	var _arg1 C.gdouble         // in
	var _arg2 C.GstSegmentFlags // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_instant_rate_change(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(event)

	var _rateMultiplier float64 // out
	var _newFlags SegmentFlags  // out

	_rateMultiplier = float64(_arg1)
	_newFlags = SegmentFlags(_arg2)

	return _rateMultiplier, _newFlags
}

// ParseInstantRateSyncTime: extract the rate multiplier and running times from
// an instant-rate-sync-time event.
//
// The function returns the following values:
//
//   - rateMultiplier (optional): location where to store the rate of the
//     instant-rate-sync-time event, or NULL.
//   - runningTime (optional): location in which to store the running time of
//     the instant-rate-sync-time event, or NULL.
//   - upstreamRunningTime (optional): location in which to store the upstream
//     running time of the instant-rate-sync-time event, or NULL.
func (event *Event) ParseInstantRateSyncTime() (rateMultiplier float64, runningTime ClockTime, upstreamRunningTime ClockTime) {
	var _arg0 *C.GstEvent    // out
	var _arg1 C.gdouble      // in
	var _arg2 C.GstClockTime // in
	var _arg3 C.GstClockTime // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_instant_rate_sync_time(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(event)

	var _rateMultiplier float64        // out
	var _runningTime ClockTime         // out
	var _upstreamRunningTime ClockTime // out

	_rateMultiplier = float64(_arg1)
	_runningTime = ClockTime(_arg2)
	_upstreamRunningTime = ClockTime(_arg3)

	return _rateMultiplier, _runningTime, _upstreamRunningTime
}

// ParseLatency: get the latency in the latency event.
//
// The function returns the following values:
//
//   - latency (optional): pointer to store the latency in.
func (event *Event) ParseLatency() ClockTime {
	var _arg0 *C.GstEvent    // out
	var _arg1 C.GstClockTime // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_latency(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _latency ClockTime // out

	_latency = ClockTime(_arg1)

	return _latency
}

// ParseProtection parses an event containing protection system specific
// information and stores the results in system_id, data and origin. The data
// stored in system_id, origin and data are valid until event is released.
//
// The function returns the following values:
//
//   - systemId (optional): pointer to store the UUID string uniquely
//     identifying a content protection system.
//   - data (optional): pointer to store a Buffer holding protection system
//     specific information.
//   - origin (optional): pointer to store a value that indicates where the
//     protection information carried by event was extracted from.
func (event *Event) ParseProtection() (systemId string, data *Buffer, origin string) {
	var _arg0 *C.GstEvent  // out
	var _arg1 *C.gchar     // in
	var _arg2 *C.GstBuffer // in
	var _arg3 *C.gchar     // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_protection(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(event)

	var _systemId string // out
	var _data *Buffer    // out
	var _origin string   // out

	if _arg1 != nil {
		_systemId = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
	}
	if _arg2 != nil {
		_data = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
	}
	if _arg3 != nil {
		_origin = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
	}

	return _systemId, _data, _origin
}

// ParseQos: get the type, proportion, diff and timestamp in the qos event.
// See gst_event_new_qos() for more information about the different QoS values.
//
// timestamp will be adjusted for any pad offsets of pads it was passing
// through.
//
// The function returns the following values:
//
//   - typ (optional): pointer to store the QoS type in.
//   - proportion (optional): pointer to store the proportion in.
//   - diff (optional): pointer to store the diff in.
//   - timestamp (optional): pointer to store the timestamp in.
func (event *Event) ParseQos() (QOSType, float64, ClockTimeDiff, ClockTime) {
	var _arg0 *C.GstEvent        // out
	var _arg1 C.GstQOSType       // in
	var _arg2 C.gdouble          // in
	var _arg3 C.GstClockTimeDiff // in
	var _arg4 C.GstClockTime     // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_qos(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(event)

	var _typ QOSType         // out
	var _proportion float64  // out
	var _diff ClockTimeDiff  // out
	var _timestamp ClockTime // out

	_typ = QOSType(_arg1)
	_proportion = float64(_arg2)
	_diff = ClockTimeDiff(_arg3)
	_timestamp = ClockTime(_arg4)

	return _typ, _proportion, _diff, _timestamp
}

// ParseSeek parses a seek event and stores the results in the given result
// locations.
//
// The function returns the following values:
//
//   - rate (optional): result location for the rate.
//   - format (optional): result location for the stream format.
//   - flags (optional): result location for the SeekFlags.
//   - startType (optional): result location for the SeekType of the start
//     position.
//   - start (optional): result location for the start position expressed in
//     format.
//   - stopType (optional): result location for the SeekType of the stop
//     position.
//   - stop (optional): result location for the stop position expressed in
//     format.
func (event *Event) ParseSeek() (rate float64, format Format, flags SeekFlags, startType SeekType, start int64, stopType SeekType, stop int64) {
	var _arg0 *C.GstEvent    // out
	var _arg1 C.gdouble      // in
	var _arg2 C.GstFormat    // in
	var _arg3 C.GstSeekFlags // in
	var _arg4 C.GstSeekType  // in
	var _arg5 C.gint64       // in
	var _arg6 C.GstSeekType  // in
	var _arg7 C.gint64       // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_seek(_arg0, &_arg1, &_arg2, &_arg3, &_arg4, &_arg5, &_arg6, &_arg7)
	runtime.KeepAlive(event)

	var _rate float64       // out
	var _format Format      // out
	var _flags SeekFlags    // out
	var _startType SeekType // out
	var _start int64        // out
	var _stopType SeekType  // out
	var _stop int64         // out

	_rate = float64(_arg1)
	_format = Format(_arg2)
	_flags = SeekFlags(_arg3)
	_startType = SeekType(_arg4)
	_start = int64(_arg5)
	_stopType = SeekType(_arg6)
	_stop = int64(_arg7)

	return _rate, _format, _flags, _startType, _start, _stopType, _stop
}

// ParseSeekTrickmodeInterval: retrieve the trickmode interval that may have
// been set on a seek event with gst_event_set_seek_trickmode_interval().
//
// The function returns the following values:
//
//   - interval (optional): interval.
func (event *Event) ParseSeekTrickmodeInterval() ClockTime {
	var _arg0 *C.GstEvent    // out
	var _arg1 C.GstClockTime // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_seek_trickmode_interval(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _interval ClockTime // out

	_interval = ClockTime(_arg1)

	return _interval
}

// ParseSegment parses a segment event and stores the result in the given
// segment location. segment remains valid only until the event is freed.
// Don't modify the segment and make a copy if you want to modify it or store it
// for later use.
//
// The function returns the following values:
//
//   - segment (optional): pointer to a Segment.
func (event *Event) ParseSegment() *Segment {
	var _arg0 *C.GstEvent   // out
	var _arg1 *C.GstSegment // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_segment(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _segment *Segment // out

	if _arg1 != nil {
		_segment = (*Segment)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
	}

	return _segment
}

// ParseSegmentDone extracts the position and format from the segment done
// message.
//
// The function returns the following values:
//
//   - format (optional): result location for the format, or NULL.
//   - position (optional): result location for the position, or NULL.
func (event *Event) ParseSegmentDone() (Format, int64) {
	var _arg0 *C.GstEvent // out
	var _arg1 C.GstFormat // in
	var _arg2 C.gint64    // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_segment_done(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(event)

	var _format Format  // out
	var _position int64 // out

	_format = Format(_arg1)
	_position = int64(_arg2)

	return _format, _position
}

// ParseSelectStreams: parse the SELECT_STREAMS event and retrieve the contained
// streams.
//
// The function returns the following values:
//
//   - streams (optional): streams.
func (event *Event) ParseSelectStreams() []string {
	var _arg0 *C.GstEvent // out
	var _arg1 *C.GList    // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_select_streams(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _streams []string // out

	if _arg1 != nil {
		_streams = make([]string, 0, gextras.ListSize(unsafe.Pointer(_arg1)))
		gextras.MoveList(unsafe.Pointer(_arg1), true, func(v unsafe.Pointer) {
			src := (*C.gchar)(v)
			var dst string // out
			dst = C.GoString((*C.gchar)(unsafe.Pointer(src)))
			_streams = append(_streams, dst)
		})
	}

	return _streams
}

// ParseSinkMessage: parse the sink-message event. Unref msg after usage.
//
// The function returns the following values:
//
//   - msg (optional): pointer to store the Message in.
func (event *Event) ParseSinkMessage() *Message {
	var _arg0 *C.GstEvent   // out
	var _arg1 *C.GstMessage // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_sink_message(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _msg *Message // out

	if _arg1 != nil {
		_msg = (*Message)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_msg)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _msg
}

// ParseStep: parse the step event.
//
// The function returns the following values:
//
//   - format (optional): pointer to store the format in.
//   - amount (optional): pointer to store the amount in.
//   - rate (optional): pointer to store the rate in.
//   - flush (optional): pointer to store the flush boolean in.
//   - intermediate (optional): pointer to store the intermediate boolean in.
func (event *Event) ParseStep() (format Format, amount uint64, rate float64, flush bool, intermediate bool) {
	var _arg0 *C.GstEvent // out
	var _arg1 C.GstFormat // in
	var _arg2 C.guint64   // in
	var _arg3 C.gdouble   // in
	var _arg4 C.gboolean  // in
	var _arg5 C.gboolean  // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_step(_arg0, &_arg1, &_arg2, &_arg3, &_arg4, &_arg5)
	runtime.KeepAlive(event)

	var _format Format     // out
	var _amount uint64     // out
	var _rate float64      // out
	var _flush bool        // out
	var _intermediate bool // out

	_format = Format(_arg1)
	_amount = uint64(_arg2)
	_rate = float64(_arg3)
	if _arg4 != 0 {
		_flush = true
	}
	if _arg5 != 0 {
		_intermediate = true
	}

	return _format, _amount, _rate, _flush, _intermediate
}

// ParseStream: parse a stream-start event and extract the Stream from it.
//
// The function returns the following values:
//
//   - stream (optional) address of variable to store the stream.
func (event *Event) ParseStream() *Stream {
	var _arg0 *C.GstEvent  // out
	var _arg1 *C.GstStream // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_stream(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _stream *Stream // out

	if _arg1 != nil {
		_stream = wrapStream(coreglib.AssumeOwnership(unsafe.Pointer(_arg1)))
	}

	return _stream
}

// ParseStreamCollection: retrieve new StreamCollection from STREAM_COLLECTION
// event event.
//
// The function returns the following values:
//
//   - collection (optional): pointer to store the collection.
func (event *Event) ParseStreamCollection() *StreamCollection {
	var _arg0 *C.GstEvent            // out
	var _arg1 *C.GstStreamCollection // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_stream_collection(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _collection *StreamCollection // out

	if _arg1 != nil {
		_collection = wrapStreamCollection(coreglib.AssumeOwnership(unsafe.Pointer(_arg1)))
	}

	return _collection
}

// The function returns the following values:
//
//   - flags (optional) address of variable where to store the stream flags.
func (event *Event) ParseStreamFlags() StreamFlags {
	var _arg0 *C.GstEvent      // out
	var _arg1 C.GstStreamFlags // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_stream_flags(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _flags StreamFlags // out

	_flags = StreamFlags(_arg1)

	return _flags
}

// ParseStreamGroupDone: parse a stream-group-done event and store the result in
// the given group_id location.
//
// The function returns the following values:
//
//   - groupId (optional) address of variable to store the group id into.
func (event *Event) ParseStreamGroupDone() uint {
	var _arg0 *C.GstEvent // out
	var _arg1 C.guint     // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_stream_group_done(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _groupId uint // out

	_groupId = uint(_arg1)

	return _groupId
}

// ParseStreamStart: parse a stream-id event and store the result in the given
// stream_id location. The string stored in stream_id must not be modified and
// will remain valid only until event gets freed. Make a copy if you want to
// modify it or store it for later use.
//
// The function returns the following values:
//
//   - streamId (optional): pointer to store the stream-id.
func (event *Event) ParseStreamStart() string {
	var _arg0 *C.GstEvent // out
	var _arg1 *C.gchar    // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_stream_start(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _streamId string // out

	if _arg1 != nil {
		_streamId = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
	}

	return _streamId
}

// ParseTag parses a tag event and stores the results in the given taglist
// location. No reference to the taglist will be returned, it remains valid only
// until the event is freed. Don't modify or free the taglist, make a copy if
// you want to modify it or store it for later use.
//
// The function returns the following values:
//
//   - taglist (optional): pointer to metadata list.
func (event *Event) ParseTag() *TagList {
	var _arg0 *C.GstEvent   // out
	var _arg1 *C.GstTagList // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_tag(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _taglist *TagList // out

	if _arg1 != nil {
		_taglist = (*TagList)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
	}

	return _taglist
}

// ParseToc: parse a TOC event and store the results in the given toc and
// updated locations.
//
// The function returns the following values:
//
//   - toc (optional): pointer to Toc structure.
//   - updated (optional): pointer to store TOC updated flag.
func (event *Event) ParseToc() (*Toc, bool) {
	var _arg0 *C.GstEvent // out
	var _arg1 *C.GstToc   // in
	var _arg2 C.gboolean  // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_toc(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(event)

	var _toc *Toc     // out
	var _updated bool // out

	if _arg1 != nil {
		_toc = (*Toc)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_toc)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}
	if _arg2 != 0 {
		_updated = true
	}

	return _toc, _updated
}

// ParseTocSelect: parse a TOC select event and store the results in the given
// uid location.
//
// The function returns the following values:
//
//   - uid (optional): storage for the selection UID.
func (event *Event) ParseTocSelect() string {
	var _arg0 *C.GstEvent // out
	var _arg1 *C.gchar    // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gst_event_parse_toc_select(_arg0, &_arg1)
	runtime.KeepAlive(event)

	var _uid string // out

	if _arg1 != nil {
		_uid = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	return _uid
}

// SetGapFlags sets flags on event to give additional information about the
// reason for the T_EVENT_GAP.
//
// The function takes the following parameters:
//
//   - flags: GapFlags.
func (event *Event) SetGapFlags(flags GapFlags) {
	var _arg0 *C.GstEvent   // out
	var _arg1 C.GstGapFlags // out

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	_arg1 = C.GstGapFlags(flags)

	C.gst_event_set_gap_flags(_arg0, _arg1)
	runtime.KeepAlive(event)
	runtime.KeepAlive(flags)
}

// SetGroupID: all streams that have the same group id are supposed to be played
// together, i.e. all streams inside a container file should have the same group
// id but different stream ids. The group id should change each time the stream
// is started, resulting in different group ids each time a file is played for
// example.
//
// Use gst_util_group_id_next() to get a new group id.
//
// The function takes the following parameters:
//
//   - groupId: group id to set.
func (event *Event) SetGroupID(groupId uint) {
	var _arg0 *C.GstEvent // out
	var _arg1 C.guint     // out

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	_arg1 = C.guint(groupId)

	C.gst_event_set_group_id(_arg0, _arg1)
	runtime.KeepAlive(event)
	runtime.KeepAlive(groupId)
}

// SetRunningTimeOffset: set the running time offset of a event. See
// gst_event_get_running_time_offset() for more information.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - offset: the new running time offset.
func (event *Event) SetRunningTimeOffset(offset int64) {
	var _arg0 *C.GstEvent // out
	var _arg1 C.gint64    // out

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	_arg1 = C.gint64(offset)

	C.gst_event_set_running_time_offset(_arg0, _arg1)
	runtime.KeepAlive(event)
	runtime.KeepAlive(offset)
}

// SetSeekTrickmodeInterval sets a trickmode interval on a (writable) seek
// event. Elements that support TRICKMODE_KEY_UNITS seeks SHOULD use this as the
// minimal interval between each frame they may output.
func (event *Event) SetSeekTrickmodeInterval(interval ClockTime) {
	var _arg0 *C.GstEvent    // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	_arg1 = C.GstClockTime(interval)

	C.gst_event_set_seek_trickmode_interval(_arg0, _arg1)
	runtime.KeepAlive(event)
	runtime.KeepAlive(interval)
}

// SetSeqnum: set the sequence number of a event.
//
// This function might be called by the creator of a event to indicate that the
// event relates to other events or messages. See gst_event_get_seqnum() for
// more information.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - seqnum: sequence number.
func (event *Event) SetSeqnum(seqnum uint32) {
	var _arg0 *C.GstEvent // out
	var _arg1 C.guint32   // out

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	_arg1 = C.guint32(seqnum)

	C.gst_event_set_seqnum(_arg0, _arg1)
	runtime.KeepAlive(event)
	runtime.KeepAlive(seqnum)
}

// SetStream: set the stream on the stream-start event.
//
// The function takes the following parameters:
//
//   - stream object to set.
func (event *Event) SetStream(stream *Stream) {
	var _arg0 *C.GstEvent  // out
	var _arg1 *C.GstStream // out

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	_arg1 = (*C.GstStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	C.gst_event_set_stream(_arg0, _arg1)
	runtime.KeepAlive(event)
	runtime.KeepAlive(stream)
}

// The function takes the following parameters:
//
//   - flags: stream flags to set.
func (event *Event) SetStreamFlags(flags StreamFlags) {
	var _arg0 *C.GstEvent      // out
	var _arg1 C.GstStreamFlags // out

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	_arg1 = C.GstStreamFlags(flags)

	C.gst_event_set_stream_flags(_arg0, _arg1)
	runtime.KeepAlive(event)
	runtime.KeepAlive(flags)
}

// WritableStructure: get a writable version of the structure.
//
// The function returns the following values:
//
//   - structure of the event. The structure is still owned by the event, which
//     means that you should not free it and that the pointer becomes invalid
//     when you free the event. This function ensures that event is writable,
//     and if so, will never return NULL.
//
//     MT safe.
func (event *Event) WritableStructure() *Structure {
	var _arg0 *C.GstEvent     // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gst_event_writable_structure(_arg0)
	runtime.KeepAlive(event)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _structure
}

// FormatDefinition: format definition
//
// An instance of this type is always passed by reference.
type FormatDefinition struct {
	*formatDefinition
}

// formatDefinition is the struct that's finalized.
type formatDefinition struct {
	native *C.GstFormatDefinition
}

// Value: unique id of this format.
func (f *FormatDefinition) Value() Format {
	valptr := &f.native.value
	var _v Format // out
	_v = Format(*valptr)
	return _v
}

// Nick: short nick of the format.
func (f *FormatDefinition) Nick() string {
	valptr := &f.native.nick
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Description: longer description of the format.
func (f *FormatDefinition) Description() string {
	valptr := &f.native.description
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Quark: quark for the nick.
func (f *FormatDefinition) Quark() glib.Quark {
	valptr := &f.native.quark
	var _v glib.Quark // out
	_v = glib.Quark(*valptr)
	return _v
}

// GhostPadClass: instance of this type is always passed by reference.
type GhostPadClass struct {
	*ghostPadClass
}

// ghostPadClass is the struct that's finalized.
type ghostPadClass struct {
	native *C.GstGhostPadClass
}

func (g *GhostPadClass) ParentClass() *ProxyPadClass {
	valptr := &g.native.parent_class
	var _v *ProxyPadClass // out
	_v = (*ProxyPadClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Iterator is used to retrieve multiple objects from another object in a
// threadsafe way.
//
// Various GStreamer objects provide access to their internal structures using
// an iterator.
//
// Note that if calling a GstIterator function results in your code receiving
// a refcounted object (with, say, g_value_get_object()), the refcount for that
// object will not be increased. Your code is responsible for taking a reference
// if it wants to continue using it later.
//
// The basic use pattern of an iterator is as follows:
//
//	GstIterator *it = _get_iterator(object);
//	GValue item = G_VALUE_INIT;
//	done = FALSE;
//	while (!done) {
//	  switch (gst_iterator_next (it, &item)) {
//	    case GST_ITERATOR_OK:
//	      ...get/use/change item here...
//	      g_value_reset (&item);
//	      break;
//	    case GST_ITERATOR_RESYNC:
//	      ...rollback changes to items...
//	      gst_iterator_resync (it);
//	      break;
//	    case GST_ITERATOR_ERROR:
//	      ...wrong parameters were given...
//	      done = TRUE;
//	      break;
//	    case GST_ITERATOR_DONE:
//	      done = TRUE;
//	      break;
//	  }
//	}
//	g_value_unset (&item);
//	gst_iterator_free (it);
//
// An instance of this type is always passed by reference.
type Iterator struct {
	*iterator
}

// iterator is the struct that's finalized.
type iterator struct {
	native *C.GstIterator
}

func marshalIterator(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Iterator{&iterator{(*C.GstIterator)(b)}}, nil
}

// NewIteratorSingle constructs a struct Iterator.
func NewIteratorSingle(typ coreglib.Type, object *coreglib.Value) *Iterator {
	var _arg1 C.GType        // out
	var _arg2 *C.GValue      // out
	var _cret *C.GstIterator // in

	_arg1 = C.GType(typ)
	_arg2 = (*C.GValue)(unsafe.Pointer(object.Native()))

	_cret = C.gst_iterator_new_single(_arg1, _arg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(object)

	var _iterator *Iterator // out

	_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iterator)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_iterator_free((*C.GstIterator)(intern.C))
		},
	)

	return _iterator
}

// Copy the iterator and its state.
//
// The function returns the following values:
//
//   - iterator: new copy of it.
func (it *Iterator) Copy() *Iterator {
	var _arg0 *C.GstIterator // out
	var _cret *C.GstIterator // in

	_arg0 = (*C.GstIterator)(gextras.StructNative(unsafe.Pointer(it)))

	_cret = C.gst_iterator_copy(_arg0)
	runtime.KeepAlive(it)

	var _iterator *Iterator // out

	_iterator = (*Iterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iterator)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_iterator_free((*C.GstIterator)(intern.C))
		},
	)

	return _iterator
}

// Fold folds func over the elements of iter. That is to say, func will be
// called as func (object, ret, user_data) for each object in it. The normal use
// of this procedure is to accumulate the results of operating on the objects in
// ret.
//
// This procedure can be used (and is used internally) to implement the
// gst_iterator_foreach() and gst_iterator_find_custom() operations.
//
// The fold will proceed as long as func returns TRUE. When the iterator has no
// more arguments, GST_ITERATOR_DONE will be returned. If func returns FALSE,
// the fold will stop, and GST_ITERATOR_OK will be returned. Errors or resyncs
// will cause fold to return GST_ITERATOR_ERROR or GST_ITERATOR_RESYNC as
// appropriate.
//
// The iterator will not be freed.
//
// The function takes the following parameters:
//
//   - fn: fold function.
//   - ret: seed value passed to the fold function.
//
// The function returns the following values:
//
//   - iteratorResult as described above.
//
//     MT safe.
func (it *Iterator) Fold(fn IteratorFoldFunction, ret *coreglib.Value) IteratorResult {
	var _arg0 *C.GstIterator            // out
	var _arg1 C.GstIteratorFoldFunction // out
	var _arg3 C.gpointer
	var _arg2 *C.GValue           // out
	var _cret C.GstIteratorResult // in

	_arg0 = (*C.GstIterator)(gextras.StructNative(unsafe.Pointer(it)))
	_arg1 = (*[0]byte)(C._gotk4_gst1_IteratorFoldFunction)
	_arg3 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg3))
	_arg2 = (*C.GValue)(unsafe.Pointer(ret.Native()))

	_cret = C.gst_iterator_fold(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(it)
	runtime.KeepAlive(fn)
	runtime.KeepAlive(ret)

	var _iteratorResult IteratorResult // out

	_iteratorResult = IteratorResult(_cret)

	return _iteratorResult
}

// ForEach: iterate over all element of it and call the given function func for
// each element.
//
// The function takes the following parameters:
//
//   - fn: function to call for each element.
//
// The function returns the following values:
//
//   - iteratorResult: result call to gst_iterator_fold(). The iterator will not
//     be freed.
//
//     MT safe.
func (it *Iterator) ForEach(fn IteratorForEachFunction) IteratorResult {
	var _arg0 *C.GstIterator               // out
	var _arg1 C.GstIteratorForeachFunction // out
	var _arg2 C.gpointer
	var _cret C.GstIteratorResult // in

	_arg0 = (*C.GstIterator)(gextras.StructNative(unsafe.Pointer(it)))
	_arg1 = (*[0]byte)(C._gotk4_gst1_IteratorForEachFunction)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.gst_iterator_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(it)
	runtime.KeepAlive(fn)

	var _iteratorResult IteratorResult // out

	_iteratorResult = IteratorResult(_cret)

	return _iteratorResult
}

// Next: get the next item from the iterator in elem.
//
// Only when this function returns GST_ITERATOR_OK, elem will contain a valid
// value. elem must have been initialized to the type of the iterator or
// initialized to zeroes with g_value_unset(). The caller is responsible for
// unsetting or resetting elem with g_value_unset() or g_value_reset() after
// usage.
//
// When this function returns GST_ITERATOR_DONE, no more elements can be
// retrieved from it.
//
// A return value of GST_ITERATOR_RESYNC indicates that the element list was
// concurrently updated. The user of it should call gst_iterator_resync() to get
// the newly updated list.
//
// A return value of GST_ITERATOR_ERROR indicates an unrecoverable fatal error.
//
// The function returns the following values:
//
//   - elem: pointer to hold next element.
//
//   - iteratorResult: result of the iteration. Unset elem after usage.
//
//     MT safe.
func (it *Iterator) Next() (coreglib.Value, IteratorResult) {
	var _arg0 *C.GstIterator      // out
	var _arg1 C.GValue            // in
	var _cret C.GstIteratorResult // in

	_arg0 = (*C.GstIterator)(gextras.StructNative(unsafe.Pointer(it)))

	_cret = C.gst_iterator_next(_arg0, &_arg1)
	runtime.KeepAlive(it)

	var _elem coreglib.Value           // out
	var _iteratorResult IteratorResult // out

	_elem = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))
	_iteratorResult = IteratorResult(_cret)

	return _elem, _iteratorResult
}

// Push pushes other iterator onto it. All calls performed on it are forwarded
// to other. If other returns GST_ITERATOR_DONE, it is popped again and calls
// are handled by it again.
//
// This function is mainly used by objects implementing the iterator next
// function to recurse into substructures.
//
// When gst_iterator_resync() is called on it, other will automatically be
// popped.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - other to push.
func (it *Iterator) Push(other *Iterator) {
	var _arg0 *C.GstIterator // out
	var _arg1 *C.GstIterator // out

	_arg0 = (*C.GstIterator)(gextras.StructNative(unsafe.Pointer(it)))
	_arg1 = (*C.GstIterator)(gextras.StructNative(unsafe.Pointer(other)))

	C.gst_iterator_push(_arg0, _arg1)
	runtime.KeepAlive(it)
	runtime.KeepAlive(other)
}

// Resync the iterator. this function is mostly called after gst_iterator_next()
// returned GST_ITERATOR_RESYNC.
//
// When an iterator was pushed on it, it will automatically be popped again with
// this function.
//
// MT safe.
func (it *Iterator) Resync() {
	var _arg0 *C.GstIterator // out

	_arg0 = (*C.GstIterator)(gextras.StructNative(unsafe.Pointer(it)))

	C.gst_iterator_resync(_arg0)
	runtime.KeepAlive(it)
}

// MapInfo: structure containing the result of a map operation such as
// gst_memory_map(). It contains the data and size.
//
// MapInfo cannot be used with g_auto() because it is ambiguous whether it
// needs to be unmapped using gst_buffer_unmap() or gst_memory_unmap(). Instead,
// BufferMapInfo and MemoryMapInfo can be used in that case.
//
// An instance of this type is always passed by reference.
type MapInfo struct {
	*mapInfo
}

// mapInfo is the struct that's finalized.
type mapInfo struct {
	native *C.GstMapInfo
}

// Memory is a lightweight refcounted object that wraps a region of memory.
// They are typically used to manage the data of a Buffer.
//
// A GstMemory object has an allocated region of memory of maxsize. The maximum
// size does not change during the lifetime of the memory object. The memory
// also has an offset and size property that specifies the valid range of memory
// in the allocated region.
//
// Memory is usually created by allocators with a gst_allocator_alloc() method
// call. When NULL is used as the allocator, the default allocator will be used.
//
// New allocators can be registered with gst_allocator_register(). Allocators
// are identified by name and can be retrieved with gst_allocator_find().
// gst_allocator_set_default() can be used to change the default allocator.
//
// New memory can be created with gst_memory_new_wrapped() that wraps the memory
// allocated elsewhere.
//
// Refcounting of the memory block is performed with gst_memory_ref() and
// gst_memory_unref().
//
// The size of the memory can be retrieved and changed with
// gst_memory_get_sizes() and gst_memory_resize() respectively.
//
// Getting access to the data of the memory is performed with gst_memory_map().
// The call will return a pointer to offset bytes into the region of memory.
// After the memory access is completed, gst_memory_unmap() should be called.
//
// Memory can be copied with gst_memory_copy(), which will return a writable
// copy. gst_memory_share() will create a new memory block that shares the
// memory with an existing memory block at a custom offset and with a custom
// size.
//
// Memory can be efficiently merged when gst_memory_is_span() returns TRUE.
//
// An instance of this type is always passed by reference.
type Memory struct {
	*memory
}

// memory is the struct that's finalized.
type memory struct {
	native *C.GstMemory
}

func marshalMemory(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Memory{&memory{(*C.GstMemory)(b)}}, nil
}

// MiniObject: parent structure.
func (m *Memory) MiniObject() *MiniObject {
	valptr := &m.native.mini_object
	var _v *MiniObject // out
	_v = (*MiniObject)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Allocator: pointer to the Allocator.
func (m *Memory) Allocator() Allocatorrer {
	valptr := &m.native.allocator
	var _v Allocatorrer // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gst.Allocatorrer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Allocatorrer)
			return ok
		})
		rv, ok := casted.(Allocatorrer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Allocatorrer")
		}
		_v = rv
	}
	return _v
}

// Parent: parent memory block.
func (m *Memory) Parent() *Memory {
	valptr := &m.native.parent
	var _v *Memory // out
	_v = (*Memory)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// Maxsize: maximum size allocated.
func (m *Memory) Maxsize() uint {
	valptr := &m.native.maxsize
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Align: alignment of the memory.
func (m *Memory) Align() uint {
	valptr := &m.native.align
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Offset: offset where valid data starts.
func (m *Memory) Offset() uint {
	valptr := &m.native.offset
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Size: size of valid data.
func (m *Memory) Size() uint {
	valptr := &m.native.size
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Maxsize: maximum size allocated.
func (m *Memory) SetMaxsize(maxsize uint) {
	valptr := &m.native.maxsize
	*valptr = C.gsize(maxsize)
}

// Align: alignment of the memory.
func (m *Memory) SetAlign(align uint) {
	valptr := &m.native.align
	*valptr = C.gsize(align)
}

// Offset: offset where valid data starts.
func (m *Memory) SetOffset(offset uint) {
	valptr := &m.native.offset
	*valptr = C.gsize(offset)
}

// Size: size of valid data.
func (m *Memory) SetSize(size uint) {
	valptr := &m.native.size
	*valptr = C.gsize(size)
}

// Copy: return a copy of size bytes from mem starting from offset. This copy is
// guaranteed to be writable. size can be set to -1 to return a copy from offset
// to the end of the memory region.
//
// The function takes the following parameters:
//
//   - offset to copy from.
//   - size to copy, or -1 to copy to the end of the memory region.
//
// The function returns the following values:
//
//   - memory (optional): new copy of mem if the copy succeeded, NULL otherwise.
func (mem *Memory) Copy(offset int, size int) *Memory {
	var _arg0 *C.GstMemory // out
	var _arg1 C.gssize     // out
	var _arg2 C.gssize     // out
	var _cret *C.GstMemory // in

	_arg0 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	_arg1 = C.gssize(offset)
	_arg2 = C.gssize(size)

	_cret = C.gst_memory_copy(_arg0, _arg1, _arg2)
	runtime.KeepAlive(mem)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _memory *Memory // out

	if _cret != nil {
		_memory = (*Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_memory)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _memory
}

// Sizes: get the current size, offset and maxsize of mem.
//
// The function returns the following values:
//
//   - offset (optional): pointer to offset.
//   - maxsize (optional): pointer to maxsize.
//   - gsize: current size of mem.
func (mem *Memory) Sizes() (offset uint, maxsize uint, gsize uint) {
	var _arg0 *C.GstMemory // out
	var _arg1 C.gsize      // in
	var _arg2 C.gsize      // in
	var _cret C.gsize      // in

	_arg0 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))

	_cret = C.gst_memory_get_sizes(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(mem)

	var _offset uint  // out
	var _maxsize uint // out
	var _gsize uint   // out

	_offset = uint(_arg1)
	_maxsize = uint(_arg2)
	_gsize = uint(_cret)

	return _offset, _maxsize, _gsize
}

// IsSpan: check if mem1 and mem2 share the memory with a common parent memory
// object and that the memory is contiguous.
//
// If this is the case, the memory of mem1 and mem2 can be merged efficiently by
// performing gst_memory_share() on the parent object from the returned offset.
//
// The function takes the following parameters:
//
//   - mem2: Memory.
//
// The function returns the following values:
//
//   - offset: pointer to a result offset.
//   - ok: TRUE if the memory is contiguous and of a common parent.
func (mem1 *Memory) IsSpan(mem2 *Memory) (uint, bool) {
	var _arg0 *C.GstMemory // out
	var _arg1 *C.GstMemory // out
	var _arg2 C.gsize      // in
	var _cret C.gboolean   // in

	_arg0 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem1)))
	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem2)))

	_cret = C.gst_memory_is_span(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(mem1)
	runtime.KeepAlive(mem2)

	var _offset uint // out
	var _ok bool     // out

	_offset = uint(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _offset, _ok
}

// IsType: check if mem if allocated with an allocator for mem_type.
//
// The function takes the following parameters:
//
//   - memType: memory type.
//
// The function returns the following values:
//
//   - ok: TRUE if mem was allocated from an allocator for mem_type.
func (mem *Memory) IsType(memType string) bool {
	var _arg0 *C.GstMemory // out
	var _arg1 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(memType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_memory_is_type(_arg0, _arg1)
	runtime.KeepAlive(mem)
	runtime.KeepAlive(memType)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MakeMapped: create a Memory object that is mapped with flags. If mem is
// mappable with flags, this function returns the mapped mem directly. Otherwise
// a mapped copy of mem is returned.
//
// This function takes ownership of old mem and returns a reference to a new
// Memory.
//
// The function takes the following parameters:
//
//   - flags: mapping flags.
//
// The function returns the following values:
//
//   - info: pointer for info.
//   - memory (optional) object mapped with flags or NULL when a mapping is not
//     possible.
func (mem *Memory) MakeMapped(flags MapFlags) (*MapInfo, *Memory) {
	var _arg0 *C.GstMemory  // out
	var _arg1 C.GstMapInfo  // in
	var _arg2 C.GstMapFlags // out
	var _cret *C.GstMemory  // in

	_arg0 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(mem)), nil)
	_arg2 = C.GstMapFlags(flags)

	_cret = C.gst_memory_make_mapped(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(mem)
	runtime.KeepAlive(flags)

	var _info *MapInfo  // out
	var _memory *Memory // out

	_info = (*MapInfo)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != nil {
		_memory = (*Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_memory)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _info, _memory
}

// Map: fill info with the pointer and sizes of the memory in mem that can be
// accessed according to flags.
//
// This function can return FALSE for various reasons:
//
// - the memory backed by mem is not accessible with the given flags.
//
// - the memory was already mapped with a different mapping.
//
// info and its contents remain valid for as long as mem is valid and until
// gst_memory_unmap() is called.
//
// For each gst_memory_map() call, a corresponding gst_memory_unmap() call
// should be done.
//
// The function takes the following parameters:
//
//   - flags: mapping flags.
//
// The function returns the following values:
//
//   - info: pointer for info.
//   - ok: TRUE if the map operation was successful.
func (mem *Memory) Map(flags MapFlags) (*MapInfo, bool) {
	var _arg0 *C.GstMemory  // out
	var _arg1 C.GstMapInfo  // in
	var _arg2 C.GstMapFlags // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	_arg2 = C.GstMapFlags(flags)

	_cret = C.gst_memory_map(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(mem)
	runtime.KeepAlive(flags)

	var _info *MapInfo // out
	var _ok bool       // out

	_info = (*MapInfo)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _info, _ok
}

// Resize the memory region. mem should be writable and offset + size should be
// less than the maxsize of mem.
//
// T_MEMORY_FLAG_ZERO_PREFIXED and T_MEMORY_FLAG_ZERO_PADDED will be cleared
// when offset or padding is increased respectively.
//
// The function takes the following parameters:
//
//   - offset: new offset.
//   - size: new size.
func (mem *Memory) Resize(offset int, size uint) {
	var _arg0 *C.GstMemory // out
	var _arg1 C.gssize     // out
	var _arg2 C.gsize      // out

	_arg0 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	_arg1 = C.gssize(offset)
	_arg2 = C.gsize(size)

	C.gst_memory_resize(_arg0, _arg1, _arg2)
	runtime.KeepAlive(mem)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)
}

// Share: return a shared copy of size bytes from mem starting from offset.
// No memory copy is performed and the memory region is simply shared.
// The result is guaranteed to be non-writable. size can be set to -1 to return
// a shared copy from offset to the end of the memory region.
//
// The function takes the following parameters:
//
//   - offset to share from.
//   - size to share, or -1 to share to the end of the memory region.
//
// The function returns the following values:
//
//   - memory: new Memory.
func (mem *Memory) Share(offset int, size int) *Memory {
	var _arg0 *C.GstMemory // out
	var _arg1 C.gssize     // out
	var _arg2 C.gssize     // out
	var _cret *C.GstMemory // in

	_arg0 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	_arg1 = C.gssize(offset)
	_arg2 = C.gssize(size)

	_cret = C.gst_memory_share(_arg0, _arg1, _arg2)
	runtime.KeepAlive(mem)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _memory *Memory // out

	_memory = (*Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_memory)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _memory
}

// Unmap: release the memory obtained with gst_memory_map().
//
// The function takes the following parameters:
//
//   - info: MapInfo.
func (mem *Memory) Unmap(info *MapInfo) {
	var _arg0 *C.GstMemory  // out
	var _arg1 *C.GstMapInfo // out

	_arg0 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))
	_arg1 = (*C.GstMapInfo)(gextras.StructNative(unsafe.Pointer(info)))

	C.gst_memory_unmap(_arg0, _arg1)
	runtime.KeepAlive(mem)
	runtime.KeepAlive(info)
}

// Message messages are implemented as a subclass of MiniObject with a generic
// Structure as the content. This allows for writing custom messages without
// requiring an API change while allowing a wide range of different types of
// messages.
//
// Messages are posted by objects in the pipeline and are passed to the
// application using the Bus.
//
// The basic use pattern of posting a message on a Bus is as follows:
//
//	gst_bus_post (bus, gst_message_new_eos());
//
// A Element usually posts messages on the bus provided by the parent container
// using gst_element_post_message().
//
// An instance of this type is always passed by reference.
type Message struct {
	*message
}

// message is the struct that's finalized.
type message struct {
	native *C.GstMessage
}

func marshalMessage(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Message{&message{(*C.GstMessage)(b)}}, nil
}

// NewMessageApplication constructs a struct Message.
func NewMessageApplication(src GstObjector, structure *Structure) *Message {
	var _arg1 *C.GstObject    // out
	var _arg2 *C.GstStructure // out
	var _cret *C.GstMessage   // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(structure)), nil)

	_cret = C.gst_message_new_application(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(structure)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageAsyncDone constructs a struct Message.
func NewMessageAsyncDone(src GstObjector, runningTime ClockTime) *Message {
	var _arg1 *C.GstObject   // out
	var _arg2 C.GstClockTime // out
	var _cret *C.GstMessage  // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = C.GstClockTime(runningTime)

	_cret = C.gst_message_new_async_done(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(runningTime)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageAsyncStart constructs a struct Message.
func NewMessageAsyncStart(src GstObjector) *Message {
	var _arg1 *C.GstObject  // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}

	_cret = C.gst_message_new_async_start(_arg1)
	runtime.KeepAlive(src)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageBuffering constructs a struct Message.
func NewMessageBuffering(src GstObjector, percent int) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 C.gint        // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = C.gint(percent)

	_cret = C.gst_message_new_buffering(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(percent)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageClockLost constructs a struct Message.
func NewMessageClockLost(src GstObjector, clock Clocker) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GstClock   // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	_cret = C.gst_message_new_clock_lost(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(clock)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageClockProvide constructs a struct Message.
func NewMessageClockProvide(src GstObjector, clock Clocker, ready bool) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GstClock   // out
	var _arg3 C.gboolean    // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
	if ready {
		_arg3 = C.TRUE
	}

	_cret = C.gst_message_new_clock_provide(_arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(ready)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageCustom constructs a struct Message.
func NewMessageCustom(typ MessageType, src GstObjector, structure *Structure) *Message {
	var _arg1 C.GstMessageType // out
	var _arg2 *C.GstObject     // out
	var _arg3 *C.GstStructure  // out
	var _cret *C.GstMessage    // in

	_arg1 = C.GstMessageType(typ)
	if src != nil {
		_arg2 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	if structure != nil {
		_arg3 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(structure)), nil)
	}

	_cret = C.gst_message_new_custom(_arg1, _arg2, _arg3)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(src)
	runtime.KeepAlive(structure)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageDeviceAdded constructs a struct Message.
func NewMessageDeviceAdded(src GstObjector, device Devicer) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GstDevice  // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gst_message_new_device_added(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(device)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageDeviceChanged constructs a struct Message.
func NewMessageDeviceChanged(src GstObjector, device Devicer, changedDevice Devicer) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GstDevice  // out
	var _arg3 *C.GstDevice  // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg3 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(changedDevice).Native()))

	_cret = C.gst_message_new_device_changed(_arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(device)
	runtime.KeepAlive(changedDevice)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageDeviceRemoved constructs a struct Message.
func NewMessageDeviceRemoved(src GstObjector, device Devicer) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GstDevice  // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = (*C.GstDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gst_message_new_device_removed(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(device)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageDurationChanged constructs a struct Message.
func NewMessageDurationChanged(src GstObjector) *Message {
	var _arg1 *C.GstObject  // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}

	_cret = C.gst_message_new_duration_changed(_arg1)
	runtime.KeepAlive(src)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageElement constructs a struct Message.
func NewMessageElement(src GstObjector, structure *Structure) *Message {
	var _arg1 *C.GstObject    // out
	var _arg2 *C.GstStructure // out
	var _cret *C.GstMessage   // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(structure)), nil)

	_cret = C.gst_message_new_element(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(structure)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageEos constructs a struct Message.
func NewMessageEos(src GstObjector) *Message {
	var _arg1 *C.GstObject  // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}

	_cret = C.gst_message_new_eos(_arg1)
	runtime.KeepAlive(src)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageError constructs a struct Message.
func NewMessageError(src GstObjector, err error, debug string) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GError     // out
	var _arg3 *C.gchar      // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	if err != nil {
		_arg2 = (*C.GError)(gerror.New(err))
	}
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(debug)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gst_message_new_error(_arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(err)
	runtime.KeepAlive(debug)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageErrorWithDetails constructs a struct Message.
func NewMessageErrorWithDetails(src GstObjector, err error, debug string, details *Structure) *Message {
	var _arg1 *C.GstObject    // out
	var _arg2 *C.GError       // out
	var _arg3 *C.gchar        // out
	var _arg4 *C.GstStructure // out
	var _cret *C.GstMessage   // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	if err != nil {
		_arg2 = (*C.GError)(gerror.New(err))
	}
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(debug)))
	defer C.free(unsafe.Pointer(_arg3))
	if details != nil {
		_arg4 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(details)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(details)), nil)
	}

	_cret = C.gst_message_new_error_with_details(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(src)
	runtime.KeepAlive(err)
	runtime.KeepAlive(debug)
	runtime.KeepAlive(details)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageHaveContext constructs a struct Message.
func NewMessageHaveContext(src GstObjector, context *Context) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GstContext // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = (*C.GstContext)(gextras.StructNative(unsafe.Pointer(context)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(context)), nil)

	_cret = C.gst_message_new_have_context(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(context)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageInfo constructs a struct Message.
func NewMessageInfo(src GstObjector, err error, debug string) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GError     // out
	var _arg3 *C.gchar      // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	if err != nil {
		_arg2 = (*C.GError)(gerror.New(err))
	}
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(debug)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gst_message_new_info(_arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(err)
	runtime.KeepAlive(debug)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageInfoWithDetails constructs a struct Message.
func NewMessageInfoWithDetails(src GstObjector, err error, debug string, details *Structure) *Message {
	var _arg1 *C.GstObject    // out
	var _arg2 *C.GError       // out
	var _arg3 *C.gchar        // out
	var _arg4 *C.GstStructure // out
	var _cret *C.GstMessage   // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	if err != nil {
		_arg2 = (*C.GError)(gerror.New(err))
	}
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(debug)))
	defer C.free(unsafe.Pointer(_arg3))
	if details != nil {
		_arg4 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(details)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(details)), nil)
	}

	_cret = C.gst_message_new_info_with_details(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(src)
	runtime.KeepAlive(err)
	runtime.KeepAlive(debug)
	runtime.KeepAlive(details)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageInstantRateRequest constructs a struct Message.
func NewMessageInstantRateRequest(src GstObjector, rateMultiplier float64) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 C.gdouble     // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = C.gdouble(rateMultiplier)

	_cret = C.gst_message_new_instant_rate_request(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(rateMultiplier)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageLatency constructs a struct Message.
func NewMessageLatency(src GstObjector) *Message {
	var _arg1 *C.GstObject  // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}

	_cret = C.gst_message_new_latency(_arg1)
	runtime.KeepAlive(src)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageNeedContext constructs a struct Message.
func NewMessageNeedContext(src GstObjector, contextType string) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.gchar      // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(contextType)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_message_new_need_context(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(contextType)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageNewClock constructs a struct Message.
func NewMessageNewClock(src GstObjector, clock Clocker) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GstClock   // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))

	_cret = C.gst_message_new_new_clock(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(clock)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageProgress constructs a struct Message.
func NewMessageProgress(src GstObjector, typ ProgressType, code string, text string) *Message {
	var _arg1 *C.GstObject      // out
	var _arg2 C.GstProgressType // out
	var _arg3 *C.gchar          // out
	var _arg4 *C.gchar          // out
	var _cret *C.GstMessage     // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = C.GstProgressType(typ)
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(code)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg4))

	_cret = C.gst_message_new_progress(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(src)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(code)
	runtime.KeepAlive(text)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessagePropertyNotify constructs a struct Message.
func NewMessagePropertyNotify(src GstObjector, propertyName string, val *coreglib.Value) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.gchar      // out
	var _arg3 *C.GValue     // out
	var _cret *C.GstMessage // in

	_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg2))
	if val != nil {
		_arg3 = (*C.GValue)(unsafe.Pointer(val.Native()))
	}

	_cret = C.gst_message_new_property_notify(_arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(val)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageQos constructs a struct Message.
func NewMessageQos(src GstObjector, live bool, runningTime uint64, streamTime uint64, timestamp uint64, duration uint64) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 C.gboolean    // out
	var _arg3 C.guint64     // out
	var _arg4 C.guint64     // out
	var _arg5 C.guint64     // out
	var _arg6 C.guint64     // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	if live {
		_arg2 = C.TRUE
	}
	_arg3 = C.guint64(runningTime)
	_arg4 = C.guint64(streamTime)
	_arg5 = C.guint64(timestamp)
	_arg6 = C.guint64(duration)

	_cret = C.gst_message_new_qos(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(src)
	runtime.KeepAlive(live)
	runtime.KeepAlive(runningTime)
	runtime.KeepAlive(streamTime)
	runtime.KeepAlive(timestamp)
	runtime.KeepAlive(duration)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageRedirect constructs a struct Message.
func NewMessageRedirect(src GstObjector, location string, tagList *TagList, entryStruct *Structure) *Message {
	var _arg1 *C.GstObject    // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.GstTagList   // out
	var _arg4 *C.GstStructure // out
	var _cret *C.GstMessage   // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(location)))
	defer C.free(unsafe.Pointer(_arg2))
	if tagList != nil {
		_arg3 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(tagList)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(tagList)), nil)
	}
	if entryStruct != nil {
		_arg4 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(entryStruct)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(entryStruct)), nil)
	}

	_cret = C.gst_message_new_redirect(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(src)
	runtime.KeepAlive(location)
	runtime.KeepAlive(tagList)
	runtime.KeepAlive(entryStruct)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageRequestState constructs a struct Message.
func NewMessageRequestState(src GstObjector, state State) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 C.GstState    // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = C.GstState(state)

	_cret = C.gst_message_new_request_state(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(state)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageResetTime constructs a struct Message.
func NewMessageResetTime(src GstObjector, runningTime ClockTime) *Message {
	var _arg1 *C.GstObject   // out
	var _arg2 C.GstClockTime // out
	var _cret *C.GstMessage  // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = C.GstClockTime(runningTime)

	_cret = C.gst_message_new_reset_time(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(runningTime)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageSegmentDone constructs a struct Message.
func NewMessageSegmentDone(src GstObjector, format Format, position int64) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 C.GstFormat   // out
	var _arg3 C.gint64      // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = C.GstFormat(format)
	_arg3 = C.gint64(position)

	_cret = C.gst_message_new_segment_done(_arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(format)
	runtime.KeepAlive(position)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageSegmentStart constructs a struct Message.
func NewMessageSegmentStart(src GstObjector, format Format, position int64) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 C.GstFormat   // out
	var _arg3 C.gint64      // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = C.GstFormat(format)
	_arg3 = C.gint64(position)

	_cret = C.gst_message_new_segment_start(_arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(format)
	runtime.KeepAlive(position)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageStateChanged constructs a struct Message.
func NewMessageStateChanged(src GstObjector, oldstate State, newstate State, pending State) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 C.GstState    // out
	var _arg3 C.GstState    // out
	var _arg4 C.GstState    // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = C.GstState(oldstate)
	_arg3 = C.GstState(newstate)
	_arg4 = C.GstState(pending)

	_cret = C.gst_message_new_state_changed(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(src)
	runtime.KeepAlive(oldstate)
	runtime.KeepAlive(newstate)
	runtime.KeepAlive(pending)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageStateDirty constructs a struct Message.
func NewMessageStateDirty(src GstObjector) *Message {
	var _arg1 *C.GstObject  // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}

	_cret = C.gst_message_new_state_dirty(_arg1)
	runtime.KeepAlive(src)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageStepDone constructs a struct Message.
func NewMessageStepDone(src GstObjector, format Format, amount uint64, rate float64, flush bool, intermediate bool, duration uint64, eos bool) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 C.GstFormat   // out
	var _arg3 C.guint64     // out
	var _arg4 C.gdouble     // out
	var _arg5 C.gboolean    // out
	var _arg6 C.gboolean    // out
	var _arg7 C.guint64     // out
	var _arg8 C.gboolean    // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = C.GstFormat(format)
	_arg3 = C.guint64(amount)
	_arg4 = C.gdouble(rate)
	if flush {
		_arg5 = C.TRUE
	}
	if intermediate {
		_arg6 = C.TRUE
	}
	_arg7 = C.guint64(duration)
	if eos {
		_arg8 = C.TRUE
	}

	_cret = C.gst_message_new_step_done(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(src)
	runtime.KeepAlive(format)
	runtime.KeepAlive(amount)
	runtime.KeepAlive(rate)
	runtime.KeepAlive(flush)
	runtime.KeepAlive(intermediate)
	runtime.KeepAlive(duration)
	runtime.KeepAlive(eos)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageStepStart constructs a struct Message.
func NewMessageStepStart(src GstObjector, active bool, format Format, amount uint64, rate float64, flush bool, intermediate bool) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 C.gboolean    // out
	var _arg3 C.GstFormat   // out
	var _arg4 C.guint64     // out
	var _arg5 C.gdouble     // out
	var _arg6 C.gboolean    // out
	var _arg7 C.gboolean    // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	if active {
		_arg2 = C.TRUE
	}
	_arg3 = C.GstFormat(format)
	_arg4 = C.guint64(amount)
	_arg5 = C.gdouble(rate)
	if flush {
		_arg6 = C.TRUE
	}
	if intermediate {
		_arg7 = C.TRUE
	}

	_cret = C.gst_message_new_step_start(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(src)
	runtime.KeepAlive(active)
	runtime.KeepAlive(format)
	runtime.KeepAlive(amount)
	runtime.KeepAlive(rate)
	runtime.KeepAlive(flush)
	runtime.KeepAlive(intermediate)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageStreamCollection constructs a struct Message.
func NewMessageStreamCollection(src GstObjector, collection *StreamCollection) *Message {
	var _arg1 *C.GstObject           // out
	var _arg2 *C.GstStreamCollection // out
	var _cret *C.GstMessage          // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = (*C.GstStreamCollection)(unsafe.Pointer(coreglib.InternObject(collection).Native()))

	_cret = C.gst_message_new_stream_collection(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(collection)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageStreamStart constructs a struct Message.
func NewMessageStreamStart(src GstObjector) *Message {
	var _arg1 *C.GstObject  // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}

	_cret = C.gst_message_new_stream_start(_arg1)
	runtime.KeepAlive(src)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageStreamStatus constructs a struct Message.
func NewMessageStreamStatus(src GstObjector, typ StreamStatusType, owner Elementer) *Message {
	var _arg1 *C.GstObject          // out
	var _arg2 C.GstStreamStatusType // out
	var _arg3 *C.GstElement         // out
	var _cret *C.GstMessage         // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = C.GstStreamStatusType(typ)
	_arg3 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(owner).Native()))

	_cret = C.gst_message_new_stream_status(_arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(owner)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageStreamsSelected constructs a struct Message.
func NewMessageStreamsSelected(src GstObjector, collection *StreamCollection) *Message {
	var _arg1 *C.GstObject           // out
	var _arg2 *C.GstStreamCollection // out
	var _cret *C.GstMessage          // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = (*C.GstStreamCollection)(unsafe.Pointer(coreglib.InternObject(collection).Native()))

	_cret = C.gst_message_new_streams_selected(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(collection)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageStructureChange constructs a struct Message.
func NewMessageStructureChange(src GstObjector, typ StructureChangeType, owner Elementer, busy bool) *Message {
	var _arg1 *C.GstObject             // out
	var _arg2 C.GstStructureChangeType // out
	var _arg3 *C.GstElement            // out
	var _arg4 C.gboolean               // out
	var _cret *C.GstMessage            // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = C.GstStructureChangeType(typ)
	_arg3 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(owner).Native()))
	if busy {
		_arg4 = C.TRUE
	}

	_cret = C.gst_message_new_structure_change(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(src)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(owner)
	runtime.KeepAlive(busy)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageTag constructs a struct Message.
func NewMessageTag(src GstObjector, tagList *TagList) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GstTagList // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(tagList)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(tagList)), nil)

	_cret = C.gst_message_new_tag(_arg1, _arg2)
	runtime.KeepAlive(src)
	runtime.KeepAlive(tagList)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageToc constructs a struct Message.
func NewMessageToc(src GstObjector, toc *Toc, updated bool) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GstToc     // out
	var _arg3 C.gboolean    // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	_arg2 = (*C.GstToc)(gextras.StructNative(unsafe.Pointer(toc)))
	if updated {
		_arg3 = C.TRUE
	}

	_cret = C.gst_message_new_toc(_arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(toc)
	runtime.KeepAlive(updated)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageWarning constructs a struct Message.
func NewMessageWarning(src GstObjector, err error, debug string) *Message {
	var _arg1 *C.GstObject  // out
	var _arg2 *C.GError     // out
	var _arg3 *C.gchar      // out
	var _cret *C.GstMessage // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	if err != nil {
		_arg2 = (*C.GError)(gerror.New(err))
	}
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(debug)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gst_message_new_warning(_arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(err)
	runtime.KeepAlive(debug)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// NewMessageWarningWithDetails constructs a struct Message.
func NewMessageWarningWithDetails(src GstObjector, err error, debug string, details *Structure) *Message {
	var _arg1 *C.GstObject    // out
	var _arg2 *C.GError       // out
	var _arg3 *C.gchar        // out
	var _arg4 *C.GstStructure // out
	var _cret *C.GstMessage   // in

	if src != nil {
		_arg1 = (*C.GstObject)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	}
	if err != nil {
		_arg2 = (*C.GError)(gerror.New(err))
	}
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(debug)))
	defer C.free(unsafe.Pointer(_arg3))
	if details != nil {
		_arg4 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(details)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(details)), nil)
	}

	_cret = C.gst_message_new_warning_with_details(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(src)
	runtime.KeepAlive(err)
	runtime.KeepAlive(debug)
	runtime.KeepAlive(details)

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _message
}

// MiniObject: parent structure.
func (m *Message) MiniObject() *MiniObject {
	valptr := &m.native.mini_object
	var _v *MiniObject // out
	_v = (*MiniObject)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Type of the message.
func (m *Message) Type() MessageType {
	valptr := &m.native._type
	var _v MessageType // out
	_v = MessageType(*valptr)
	return _v
}

// Timestamp: timestamp of the message.
func (m *Message) Timestamp() uint64 {
	valptr := &m.native.timestamp
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Src: src of the message.
func (m *Message) Src() GstObjector {
	valptr := &m.native.src
	var _v GstObjector // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gst.GstObjector is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(GstObjector)
			return ok
		})
		rv, ok := casted.(GstObjector)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.GstObjector")
		}
		_v = rv
	}
	return _v
}

// Timestamp: timestamp of the message.
func (m *Message) SetTimestamp(timestamp uint64) {
	valptr := &m.native.timestamp
	*valptr = C.guint64(timestamp)
}

// AddRedirectEntry creates and appends a new entry.
//
// The specified location string is copied. However, ownership over the tag list
// and structure are transferred to the message.
//
// The function takes the following parameters:
//
//   - location string for the new entry.
//   - tagList (optional): tag list for the new entry.
//   - entryStruct (optional): structure for the new entry.
func (message *Message) AddRedirectEntry(location string, tagList *TagList, entryStruct *Structure) {
	var _arg0 *C.GstMessage   // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GstTagList   // out
	var _arg3 *C.GstStructure // out

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(location)))
	defer C.free(unsafe.Pointer(_arg1))
	if tagList != nil {
		_arg2 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(tagList)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(tagList)), nil)
	}
	if entryStruct != nil {
		_arg3 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(entryStruct)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(entryStruct)), nil)
	}

	C.gst_message_add_redirect_entry(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(message)
	runtime.KeepAlive(location)
	runtime.KeepAlive(tagList)
	runtime.KeepAlive(entryStruct)
}

// The function returns the following values:
//
//   - gsize: number of entries stored in the message.
func (message *Message) NumRedirectEntries() uint {
	var _arg0 *C.GstMessage // out
	var _cret C.gsize       // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	_cret = C.gst_message_get_num_redirect_entries(_arg0)
	runtime.KeepAlive(message)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Seqnum: retrieve the sequence number of a message.
//
// Messages have ever-incrementing sequence numbers, which may also be set
// explicitly via gst_message_set_seqnum(). Sequence numbers are typically
// used to indicate that a message corresponds to some other set of messages or
// events, for example a SEGMENT_DONE message corresponding to a SEEK event.
// It is considered good practice to make this correspondence when possible,
// though it is not required.
//
// Note that events and messages share the same sequence number incrementor;
// two events or messages will never have the same sequence number unless that
// correspondence was made explicitly.
//
// The function returns the following values:
//
//   - guint32 message's sequence number.
//
//     MT safe.
func (message *Message) Seqnum() uint32 {
	var _arg0 *C.GstMessage // out
	var _cret C.guint32     // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	_cret = C.gst_message_get_seqnum(_arg0)
	runtime.KeepAlive(message)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// StreamStatusObject extracts the object managing the streaming thread from
// message.
//
// The function returns the following values:
//
//   - value (optional): GValue containing the object that manages the streaming
//     thread. This object is usually of type GstTask but other types can be
//     added in the future. The object remains valid as long as message is
//     valid.
func (message *Message) StreamStatusObject() *coreglib.Value {
	var _arg0 *C.GstMessage // out
	var _cret *C.GValue     // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	_cret = C.gst_message_get_stream_status_object(_arg0)
	runtime.KeepAlive(message)

	var _value *coreglib.Value // out

	if _cret != nil {
		_value = coreglib.ValueFromNative(unsafe.Pointer(_cret))
	}

	return _value
}

// Structure access the structure of the message.
//
// The function returns the following values:
//
//   - structure (optional) of the message. The structure is still owned by the
//     message, which means that you should not free it and that the pointer
//     becomes invalid when you free the message.
//
//     MT safe.
func (message *Message) Structure() *Structure {
	var _arg0 *C.GstMessage   // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	_cret = C.gst_message_get_structure(_arg0)
	runtime.KeepAlive(message)

	var _structure *Structure // out

	if _cret != nil {
		_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _structure
}

// HasName checks if message has the given name. This function is usually used
// to check the name of a custom message.
//
// The function takes the following parameters:
//
//   - name to check.
//
// The function returns the following values:
//
//   - ok: TRUE if name matches the name of the message structure.
func (message *Message) HasName(name string) bool {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.gchar      // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_message_has_name(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ParseAsyncDone: extract the running_time from the async_done message.
//
// MT safe.
//
// The function returns the following values:
//
//   - runningTime (optional): result location for the running_time or NULL.
func (message *Message) ParseAsyncDone() ClockTime {
	var _arg0 *C.GstMessage  // out
	var _arg1 C.GstClockTime // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_async_done(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _runningTime ClockTime // out

	_runningTime = ClockTime(_arg1)

	return _runningTime
}

// ParseBuffering extracts the buffering percent from the GstMessage. see also
// gst_message_new_buffering().
//
// MT safe.
//
// The function returns the following values:
//
//   - percent (optional): return location for the percent.
func (message *Message) ParseBuffering() int {
	var _arg0 *C.GstMessage // out
	var _arg1 C.gint        // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_buffering(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _percent int // out

	_percent = int(_arg1)

	return _percent
}

// ParseBufferingStats extracts the buffering stats values from message.
//
// The function returns the following values:
//
//   - mode (optional): buffering mode, or NULL.
//   - avgIn (optional): average input rate, or NULL.
//   - avgOut (optional): average output rate, or NULL.
//   - bufferingLeft (optional): amount of buffering time left in milliseconds,
//     or NULL.
func (message *Message) ParseBufferingStats() (mode BufferingMode, avgIn int, avgOut int, bufferingLeft int64) {
	var _arg0 *C.GstMessage      // out
	var _arg1 C.GstBufferingMode // in
	var _arg2 C.gint             // in
	var _arg3 C.gint             // in
	var _arg4 C.gint64           // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_buffering_stats(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(message)

	var _mode BufferingMode  // out
	var _avgIn int           // out
	var _avgOut int          // out
	var _bufferingLeft int64 // out

	_mode = BufferingMode(_arg1)
	_avgIn = int(_arg2)
	_avgOut = int(_arg3)
	_bufferingLeft = int64(_arg4)

	return _mode, _avgIn, _avgOut, _bufferingLeft
}

// ParseClockLost extracts the lost clock from the GstMessage. The clock object
// returned remains valid until the message is freed.
//
// MT safe.
//
// The function returns the following values:
//
//   - clock (optional): pointer to hold the lost clock.
func (message *Message) ParseClockLost() Clocker {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GstClock   // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_clock_lost(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _clock Clocker // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Clocker)
				return ok
			})
			rv, ok := casted.(Clocker)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Clocker")
			}
			_clock = rv
		}
	}

	return _clock
}

// ParseClockProvide extracts the clock and ready flag from the GstMessage.
// The clock object returned remains valid until the message is freed.
//
// MT safe.
//
// The function returns the following values:
//
//   - clock (optional): pointer to hold a clock object, or NULL.
//   - ready (optional): pointer to hold the ready flag, or NULL.
func (message *Message) ParseClockProvide() (Clocker, bool) {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GstClock   // in
	var _arg2 C.gboolean    // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_clock_provide(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(message)

	var _clock Clocker // out
	var _ready bool    // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Clocker)
				return ok
			})
			rv, ok := casted.(Clocker)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Clocker")
			}
			_clock = rv
		}
	}
	if _arg2 != 0 {
		_ready = true
	}

	return _clock, _ready
}

// ParseContextType: parse a context type from an existing
// GST_MESSAGE_NEED_CONTEXT message.
//
// The function returns the following values:
//
//   - contextType (optional): context type, or NULL.
//   - ok indicating if the parsing succeeded.
func (message *Message) ParseContextType() (string, bool) {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.gchar      // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	_cret = C.gst_message_parse_context_type(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _contextType string // out
	var _ok bool            // out

	if _arg1 != nil {
		_contextType = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
	}
	if _cret != 0 {
		_ok = true
	}

	return _contextType, _ok
}

// ParseDeviceAdded parses a device-added message. The device-added message is
// produced by DeviceProvider or a DeviceMonitor. It announces the appearance of
// monitored devices.
//
// The function returns the following values:
//
//   - device (optional): location where to store a pointer to the new Device,
//     or NULL.
func (message *Message) ParseDeviceAdded() Devicer {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GstDevice  // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_device_added(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _device Devicer // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Devicer)
				return ok
			})
			rv, ok := casted.(Devicer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Devicer")
			}
			_device = rv
		}
	}

	return _device
}

// ParseDeviceChanged parses a device-changed message. The device-changed
// message is produced by DeviceProvider or a DeviceMonitor. It announces the
// disappearance of monitored devices. * It announce that a device properties
// has changed and device represents the new modified version of changed_device.
//
// The function returns the following values:
//
//   - device (optional): location where to store a pointer to the updated
//     version of the Device, or NULL.
//   - changedDevice (optional): location where to store a pointer to the old
//     version of the Device, or NULL.
func (message *Message) ParseDeviceChanged() (device Devicer, changedDevice Devicer) {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GstDevice  // in
	var _arg2 *C.GstDevice  // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_device_changed(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(message)

	var _device Devicer        // out
	var _changedDevice Devicer // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Devicer)
				return ok
			})
			rv, ok := casted.(Devicer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Devicer")
			}
			_device = rv
		}
	}
	if _arg2 != nil {
		{
			objptr := unsafe.Pointer(_arg2)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Devicer)
				return ok
			})
			rv, ok := casted.(Devicer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Devicer")
			}
			_changedDevice = rv
		}
	}

	return _device, _changedDevice
}

// ParseDeviceRemoved parses a device-removed message. The device-removed
// message is produced by DeviceProvider or a DeviceMonitor. It announces the
// disappearance of monitored devices.
//
// The function returns the following values:
//
//   - device (optional): location where to store a pointer to the removed
//     Device, or NULL.
func (message *Message) ParseDeviceRemoved() Devicer {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GstDevice  // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_device_removed(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _device Devicer // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Devicer)
				return ok
			})
			rv, ok := casted.(Devicer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Devicer")
			}
			_device = rv
		}
	}

	return _device
}

// ParseError extracts the GError and debug string from the GstMessage.
// The values returned in the output arguments are copies; the caller must free
// them when done.
//
// Typical usage of this function might be:
//
//	...
//	switch (GST_MESSAGE_TYPE (msg)) {
//	  case GST_MESSAGE_ERROR: {
//	    GError *err = NULL;
//	    gchar *dbg_info = NULL;
//
//	    gst_message_parse_error (msg, &err, &dbg_info);
//	    g_printerr ("ERROR from element s: s\n",
//	        GST_OBJECT_NAME (msg->src), err->message);
//	    g_printerr ("Debugging info: s\n", (dbg_info) ? dbg_info : "none");
//	    g_error_free (err);
//	    g_free (dbg_info);
//	    break;
//	  }
//	  ...
//	}
//	...
//
// MT safe.
//
// The function returns the following values:
//
//   - gerror (optional): location for the GError.
//   - debug (optional): location for the debug message, or NULL.
func (message *Message) ParseError() (error, string) {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GError     // in
	var _arg2 *C.gchar      // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_error(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(message)

	var _gerror error // out
	var _debug string // out

	if _arg1 != nil {
		_gerror = gerror.Take(unsafe.Pointer(_arg1))
	}
	if _arg2 != nil {
		_debug = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	return _gerror, _debug
}

// ParseErrorDetails returns the optional details structure, may be NULL if
// none. The returned structure must not be freed.
//
// The function returns the following values:
//
//   - structure (optional): pointer to the returned details.
func (message *Message) ParseErrorDetails() *Structure {
	var _arg0 *C.GstMessage   // out
	var _arg1 *C.GstStructure // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_error_details(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _structure *Structure // out

	if _arg1 != nil {
		_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
	}

	return _structure
}

// ParseGroupID: extract the group from the STREAM_START message.
//
// The function returns the following values:
//
//   - groupId (optional): result location for the group id or NULL.
//
//   - ok: TRUE if the message had a group id set, FALSE otherwise
//
//     MT safe.
func (message *Message) ParseGroupID() (uint, bool) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.guint       // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	_cret = C.gst_message_parse_group_id(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _groupId uint // out
	var _ok bool      // out

	_groupId = uint(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _groupId, _ok
}

// ParseHaveContext: extract the context from the HAVE_CONTEXT message.
//
// MT safe.
//
// The function returns the following values:
//
//   - context (optional): result location for the context or NULL.
func (message *Message) ParseHaveContext() *Context {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GstContext // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_have_context(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _context *Context // out

	if _arg1 != nil {
		_context = (*Context)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_context)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _context
}

// ParseInfo extracts the GError and debug string from the GstMessage. The
// values returned in the output arguments are copies; the caller must free them
// when done.
//
// MT safe.
//
// The function returns the following values:
//
//   - gerror (optional): location for the GError.
//   - debug (optional): location for the debug message, or NULL.
func (message *Message) ParseInfo() (error, string) {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GError     // in
	var _arg2 *C.gchar      // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_info(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(message)

	var _gerror error // out
	var _debug string // out

	if _arg1 != nil {
		_gerror = gerror.Take(unsafe.Pointer(_arg1))
	}
	if _arg2 != nil {
		_debug = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	return _gerror, _debug
}

// ParseInfoDetails returns the optional details structure, may be NULL if none
// The returned structure must not be freed.
//
// The function returns the following values:
//
//   - structure (optional): pointer to the returned details.
func (message *Message) ParseInfoDetails() *Structure {
	var _arg0 *C.GstMessage   // out
	var _arg1 *C.GstStructure // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_info_details(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _structure *Structure // out

	if _arg1 != nil {
		_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
	}

	return _structure
}

// ParseInstantRateRequest parses the rate_multiplier from the
// instant-rate-request message.
//
// The function returns the following values:
//
//   - rateMultiplier (optional): return location for the rate, or NULL.
func (message *Message) ParseInstantRateRequest() float64 {
	var _arg0 *C.GstMessage // out
	var _arg1 C.gdouble     // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_instant_rate_request(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _rateMultiplier float64 // out

	_rateMultiplier = float64(_arg1)

	return _rateMultiplier
}

// ParseNewClock extracts the new clock from the GstMessage. The clock object
// returned remains valid until the message is freed.
//
// MT safe.
//
// The function returns the following values:
//
//   - clock (optional): pointer to hold the selected new clock.
func (message *Message) ParseNewClock() Clocker {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GstClock   // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_new_clock(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _clock Clocker // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Clocker)
				return ok
			})
			rv, ok := casted.(Clocker)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Clocker")
			}
			_clock = rv
		}
	}

	return _clock
}

// ParseProgress parses the progress type, code and text.
//
// The function returns the following values:
//
//   - typ (optional): location for the type.
//   - code (optional): location for the code.
//   - text (optional): location for the text.
func (message *Message) ParseProgress() (typ ProgressType, code string, text string) {
	var _arg0 *C.GstMessage     // out
	var _arg1 C.GstProgressType // in
	var _arg2 *C.gchar          // in
	var _arg3 *C.gchar          // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_progress(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(message)

	var _typ ProgressType // out
	var _code string      // out
	var _text string      // out

	_typ = ProgressType(_arg1)
	if _arg2 != nil {
		_code = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if _arg3 != nil {
		_text = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	return _typ, _code, _text
}

// ParsePropertyNotify parses a property-notify message. These will be posted
// on the bus only when set up with gst_element_add_property_notify_watch() or
// gst_element_add_property_deep_notify_watch().
//
// The function returns the following values:
//
//   - object (optional): location where to store a pointer to the object whose
//     property got changed, or NULL.
//   - propertyName (optional): return location for the name of the property
//     that got changed, or NULL.
//   - propertyValue (optional): return location for the new value of the
//     property that got changed, or NULL. This will only be set if the property
//     notify watch was told to include the value when it was set up.
func (message *Message) ParsePropertyNotify() (GstObjector, string, *coreglib.Value) {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GstObject  // in
	var _arg2 *C.gchar      // in
	var _arg3 *C.GValue     // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_property_notify(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(message)

	var _object GstObjector            // out
	var _propertyName string           // out
	var _propertyValue *coreglib.Value // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(GstObjector)
				return ok
			})
			rv, ok := casted.(GstObjector)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.GstObjector")
			}
			_object = rv
		}
	}
	if _arg2 != nil {
		_propertyName = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
	}
	if _arg3 != nil {
		_propertyValue = coreglib.ValueFromNative(unsafe.Pointer(_arg3))
	}

	return _object, _propertyName, _propertyValue
}

// ParseQos: extract the timestamps and live status from the QoS message.
//
// The returned values give the running_time, stream_time, timestamp and
// duration of the dropped buffer. Values of GST_CLOCK_TIME_NONE mean unknown
// values.
//
// MT safe.
//
// The function returns the following values:
//
//   - live (optional): if the message was generated by a live element.
//   - runningTime (optional): running time of the buffer that generated the
//     message.
//   - streamTime (optional): stream time of the buffer that generated the
//     message.
//   - timestamp (optional) timestamps of the buffer that generated the message.
//   - duration (optional) of the buffer that generated the message.
func (message *Message) ParseQos() (live bool, runningTime uint64, streamTime uint64, timestamp uint64, duration uint64) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.gboolean    // in
	var _arg2 C.guint64     // in
	var _arg3 C.guint64     // in
	var _arg4 C.guint64     // in
	var _arg5 C.guint64     // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_qos(_arg0, &_arg1, &_arg2, &_arg3, &_arg4, &_arg5)
	runtime.KeepAlive(message)

	var _live bool          // out
	var _runningTime uint64 // out
	var _streamTime uint64  // out
	var _timestamp uint64   // out
	var _duration uint64    // out

	if _arg1 != 0 {
		_live = true
	}
	_runningTime = uint64(_arg2)
	_streamTime = uint64(_arg3)
	_timestamp = uint64(_arg4)
	_duration = uint64(_arg5)

	return _live, _runningTime, _streamTime, _timestamp, _duration
}

// ParseQosStats: extract the QoS stats representing the history of the current
// continuous pipeline playback period.
//
// When format is GST_FORMAT_UNDEFINED both dropped and processed are invalid.
// Values of -1 for either processed or dropped mean unknown values.
//
// MT safe.
//
// The function returns the following values:
//
//   - format (optional) units of the 'processed' and 'dropped' fields. Video
//     sinks and video filters will use GST_FORMAT_BUFFERS (frames). Audio sinks
//     and audio filters will likely use GST_FORMAT_DEFAULT (samples).
//   - processed (optional): total number of units correctly processed since the
//     last state change to READY or a flushing operation.
//   - dropped (optional): total number of units dropped since the last state
//     change to READY or a flushing operation.
func (message *Message) ParseQosStats() (format Format, processed uint64, dropped uint64) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.GstFormat   // in
	var _arg2 C.guint64     // in
	var _arg3 C.guint64     // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_qos_stats(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(message)

	var _format Format    // out
	var _processed uint64 // out
	var _dropped uint64   // out

	_format = Format(_arg1)
	_processed = uint64(_arg2)
	_dropped = uint64(_arg3)

	return _format, _processed, _dropped
}

// ParseQosValues: extract the QoS values that have been calculated/analysed
// from the QoS data
//
// MT safe.
//
// The function returns the following values:
//
//   - jitter (optional): difference of the running-time against the deadline.
//   - proportion (optional): long term prediction of the ideal rate relative to
//     normal rate to get optimal quality.
//   - quality (optional): element dependent integer value that specifies the
//     current quality level of the element. The default maximum quality is
//     1000000.
func (message *Message) ParseQosValues() (int64, float64, int) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.gint64      // in
	var _arg2 C.gdouble     // in
	var _arg3 C.gint        // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_qos_values(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(message)

	var _jitter int64       // out
	var _proportion float64 // out
	var _quality int        // out

	_jitter = int64(_arg1)
	_proportion = float64(_arg2)
	_quality = int(_arg3)

	return _jitter, _proportion, _quality
}

// ParseRedirectEntry parses the location and/or structure from
// the entry with the given index. The index must be between 0 and
// gst_message_get_num_redirect_entries() - 1. Returned pointers are valid for
// as long as this message exists.
//
// The function takes the following parameters:
//
//   - entryIndex: index of the entry to parse.
//
// The function returns the following values:
//
//   - location (optional): return location for the pointer to the entry's
//     location string, or NULL.
//   - tagList (optional): return location for the pointer to the entry's tag
//     list, or NULL.
//   - entryStruct (optional): return location for the pointer to the entry's
//     structure, or NULL.
func (message *Message) ParseRedirectEntry(entryIndex uint) (string, *TagList, *Structure) {
	var _arg0 *C.GstMessage   // out
	var _arg1 C.gsize         // out
	var _arg2 *C.gchar        // in
	var _arg3 *C.GstTagList   // in
	var _arg4 *C.GstStructure // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg1 = C.gsize(entryIndex)

	C.gst_message_parse_redirect_entry(_arg0, _arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(message)
	runtime.KeepAlive(entryIndex)

	var _location string        // out
	var _tagList *TagList       // out
	var _entryStruct *Structure // out

	if _arg2 != nil {
		_location = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
	}
	if _arg3 != nil {
		_tagList = (*TagList)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
	}
	if _arg4 != nil {
		_entryStruct = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_arg4)))
	}

	return _location, _tagList, _entryStruct
}

// ParseRequestState: extract the requested state from the request_state
// message.
//
// MT safe.
//
// The function returns the following values:
//
//   - state (optional): result location for the requested state or NULL.
func (message *Message) ParseRequestState() State {
	var _arg0 *C.GstMessage // out
	var _arg1 C.GstState    // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_request_state(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _state State // out

	_state = State(_arg1)

	return _state
}

// ParseResetTime: extract the running-time from the RESET_TIME message.
//
// MT safe.
//
// The function returns the following values:
//
//   - runningTime (optional): result location for the running_time or NULL.
func (message *Message) ParseResetTime() ClockTime {
	var _arg0 *C.GstMessage  // out
	var _arg1 C.GstClockTime // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_reset_time(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _runningTime ClockTime // out

	_runningTime = ClockTime(_arg1)

	return _runningTime
}

// ParseSegmentDone extracts the position and format from the segment done
// message.
//
// MT safe.
//
// The function returns the following values:
//
//   - format (optional): result location for the format, or NULL.
//   - position (optional): result location for the position, or NULL.
func (message *Message) ParseSegmentDone() (Format, int64) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.GstFormat   // in
	var _arg2 C.gint64      // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_segment_done(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(message)

	var _format Format  // out
	var _position int64 // out

	_format = Format(_arg1)
	_position = int64(_arg2)

	return _format, _position
}

// ParseSegmentStart extracts the position and format from the segment start
// message.
//
// MT safe.
//
// The function returns the following values:
//
//   - format (optional): result location for the format, or NULL.
//   - position (optional): result location for the position, or NULL.
func (message *Message) ParseSegmentStart() (Format, int64) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.GstFormat   // in
	var _arg2 C.gint64      // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_segment_start(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(message)

	var _format Format  // out
	var _position int64 // out

	_format = Format(_arg1)
	_position = int64(_arg2)

	return _format, _position
}

// ParseStateChanged extracts the old and new states from the GstMessage.
//
// Typical usage of this function might be:
//
//	...
//	switch (GST_MESSAGE_TYPE (msg)) {
//	  case GST_MESSAGE_STATE_CHANGED: {
//	    GstState old_state, new_state;
//
//	    gst_message_parse_state_changed (msg, &old_state, &new_state, NULL);
//	    g_print ("Element s changed state from s to s.\n",
//	        GST_OBJECT_NAME (msg->src),
//	        gst_element_state_get_name (old_state),
//	        gst_element_state_get_name (new_state));
//	    break;
//	  }
//	  ...
//	}
//	...
//
// MT safe.
//
// The function returns the following values:
//
//   - oldstate (optional) previous state, or NULL.
//   - newstate (optional): new (current) state, or NULL.
//   - pending (optional) (target) state, or NULL.
func (message *Message) ParseStateChanged() (oldstate State, newstate State, pending State) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.GstState    // in
	var _arg2 C.GstState    // in
	var _arg3 C.GstState    // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_state_changed(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(message)

	var _oldstate State // out
	var _newstate State // out
	var _pending State  // out

	_oldstate = State(_arg1)
	_newstate = State(_arg2)
	_pending = State(_arg3)

	return _oldstate, _newstate, _pending
}

// ParseStepDone: extract the values the step_done message.
//
// MT safe.
//
// The function returns the following values:
//
//   - format (optional): result location for the format.
//   - amount (optional): result location for the amount.
//   - rate (optional): result location for the rate.
//   - flush (optional): result location for the flush flag.
//   - intermediate (optional): result location for the intermediate flag.
//   - duration (optional): result location for the duration.
//   - eos (optional): result location for the EOS flag.
func (message *Message) ParseStepDone() (format Format, amount uint64, rate float64, flush bool, intermediate bool, duration uint64, eos bool) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.GstFormat   // in
	var _arg2 C.guint64     // in
	var _arg3 C.gdouble     // in
	var _arg4 C.gboolean    // in
	var _arg5 C.gboolean    // in
	var _arg6 C.guint64     // in
	var _arg7 C.gboolean    // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_step_done(_arg0, &_arg1, &_arg2, &_arg3, &_arg4, &_arg5, &_arg6, &_arg7)
	runtime.KeepAlive(message)

	var _format Format     // out
	var _amount uint64     // out
	var _rate float64      // out
	var _flush bool        // out
	var _intermediate bool // out
	var _duration uint64   // out
	var _eos bool          // out

	_format = Format(_arg1)
	_amount = uint64(_arg2)
	_rate = float64(_arg3)
	if _arg4 != 0 {
		_flush = true
	}
	if _arg5 != 0 {
		_intermediate = true
	}
	_duration = uint64(_arg6)
	if _arg7 != 0 {
		_eos = true
	}

	return _format, _amount, _rate, _flush, _intermediate, _duration, _eos
}

// ParseStepStart: extract the values from step_start message.
//
// MT safe.
//
// The function returns the following values:
//
//   - active (optional): result location for the active flag.
//   - format (optional): result location for the format.
//   - amount (optional): result location for the amount.
//   - rate (optional): result location for the rate.
//   - flush (optional): result location for the flush flag.
//   - intermediate (optional): result location for the intermediate flag.
func (message *Message) ParseStepStart() (active bool, format Format, amount uint64, rate float64, flush bool, intermediate bool) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.gboolean    // in
	var _arg2 C.GstFormat   // in
	var _arg3 C.guint64     // in
	var _arg4 C.gdouble     // in
	var _arg5 C.gboolean    // in
	var _arg6 C.gboolean    // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_step_start(_arg0, &_arg1, &_arg2, &_arg3, &_arg4, &_arg5, &_arg6)
	runtime.KeepAlive(message)

	var _active bool       // out
	var _format Format     // out
	var _amount uint64     // out
	var _rate float64      // out
	var _flush bool        // out
	var _intermediate bool // out

	if _arg1 != 0 {
		_active = true
	}
	_format = Format(_arg2)
	_amount = uint64(_arg3)
	_rate = float64(_arg4)
	if _arg5 != 0 {
		_flush = true
	}
	if _arg6 != 0 {
		_intermediate = true
	}

	return _active, _format, _amount, _rate, _flush, _intermediate
}

// ParseStreamCollection parses a stream-collection message.
//
// The function returns the following values:
//
//   - collection (optional): location where to store a pointer to the
//     StreamCollection, or NULL.
func (message *Message) ParseStreamCollection() *StreamCollection {
	var _arg0 *C.GstMessage          // out
	var _arg1 *C.GstStreamCollection // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_stream_collection(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _collection *StreamCollection // out

	if _arg1 != nil {
		_collection = wrapStreamCollection(coreglib.AssumeOwnership(unsafe.Pointer(_arg1)))
	}

	return _collection
}

// ParseStreamStatus extracts the stream status type and owner the GstMessage.
// The returned owner remains valid for as long as the reference to message is
// valid and should thus not be unreffed.
//
// MT safe.
//
// The function returns the following values:
//
//   - typ: pointer to hold the status type.
//   - owner element of the message source.
func (message *Message) ParseStreamStatus() (StreamStatusType, Elementer) {
	var _arg0 *C.GstMessage         // out
	var _arg1 C.GstStreamStatusType // in
	var _arg2 *C.GstElement         // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_stream_status(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(message)

	var _typ StreamStatusType // out
	var _owner Elementer      // out

	_typ = StreamStatusType(_arg1)
	{
		objptr := unsafe.Pointer(_arg2)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_owner = rv
	}

	return _typ, _owner
}

// ParseStreamsSelected parses a streams-selected message.
//
// The function returns the following values:
//
//   - collection (optional): location where to store a pointer to the
//     StreamCollection, or NULL.
func (message *Message) ParseStreamsSelected() *StreamCollection {
	var _arg0 *C.GstMessage          // out
	var _arg1 *C.GstStreamCollection // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_streams_selected(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _collection *StreamCollection // out

	if _arg1 != nil {
		_collection = wrapStreamCollection(coreglib.AssumeOwnership(unsafe.Pointer(_arg1)))
	}

	return _collection
}

// ParseStructureChange extracts the change type and completion status from the
// GstMessage.
//
// MT safe.
//
// The function returns the following values:
//
//   - typ: pointer to hold the change type.
//   - owner (optional) element of the message source.
//   - busy (optional): pointer to hold whether the change is in progress or has
//     been completed.
func (message *Message) ParseStructureChange() (StructureChangeType, Elementer, bool) {
	var _arg0 *C.GstMessage            // out
	var _arg1 C.GstStructureChangeType // in
	var _arg2 *C.GstElement            // in
	var _arg3 C.gboolean               // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_structure_change(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(message)

	var _typ StructureChangeType // out
	var _owner Elementer         // out
	var _busy bool               // out

	_typ = StructureChangeType(_arg1)
	if _arg2 != nil {
		{
			objptr := unsafe.Pointer(_arg2)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Elementer)
				return ok
			})
			rv, ok := casted.(Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_owner = rv
		}
	}
	if _arg3 != 0 {
		_busy = true
	}

	return _typ, _owner, _busy
}

// ParseTag extracts the tag list from the GstMessage. The tag list returned in
// the output argument is a copy; the caller must free it when done.
//
// Typical usage of this function might be:
//
//	...
//	switch (GST_MESSAGE_TYPE (msg)) {
//	  case GST_MESSAGE_TAG: {
//	    GstTagList *tags = NULL;
//
//	    gst_message_parse_tag (msg, &tags);
//	    g_print ("Got tags from element s\n", GST_OBJECT_NAME (msg->src));
//	    handle_tags (tags);
//	    gst_tag_list_unref (tags);
//	    break;
//	  }
//	  ...
//	}
//	...
//
// MT safe.
//
// The function returns the following values:
//
//   - tagList: return location for the tag-list.
func (message *Message) ParseTag() *TagList {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GstTagList // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_tag(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _tagList *TagList // out

	_tagList = (*TagList)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_tagList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _tagList
}

// ParseToc: extract the TOC from the Message. The TOC returned in the output
// argument is a copy; the caller must free it with gst_toc_unref() when done.
//
// MT safe.
//
// The function returns the following values:
//
//   - toc: return location for the TOC.
//   - updated: return location for the updated flag.
func (message *Message) ParseToc() (*Toc, bool) {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GstToc     // in
	var _arg2 C.gboolean    // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_toc(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(message)

	var _toc *Toc     // out
	var _updated bool // out

	_toc = (*Toc)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_toc)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	if _arg2 != 0 {
		_updated = true
	}

	return _toc, _updated
}

// ParseWarning extracts the GError and debug string from the GstMessage.
// The values returned in the output arguments are copies; the caller must free
// them when done.
//
// MT safe.
//
// The function returns the following values:
//
//   - gerror (optional): location for the GError.
//   - debug (optional): location for the debug message, or NULL.
func (message *Message) ParseWarning() (error, string) {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GError     // in
	var _arg2 *C.gchar      // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_warning(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(message)

	var _gerror error // out
	var _debug string // out

	if _arg1 != nil {
		_gerror = gerror.Take(unsafe.Pointer(_arg1))
	}
	if _arg2 != nil {
		_debug = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	return _gerror, _debug
}

// ParseWarningDetails returns the optional details structure, may be NULL if
// none The returned structure must not be freed.
//
// The function returns the following values:
//
//   - structure (optional): pointer to the returned details.
func (message *Message) ParseWarningDetails() *Structure {
	var _arg0 *C.GstMessage   // out
	var _arg1 *C.GstStructure // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	C.gst_message_parse_warning_details(_arg0, &_arg1)
	runtime.KeepAlive(message)

	var _structure *Structure // out

	if _arg1 != nil {
		_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
	}

	return _structure
}

// SetBufferingStats configures the buffering stats values in message.
//
// The function takes the following parameters:
//
//   - mode: buffering mode.
//   - avgIn: average input rate.
//   - avgOut: average output rate.
//   - bufferingLeft: amount of buffering time left in milliseconds.
func (message *Message) SetBufferingStats(mode BufferingMode, avgIn int, avgOut int, bufferingLeft int64) {
	var _arg0 *C.GstMessage      // out
	var _arg1 C.GstBufferingMode // out
	var _arg2 C.gint             // out
	var _arg3 C.gint             // out
	var _arg4 C.gint64           // out

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg1 = C.GstBufferingMode(mode)
	_arg2 = C.gint(avgIn)
	_arg3 = C.gint(avgOut)
	_arg4 = C.gint64(bufferingLeft)

	C.gst_message_set_buffering_stats(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(message)
	runtime.KeepAlive(mode)
	runtime.KeepAlive(avgIn)
	runtime.KeepAlive(avgOut)
	runtime.KeepAlive(bufferingLeft)
}

// SetGroupID sets the group id on the stream-start message.
//
// All streams that have the same group id are supposed to be played together,
// i.e. all streams inside a container file should have the same group id but
// different stream ids. The group id should change each time the stream is
// started, resulting in different group ids each time a file is played for
// example.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - groupId: group id.
func (message *Message) SetGroupID(groupId uint) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.guint       // out

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg1 = C.guint(groupId)

	C.gst_message_set_group_id(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(groupId)
}

// SetQosStats: set the QoS stats representing the history of the current
// continuous pipeline playback period.
//
// When format is GST_FORMAT_UNDEFINED both dropped and processed are invalid.
// Values of -1 for either processed or dropped mean unknown values.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - format units of the 'processed' and 'dropped' fields. Video sinks and
//     video filters will use GST_FORMAT_BUFFERS (frames). Audio sinks and audio
//     filters will likely use GST_FORMAT_DEFAULT (samples).
//   - processed: total number of units correctly processed since the last state
//     change to READY or a flushing operation.
//   - dropped: total number of units dropped since the last state change to
//     READY or a flushing operation.
func (message *Message) SetQosStats(format Format, processed uint64, dropped uint64) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _arg3 C.guint64     // out

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(processed)
	_arg3 = C.guint64(dropped)

	C.gst_message_set_qos_stats(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(message)
	runtime.KeepAlive(format)
	runtime.KeepAlive(processed)
	runtime.KeepAlive(dropped)
}

// SetQosValues: set the QoS values that have been calculated/analysed from the
// QoS data
//
// MT safe.
//
// The function takes the following parameters:
//
//   - jitter: difference of the running-time against the deadline.
//   - proportion: long term prediction of the ideal rate relative to normal
//     rate to get optimal quality.
//   - quality: element dependent integer value that specifies the current
//     quality level of the element. The default maximum quality is 1000000.
func (message *Message) SetQosValues(jitter int64, proportion float64, quality int) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.gint64      // out
	var _arg2 C.gdouble     // out
	var _arg3 C.gint        // out

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg1 = C.gint64(jitter)
	_arg2 = C.gdouble(proportion)
	_arg3 = C.gint(quality)

	C.gst_message_set_qos_values(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(message)
	runtime.KeepAlive(jitter)
	runtime.KeepAlive(proportion)
	runtime.KeepAlive(quality)
}

// SetSeqnum: set the sequence number of a message.
//
// This function might be called by the creator of a message to indicate that
// the message relates to other messages or events. See gst_message_get_seqnum()
// for more information.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - seqnum: sequence number.
func (message *Message) SetSeqnum(seqnum uint32) {
	var _arg0 *C.GstMessage // out
	var _arg1 C.guint32     // out

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg1 = C.guint32(seqnum)

	C.gst_message_set_seqnum(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(seqnum)
}

// SetStreamStatusObject configures the object handling the streaming thread.
// This is usually a GstTask object but other objects might be added in the
// future.
//
// The function takes the following parameters:
//
//   - object controlling the streaming.
func (message *Message) SetStreamStatusObject(object *coreglib.Value) {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GValue     // out

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg1 = (*C.GValue)(unsafe.Pointer(object.Native()))

	C.gst_message_set_stream_status_object(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(object)
}

// StreamsSelectedAdd adds the stream to the message.
//
// The function takes the following parameters:
//
//   - stream to add to message.
func (message *Message) StreamsSelectedAdd(stream *Stream) {
	var _arg0 *C.GstMessage // out
	var _arg1 *C.GstStream  // out

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg1 = (*C.GstStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	C.gst_message_streams_selected_add(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(stream)
}

// StreamsSelectedGetSize returns the number of streams contained in the
// message.
//
// The function returns the following values:
//
//   - guint: number of streams contained within.
func (message *Message) StreamsSelectedGetSize() uint {
	var _arg0 *C.GstMessage // out
	var _cret C.guint       // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	_cret = C.gst_message_streams_selected_get_size(_arg0)
	runtime.KeepAlive(message)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// StreamsSelectedGetStream retrieves the Stream with index index from the
// message.
//
// The function takes the following parameters:
//
//   - idx: index of the stream to retrieve.
//
// The function returns the following values:
//
//   - stream (optional): Stream.
func (message *Message) StreamsSelectedGetStream(idx uint) *Stream {
	var _arg0 *C.GstMessage // out
	var _arg1 C.guint       // out
	var _cret *C.GstStream  // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg1 = C.guint(idx)

	_cret = C.gst_message_streams_selected_get_stream(_arg0, _arg1)
	runtime.KeepAlive(message)
	runtime.KeepAlive(idx)

	var _stream *Stream // out

	if _cret != nil {
		_stream = wrapStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _stream
}

// WritableStructure: get a writable version of the structure.
//
// The function returns the following values:
//
//   - structure of the message. The structure is still owned by the message,
//     which means that you should not free it and that the pointer becomes
//     invalid when you free the message. This function ensures that message is
//     writable, and if so, will never return NULL.
//
//     MT safe.
func (message *Message) WritableStructure() *Structure {
	var _arg0 *C.GstMessage   // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))

	_cret = C.gst_message_writable_structure(_arg0)
	runtime.KeepAlive(message)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _structure
}

// Meta structure should be included as the first member of a Buffer metadata
// structure. The structure defines the API of the metadata and should be
// accessible to all elements using the metadata.
//
// A metadata API is registered with gst_meta_api_type_register() which takes
// a name for the metadata API and some tags associated with the metadata.
// With gst_meta_api_type_has_tag() one can check if a certain metadata API
// contains a given tag.
//
// Multiple implementations of a metadata API can be registered. To implement
// a metadata API, gst_meta_register() should be used. This function takes all
// parameters needed to create, free and transform metadata along with the size
// of the metadata. The function returns a MetaInfo structure that contains the
// information for the implementation of the API.
//
// A specific implementation can be retrieved by name with gst_meta_get_info().
//
// See Buffer for how the metadata can be added, retrieved and removed from
// buffers.
//
// An instance of this type is always passed by reference.
type Meta struct {
	*meta
}

// meta is the struct that's finalized.
type meta struct {
	native *C.GstMeta
}

// Flags: extra flags for the metadata.
func (m *Meta) Flags() MetaFlags {
	valptr := &m.native.flags
	var _v MetaFlags // out
	_v = MetaFlags(*valptr)
	return _v
}

// Info: pointer to the MetaInfo.
func (m *Meta) Info() *MetaInfo {
	valptr := &m.native.info
	var _v *MetaInfo // out
	_v = (*MetaInfo)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// CompareSeqnum: meta sequence number compare function. Can be used as Func or
// a DataFunc.
//
// The function takes the following parameters:
//
//   - meta2: Meta.
//
// The function returns the following values:
//
//   - gint: negative number if meta1 comes before meta2, 0 if both metas have
//     an equal sequence number, or a positive integer if meta1 comes after
//     meta2.
func (meta1 *Meta) CompareSeqnum(meta2 *Meta) int {
	var _arg0 *C.GstMeta // out
	var _arg1 *C.GstMeta // out
	var _cret C.gint     // in

	_arg0 = (*C.GstMeta)(gextras.StructNative(unsafe.Pointer(meta1)))
	_arg1 = (*C.GstMeta)(gextras.StructNative(unsafe.Pointer(meta2)))

	_cret = C.gst_meta_compare_seqnum(_arg0, _arg1)
	runtime.KeepAlive(meta1)
	runtime.KeepAlive(meta2)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Seqnum gets seqnum for this meta.
func (meta *Meta) Seqnum() uint64 {
	var _arg0 *C.GstMeta // out
	var _cret C.guint64  // in

	_arg0 = (*C.GstMeta)(gextras.StructNative(unsafe.Pointer(meta)))

	_cret = C.gst_meta_get_seqnum(_arg0)
	runtime.KeepAlive(meta)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// Serialize meta into a format that can be stored or transmitted and later
// deserialized by gst_meta_deserialize().
//
// This is only supported for meta that implements MetaInfo.serialize_func,
// FALSE is returned otherwise.
//
// Upon failure, data->data pointer could have been reallocated, but data->len
// won't be modified. This is intended to be able to append multiple metas into
// the same Array.
//
// Since serialization size is often the same for every buffer, caller may want
// to remember the size of previous data to preallocate the next.
//
// The function takes the following parameters:
//
//   - data to append serialization data.
//
// The function returns the following values:
//
//   - ok: TRUE on success, FALSE otherwise.
func (meta *Meta) Serialize(data *ByteArrayInterface) bool {
	var _arg0 *C.GstMeta               // out
	var _arg1 *C.GstByteArrayInterface // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstMeta)(gextras.StructNative(unsafe.Pointer(meta)))
	_arg1 = (*C.GstByteArrayInterface)(gextras.StructNative(unsafe.Pointer(data)))

	_cret = C.gst_meta_serialize(_arg0, _arg1)
	runtime.KeepAlive(meta)
	runtime.KeepAlive(data)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SerializeSimple: same as gst_meta_serialize() but with a Array instead of
// ByteArrayInterface.
//
// The function takes the following parameters:
//
//   - data to append serialization data.
//
// The function returns the following values:
//
//   - ok: TRUE on success, FALSE otherwise.
func (meta *Meta) SerializeSimple(data []byte) bool {
	var _arg0 *C.GstMeta    // out
	var _arg1 *C.GByteArray // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstMeta)(gextras.StructNative(unsafe.Pointer(meta)))
	_arg1 = C.g_byte_array_sized_new(C.guint(len(data)))
	if len(data) > 0 {
		_arg1 = C.g_byte_array_append(_arg1, (*C.guint8)(&data[0]), C.guint(len(data)))
	}
	defer C.g_byte_array_unref(_arg1)

	_cret = C.gst_meta_serialize_simple(_arg0, _arg1)
	runtime.KeepAlive(meta)
	runtime.KeepAlive(data)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - api: API.
//
// The function returns the following values:
//
//   - utf8s: array of tags as strings.
func MetaApiTypeGetTags(api coreglib.Type) []string {
	var _arg1 C.GType   // out
	var _cret **C.gchar // in

	_arg1 = C.GType(api)

	_cret = C.gst_meta_api_type_get_tags(_arg1)
	runtime.KeepAlive(api)

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// MetaApiTypeHasTag: check if api was registered with tag.
//
// The function takes the following parameters:
//
//   - api: API.
//   - tag to check.
//
// The function returns the following values:
//
//   - ok: TRUE if api was registered with tag.
func MetaApiTypeHasTag(api coreglib.Type, tag glib.Quark) bool {
	var _arg1 C.GType    // out
	var _arg2 C.GQuark   // out
	var _cret C.gboolean // in

	_arg1 = C.GType(api)
	_arg2 = C.GQuark(tag)

	_cret = C.gst_meta_api_type_has_tag(_arg1, _arg2)
	runtime.KeepAlive(api)
	runtime.KeepAlive(tag)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MetaApiTypeRegister: register and return a GType for the api and associate it
// with tags.
//
// The function takes the following parameters:
//
//   - api: API to register.
//   - tags for api.
//
// The function returns the following values:
//
//   - gType: unique GType for api.
func MetaApiTypeRegister(api string, tags []string) coreglib.Type {
	var _arg1 *C.gchar  // out
	var _arg2 **C.gchar // out
	var _cret C.GType   // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(api)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		_arg2 = (**C.gchar)(C.calloc(C.size_t((len(tags) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice(_arg2, len(tags)+1)
			var zero *C.gchar
			out[len(tags)] = zero
			for i := range tags {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(tags[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.gst_meta_api_type_register(_arg1, _arg2)
	runtime.KeepAlive(api)
	runtime.KeepAlive(tags)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// MetaDeserialize: recreate a Meta from serialized data returned by
// gst_meta_serialize() and add it to buffer.
//
// Note that the meta must have been previously registered by calling one of
// gst_*_meta_get_info () functions.
//
// consumed is set to the number of bytes that can be skipped from data to find
// the next meta serialization, if any. In case of parsing error that does not
// allow to determine that size, consumed is set to 0.
//
// The function takes the following parameters:
//
//   - buffer: Buffer.
//   - data: serialization data obtained from gst_meta_serialize().
//   - size of data.
//
// The function returns the following values:
//
//   - consumed: total size used by this meta, could be less than size.
//   - meta (optional): metadata owned by buffer, or NULL.
func MetaDeserialize(buffer *Buffer, data *byte, size uint) (uint32, *Meta) {
	var _arg1 *C.GstBuffer // out
	var _arg2 *C.guint8    // out
	var _arg3 C.gsize      // out
	var _arg4 C.guint32    // in
	var _cret *C.GstMeta   // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = (*C.guint8)(unsafe.Pointer(data))
	_arg3 = C.gsize(size)

	_cret = C.gst_meta_deserialize(_arg1, _arg2, _arg3, &_arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(data)
	runtime.KeepAlive(size)

	var _consumed uint32 // out
	var _meta *Meta      // out

	_consumed = uint32(_arg4)
	if _cret != nil {
		_meta = (*Meta)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _consumed, _meta
}

// MetaGetInfo: lookup a previously registered meta info structure by its
// implementation name impl.
//
// The function takes the following parameters:
//
//   - impl: name.
//
// The function returns the following values:
//
//   - metaInfo (optional) with impl, or NULL when no such metainfo exists.
func MetaGetInfo(impl string) *MetaInfo {
	var _arg1 *C.gchar       // out
	var _cret *C.GstMetaInfo // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(impl)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_meta_get_info(_arg1)
	runtime.KeepAlive(impl)

	var _metaInfo *MetaInfo // out

	if _cret != nil {
		_metaInfo = (*MetaInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _metaInfo
}

// MetaRegisterCustom: register a new custom Meta implementation, backed by an
// opaque structure holding a Structure.
//
// The registered info can be retrieved later with gst_meta_get_info() by using
// name as the key.
//
// The backing Structure can be retrieved with gst_custom_meta_get_structure(),
// its mutability is conditioned by the writability of the buffer the meta is
// attached to.
//
// When transform_func is NULL, the meta and its backing Structure will
// always be copied when the transform operation is copy, other operations are
// discarded, copy regions are ignored.
//
// The function takes the following parameters:
//
//   - name of the Meta implementation.
//   - tags for api.
//   - transformFunc (optional): MetaTransformFunction.
//
// The function returns the following values:
//
//   - metaInfo that can be used to access metadata.
func MetaRegisterCustom(name string, tags []string, transformFunc CustomMetaTransformFunction) *MetaInfo {
	var _arg1 *C.gchar                         // out
	var _arg2 **C.gchar                        // out
	var _arg3 C.GstCustomMetaTransformFunction // out
	var _arg4 C.gpointer
	var _arg5 C.GDestroyNotify
	var _cret *C.GstMetaInfo // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		_arg2 = (**C.gchar)(C.calloc(C.size_t((len(tags) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice(_arg2, len(tags)+1)
			var zero *C.gchar
			out[len(tags)] = zero
			for i := range tags {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(tags[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	if transformFunc != nil {
		_arg3 = (*[0]byte)(C._gotk4_gst1_CustomMetaTransformFunction)
		_arg4 = C.gpointer(gbox.Assign(transformFunc))
		_arg5 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	_cret = C.gst_meta_register_custom(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(name)
	runtime.KeepAlive(tags)
	runtime.KeepAlive(transformFunc)

	var _metaInfo *MetaInfo // out

	_metaInfo = (*MetaInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _metaInfo
}

// MetaRegisterCustomSimple: simplified version of gst_meta_register_custom(),
// with no tags and no transform function.
//
// The function takes the following parameters:
//
//   - name of the Meta implementation.
//
// The function returns the following values:
//
//   - metaInfo that can be used to access metadata.
func MetaRegisterCustomSimple(name string) *MetaInfo {
	var _arg1 *C.gchar       // out
	var _cret *C.GstMetaInfo // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_meta_register_custom_simple(_arg1)
	runtime.KeepAlive(name)

	var _metaInfo *MetaInfo // out

	_metaInfo = (*MetaInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _metaInfo
}

// MetaInfo provides information about a specific metadata structure.
//
// An instance of this type is always passed by reference.
type MetaInfo struct {
	*metaInfo
}

// metaInfo is the struct that's finalized.
type metaInfo struct {
	native *C.GstMetaInfo
}

// The function returns the following values:
//
//   - ok: whether info was registered as a CustomMeta with
//     gst_meta_register_custom().
func (info *MetaInfo) IsCustom() bool {
	var _arg0 *C.GstMetaInfo // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstMetaInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gst_meta_info_is_custom(_arg0)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Register registers a new meta.
//
// Use the structure returned by gst_meta_info_new(), it consumes it and the
// structure shouldnt be used after. The one returned by the function can be
// kept.
//
// The function returns the following values:
//
//   - metaInfo: registered meta.
func (info *MetaInfo) Register() *MetaInfo {
	var _arg0 *C.GstMetaInfo // out
	var _cret *C.GstMetaInfo // in

	_arg0 = (*C.GstMetaInfo)(gextras.StructNative(unsafe.Pointer(info)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(info)), nil)

	_cret = C.gst_meta_info_register(_arg0)
	runtime.KeepAlive(info)

	var _metaInfo *MetaInfo // out

	_metaInfo = (*MetaInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _metaInfo
}

// MetaTransformCopy: extra data passed to a "gst-copy" transform
// MetaTransformFunction.
//
// An instance of this type is always passed by reference.
type MetaTransformCopy struct {
	*metaTransformCopy
}

// metaTransformCopy is the struct that's finalized.
type metaTransformCopy struct {
	native *C.GstMetaTransformCopy
}

// NewMetaTransformCopy creates a new MetaTransformCopy instance from the given
// fields. Beware that this function allocates on the Go heap; be careful
// when using it!
func NewMetaTransformCopy(region bool, offset, size uint) MetaTransformCopy {
	var f0 C.gboolean // out
	if region {
		f0 = C.TRUE
	}
	var f1 C.gsize // out
	f1 = C.gsize(offset)
	var f2 C.gsize // out
	f2 = C.gsize(size)

	v := C.GstMetaTransformCopy{
		region: f0,
		offset: f1,
		size:   f2,
	}

	return *(*MetaTransformCopy)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

// Region: TRUE if only region is copied.
func (m *MetaTransformCopy) Region() bool {
	valptr := &m.native.region
	var _v bool // out
	if *valptr != 0 {
		_v = true
	}
	return _v
}

// Offset: offset to copy, 0 if region is FALSE, otherwise > 0.
func (m *MetaTransformCopy) Offset() uint {
	valptr := &m.native.offset
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Size: size to copy, -1 or the buffer size when region is FALSE.
func (m *MetaTransformCopy) Size() uint {
	valptr := &m.native.size
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Region: TRUE if only region is copied.
func (m *MetaTransformCopy) SetRegion(region bool) {
	valptr := &m.native.region
	if region {
		*valptr = C.TRUE
	}
}

// Offset: offset to copy, 0 if region is FALSE, otherwise > 0.
func (m *MetaTransformCopy) SetOffset(offset uint) {
	valptr := &m.native.offset
	*valptr = C.gsize(offset)
}

// Size: size to copy, -1 or the buffer size when region is FALSE.
func (m *MetaTransformCopy) SetSize(size uint) {
	valptr := &m.native.size
	*valptr = C.gsize(size)
}

// MiniObject is a simple structure that can be used to implement refcounted
// types.
//
// Subclasses will include MiniObject as the first member in their structure and
// then call gst_mini_object_init() to initialize the MiniObject fields.
//
// gst_mini_object_ref() and gst_mini_object_unref() increment and decrement
// the refcount respectively. When the refcount of a mini-object reaches 0,
// the dispose function is called first and when this returns TRUE, the free
// function of the miniobject is called.
//
// A copy can be made with gst_mini_object_copy().
//
// gst_mini_object_is_writable() will return TRUE when the refcount of the
// object is exactly 1 and there is no parent or a single parent exists and is
// writable itself, meaning the current caller has the only reference to the
// object. gst_mini_object_make_writable() will return a writable version of the
// object, which might be a new copy when the refcount was not 1.
//
// Opaque data can be associated with a MiniObject with
// gst_mini_object_set_qdata() and gst_mini_object_get_qdata(). The data is
// meant to be specific to the particular object and is not automatically copied
// with gst_mini_object_copy() or similar methods.
//
// A weak reference can be added and remove with gst_mini_object_weak_ref() and
// gst_mini_object_weak_unref() respectively.
//
// An instance of this type is always passed by reference.
type MiniObject struct {
	*miniObject
}

// miniObject is the struct that's finalized.
type miniObject struct {
	native *C.GstMiniObject
}

func marshalMiniObject(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &MiniObject{&miniObject{(*C.GstMiniObject)(b)}}, nil
}

// AddParent: this adds parent as a parent for object. Having one ore more
// parents affects the writability of object: if a parent is not writable,
// object is also not writable, regardless of its refcount. object is only
// writable if all the parents are writable and its own refcount is exactly 1.
//
// Note: This function does not take ownership of parent and also does not take
// an additional reference. It is the responsibility of the caller to remove the
// parent again at a later time.
//
// The function takes the following parameters:
//
//   - parent MiniObject.
func (object *MiniObject) AddParent(parent *MiniObject) {
	var _arg0 *C.GstMiniObject // out
	var _arg1 *C.GstMiniObject // out

	_arg0 = (*C.GstMiniObject)(gextras.StructNative(unsafe.Pointer(object)))
	_arg1 = (*C.GstMiniObject)(gextras.StructNative(unsafe.Pointer(parent)))

	C.gst_mini_object_add_parent(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(parent)
}

// Qdata: this function gets back user data pointers stored via
// gst_mini_object_set_qdata().
//
// The function takes the following parameters:
//
//   - quark naming the user data pointer.
//
// The function returns the following values:
//
//   - gpointer (optional): user data pointer set, or NULL.
func (object *MiniObject) Qdata(quark glib.Quark) unsafe.Pointer {
	var _arg0 *C.GstMiniObject // out
	var _arg1 C.GQuark         // out
	var _cret C.gpointer       // in

	_arg0 = (*C.GstMiniObject)(gextras.StructNative(unsafe.Pointer(object)))
	_arg1 = C.GQuark(quark)

	_cret = C.gst_mini_object_get_qdata(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(quark)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// IsWritable: if mini_object has the LOCKABLE flag set, check if the current
// EXCLUSIVE lock on object is the only one, this means that changes to the
// object will not be visible to any other object.
//
// If the LOCKABLE flag is not set, check if the refcount of mini_object is
// exactly 1, meaning that no other reference exists to the object and that the
// object is therefore writable.
//
// Modification of a mini-object should only be done after verifying that it is
// writable.
//
// The function returns the following values:
//
//   - ok: TRUE if the object is writable.
func (miniObject *MiniObject) IsWritable() bool {
	var _arg0 *C.GstMiniObject // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstMiniObject)(gextras.StructNative(unsafe.Pointer(miniObject)))

	_cret = C.gst_mini_object_is_writable(_arg0)
	runtime.KeepAlive(miniObject)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Lock the mini-object with the specified access mode in flags.
//
// The function takes the following parameters:
//
//   - flags: LockFlags.
//
// The function returns the following values:
//
//   - ok: TRUE if object could be locked.
func (object *MiniObject) Lock(flags LockFlags) bool {
	var _arg0 *C.GstMiniObject // out
	var _arg1 C.GstLockFlags   // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstMiniObject)(gextras.StructNative(unsafe.Pointer(object)))
	_arg1 = C.GstLockFlags(flags)

	_cret = C.gst_mini_object_lock(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(flags)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveParent: this removes parent as a parent for object. See
// gst_mini_object_add_parent().
//
// The function takes the following parameters:
//
//   - parent MiniObject.
func (object *MiniObject) RemoveParent(parent *MiniObject) {
	var _arg0 *C.GstMiniObject // out
	var _arg1 *C.GstMiniObject // out

	_arg0 = (*C.GstMiniObject)(gextras.StructNative(unsafe.Pointer(object)))
	_arg1 = (*C.GstMiniObject)(gextras.StructNative(unsafe.Pointer(parent)))

	C.gst_mini_object_remove_parent(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(parent)
}

// StealQdata: this function gets back user data pointers stored via
// gst_mini_object_set_qdata() and removes the data from object without invoking
// its destroy() function (if any was set).
//
// The function takes the following parameters:
//
//   - quark naming the user data pointer.
//
// The function returns the following values:
//
//   - gpointer (optional): user data pointer set, or NULL.
func (object *MiniObject) StealQdata(quark glib.Quark) unsafe.Pointer {
	var _arg0 *C.GstMiniObject // out
	var _arg1 C.GQuark         // out
	var _cret C.gpointer       // in

	_arg0 = (*C.GstMiniObject)(gextras.StructNative(unsafe.Pointer(object)))
	_arg1 = C.GQuark(quark)

	_cret = C.gst_mini_object_steal_qdata(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(quark)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// Unlock the mini-object with the specified access mode in flags.
//
// The function takes the following parameters:
//
//   - flags: LockFlags.
func (object *MiniObject) Unlock(flags LockFlags) {
	var _arg0 *C.GstMiniObject // out
	var _arg1 C.GstLockFlags   // out

	_arg0 = (*C.GstMiniObject)(gextras.StructNative(unsafe.Pointer(object)))
	_arg1 = C.GstLockFlags(flags)

	C.gst_mini_object_unlock(_arg0, _arg1)
	runtime.KeepAlive(object)
	runtime.KeepAlive(flags)
}

// ObjectClass: GStreamer base object class.
//
// An instance of this type is always passed by reference.
type ObjectClass struct {
	*objectClass
}

// objectClass is the struct that's finalized.
type objectClass struct {
	native *C.GstObjectClass
}

// PathStringSeparator: separator used by gst_object_get_path_string().
func (o *ObjectClass) PathStringSeparator() string {
	valptr := &o.native.path_string_separator
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// PadClass: instance of this type is always passed by reference.
type PadClass struct {
	*padClass
}

// padClass is the struct that's finalized.
type padClass struct {
	native *C.GstPadClass
}

func (p *PadClass) ParentClass() *ObjectClass {
	valptr := &p.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// PadProbeInfo: info passed in the PadProbeCallback.
//
// An instance of this type is always passed by reference.
type PadProbeInfo struct {
	*padProbeInfo
}

// padProbeInfo is the struct that's finalized.
type padProbeInfo struct {
	native *C.GstPadProbeInfo
}

// Type: current probe type.
func (p *PadProbeInfo) Type() PadProbeType {
	valptr := &p.native._type
	var _v PadProbeType // out
	_v = PadProbeType(*valptr)
	return _v
}

// ID: id of the probe.
func (p *PadProbeInfo) ID() uint32 {
	valptr := &p.native.id
	var _v uint32 // out
	_v = uint32(*valptr)
	return _v
}

// Data: type specific data, check the type field to know the datatype. This
// field can be NULL.
func (p *PadProbeInfo) Data() unsafe.Pointer {
	valptr := &p.native.data
	var _v unsafe.Pointer // out
	_v = (unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

// Offset: offset of pull probe, this field is valid when type contains
// T_PAD_PROBE_TYPE_PULL.
func (p *PadProbeInfo) Offset() uint64 {
	valptr := &p.native.offset
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Size: size of pull probe, this field is valid when type contains
// T_PAD_PROBE_TYPE_PULL.
func (p *PadProbeInfo) Size() uint {
	valptr := &p.native.size
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// ID: id of the probe.
func (p *PadProbeInfo) SetID(id uint32) {
	valptr := &p.native.id
	*valptr = C.gulong(id)
}

// Offset: offset of pull probe, this field is valid when type contains
// T_PAD_PROBE_TYPE_PULL.
func (p *PadProbeInfo) SetOffset(offset uint64) {
	valptr := &p.native.offset
	*valptr = C.guint64(offset)
}

// Size: size of pull probe, this field is valid when type contains
// T_PAD_PROBE_TYPE_PULL.
func (p *PadProbeInfo) SetSize(size uint) {
	valptr := &p.native.size
	*valptr = C.guint(size)
}

// The function returns the following values:
//
//   - buffer (optional) from the probe.
func (info *PadProbeInfo) Buffer() *Buffer {
	var _arg0 *C.GstPadProbeInfo // out
	var _cret *C.GstBuffer       // in

	_arg0 = (*C.GstPadProbeInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gst_pad_probe_info_get_buffer(_arg0)
	runtime.KeepAlive(info)

	var _buffer *Buffer // out

	if _cret != nil {
		_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _buffer
}

// The function returns the following values:
//
//   - bufferList (optional) from the probe.
func (info *PadProbeInfo) BufferList() *BufferList {
	var _arg0 *C.GstPadProbeInfo // out
	var _cret *C.GstBufferList   // in

	_arg0 = (*C.GstPadProbeInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gst_pad_probe_info_get_buffer_list(_arg0)
	runtime.KeepAlive(info)

	var _bufferList *BufferList // out

	if _cret != nil {
		_bufferList = (*BufferList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _bufferList
}

// The function returns the following values:
//
//   - event (optional) from the probe.
func (info *PadProbeInfo) Event() *Event {
	var _arg0 *C.GstPadProbeInfo // out
	var _cret *C.GstEvent        // in

	_arg0 = (*C.GstPadProbeInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gst_pad_probe_info_get_event(_arg0)
	runtime.KeepAlive(info)

	var _event *Event // out

	if _cret != nil {
		_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _event
}

// The function returns the following values:
//
//   - query (optional) from the probe.
func (info *PadProbeInfo) Query() *Query {
	var _arg0 *C.GstPadProbeInfo // out
	var _cret *C.GstQuery        // in

	_arg0 = (*C.GstPadProbeInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gst_pad_probe_info_get_query(_arg0)
	runtime.KeepAlive(info)

	var _query *Query // out

	if _cret != nil {
		_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _query
}

// PadTemplateClass: instance of this type is always passed by reference.
type PadTemplateClass struct {
	*padTemplateClass
}

// padTemplateClass is the struct that's finalized.
type padTemplateClass struct {
	native *C.GstPadTemplateClass
}

func (p *PadTemplateClass) ParentClass() *ObjectClass {
	valptr := &p.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ParamSpecArray: GParamSpec derived structure for arrays of values.
//
// An instance of this type is always passed by reference.
type ParamSpecArray struct {
	*paramSpecArray
}

// paramSpecArray is the struct that's finalized.
type paramSpecArray struct {
	native *C.GstParamSpecArray
}

// ParamSpecFraction: GParamSpec derived structure that contains the meta data
// for fractional properties.
//
// An instance of this type is always passed by reference.
type ParamSpecFraction struct {
	*paramSpecFraction
}

// paramSpecFraction is the struct that's finalized.
type paramSpecFraction struct {
	native *C.GstParamSpecFraction
}

// MinNum: minimal numerator.
func (p *ParamSpecFraction) MinNum() int {
	valptr := &p.native.min_num
	var _v int // out
	_v = int(*valptr)
	return _v
}

// MinDen: minimal denominator.
func (p *ParamSpecFraction) MinDen() int {
	valptr := &p.native.min_den
	var _v int // out
	_v = int(*valptr)
	return _v
}

// MaxNum: maximal numerator.
func (p *ParamSpecFraction) MaxNum() int {
	valptr := &p.native.max_num
	var _v int // out
	_v = int(*valptr)
	return _v
}

// MaxDen: maximal denominator.
func (p *ParamSpecFraction) MaxDen() int {
	valptr := &p.native.max_den
	var _v int // out
	_v = int(*valptr)
	return _v
}

// DefNum: default numerator.
func (p *ParamSpecFraction) DefNum() int {
	valptr := &p.native.def_num
	var _v int // out
	_v = int(*valptr)
	return _v
}

// DefDen: default denominator.
func (p *ParamSpecFraction) DefDen() int {
	valptr := &p.native.def_den
	var _v int // out
	_v = int(*valptr)
	return _v
}

// MinNum: minimal numerator.
func (p *ParamSpecFraction) SetMinNum(minNum int) {
	valptr := &p.native.min_num
	*valptr = C.gint(minNum)
}

// MinDen: minimal denominator.
func (p *ParamSpecFraction) SetMinDen(minDen int) {
	valptr := &p.native.min_den
	*valptr = C.gint(minDen)
}

// MaxNum: maximal numerator.
func (p *ParamSpecFraction) SetMaxNum(maxNum int) {
	valptr := &p.native.max_num
	*valptr = C.gint(maxNum)
}

// MaxDen: maximal denominator.
func (p *ParamSpecFraction) SetMaxDen(maxDen int) {
	valptr := &p.native.max_den
	*valptr = C.gint(maxDen)
}

// DefNum: default numerator.
func (p *ParamSpecFraction) SetDefNum(defNum int) {
	valptr := &p.native.def_num
	*valptr = C.gint(defNum)
}

// DefDen: default denominator.
func (p *ParamSpecFraction) SetDefDen(defDen int) {
	valptr := &p.native.def_den
	*valptr = C.gint(defDen)
}

// ParentBufferMeta is a Meta which can be attached to a Buffer to hold a
// reference to another buffer that is only released when the child Buffer is
// released.
//
// Typically, ParentBufferMeta is used when the child buffer is directly using
// the Memory of the parent buffer, and wants to prevent the parent buffer from
// being returned to a buffer pool until the Memory is available for re-use.
//
// An instance of this type is always passed by reference.
type ParentBufferMeta struct {
	*parentBufferMeta
}

// parentBufferMeta is the struct that's finalized.
type parentBufferMeta struct {
	native *C.GstParentBufferMeta
}

// Parent: parent Meta structure.
func (p *ParentBufferMeta) Parent() *Meta {
	valptr := &p.native.parent
	var _v *Meta // out
	_v = (*Meta)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Buffer on which a reference is being held.
func (p *ParentBufferMeta) Buffer() *Buffer {
	valptr := &p.native.buffer
	var _v *Buffer // out
	_v = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// ParentBufferMetaGetInfo gets the global MetaInfo describing the
// ParentBufferMeta meta.
//
// The function returns the following values:
//
//   - metaInfo: MetaInfo.
func ParentBufferMetaGetInfo() *MetaInfo {
	var _cret *C.GstMetaInfo // in

	_cret = C.gst_parent_buffer_meta_get_info()

	var _metaInfo *MetaInfo // out

	_metaInfo = (*MetaInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _metaInfo
}

// ParseContext: opaque structure.
//
// An instance of this type is always passed by reference.
type ParseContext struct {
	*parseContext
}

// parseContext is the struct that's finalized.
type parseContext struct {
	native *C.GstParseContext
}

func marshalParseContext(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &ParseContext{&parseContext{(*C.GstParseContext)(b)}}, nil
}

// NewParseContext constructs a struct ParseContext.
func NewParseContext() *ParseContext {
	var _cret *C.GstParseContext // in

	_cret = C.gst_parse_context_new()

	var _parseContext *ParseContext // out

	if _cret != nil {
		_parseContext = (*ParseContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_parseContext)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_parse_context_free((*C.GstParseContext)(intern.C))
			},
		)
	}

	return _parseContext
}

// Copy copies the context.
//
// The function returns the following values:
//
//   - parseContext (optional): copied ParseContext.
func (context *ParseContext) Copy() *ParseContext {
	var _arg0 *C.GstParseContext // out
	var _cret *C.GstParseContext // in

	_arg0 = (*C.GstParseContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.gst_parse_context_copy(_arg0)
	runtime.KeepAlive(context)

	var _parseContext *ParseContext // out

	if _cret != nil {
		_parseContext = (*ParseContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_parseContext)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_parse_context_free((*C.GstParseContext)(intern.C))
			},
		)
	}

	return _parseContext
}

// MissingElements: retrieve missing elements from a previous run of
// gst_parse_launch_full() or gst_parse_launchv_full(). Will only return results
// if an error code of GST_PARSE_ERROR_NO_SUCH_ELEMENT was returned.
//
// The function returns the following values:
//
//   - utf8s (optional): a NULL-terminated array of element factory name strings
//     of missing elements. Free with g_strfreev() when no longer needed.
func (context *ParseContext) MissingElements() []string {
	var _arg0 *C.GstParseContext // out
	var _cret **C.gchar          // in

	_arg0 = (*C.GstParseContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.gst_parse_context_get_missing_elements(_arg0)
	runtime.KeepAlive(context)

	var _utf8s []string // out

	if _cret != nil {
		defer C.free(unsafe.Pointer(_cret))
		{
			var i int
			var z *C.gchar
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
				defer C.free(unsafe.Pointer(src[i]))
			}
		}
	}

	return _utf8s
}

// PipelineClass: instance of this type is always passed by reference.
type PipelineClass struct {
	*pipelineClass
}

// pipelineClass is the struct that's finalized.
type pipelineClass struct {
	native *C.GstPipelineClass
}

func (p *PipelineClass) ParentClass() *BinClass {
	valptr := &p.native.parent_class
	var _v *BinClass // out
	_v = (*BinClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// PluginDesc: plugin should export a variable of this type called plugin_desc.
// The plugin loader will use the data provided there to initialize the plugin.
//
// The licence parameter must be one of: LGPL, GPL, QPL, GPL/QPL, MPL, BSD,
// MIT/X11, Proprietary, unknown.
//
// An instance of this type is always passed by reference.
type PluginDesc struct {
	*pluginDesc
}

// pluginDesc is the struct that's finalized.
type pluginDesc struct {
	native *C.GstPluginDesc
}

// PollFD: file descriptor object.
//
// An instance of this type is always passed by reference.
type PollFD struct {
	*pollFD
}

// pollFD is the struct that's finalized.
type pollFD struct {
	native *C.GstPollFD
}

// Fd: file descriptor.
func (p *PollFD) Fd() int {
	valptr := &p.native.fd
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Fd: file descriptor.
func (p *PollFD) SetFd(fd int) {
	valptr := &p.native.fd
	*valptr = C.int(fd)
}

// Init initializes fd. Alternatively you can initialize it with T_POLL_FD_INIT.
func (fd *PollFD) Init() {
	var _arg0 *C.GstPollFD // out

	_arg0 = (*C.GstPollFD)(gextras.StructNative(unsafe.Pointer(fd)))

	C.gst_poll_fd_init(_arg0)
	runtime.KeepAlive(fd)
}

// PresetInterface interface.
//
// An instance of this type is always passed by reference.
type PresetInterface struct {
	*presetInterface
}

// presetInterface is the struct that's finalized.
type presetInterface struct {
	native *C.GstPresetInterface
}

// Promise object implements the container for values that
// may be available later. i.e. a Future or a Promise in
// <https://en.wikipedia.org/wiki/Futures_and_promises>. As with all
// Future/Promise-like functionality, there is the concept of the producer of
// the value and the consumer of the value.
//
// A Promise is created with gst_promise_new() by the consumer and passed
// to the producer to avoid thread safety issues with the change callback.
// A Promise can be replied to with a value (or an error) by the producer with
// gst_promise_reply(). The exact value returned is defined by the API contract
// of the producer and NULL may be a valid reply. gst_promise_interrupt() is
// for the consumer to indicate to the producer that the value is not needed
// anymore and producing that value can stop. The GST_PROMISE_RESULT_EXPIRED
// state set by a call to gst_promise_expire() indicates to the consumer
// that a value will never be produced and is intended to be called by a
// third party that implements some notion of message handling such as Bus.
// A callback can also be installed at Promise creation for result changes with
// gst_promise_new_with_change_func(). The change callback can be used to chain
// Promises's together as in the following example.
//
//	const GstStructure *reply;
//	GstPromise *p;
//	if (gst_promise_wait (promise) != GST_PROMISE_RESULT_REPLIED)
//	  return; // interrupted or expired value
//	reply = gst_promise_get_reply (promise);
//	if (error in reply)
//	  return; // propagate error
//	p = gst_promise_new_with_change_func (another_promise_change_func, user_data, notify);
//	pass p to promise-using API
//
// Each Promise starts out with a PromiseResult of GST_PROMISE_RESULT_PENDING
// and only ever transitions once into one of the other PromiseResult's.
//
// In order to support multi-threaded code, gst_promise_reply(),
// gst_promise_interrupt() and gst_promise_expire() may all be from different
// threads with some restrictions and the final result of the promise is
// whichever call is made first. There are two restrictions on ordering:
//
// 1. That gst_promise_reply() and gst_promise_interrupt() cannot be
// called after gst_promise_expire() 2. That gst_promise_reply() and
// gst_promise_interrupt() cannot be called twice.
//
// The change function set with gst_promise_new_with_change_func() is called
// directly from either the gst_promise_reply(), gst_promise_interrupt() or
// gst_promise_expire() and can be called from an arbitrary thread. Promise
// using APIs can restrict this to a single thread or a subset of threads but
// that is entirely up to the API that uses Promise.
//
// An instance of this type is always passed by reference.
type Promise struct {
	*promise
}

// promise is the struct that's finalized.
type promise struct {
	native *C.GstPromise
}

func marshalPromise(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Promise{&promise{(*C.GstPromise)(b)}}, nil
}

// NewPromise constructs a struct Promise.
func NewPromise() *Promise {
	var _cret *C.GstPromise // in

	_cret = C.gst_promise_new()

	var _promise *Promise // out

	_promise = (*Promise)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_promise)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _promise
}

// NewPromiseWithChangeFunc constructs a struct Promise.
func NewPromiseWithChangeFunc(fn PromiseChangeFunc) *Promise {
	var _arg1 C.GstPromiseChangeFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify
	var _cret *C.GstPromise // in

	_arg1 = (*[0]byte)(C._gotk4_gst1_PromiseChangeFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.gst_promise_new_with_change_func(_arg1, _arg2, _arg3)
	runtime.KeepAlive(fn)

	var _promise *Promise // out

	_promise = (*Promise)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_promise)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _promise
}

// Parent: parent MiniObject.
func (p *Promise) Parent() *MiniObject {
	valptr := &p.native.parent
	var _v *MiniObject // out
	_v = (*MiniObject)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Expire a promise. This will wake up any waiters with
// GST_PROMISE_RESULT_EXPIRED. Called by a message loop when the parent message
// is handled and/or destroyed (possibly unanswered).
func (promise *Promise) Expire() {
	var _arg0 *C.GstPromise // out

	_arg0 = (*C.GstPromise)(gextras.StructNative(unsafe.Pointer(promise)))

	C.gst_promise_expire(_arg0)
	runtime.KeepAlive(promise)
}

// GetReply: retrieve the reply set on promise. promise must be in
// GST_PROMISE_RESULT_REPLIED and the returned structure is owned by promise.
//
// The function returns the following values:
//
//   - structure (optional): reply set on promise.
func (promise *Promise) GetReply() *Structure {
	var _arg0 *C.GstPromise   // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstPromise)(gextras.StructNative(unsafe.Pointer(promise)))

	_cret = C.gst_promise_get_reply(_arg0)
	runtime.KeepAlive(promise)

	var _structure *Structure // out

	if _cret != nil {
		_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _structure
}

// Interrupt waiting for a promise. This will wake up any waiters with
// GST_PROMISE_RESULT_INTERRUPTED. Called when the consumer does not want the
// value produced anymore.
func (promise *Promise) Interrupt() {
	var _arg0 *C.GstPromise // out

	_arg0 = (*C.GstPromise)(gextras.StructNative(unsafe.Pointer(promise)))

	C.gst_promise_interrupt(_arg0)
	runtime.KeepAlive(promise)
}

// Reply: set a reply on promise. This will wake up any waiters with
// GST_PROMISE_RESULT_REPLIED. Called by the producer of the value to indicate
// success (or failure).
//
// If promise has already been interrupted by the consumer, then this reply is
// not visible to the consumer.
//
// The function takes the following parameters:
//
//   - s (optional) with the the reply contents.
func (promise *Promise) Reply(s *Structure) {
	var _arg0 *C.GstPromise   // out
	var _arg1 *C.GstStructure // out

	if promise != nil {
		_arg0 = (*C.GstPromise)(gextras.StructNative(unsafe.Pointer(promise)))
	}
	if s != nil {
		_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(s)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(s)), nil)
	}

	C.gst_promise_reply(_arg0, _arg1)
	runtime.KeepAlive(promise)
	runtime.KeepAlive(s)
}

// Wait for promise to move out of the GST_PROMISE_RESULT_PENDING state. If
// promise is not in GST_PROMISE_RESULT_PENDING then it will return immediately
// with the current result.
//
// The function returns the following values:
//
//   - promiseResult: result of the promise.
func (promise *Promise) Wait() PromiseResult {
	var _arg0 *C.GstPromise      // out
	var _cret C.GstPromiseResult // in

	_arg0 = (*C.GstPromise)(gextras.StructNative(unsafe.Pointer(promise)))

	_cret = C.gst_promise_wait(_arg0)
	runtime.KeepAlive(promise)

	var _promiseResult PromiseResult // out

	_promiseResult = PromiseResult(_cret)

	return _promiseResult
}

// ProtectionMeta: metadata type that holds information about a sample from a
// protection-protected track, including the information needed to decrypt it
// (if it is encrypted).
//
// An instance of this type is always passed by reference.
type ProtectionMeta struct {
	*protectionMeta
}

// protectionMeta is the struct that's finalized.
type protectionMeta struct {
	native *C.GstProtectionMeta
}

// Meta: parent Meta.
func (p *ProtectionMeta) Meta() *Meta {
	valptr := &p.native.meta
	var _v *Meta // out
	_v = (*Meta)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Info: cryptographic information needed to decrypt the sample.
func (p *ProtectionMeta) Info() *Structure {
	valptr := &p.native.info
	var _v *Structure // out
	_v = (*Structure)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

func ProtectionMetaGetInfo() *MetaInfo {
	var _cret *C.GstMetaInfo // in

	_cret = C.gst_protection_meta_get_info()

	var _metaInfo *MetaInfo // out

	_metaInfo = (*MetaInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _metaInfo
}

// ProxyPadClass: instance of this type is always passed by reference.
type ProxyPadClass struct {
	*proxyPadClass
}

// proxyPadClass is the struct that's finalized.
type proxyPadClass struct {
	native *C.GstProxyPadClass
}

func (p *ProxyPadClass) ParentClass() *PadClass {
	valptr := &p.native.parent_class
	var _v *PadClass // out
	_v = (*PadClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Query queries can be performed on pads (gst_pad_query()) and elements
// (gst_element_query()). Please note that some queries might need a running
// pipeline to work.
//
// Queries can be created using the gst_query_new_*() functions. Query values
// can be set using gst_query_set_*(), and parsed using gst_query_parse_*()
// helpers.
//
// The following example shows how to query the duration of a pipeline:
//
//	GstQuery *query;
//	gboolean res;
//	query = gst_query_new_duration (GST_FORMAT_TIME);
//	res = gst_element_query (pipeline, query);
//	if (res) {
//	  gint64 duration;
//	  gst_query_parse_duration (query, NULL, &duration);
//	  g_print ("duration = %"GST_TIME_FORMAT, GST_TIME_ARGS (duration));
//	} else {
//	  g_print ("duration query failed...");
//	}
//	gst_query_unref (query);
//
// An instance of this type is always passed by reference.
type Query struct {
	*query
}

// query is the struct that's finalized.
type query struct {
	native *C.GstQuery
}

func marshalQuery(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Query{&query{(*C.GstQuery)(b)}}, nil
}

// NewQueryAcceptCaps constructs a struct Query.
func NewQueryAcceptCaps(caps *Caps) *Query {
	var _arg1 *C.GstCaps  // out
	var _cret *C.GstQuery // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_query_new_accept_caps(_arg1)
	runtime.KeepAlive(caps)

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryAllocation constructs a struct Query.
func NewQueryAllocation(caps *Caps, needPool bool) *Query {
	var _arg1 *C.GstCaps  // out
	var _arg2 C.gboolean  // out
	var _cret *C.GstQuery // in

	if caps != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}
	if needPool {
		_arg2 = C.TRUE
	}

	_cret = C.gst_query_new_allocation(_arg1, _arg2)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(needPool)

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryBitrate constructs a struct Query.
func NewQueryBitrate() *Query {
	var _cret *C.GstQuery // in

	_cret = C.gst_query_new_bitrate()

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryBuffering constructs a struct Query.
func NewQueryBuffering(format Format) *Query {
	var _arg1 C.GstFormat // out
	var _cret *C.GstQuery // in

	_arg1 = C.GstFormat(format)

	_cret = C.gst_query_new_buffering(_arg1)
	runtime.KeepAlive(format)

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryCaps constructs a struct Query.
func NewQueryCaps(filter *Caps) *Query {
	var _arg1 *C.GstCaps  // out
	var _cret *C.GstQuery // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))

	_cret = C.gst_query_new_caps(_arg1)
	runtime.KeepAlive(filter)

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryContext constructs a struct Query.
func NewQueryContext(contextType string) *Query {
	var _arg1 *C.gchar    // out
	var _cret *C.GstQuery // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(contextType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_query_new_context(_arg1)
	runtime.KeepAlive(contextType)

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryConvert constructs a struct Query.
func NewQueryConvert(srcFormat Format, value int64, destFormat Format) *Query {
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // out
	var _arg3 C.GstFormat // out
	var _cret *C.GstQuery // in

	_arg1 = C.GstFormat(srcFormat)
	_arg2 = C.gint64(value)
	_arg3 = C.GstFormat(destFormat)

	_cret = C.gst_query_new_convert(_arg1, _arg2, _arg3)
	runtime.KeepAlive(srcFormat)
	runtime.KeepAlive(value)
	runtime.KeepAlive(destFormat)

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryCustom constructs a struct Query.
func NewQueryCustom(typ QueryType, structure *Structure) *Query {
	var _arg1 C.GstQueryType  // out
	var _arg2 *C.GstStructure // out
	var _cret *C.GstQuery     // in

	_arg1 = C.GstQueryType(typ)
	if structure != nil {
		_arg2 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(structure)), nil)
	}

	_cret = C.gst_query_new_custom(_arg1, _arg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(structure)

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryDrain constructs a struct Query.
func NewQueryDrain() *Query {
	var _cret *C.GstQuery // in

	_cret = C.gst_query_new_drain()

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryDuration constructs a struct Query.
func NewQueryDuration(format Format) *Query {
	var _arg1 C.GstFormat // out
	var _cret *C.GstQuery // in

	_arg1 = C.GstFormat(format)

	_cret = C.gst_query_new_duration(_arg1)
	runtime.KeepAlive(format)

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryFormats constructs a struct Query.
func NewQueryFormats() *Query {
	var _cret *C.GstQuery // in

	_cret = C.gst_query_new_formats()

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryLatency constructs a struct Query.
func NewQueryLatency() *Query {
	var _cret *C.GstQuery // in

	_cret = C.gst_query_new_latency()

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryPosition constructs a struct Query.
func NewQueryPosition(format Format) *Query {
	var _arg1 C.GstFormat // out
	var _cret *C.GstQuery // in

	_arg1 = C.GstFormat(format)

	_cret = C.gst_query_new_position(_arg1)
	runtime.KeepAlive(format)

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryScheduling constructs a struct Query.
func NewQueryScheduling() *Query {
	var _cret *C.GstQuery // in

	_cret = C.gst_query_new_scheduling()

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQuerySeeking constructs a struct Query.
func NewQuerySeeking(format Format) *Query {
	var _arg1 C.GstFormat // out
	var _cret *C.GstQuery // in

	_arg1 = C.GstFormat(format)

	_cret = C.gst_query_new_seeking(_arg1)
	runtime.KeepAlive(format)

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQuerySegment constructs a struct Query.
func NewQuerySegment(format Format) *Query {
	var _arg1 C.GstFormat // out
	var _cret *C.GstQuery // in

	_arg1 = C.GstFormat(format)

	_cret = C.gst_query_new_segment(_arg1)
	runtime.KeepAlive(format)

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQuerySelectable constructs a struct Query.
func NewQuerySelectable() *Query {
	var _cret *C.GstQuery // in

	_cret = C.gst_query_new_selectable()

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// NewQueryURI constructs a struct Query.
func NewQueryURI() *Query {
	var _cret *C.GstQuery // in

	_cret = C.gst_query_new_uri()

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _query
}

// MiniObject: parent MiniObject type.
func (q *Query) MiniObject() *MiniObject {
	valptr := &q.native.mini_object
	var _v *MiniObject // out
	_v = (*MiniObject)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Type: QueryType.
func (q *Query) Type() QueryType {
	valptr := &q.native._type
	var _v QueryType // out
	_v = QueryType(*valptr)
	return _v
}

// AddAllocationMeta: add api with params as one of the supported metadata API
// to query.
//
// The function takes the following parameters:
//
//   - api: metadata API.
//   - params (optional): API specific parameters.
func (query *Query) AddAllocationMeta(api coreglib.Type, params *Structure) {
	var _arg0 *C.GstQuery     // out
	var _arg1 C.GType         // out
	var _arg2 *C.GstStructure // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GType(api)
	if params != nil {
		_arg2 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(params)))
	}

	C.gst_query_add_allocation_meta(_arg0, _arg1, _arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(api)
	runtime.KeepAlive(params)
}

// AddAllocationParam: add allocator and its params as a supported memory
// allocator.
//
// The function takes the following parameters:
//
//   - allocator (optional): memory allocator.
//   - params (optional): AllocationParams.
func (query *Query) AddAllocationParam(allocator Allocatorrer, params *AllocationParams) {
	var _arg0 *C.GstQuery            // out
	var _arg1 *C.GstAllocator        // out
	var _arg2 *C.GstAllocationParams // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	if allocator != nil {
		_arg1 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	}
	if params != nil {
		_arg2 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	C.gst_query_add_allocation_param(_arg0, _arg1, _arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(allocator)
	runtime.KeepAlive(params)
}

// AddAllocationPool: set the pool parameters in query.
//
// The function takes the following parameters:
//
//   - pool (optional): BufferPool.
//   - size: buffer size.
//   - minBuffers: min buffers.
//   - maxBuffers: max buffers.
func (query *Query) AddAllocationPool(pool *BufferPool, size uint, minBuffers uint, maxBuffers uint) {
	var _arg0 *C.GstQuery      // out
	var _arg1 *C.GstBufferPool // out
	var _arg2 C.guint          // out
	var _arg3 C.guint          // out
	var _arg4 C.guint          // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	if pool != nil {
		_arg1 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	}
	_arg2 = C.guint(size)
	_arg3 = C.guint(minBuffers)
	_arg4 = C.guint(maxBuffers)

	C.gst_query_add_allocation_pool(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(query)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(size)
	runtime.KeepAlive(minBuffers)
	runtime.KeepAlive(maxBuffers)
}

// AddBufferingRange: set the buffering-ranges array field in query. The current
// last start position of the array should be inferior to start.
//
// The function takes the following parameters:
//
//   - start position of the range.
//   - stop position of the range.
//
// The function returns the following values:
//
//   - ok indicating if the range was added or not.
func (query *Query) AddBufferingRange(start int64, stop int64) bool {
	var _arg0 *C.GstQuery // out
	var _arg1 C.gint64    // out
	var _arg2 C.gint64    // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.gint64(start)
	_arg2 = C.gint64(stop)

	_cret = C.gst_query_add_buffering_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(start)
	runtime.KeepAlive(stop)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AddSchedulingMode: add mode as one of the supported scheduling modes to
// query.
//
// The function takes the following parameters:
//
//   - mode: PadMode.
func (query *Query) AddSchedulingMode(mode PadMode) {
	var _arg0 *C.GstQuery  // out
	var _arg1 C.GstPadMode // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GstPadMode(mode)

	C.gst_query_add_scheduling_mode(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(mode)
}

// FindAllocationMeta: check if query has metadata api set. When this function
// returns TRUE, index will contain the index where the requested API and the
// parameters can be found.
//
// The function takes the following parameters:
//
//   - api: metadata API.
//
// The function returns the following values:
//
//   - index (optional): index.
//   - ok: TRUE when api is in the list of metadata.
func (query *Query) FindAllocationMeta(api coreglib.Type) (uint, bool) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.GType     // out
	var _arg2 C.guint     // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GType(api)

	_cret = C.gst_query_find_allocation_meta(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(api)

	var _index uint // out
	var _ok bool    // out

	_index = uint(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _index, _ok
}

// NAllocationMetas: retrieve the number of values currently stored in the meta
// API array of the query's structure.
//
// The function returns the following values:
//
//   - guint: metadata API array size as a #guint.
func (query *Query) NAllocationMetas() uint {
	var _arg0 *C.GstQuery // out
	var _cret C.guint     // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_query_get_n_allocation_metas(_arg0)
	runtime.KeepAlive(query)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// NAllocationParams: retrieve the number of values currently stored in the
// allocator params array of the query's structure.
//
// If no memory allocator is specified, the downstream element can handle the
// default memory allocator. The first memory allocator in the query should be
// generic and allow mapping to system memory, all following allocators should
// be ordered by preference with the preferred one first.
//
// The function returns the following values:
//
//   - guint: allocator array size as a #guint.
func (query *Query) NAllocationParams() uint {
	var _arg0 *C.GstQuery // out
	var _cret C.guint     // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_query_get_n_allocation_params(_arg0)
	runtime.KeepAlive(query)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// NAllocationPools: retrieve the number of values currently stored in the pool
// array of the query's structure.
//
// The function returns the following values:
//
//   - guint: pool array size as a #guint.
func (query *Query) NAllocationPools() uint {
	var _arg0 *C.GstQuery // out
	var _cret C.guint     // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_query_get_n_allocation_pools(_arg0)
	runtime.KeepAlive(query)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// NBufferingRanges: retrieve the number of values currently stored in the
// buffered-ranges array of the query's structure.
//
// The function returns the following values:
//
//   - guint: range array size as a #guint.
func (query *Query) NBufferingRanges() uint {
	var _arg0 *C.GstQuery // out
	var _cret C.guint     // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_query_get_n_buffering_ranges(_arg0)
	runtime.KeepAlive(query)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// NSchedulingModes: retrieve the number of values currently stored in the
// scheduling mode array of the query's structure.
//
// The function returns the following values:
//
//   - guint: scheduling mode array size as a #guint.
func (query *Query) NSchedulingModes() uint {
	var _arg0 *C.GstQuery // out
	var _cret C.guint     // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_query_get_n_scheduling_modes(_arg0)
	runtime.KeepAlive(query)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Structure: get the structure of a query.
//
// The function returns the following values:
//
//   - structure (optional) of the query. The structure is still owned by the
//     query and will therefore be freed when the query is unreffed.
func (query *Query) Structure() *Structure {
	var _arg0 *C.GstQuery     // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_query_get_structure(_arg0)
	runtime.KeepAlive(query)

	var _structure *Structure // out

	if _cret != nil {
		_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _structure
}

// HasSchedulingMode: check if query has scheduling mode set.
//
// > When checking if upstream supports pull mode, it is usually not > enough
// to just check for GST_PAD_MODE_PULL with this function, you > also want to
// check whether the scheduling flags returned by > gst_query_parse_scheduling()
// have the seeking flag set (meaning > random access is supported, not only
// sequential pulls).
//
// The function takes the following parameters:
//
//   - mode: scheduling mode.
//
// The function returns the following values:
//
//   - ok: TRUE when mode is in the list of scheduling modes.
func (query *Query) HasSchedulingMode(mode PadMode) bool {
	var _arg0 *C.GstQuery  // out
	var _arg1 C.GstPadMode // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GstPadMode(mode)

	_cret = C.gst_query_has_scheduling_mode(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(mode)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasSchedulingModeWithFlags: check if query has scheduling mode set and flags
// is set in query scheduling flags.
//
// The function takes the following parameters:
//
//   - mode: scheduling mode.
//   - flags: SchedulingFlags.
//
// The function returns the following values:
//
//   - ok: TRUE when mode is in the list of scheduling modes and flags are
//     compatible with query flags.
func (query *Query) HasSchedulingModeWithFlags(mode PadMode, flags SchedulingFlags) bool {
	var _arg0 *C.GstQuery          // out
	var _arg1 C.GstPadMode         // out
	var _arg2 C.GstSchedulingFlags // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GstPadMode(mode)
	_arg2 = C.GstSchedulingFlags(flags)

	_cret = C.gst_query_has_scheduling_mode_with_flags(_arg0, _arg1, _arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(mode)
	runtime.KeepAlive(flags)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ParseAcceptCaps: get the caps from query. The caps remains valid as long as
// query remains valid.
//
// The function returns the following values:
//
//   - caps: pointer to the caps.
func (query *Query) ParseAcceptCaps() *Caps {
	var _arg0 *C.GstQuery // out
	var _arg1 *C.GstCaps  // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_accept_caps(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_arg1)))

	return _caps
}

// ParseAcceptCapsResult: parse the result from query and store in result.
//
// The function returns the following values:
//
//   - result (optional): location for the result.
func (query *Query) ParseAcceptCapsResult() bool {
	var _arg0 *C.GstQuery // out
	var _arg1 C.gboolean  // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_accept_caps_result(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _result bool // out

	if _arg1 != 0 {
		_result = true
	}

	return _result
}

// ParseAllocation: parse an allocation query, writing the requested caps in
// caps and whether a pool is needed in need_pool, if the respective parameters
// are non-NULL.
//
// Pool details can be retrieved using gst_query_get_n_allocation_pools() and
// gst_query_parse_nth_allocation_pool().
//
// The function returns the following values:
//
//   - caps (optional): Caps.
//   - needPool (optional): whether a BufferPool is needed.
func (query *Query) ParseAllocation() (*Caps, bool) {
	var _arg0 *C.GstQuery // out
	var _arg1 *C.GstCaps  // in
	var _arg2 C.gboolean  // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_allocation(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(query)

	var _caps *Caps    // out
	var _needPool bool // out

	if _arg1 != nil {
		_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
	}
	if _arg2 != 0 {
		_needPool = true
	}

	return _caps, _needPool
}

// ParseBitrate: get the results of a bitrate query. See also
// gst_query_set_bitrate().
//
// The function returns the following values:
//
//   - nominalBitrate (optional): resulting bitrate in bits per second.
func (query *Query) ParseBitrate() uint {
	var _arg0 *C.GstQuery // out
	var _arg1 C.guint     // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_bitrate(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _nominalBitrate uint // out

	_nominalBitrate = uint(_arg1)

	return _nominalBitrate
}

// ParseBufferingPercent: get the percentage of buffered data. This is a value
// between 0 and 100. The busy indicator is TRUE when the buffering is in
// progress.
//
// The function returns the following values:
//
//   - busy (optional): if buffering is busy, or NULL.
//   - percent (optional): buffering percent, or NULL.
func (query *Query) ParseBufferingPercent() (bool, int) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.gboolean  // in
	var _arg2 C.gint      // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_buffering_percent(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(query)

	var _busy bool   // out
	var _percent int // out

	if _arg1 != 0 {
		_busy = true
	}
	_percent = int(_arg2)

	return _busy, _percent
}

// ParseBufferingRange: parse an available query, writing the format into
// format, and other results into the passed parameters, if the respective
// parameters are non-NULL.
//
// The function returns the following values:
//
//   - format (optional) to set for the segment_start and segment_end values,
//     or NULL.
//   - start (optional) to set, or NULL.
//   - stop (optional) to set, or NULL.
//   - estimatedTotal (optional): estimated total amount of download time
//     remaining in milliseconds, or NULL.
func (query *Query) ParseBufferingRange() (format Format, start int64, stop int64, estimatedTotal int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.GstFormat // in
	var _arg2 C.gint64    // in
	var _arg3 C.gint64    // in
	var _arg4 C.gint64    // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_buffering_range(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(query)

	var _format Format        // out
	var _start int64          // out
	var _stop int64           // out
	var _estimatedTotal int64 // out

	_format = Format(_arg1)
	_start = int64(_arg2)
	_stop = int64(_arg3)
	_estimatedTotal = int64(_arg4)

	return _format, _start, _stop, _estimatedTotal
}

// ParseBufferingStats extracts the buffering stats values from query.
//
// The function returns the following values:
//
//   - mode (optional): buffering mode, or NULL.
//   - avgIn (optional): average input rate, or NULL.
//   - avgOut (optional): average output rat, or NULL.
//   - bufferingLeft (optional): amount of buffering time left in milliseconds,
//     or NULL.
func (query *Query) ParseBufferingStats() (mode BufferingMode, avgIn int, avgOut int, bufferingLeft int64) {
	var _arg0 *C.GstQuery        // out
	var _arg1 C.GstBufferingMode // in
	var _arg2 C.gint             // in
	var _arg3 C.gint             // in
	var _arg4 C.gint64           // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_buffering_stats(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(query)

	var _mode BufferingMode  // out
	var _avgIn int           // out
	var _avgOut int          // out
	var _bufferingLeft int64 // out

	_mode = BufferingMode(_arg1)
	_avgIn = int(_arg2)
	_avgOut = int(_arg3)
	_bufferingLeft = int64(_arg4)

	return _mode, _avgIn, _avgOut, _bufferingLeft
}

// ParseCaps: get the filter from the caps query. The caps remains valid as long
// as query remains valid.
//
// The function returns the following values:
//
//   - filter: pointer to the caps filter.
func (query *Query) ParseCaps() *Caps {
	var _arg0 *C.GstQuery // out
	var _arg1 *C.GstCaps  // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_caps(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _filter *Caps // out

	_filter = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_arg1)))

	return _filter
}

// ParseCapsResult: get the caps result from query. The caps remains valid as
// long as query remains valid.
//
// The function returns the following values:
//
//   - caps (optional): pointer to the caps.
func (query *Query) ParseCapsResult() *Caps {
	var _arg0 *C.GstQuery // out
	var _arg1 *C.GstCaps  // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_caps_result(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _caps *Caps // out

	if _arg1 != nil {
		_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
	}

	return _caps
}

// ParseContext: get the context from the context query. The context remains
// valid as long as query remains valid.
//
// The function returns the following values:
//
//   - context (optional): pointer to store the Context.
func (query *Query) ParseContext() *Context {
	var _arg0 *C.GstQuery   // out
	var _arg1 *C.GstContext // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_context(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _context *Context // out

	if _arg1 != nil {
		_context = (*Context)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
	}

	return _context
}

// ParseContextType: parse a context type from an existing GST_QUERY_CONTEXT
// query.
//
// The function returns the following values:
//
//   - contextType (optional): context type, or NULL.
//   - ok indicating if the parsing succeeded.
func (query *Query) ParseContextType() (string, bool) {
	var _arg0 *C.GstQuery // out
	var _arg1 *C.gchar    // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_query_parse_context_type(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _contextType string // out
	var _ok bool            // out

	if _arg1 != nil {
		_contextType = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
	}
	if _cret != 0 {
		_ok = true
	}

	return _contextType, _ok
}

// ParseConvert: parse a convert query answer. Any of src_format, src_value,
// dest_format, and dest_value may be NULL, in which case that value is omitted.
//
// The function returns the following values:
//
//   - srcFormat (optional): storage for the Format of the source value,
//     or NULL.
//   - srcValue (optional): storage for the source value, or NULL.
//   - destFormat (optional): storage for the Format of the destination value,
//     or NULL.
//   - destValue (optional): storage for the destination value, or NULL.
func (query *Query) ParseConvert() (srcFormat Format, srcValue int64, destFormat Format, destValue int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.GstFormat // in
	var _arg2 C.gint64    // in
	var _arg3 C.GstFormat // in
	var _arg4 C.gint64    // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_convert(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(query)

	var _srcFormat Format  // out
	var _srcValue int64    // out
	var _destFormat Format // out
	var _destValue int64   // out

	_srcFormat = Format(_arg1)
	_srcValue = int64(_arg2)
	_destFormat = Format(_arg3)
	_destValue = int64(_arg4)

	return _srcFormat, _srcValue, _destFormat, _destValue
}

// ParseDuration: parse a duration query answer. Write the format of the
// duration into format, and the value into duration, if the respective
// variables are non-NULL.
//
// The function returns the following values:
//
//   - format (optional): storage for the Format of the duration value, or NULL.
//   - duration (optional): storage for the total duration, or NULL.
func (query *Query) ParseDuration() (Format, int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.GstFormat // in
	var _arg2 C.gint64    // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_duration(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(query)

	var _format Format  // out
	var _duration int64 // out

	_format = Format(_arg1)
	_duration = int64(_arg2)

	return _format, _duration
}

// ParseLatency: parse a latency query answer.
//
// The function returns the following values:
//
//   - live (optional): storage for live or NULL.
//   - minLatency (optional): storage for the min latency or NULL.
//   - maxLatency (optional): storage for the max latency or NULL.
func (query *Query) ParseLatency() (live bool, minLatency ClockTime, maxLatency ClockTime) {
	var _arg0 *C.GstQuery    // out
	var _arg1 C.gboolean     // in
	var _arg2 C.GstClockTime // in
	var _arg3 C.GstClockTime // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_latency(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(query)

	var _live bool            // out
	var _minLatency ClockTime // out
	var _maxLatency ClockTime // out

	if _arg1 != 0 {
		_live = true
	}
	_minLatency = ClockTime(_arg2)
	_maxLatency = ClockTime(_arg3)

	return _live, _minLatency, _maxLatency
}

// ParseNFormats: parse the number of formats in the formats query.
//
// The function returns the following values:
//
//   - nFormats (optional): number of formats in this query.
func (query *Query) ParseNFormats() uint {
	var _arg0 *C.GstQuery // out
	var _arg1 C.guint     // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_n_formats(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _nFormats uint // out

	_nFormats = uint(_arg1)

	return _nFormats
}

// ParseNthAllocationMeta: parse an available query and get the metadata API at
// index of the metadata API array.
//
// The function takes the following parameters:
//
//   - index: position in the metadata API array to read.
//
// The function returns the following values:
//
//   - params (optional): API specific parameters.
//   - gType of the metadata API at index.
func (query *Query) ParseNthAllocationMeta(index uint) (*Structure, coreglib.Type) {
	var _arg0 *C.GstQuery     // out
	var _arg1 C.guint         // out
	var _arg2 *C.GstStructure // in
	var _cret C.GType         // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(index)

	_cret = C.gst_query_parse_nth_allocation_meta(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(index)

	var _params *Structure   // out
	var _gType coreglib.Type // out

	if _arg2 != nil {
		_params = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
	}
	_gType = coreglib.Type(_cret)

	return _params, _gType
}

// ParseNthAllocationParam: parse an available query and get the allocator and
// its params at index of the allocator array.
//
// The function takes the following parameters:
//
//   - index: position in the allocator array to read.
//
// The function returns the following values:
//
//   - allocator (optional): variable to hold the result.
//   - params (optional) parameters for the allocator.
func (query *Query) ParseNthAllocationParam(index uint) (Allocatorrer, *AllocationParams) {
	var _arg0 *C.GstQuery           // out
	var _arg1 C.guint               // out
	var _arg2 *C.GstAllocator       // in
	var _arg3 C.GstAllocationParams // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(index)

	C.gst_query_parse_nth_allocation_param(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(query)
	runtime.KeepAlive(index)

	var _allocator Allocatorrer   // out
	var _params *AllocationParams // out

	if _arg2 != nil {
		{
			objptr := unsafe.Pointer(_arg2)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Allocatorrer)
				return ok
			})
			rv, ok := casted.(Allocatorrer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Allocatorrer")
			}
			_allocator = rv
		}
	}
	_params = (*AllocationParams)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _allocator, _params
}

// ParseNthAllocationPool: get the pool parameters in query.
//
// Unref pool with gst_object_unref() when it's not needed any more.
//
// The function takes the following parameters:
//
//   - index to parse.
//
// The function returns the following values:
//
//   - pool (optional): BufferPool.
//   - size (optional): buffer size.
//   - minBuffers (optional): min buffers.
//   - maxBuffers (optional): max buffers.
func (query *Query) ParseNthAllocationPool(index uint) (pool *BufferPool, size uint, minBuffers uint, maxBuffers uint) {
	var _arg0 *C.GstQuery      // out
	var _arg1 C.guint          // out
	var _arg2 *C.GstBufferPool // in
	var _arg3 C.guint          // in
	var _arg4 C.guint          // in
	var _arg5 C.guint          // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(index)

	C.gst_query_parse_nth_allocation_pool(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5)
	runtime.KeepAlive(query)
	runtime.KeepAlive(index)

	var _pool *BufferPool // out
	var _size uint        // out
	var _minBuffers uint  // out
	var _maxBuffers uint  // out

	if _arg2 != nil {
		_pool = wrapBufferPool(coreglib.AssumeOwnership(unsafe.Pointer(_arg2)))
	}
	_size = uint(_arg3)
	_minBuffers = uint(_arg4)
	_maxBuffers = uint(_arg5)

	return _pool, _size, _minBuffers, _maxBuffers
}

// ParseNthBufferingRange: parse an available query and get the start and stop
// values stored at the index of the buffered ranges array.
//
// The function takes the following parameters:
//
//   - index: position in the buffered-ranges array to read.
//
// The function returns the following values:
//
//   - start (optional) position to set, or NULL.
//   - stop (optional) position to set, or NULL.
//   - ok indicating if the parsing succeeded.
func (query *Query) ParseNthBufferingRange(index uint) (start int64, stop int64, ok bool) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.guint     // out
	var _arg2 C.gint64    // in
	var _arg3 C.gint64    // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(index)

	_cret = C.gst_query_parse_nth_buffering_range(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(query)
	runtime.KeepAlive(index)

	var _start int64 // out
	var _stop int64  // out
	var _ok bool     // out

	_start = int64(_arg2)
	_stop = int64(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _start, _stop, _ok
}

// ParseNthFormat: parse the format query and retrieve the nth format from it
// into format. If the list contains less elements than nth, format will be set
// to GST_FORMAT_UNDEFINED.
//
// The function takes the following parameters:
//
//   - nth format to retrieve.
//
// The function returns the following values:
//
//   - format (optional): pointer to store the nth format.
func (query *Query) ParseNthFormat(nth uint) Format {
	var _arg0 *C.GstQuery // out
	var _arg1 C.guint     // out
	var _arg2 C.GstFormat // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(nth)

	C.gst_query_parse_nth_format(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(nth)

	var _format Format // out

	_format = Format(_arg2)

	return _format
}

// ParseNthSchedulingMode: parse an available query and get the scheduling mode
// at index of the scheduling modes array.
//
// The function takes the following parameters:
//
//   - index: position in the scheduling modes array to read.
//
// The function returns the following values:
//
//   - padMode of the scheduling mode at index.
func (query *Query) ParseNthSchedulingMode(index uint) PadMode {
	var _arg0 *C.GstQuery  // out
	var _arg1 C.guint      // out
	var _cret C.GstPadMode // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(index)

	_cret = C.gst_query_parse_nth_scheduling_mode(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(index)

	var _padMode PadMode // out

	_padMode = PadMode(_cret)

	return _padMode
}

// ParsePosition: parse a position query, writing the format into format,
// and the position into cur, if the respective parameters are non-NULL.
//
// The function returns the following values:
//
//   - format (optional): storage for the Format of the position values (may be
//     NULL).
//   - cur (optional): storage for the current position (may be NULL).
func (query *Query) ParsePosition() (Format, int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.GstFormat // in
	var _arg2 C.gint64    // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_position(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(query)

	var _format Format // out
	var _cur int64     // out

	_format = Format(_arg1)
	_cur = int64(_arg2)

	return _format, _cur
}

// ParseScheduling: set the scheduling properties.
//
// The function returns the following values:
//
//   - flags (optional): SchedulingFlags.
//   - minsize (optional): suggested minimum size of pull requests.
//   - maxsize (optional): suggested maximum size of pull requests:.
//   - align (optional): suggested alignment of pull requests.
func (query *Query) ParseScheduling() (flags SchedulingFlags, minsize int, maxsize int, align int) {
	var _arg0 *C.GstQuery          // out
	var _arg1 C.GstSchedulingFlags // in
	var _arg2 C.gint               // in
	var _arg3 C.gint               // in
	var _arg4 C.gint               // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_scheduling(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(query)

	var _flags SchedulingFlags // out
	var _minsize int           // out
	var _maxsize int           // out
	var _align int             // out

	_flags = SchedulingFlags(_arg1)
	_minsize = int(_arg2)
	_maxsize = int(_arg3)
	_align = int(_arg4)

	return _flags, _minsize, _maxsize, _align
}

// ParseSeeking: parse a seeking query, writing the format into format,
// and other results into the passed parameters, if the respective parameters
// are non-NULL.
//
// The function returns the following values:
//
//   - format (optional) to set for the segment_start and segment_end values,
//     or NULL.
//   - seekable (optional) flag to set, or NULL.
//   - segmentStart (optional): segment_start to set, or NULL.
//   - segmentEnd (optional): segment_end to set, or NULL.
func (query *Query) ParseSeeking() (format Format, seekable bool, segmentStart int64, segmentEnd int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.GstFormat // in
	var _arg2 C.gboolean  // in
	var _arg3 C.gint64    // in
	var _arg4 C.gint64    // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_seeking(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(query)

	var _format Format      // out
	var _seekable bool      // out
	var _segmentStart int64 // out
	var _segmentEnd int64   // out

	_format = Format(_arg1)
	if _arg2 != 0 {
		_seekable = true
	}
	_segmentStart = int64(_arg3)
	_segmentEnd = int64(_arg4)

	return _format, _seekable, _segmentStart, _segmentEnd
}

// ParseSegment: parse a segment query answer. Any of rate, format, start_value,
// and stop_value may be NULL, which will cause this value to be omitted.
//
// See gst_query_set_segment() for an explanation of the function arguments.
//
// The function returns the following values:
//
//   - rate (optional): storage for the rate of the segment, or NULL.
//   - format (optional): storage for the Format of the values, or NULL.
//   - startValue (optional): storage for the start value, or NULL.
//   - stopValue (optional): storage for the stop value, or NULL.
func (query *Query) ParseSegment() (rate float64, format Format, startValue int64, stopValue int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.gdouble   // in
	var _arg2 C.GstFormat // in
	var _arg3 C.gint64    // in
	var _arg4 C.gint64    // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_segment(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(query)

	var _rate float64     // out
	var _format Format    // out
	var _startValue int64 // out
	var _stopValue int64  // out

	_rate = float64(_arg1)
	_format = Format(_arg2)
	_startValue = int64(_arg3)
	_stopValue = int64(_arg4)

	return _rate, _format, _startValue, _stopValue
}

// ParseSelectable: get the results of a selectable query. See also
// gst_query_set_selectable().
//
// The function returns the following values:
//
//   - selectable (optional): resulting stream selection capability.
func (query *Query) ParseSelectable() bool {
	var _arg0 *C.GstQuery // out
	var _arg1 C.gboolean  // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_selectable(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _selectable bool // out

	if _arg1 != 0 {
		_selectable = true
	}

	return _selectable
}

// ParseURI: parse an URI query, writing the URI into uri as a newly allocated
// string, if the respective parameters are non-NULL. Free the string with
// g_free() after usage.
//
// The function returns the following values:
//
//   - uri (optional): storage for the current URI (may be NULL).
func (query *Query) ParseURI() string {
	var _arg0 *C.GstQuery // out
	var _arg1 *C.gchar    // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_uri(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _uri string // out

	if _arg1 != nil {
		_uri = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	return _uri
}

// ParseURIRedirection: parse an URI query, writing the URI into uri as a newly
// allocated string, if the respective parameters are non-NULL. Free the string
// with g_free() after usage.
//
// The function returns the following values:
//
//   - uri (optional): storage for the redirect URI (may be NULL).
func (query *Query) ParseURIRedirection() string {
	var _arg0 *C.GstQuery // out
	var _arg1 *C.gchar    // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_uri_redirection(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _uri string // out

	if _arg1 != nil {
		_uri = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	return _uri
}

// ParseURIRedirectionPermanent: parse an URI query, and set permanent to
// TRUE if there is a redirection and it should be considered permanent. If a
// redirection is permanent, applications should update their internal storage
// of the URI, otherwise they should make all future requests to the original
// URI.
//
// The function returns the following values:
//
//   - permanent (optional): if the URI redirection is permanent (may be NULL).
func (query *Query) ParseURIRedirectionPermanent() bool {
	var _arg0 *C.GstQuery // out
	var _arg1 C.gboolean  // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_query_parse_uri_redirection_permanent(_arg0, &_arg1)
	runtime.KeepAlive(query)

	var _permanent bool // out

	if _arg1 != 0 {
		_permanent = true
	}

	return _permanent
}

// RemoveNthAllocationMeta: remove the metadata API at index of the metadata API
// array.
//
// The function takes the following parameters:
//
//   - index: position in the metadata API array to remove.
func (query *Query) RemoveNthAllocationMeta(index uint) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.guint     // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(index)

	C.gst_query_remove_nth_allocation_meta(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(index)
}

// RemoveNthAllocationParam: remove the allocation param at index of the
// allocation param array.
//
// The function takes the following parameters:
//
//   - index: position in the allocation param array to remove.
func (query *Query) RemoveNthAllocationParam(index uint) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.guint     // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(index)

	C.gst_query_remove_nth_allocation_param(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(index)
}

// RemoveNthAllocationPool: remove the allocation pool at index of the
// allocation pool array.
//
// The function takes the following parameters:
//
//   - index: position in the allocation pool array to remove.
func (query *Query) RemoveNthAllocationPool(index uint) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.guint     // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(index)

	C.gst_query_remove_nth_allocation_pool(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(index)
}

// SetAcceptCapsResult: set result as the result for the query.
//
// The function takes the following parameters:
//
//   - result to set.
func (query *Query) SetAcceptCapsResult(result bool) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	if result {
		_arg1 = C.TRUE
	}

	C.gst_query_set_accept_caps_result(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(result)
}

// SetBitrate: set the results of a bitrate query. The nominal bitrate is the
// average bitrate expected over the length of the stream as advertised in file
// headers (or similar).
//
// The function takes the following parameters:
//
//   - nominalBitrate: nominal bitrate in bits per second.
func (query *Query) SetBitrate(nominalBitrate uint) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.guint     // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(nominalBitrate)

	C.gst_query_set_bitrate(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(nominalBitrate)
}

// SetBufferingPercent: set the percentage of buffered data. This is a value
// between 0 and 100. The busy indicator is TRUE when the buffering is in
// progress.
//
// The function takes the following parameters:
//
//   - busy: if buffering is busy.
//   - percent: buffering percent.
func (query *Query) SetBufferingPercent(busy bool, percent int) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.gboolean  // out
	var _arg2 C.gint      // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	if busy {
		_arg1 = C.TRUE
	}
	_arg2 = C.gint(percent)

	C.gst_query_set_buffering_percent(_arg0, _arg1, _arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(busy)
	runtime.KeepAlive(percent)
}

// SetBufferingRange: set the available query result fields in query.
//
// The function takes the following parameters:
//
//   - format to set for the start and stop values.
//   - start to set.
//   - stop to set.
//   - estimatedTotal: estimated total amount of download time remaining in
//     milliseconds.
func (query *Query) SetBufferingRange(format Format, start int64, stop int64, estimatedTotal int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // out
	var _arg3 C.gint64    // out
	var _arg4 C.gint64    // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.gint64(start)
	_arg3 = C.gint64(stop)
	_arg4 = C.gint64(estimatedTotal)

	C.gst_query_set_buffering_range(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(query)
	runtime.KeepAlive(format)
	runtime.KeepAlive(start)
	runtime.KeepAlive(stop)
	runtime.KeepAlive(estimatedTotal)
}

// SetBufferingStats configures the buffering stats values in query.
//
// The function takes the following parameters:
//
//   - mode: buffering mode.
//   - avgIn: average input rate.
//   - avgOut: average output rate.
//   - bufferingLeft: amount of buffering time left in milliseconds.
func (query *Query) SetBufferingStats(mode BufferingMode, avgIn int, avgOut int, bufferingLeft int64) {
	var _arg0 *C.GstQuery        // out
	var _arg1 C.GstBufferingMode // out
	var _arg2 C.gint             // out
	var _arg3 C.gint             // out
	var _arg4 C.gint64           // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GstBufferingMode(mode)
	_arg2 = C.gint(avgIn)
	_arg3 = C.gint(avgOut)
	_arg4 = C.gint64(bufferingLeft)

	C.gst_query_set_buffering_stats(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(query)
	runtime.KeepAlive(mode)
	runtime.KeepAlive(avgIn)
	runtime.KeepAlive(avgOut)
	runtime.KeepAlive(bufferingLeft)
}

// SetCapsResult: set the caps result in query.
//
// The function takes the following parameters:
//
//   - caps (optional): pointer to the caps.
func (query *Query) SetCapsResult(caps *Caps) {
	var _arg0 *C.GstQuery // out
	var _arg1 *C.GstCaps  // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	if caps != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}

	C.gst_query_set_caps_result(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(caps)
}

// SetContext: answer a context query by setting the requested context.
//
// The function takes the following parameters:
//
//   - context (optional): requested Context.
func (query *Query) SetContext(context *Context) {
	var _arg0 *C.GstQuery   // out
	var _arg1 *C.GstContext // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	if context != nil {
		_arg1 = (*C.GstContext)(gextras.StructNative(unsafe.Pointer(context)))
	}

	C.gst_query_set_context(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(context)
}

// SetConvert: answer a convert query by setting the requested values.
//
// The function takes the following parameters:
//
//   - srcFormat: source Format.
//   - srcValue: source value.
//   - destFormat: destination Format.
//   - destValue: destination value.
func (query *Query) SetConvert(srcFormat Format, srcValue int64, destFormat Format, destValue int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // out
	var _arg3 C.GstFormat // out
	var _arg4 C.gint64    // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GstFormat(srcFormat)
	_arg2 = C.gint64(srcValue)
	_arg3 = C.GstFormat(destFormat)
	_arg4 = C.gint64(destValue)

	C.gst_query_set_convert(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(query)
	runtime.KeepAlive(srcFormat)
	runtime.KeepAlive(srcValue)
	runtime.KeepAlive(destFormat)
	runtime.KeepAlive(destValue)
}

// SetDuration: answer a duration query by setting the requested value in the
// given format.
//
// The function takes the following parameters:
//
//   - format for the duration.
//   - duration of the stream.
func (query *Query) SetDuration(format Format, duration int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.gint64(duration)

	C.gst_query_set_duration(_arg0, _arg1, _arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(format)
	runtime.KeepAlive(duration)
}

// SetFormatsv: set the formats query result fields in query. The number of
// formats passed in the formats array must be equal to n_formats.
//
// The function takes the following parameters:
//
//   - formats: array containing n_formats GstFormat values.
func (query *Query) SetFormatsv(formats []Format) {
	var _arg0 *C.GstQuery  // out
	var _arg2 *C.GstFormat // out
	var _arg1 C.gint

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = (C.gint)(len(formats))
	if len(formats) > 0 {
		_arg2 = (*C.GstFormat)(unsafe.Pointer(&formats[0]))
	}

	C.gst_query_set_formatsv(_arg0, _arg1, _arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(formats)
}

// SetLatency: answer a latency query by setting the requested values in the
// given format.
//
// The function takes the following parameters:
//
//   - live: if there is a live element upstream.
//   - minLatency: minimal latency of the upstream elements.
//   - maxLatency: maximal latency of the upstream elements.
func (query *Query) SetLatency(live bool, minLatency ClockTime, maxLatency ClockTime) {
	var _arg0 *C.GstQuery    // out
	var _arg1 C.gboolean     // out
	var _arg2 C.GstClockTime // out
	var _arg3 C.GstClockTime // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	if live {
		_arg1 = C.TRUE
	}
	_arg2 = C.GstClockTime(minLatency)
	_arg3 = C.GstClockTime(maxLatency)

	C.gst_query_set_latency(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(query)
	runtime.KeepAlive(live)
	runtime.KeepAlive(minLatency)
	runtime.KeepAlive(maxLatency)
}

// SetNthAllocationParam: parse an available query and get the allocator and its
// params at index of the allocator array.
//
// The function takes the following parameters:
//
//   - index: position in the allocator array to set.
//   - allocator (optional): new allocator to set.
//   - params (optional) parameters for the allocator.
func (query *Query) SetNthAllocationParam(index uint, allocator Allocatorrer, params *AllocationParams) {
	var _arg0 *C.GstQuery            // out
	var _arg1 C.guint                // out
	var _arg2 *C.GstAllocator        // out
	var _arg3 *C.GstAllocationParams // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(index)
	if allocator != nil {
		_arg2 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	}
	if params != nil {
		_arg3 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	C.gst_query_set_nth_allocation_param(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(query)
	runtime.KeepAlive(index)
	runtime.KeepAlive(allocator)
	runtime.KeepAlive(params)
}

// SetNthAllocationPool: set the pool parameters in query.
//
// The function takes the following parameters:
//
//   - index to modify.
//   - pool (optional): BufferPool.
//   - size: buffer size.
//   - minBuffers: min buffers.
//   - maxBuffers: max buffers.
func (query *Query) SetNthAllocationPool(index uint, pool *BufferPool, size uint, minBuffers uint, maxBuffers uint) {
	var _arg0 *C.GstQuery      // out
	var _arg1 C.guint          // out
	var _arg2 *C.GstBufferPool // out
	var _arg3 C.guint          // out
	var _arg4 C.guint          // out
	var _arg5 C.guint          // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.guint(index)
	if pool != nil {
		_arg2 = (*C.GstBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))
	}
	_arg3 = C.guint(size)
	_arg4 = C.guint(minBuffers)
	_arg5 = C.guint(maxBuffers)

	C.gst_query_set_nth_allocation_pool(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(query)
	runtime.KeepAlive(index)
	runtime.KeepAlive(pool)
	runtime.KeepAlive(size)
	runtime.KeepAlive(minBuffers)
	runtime.KeepAlive(maxBuffers)
}

// SetPosition: answer a position query by setting the requested value in the
// given format.
//
// The function takes the following parameters:
//
//   - format: requested Format.
//   - cur: position to set.
func (query *Query) SetPosition(format Format, cur int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.GstFormat // out
	var _arg2 C.gint64    // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.gint64(cur)

	C.gst_query_set_position(_arg0, _arg1, _arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(format)
	runtime.KeepAlive(cur)
}

// SetScheduling: set the scheduling properties.
//
// The function takes the following parameters:
//
//   - flags: SchedulingFlags.
//   - minsize: suggested minimum size of pull requests.
//   - maxsize: suggested maximum size of pull requests.
//   - align: suggested alignment of pull requests.
func (query *Query) SetScheduling(flags SchedulingFlags, minsize int, maxsize int, align int) {
	var _arg0 *C.GstQuery          // out
	var _arg1 C.GstSchedulingFlags // out
	var _arg2 C.gint               // out
	var _arg3 C.gint               // out
	var _arg4 C.gint               // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GstSchedulingFlags(flags)
	_arg2 = C.gint(minsize)
	_arg3 = C.gint(maxsize)
	_arg4 = C.gint(align)

	C.gst_query_set_scheduling(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(query)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(minsize)
	runtime.KeepAlive(maxsize)
	runtime.KeepAlive(align)
}

// SetSeeking: set the seeking query result fields in query.
//
// The function takes the following parameters:
//
//   - format to set for the segment_start and segment_end values.
//   - seekable flag to set.
//   - segmentStart: segment_start to set.
//   - segmentEnd: segment_end to set.
func (query *Query) SetSeeking(format Format, seekable bool, segmentStart int64, segmentEnd int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.GstFormat // out
	var _arg2 C.gboolean  // out
	var _arg3 C.gint64    // out
	var _arg4 C.gint64    // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.GstFormat(format)
	if seekable {
		_arg2 = C.TRUE
	}
	_arg3 = C.gint64(segmentStart)
	_arg4 = C.gint64(segmentEnd)

	C.gst_query_set_seeking(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(query)
	runtime.KeepAlive(format)
	runtime.KeepAlive(seekable)
	runtime.KeepAlive(segmentStart)
	runtime.KeepAlive(segmentEnd)
}

// SetSegment: answer a segment query by setting the requested values. The
// normal playback segment of a pipeline is 0 to duration at the default rate
// of 1.0. If a seek was performed on the pipeline to play a different segment,
// this query will return the range specified in the last seek.
//
// start_value and stop_value will respectively contain the configured playback
// range start and stop values expressed in format. The values are always
// between 0 and the duration of the media and start_value <= stop_value. rate
// will contain the playback rate. For negative rates, playback will actually
// happen from stop_value to start_value.
//
// The function takes the following parameters:
//
//   - rate of the segment.
//   - format of the segment values (start_value and stop_value).
//   - startValue: start value.
//   - stopValue: stop value.
func (query *Query) SetSegment(rate float64, format Format, startValue int64, stopValue int64) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.gdouble   // out
	var _arg2 C.GstFormat // out
	var _arg3 C.gint64    // out
	var _arg4 C.gint64    // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = C.gdouble(rate)
	_arg2 = C.GstFormat(format)
	_arg3 = C.gint64(startValue)
	_arg4 = C.gint64(stopValue)

	C.gst_query_set_segment(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(query)
	runtime.KeepAlive(rate)
	runtime.KeepAlive(format)
	runtime.KeepAlive(startValue)
	runtime.KeepAlive(stopValue)
}

// SetSelectable: set the results of a selectable query. If the element
// answering the query can handle stream selection, selectable should be set to
// TRUE.
//
// The function takes the following parameters:
//
//   - selectable: whether the element can handle stream selection.
func (query *Query) SetSelectable(selectable bool) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	if selectable {
		_arg1 = C.TRUE
	}

	C.gst_query_set_selectable(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(selectable)
}

// SetURI: answer a URI query by setting the requested URI.
//
// The function takes the following parameters:
//
//   - uri (optional): URI to set.
func (query *Query) SetURI(uri string) {
	var _arg0 *C.GstQuery // out
	var _arg1 *C.gchar    // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	if uri != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gst_query_set_uri(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(uri)
}

// SetURIRedirection: answer a URI query by setting the requested URI
// redirection.
//
// The function takes the following parameters:
//
//   - uri (optional): URI to set.
func (query *Query) SetURIRedirection(uri string) {
	var _arg0 *C.GstQuery // out
	var _arg1 *C.gchar    // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	if uri != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gst_query_set_uri_redirection(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(uri)
}

// SetURIRedirectionPermanent: answer a URI query by setting the requested URI
// redirection to permanent or not.
//
// The function takes the following parameters:
//
//   - permanent: whether the redirect is permanent or not.
func (query *Query) SetURIRedirectionPermanent(permanent bool) {
	var _arg0 *C.GstQuery // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	if permanent {
		_arg1 = C.TRUE
	}

	C.gst_query_set_uri_redirection_permanent(_arg0, _arg1)
	runtime.KeepAlive(query)
	runtime.KeepAlive(permanent)
}

// WritableStructure: get the structure of a query. This method should be called
// with a writable query so that the returned structure is guaranteed to be
// writable.
//
// The function returns the following values:
//
//   - structure of the query. The structure is still owned by the query and
//     will therefore be freed when the query is unreffed.
func (query *Query) WritableStructure() *Structure {
	var _arg0 *C.GstQuery     // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_query_writable_structure(_arg0)
	runtime.KeepAlive(query)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _structure
}

// ReferenceTimestampMeta can be used to attach alternative timestamps and
// possibly durations to a Buffer. These are generally not according to the
// pipeline clock and could be e.g. the NTP timestamp when the media was
// captured.
//
// The reference is stored as a Caps in reference. Examples of valid references
// would be
//
//   - timestamp/x-drivername-stream: for timestamps that are locally generated
//     by some driver named drivername when generating the stream, e.g. based on
//     a frame counter
//   - timestamp/x-ntp, host=pool.ntp.org, port=123: for timestamps based on a
//     specific NTP server. Note that the host/port parameters might not always
//     be given.
//   - timestamp/x-ptp, version=IEEE1588-2008, domain=1: for timestamps based on
//     a given PTP clock.
//   - timestamp/x-unix: for timestamps based on the UNIX epoch according to the
//     local clock.
//
// Since 1.24 it can be serialized using gst_meta_serialize() and
// gst_meta_deserialize().
//
// An instance of this type is always passed by reference.
type ReferenceTimestampMeta struct {
	*referenceTimestampMeta
}

// referenceTimestampMeta is the struct that's finalized.
type referenceTimestampMeta struct {
	native *C.GstReferenceTimestampMeta
}

// Parent: parent Meta structure.
func (r *ReferenceTimestampMeta) Parent() *Meta {
	valptr := &r.native.parent
	var _v *Meta // out
	_v = (*Meta)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Reference: identifier for the timestamp reference.
func (r *ReferenceTimestampMeta) Reference() *Caps {
	valptr := &r.native.reference
	var _v *Caps // out
	_v = (*Caps)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// Timestamp: timestamp.
func (r *ReferenceTimestampMeta) Timestamp() ClockTime {
	valptr := &r.native.timestamp
	var _v ClockTime // out
	_v = ClockTime(*valptr)
	return _v
}

// Duration: duration, or GST_CLOCK_TIME_NONE.
func (r *ReferenceTimestampMeta) Duration() ClockTime {
	valptr := &r.native.duration
	var _v ClockTime // out
	_v = ClockTime(*valptr)
	return _v
}

// ReferenceTimestampMetaGetInfo gets the global MetaInfo describing the
// ReferenceTimestampMeta meta.
//
// The function returns the following values:
//
//   - metaInfo: MetaInfo.
func ReferenceTimestampMetaGetInfo() *MetaInfo {
	var _cret *C.GstMetaInfo // in

	_cret = C.gst_reference_timestamp_meta_get_info()

	var _metaInfo *MetaInfo // out

	_metaInfo = (*MetaInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _metaInfo
}

// RegistryClass: instance of this type is always passed by reference.
type RegistryClass struct {
	*registryClass
}

// registryClass is the struct that's finalized.
type registryClass struct {
	native *C.GstRegistryClass
}

func (r *RegistryClass) ParentClass() *ObjectClass {
	valptr := &r.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Sample is a small object containing data, a type, timing and extra arbitrary
// information.
//
// An instance of this type is always passed by reference.
type Sample struct {
	*sample
}

// sample is the struct that's finalized.
type sample struct {
	native *C.GstSample
}

func marshalSample(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Sample{&sample{(*C.GstSample)(b)}}, nil
}

// NewSample constructs a struct Sample.
func NewSample(buffer *Buffer, caps *Caps, segment *Segment, info *Structure) *Sample {
	var _arg1 *C.GstBuffer    // out
	var _arg2 *C.GstCaps      // out
	var _arg3 *C.GstSegment   // out
	var _arg4 *C.GstStructure // out
	var _cret *C.GstSample    // in

	if buffer != nil {
		_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	}
	if caps != nil {
		_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}
	if segment != nil {
		_arg3 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	}
	if info != nil {
		_arg4 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(info)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(info)), nil)
	}

	_cret = C.gst_sample_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(info)

	var _sample *Sample // out

	_sample = (*Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_sample)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _sample
}

// Buffer: get the buffer associated with sample.
//
// The function returns the following values:
//
//   - buffer (optional) of sample or NULL when there is no buffer. The buffer
//     remains valid as long as sample is valid. If you need to hold on to it
//     for longer than that, take a ref to the buffer with gst_buffer_ref().
func (sample *Sample) Buffer() *Buffer {
	var _arg0 *C.GstSample // out
	var _cret *C.GstBuffer // in

	_arg0 = (*C.GstSample)(gextras.StructNative(unsafe.Pointer(sample)))

	_cret = C.gst_sample_get_buffer(_arg0)
	runtime.KeepAlive(sample)

	var _buffer *Buffer // out

	if _cret != nil {
		_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _buffer
}

// BufferList: get the buffer list associated with sample.
//
// The function returns the following values:
//
//   - bufferList (optional): buffer list of sample or NULL when there is no
//     buffer list. The buffer list remains valid as long as sample is valid.
//     If you need to hold on to it for longer than that, take a ref to the
//     buffer list with gst_mini_object_ref ().
func (sample *Sample) BufferList() *BufferList {
	var _arg0 *C.GstSample     // out
	var _cret *C.GstBufferList // in

	_arg0 = (*C.GstSample)(gextras.StructNative(unsafe.Pointer(sample)))

	_cret = C.gst_sample_get_buffer_list(_arg0)
	runtime.KeepAlive(sample)

	var _bufferList *BufferList // out

	if _cret != nil {
		_bufferList = (*BufferList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _bufferList
}

// Caps: get the caps associated with sample.
//
// The function returns the following values:
//
//   - caps (optional) of sample or NULL when there is no caps. The caps remain
//     valid as long as sample is valid. If you need to hold on to the caps for
//     longer than that, take a ref to the caps with gst_caps_ref().
func (sample *Sample) Caps() *Caps {
	var _arg0 *C.GstSample // out
	var _cret *C.GstCaps   // in

	_arg0 = (*C.GstSample)(gextras.StructNative(unsafe.Pointer(sample)))

	_cret = C.gst_sample_get_caps(_arg0)
	runtime.KeepAlive(sample)

	var _caps *Caps // out

	if _cret != nil {
		_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _caps
}

// Info: get extra information associated with sample.
//
// The function returns the following values:
//
//   - structure (optional): extra info of sample. The info remains valid as
//     long as sample is valid.
func (sample *Sample) Info() *Structure {
	var _arg0 *C.GstSample    // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstSample)(gextras.StructNative(unsafe.Pointer(sample)))

	_cret = C.gst_sample_get_info(_arg0)
	runtime.KeepAlive(sample)

	var _structure *Structure // out

	if _cret != nil {
		_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _structure
}

// Segment: get the segment associated with sample.
//
// The function returns the following values:
//
//   - segment of sample. The segment remains valid as long as sample is valid.
func (sample *Sample) Segment() *Segment {
	var _arg0 *C.GstSample  // out
	var _cret *C.GstSegment // in

	_arg0 = (*C.GstSample)(gextras.StructNative(unsafe.Pointer(sample)))

	_cret = C.gst_sample_get_segment(_arg0)
	runtime.KeepAlive(sample)

	var _segment *Segment // out

	_segment = (*Segment)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _segment
}

// SetBuffer: set the buffer associated with sample. sample must be writable.
//
// The function takes the following parameters:
//
//   - buffer: Buffer.
func (sample *Sample) SetBuffer(buffer *Buffer) {
	var _arg0 *C.GstSample // out
	var _arg1 *C.GstBuffer // out

	_arg0 = (*C.GstSample)(gextras.StructNative(unsafe.Pointer(sample)))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	C.gst_sample_set_buffer(_arg0, _arg1)
	runtime.KeepAlive(sample)
	runtime.KeepAlive(buffer)
}

// SetBufferList: set the buffer list associated with sample. sample must be
// writable.
//
// The function takes the following parameters:
//
//   - bufferList: BufferList.
func (sample *Sample) SetBufferList(bufferList *BufferList) {
	var _arg0 *C.GstSample     // out
	var _arg1 *C.GstBufferList // out

	_arg0 = (*C.GstSample)(gextras.StructNative(unsafe.Pointer(sample)))
	_arg1 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(bufferList)))

	C.gst_sample_set_buffer_list(_arg0, _arg1)
	runtime.KeepAlive(sample)
	runtime.KeepAlive(bufferList)
}

// SetCaps: set the caps associated with sample. sample must be writable.
//
// The function takes the following parameters:
//
//   - caps: Caps.
func (sample *Sample) SetCaps(caps *Caps) {
	var _arg0 *C.GstSample // out
	var _arg1 *C.GstCaps   // out

	_arg0 = (*C.GstSample)(gextras.StructNative(unsafe.Pointer(sample)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	C.gst_sample_set_caps(_arg0, _arg1)
	runtime.KeepAlive(sample)
	runtime.KeepAlive(caps)
}

// SetInfo: set the info structure associated with sample. sample must be
// writable, and info must not have a parent set already.
//
// The function takes the following parameters:
//
//   - info: Structure.
func (sample *Sample) SetInfo(info *Structure) bool {
	var _arg0 *C.GstSample    // out
	var _arg1 *C.GstStructure // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstSample)(gextras.StructNative(unsafe.Pointer(sample)))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(info)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(info)), nil)

	_cret = C.gst_sample_set_info(_arg0, _arg1)
	runtime.KeepAlive(sample)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSegment: set the segment associated with sample. sample must be writable.
//
// The function takes the following parameters:
//
//   - segment: Segment.
func (sample *Sample) SetSegment(segment *Segment) {
	var _arg0 *C.GstSample  // out
	var _arg1 *C.GstSegment // out

	_arg0 = (*C.GstSample)(gextras.StructNative(unsafe.Pointer(sample)))
	_arg1 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))

	C.gst_sample_set_segment(_arg0, _arg1)
	runtime.KeepAlive(sample)
	runtime.KeepAlive(segment)
}

// Segment: this helper structure holds the relevant values for tracking the
// region of interest in a media file, called a segment.
//
// The structure can be used for two purposes:
//
//   - performing seeks (handling seek events)
//   - tracking playback regions (handling newsegment events)
//
// The segment is usually configured by the application with a seek event which
// is propagated upstream and eventually handled by an element that performs the
// seek.
//
// The configured segment is then propagated back downstream with a newsegment
// event. This information is then used to clip media to the segment boundaries.
//
// A segment structure is initialized with gst_segment_init(), which takes a
// Format that will be used as the format of the segment values. The segment
// will be configured with a start value of 0 and a stop/duration of -1,
// which is undefined. The default rate and applied_rate is 1.0.
//
// The public duration field contains the duration of the segment. When using
// the segment for seeking, the start and time members should normally be left
// to their default 0 value. The stop position is left to -1 unless explicitly
// configured to a different value after a seek event.
//
// The current position in the segment should be set by changing the position
// member in the structure.
//
// For elements that perform seeks, the current segment should be updated with
// the gst_segment_do_seek() and the values from the seek event. This method
// will update all the segment fields. The position field will contain the new
// playback position. If the start_type was different from GST_SEEK_TYPE_NONE,
// playback continues from the position position, possibly with updated flags or
// rate.
//
// For elements that want to use Segment to track the playback region,
// update the segment fields with the information from the newsegment event.
// The gst_segment_clip() method can be used to check and clip the media data to
// the segment boundaries.
//
// For elements that want to synchronize to the pipeline clock,
// gst_segment_to_running_time() can be used to convert a timestamp to a value
// that can be used to synchronize to the clock. This function takes into
// account the base as well as any rate or applied_rate conversions.
//
// For elements that need to perform operations on media data in stream_time,
// gst_segment_to_stream_time() can be used to convert a timestamp and the
// segment info to stream time (which is always between 0 and the duration of
// the stream).
//
// An instance of this type is always passed by reference.
type Segment struct {
	*segment
}

// segment is the struct that's finalized.
type segment struct {
	native *C.GstSegment
}

func marshalSegment(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Segment{&segment{(*C.GstSegment)(b)}}, nil
}

// NewSegment constructs a struct Segment.
func NewSegment() *Segment {
	var _cret *C.GstSegment // in

	_cret = C.gst_segment_new()

	var _segment *Segment // out

	_segment = (*Segment)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_segment)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_segment_free((*C.GstSegment)(intern.C))
		},
	)

	return _segment
}

// Flags flags for this segment.
func (s *Segment) Flags() SegmentFlags {
	valptr := &s.native.flags
	var _v SegmentFlags // out
	_v = SegmentFlags(*valptr)
	return _v
}

// Rate: playback rate of the segment is set in response to a
// seek event and, without any seek, the value should be 1.0.
// This value is used by elements that synchronize buffer [running
// times](additional/design/synchronisation.md#running-time) on the clock
// (usually the sink elements), leading to consuming buffers faster (for a
// value > 1.0) or slower (for 0.0 < value < 1.0) than normal playback speed.
// The rate also defines the playback direction, meaning that when the value
// is lower than 0.0, the playback happens in reverse, and the stream-time
// (additional/design/synchronisation.md#stream-time) is going backward.
// The rate value should never be 0.0.
func (s *Segment) Rate() float64 {
	valptr := &s.native.rate
	var _v float64 // out
	_v = float64(*valptr)
	return _v
}

// AppliedRate: applied rate is the rate that has been applied to the stream.
// The effective/resulting playback rate of a stream is rate * applied_rate.
// The applied rate can be set by source elements when a server is
// sending the stream with an already modified playback speed rate.
// Filter elements that modify the stream in a way that modifies the playback
// speed should also modify the applied rate. For example the #videorate
// element when its #videorate:rate property is set will set the applied
// rate of the segment it pushed downstream. Also #scaletempo applies the
// input segment rate to the stream and outputs a segment with rate=1.0 and
// applied_rate=<inputsegment.rate>.
func (s *Segment) AppliedRate() float64 {
	valptr := &s.native.applied_rate
	var _v float64 // out
	_v = float64(*valptr)
	return _v
}

// Format: unit used for all of the segment's values.
func (s *Segment) Format() Format {
	valptr := &s.native.format
	var _v Format // out
	_v = Format(*valptr)
	return _v
}

// Base: running time (plus elapsed time, see offset) of the segment start
// (GstSegment.start) (stop (GstSegment.stop) if rate < 0.0).
func (s *Segment) Base() uint64 {
	valptr := &s.native.base
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Offset: offset expresses the elapsed time (in buffer timestamps) before a
// seek with its start (stop if rate < 0.0) seek type set to T_SEEK_TYPE_NONE,
// the value is set to the position of the segment at the time of the seek.
func (s *Segment) Offset() uint64 {
	valptr := &s.native.offset
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Start: start time of the segment (in buffer timestamps) (PTS)
// (GstBuffer.pts), that is the timestamp of the first buffer to output inside
// the segment (last one during reverse playback). For example decoders will
// clip (gst_segment_clip) out the buffers before the start time.
func (s *Segment) Start() uint64 {
	valptr := &s.native.start
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Stop: stop time of the segment (in buffer timestamps) (PTS) (GstBuffer.pts),
// that is the timestamp of the last buffer to output inside the segment
// (first one during reverse playback). For example decoders will clip
// (gst_segment_clip) out buffers after the stop time.
func (s *Segment) Stop() uint64 {
	valptr := &s.native.stop
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Time: stream time of the segment start (GstSegment.start) (stop
// (GstSegment.stop) if rate < 0.0).
func (s *Segment) Time() uint64 {
	valptr := &s.native.time
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Position: buffer timestamp position in the segment is supposed to be updated
// by elements such as sources, demuxers or parsers to track progress by
// setting it to the last pushed buffer' end time (timestamp (GstBuffer.pts)
// + Buffer.duration) for that specific segment. The position is used when
// reconfiguring the segment with #gst_segment_do_seek when the seek is only
// updating the segment (see offset (GstSegment.offset)).
func (s *Segment) Position() uint64 {
	valptr := &s.native.position
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Duration: duration of the segment is the maximum absolute difference between
// Segment.start and Segment.stop if stop is not set, otherwise it should be the
// difference between those two values. This should be set by elements that know
// the overall stream duration (like demuxers) and will be used when seeking
// with T_SEEK_TYPE_END.
func (s *Segment) Duration() uint64 {
	valptr := &s.native.duration
	var _v uint64 // out
	_v = uint64(*valptr)
	return _v
}

// Rate: playback rate of the segment is set in response to a
// seek event and, without any seek, the value should be 1.0.
// This value is used by elements that synchronize buffer [running
// times](additional/design/synchronisation.md#running-time) on the clock
// (usually the sink elements), leading to consuming buffers faster (for a
// value > 1.0) or slower (for 0.0 < value < 1.0) than normal playback speed.
// The rate also defines the playback direction, meaning that when the value
// is lower than 0.0, the playback happens in reverse, and the stream-time
// (additional/design/synchronisation.md#stream-time) is going backward.
// The rate value should never be 0.0.
func (s *Segment) SetRate(rate float64) {
	valptr := &s.native.rate
	*valptr = C.gdouble(rate)
}

// AppliedRate: applied rate is the rate that has been applied to the stream.
// The effective/resulting playback rate of a stream is rate * applied_rate.
// The applied rate can be set by source elements when a server is
// sending the stream with an already modified playback speed rate.
// Filter elements that modify the stream in a way that modifies the playback
// speed should also modify the applied rate. For example the #videorate
// element when its #videorate:rate property is set will set the applied
// rate of the segment it pushed downstream. Also #scaletempo applies the
// input segment rate to the stream and outputs a segment with rate=1.0 and
// applied_rate=<inputsegment.rate>.
func (s *Segment) SetAppliedRate(appliedRate float64) {
	valptr := &s.native.applied_rate
	*valptr = C.gdouble(appliedRate)
}

// Base: running time (plus elapsed time, see offset) of the segment start
// (GstSegment.start) (stop (GstSegment.stop) if rate < 0.0).
func (s *Segment) SetBase(base uint64) {
	valptr := &s.native.base
	*valptr = C.guint64(base)
}

// Offset: offset expresses the elapsed time (in buffer timestamps) before a
// seek with its start (stop if rate < 0.0) seek type set to T_SEEK_TYPE_NONE,
// the value is set to the position of the segment at the time of the seek.
func (s *Segment) SetOffset(offset uint64) {
	valptr := &s.native.offset
	*valptr = C.guint64(offset)
}

// Start: start time of the segment (in buffer timestamps) (PTS)
// (GstBuffer.pts), that is the timestamp of the first buffer to output inside
// the segment (last one during reverse playback). For example decoders will
// clip (gst_segment_clip) out the buffers before the start time.
func (s *Segment) SetStart(start uint64) {
	valptr := &s.native.start
	*valptr = C.guint64(start)
}

// Stop: stop time of the segment (in buffer timestamps) (PTS) (GstBuffer.pts),
// that is the timestamp of the last buffer to output inside the segment
// (first one during reverse playback). For example decoders will clip
// (gst_segment_clip) out buffers after the stop time.
func (s *Segment) SetStop(stop uint64) {
	valptr := &s.native.stop
	*valptr = C.guint64(stop)
}

// Time: stream time of the segment start (GstSegment.start) (stop
// (GstSegment.stop) if rate < 0.0).
func (s *Segment) SetTime(time uint64) {
	valptr := &s.native.time
	*valptr = C.guint64(time)
}

// Position: buffer timestamp position in the segment is supposed to be updated
// by elements such as sources, demuxers or parsers to track progress by
// setting it to the last pushed buffer' end time (timestamp (GstBuffer.pts)
// + Buffer.duration) for that specific segment. The position is used when
// reconfiguring the segment with #gst_segment_do_seek when the seek is only
// updating the segment (see offset (GstSegment.offset)).
func (s *Segment) SetPosition(position uint64) {
	valptr := &s.native.position
	*valptr = C.guint64(position)
}

// Duration: duration of the segment is the maximum absolute difference between
// Segment.start and Segment.stop if stop is not set, otherwise it should be the
// difference between those two values. This should be set by elements that know
// the overall stream duration (like demuxers) and will be used when seeking
// with T_SEEK_TYPE_END.
func (s *Segment) SetDuration(duration uint64) {
	valptr := &s.native.duration
	*valptr = C.guint64(duration)
}

// Clip the given start and stop values to the segment boundaries given in
// segment. start and stop are compared and clipped to segment start and stop
// values.
//
// If the function returns FALSE, start and stop are known to fall outside of
// segment and clip_start and clip_stop are not updated.
//
// When the function returns TRUE, clip_start and clip_stop will be updated.
// If clip_start or clip_stop are different from start or stop respectively,
// the region fell partially in the segment.
//
// Note that when stop is -1, clip_stop will be set to the end of the segment.
// Depending on the use case, this may or may not be what you want.
//
// The function takes the following parameters:
//
//   - format of the segment.
//   - start position in the segment.
//   - stop position in the segment.
//
// The function returns the following values:
//
//   - clipStart (optional): clipped start position in the segment.
//   - clipStop (optional): clipped stop position in the segment.
//   - ok: TRUE if the given start and stop times fall partially or completely
//     in segment, FALSE if the values are completely outside of the segment.
func (segment *Segment) Clip(format Format, start uint64, stop uint64) (clipStart uint64, clipStop uint64, ok bool) {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _arg3 C.guint64     // out
	var _arg4 C.guint64     // in
	var _arg5 C.guint64     // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(start)
	_arg3 = C.guint64(stop)

	_cret = C.gst_segment_clip(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(start)
	runtime.KeepAlive(stop)

	var _clipStart uint64 // out
	var _clipStop uint64  // out
	var _ok bool          // out

	_clipStart = uint64(_arg4)
	_clipStop = uint64(_arg5)
	if _cret != 0 {
		_ok = true
	}

	return _clipStart, _clipStop, _ok
}

// Copy: create a copy of given segment.
//
// Free-function: gst_segment_free.
//
// The function returns the following values:
//
//   - ret: new Segment, free with gst_segment_free().
func (segment *Segment) Copy() *Segment {
	var _arg0 *C.GstSegment // out
	var _cret *C.GstSegment // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))

	_cret = C.gst_segment_copy(_arg0)
	runtime.KeepAlive(segment)

	var _ret *Segment // out

	_ret = (*Segment)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_segment_free((*C.GstSegment)(intern.C))
		},
	)

	return _ret
}

// CopyInto: copy the contents of src into dest.
//
// The function takes the following parameters:
//
//   - dest: Segment.
func (src *Segment) CopyInto(dest *Segment) {
	var _arg0 *C.GstSegment // out
	var _arg1 *C.GstSegment // out

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(src)))
	_arg1 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(dest)))

	C.gst_segment_copy_into(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(dest)
}

// DoSeek: update the segment structure with the field values of a seek event
// (see gst_event_new_seek()).
//
// After calling this method, the segment field position and time will contain
// the requested new position in the segment. The new requested position in the
// segment depends on rate and start_type and stop_type.
//
// For positive rate, the new position in the segment is the new segment start
// field when it was updated with a start_type different from T_SEEK_TYPE_NONE.
// If no update was performed on segment start position (T_SEEK_TYPE_NONE),
// start is ignored and segment position is unmodified.
//
// For negative rate, the new position in the segment is the new segment stop
// field when it was updated with a stop_type different from T_SEEK_TYPE_NONE.
// If no stop was previously configured in the segment, the duration of the
// segment will be used to update the stop position. If no update was performed
// on segment stop position (T_SEEK_TYPE_NONE), stop is ignored and segment
// position is unmodified.
//
// The applied rate of the segment will be set to 1.0 by default. If the caller
// can apply a rate change, it should update segment rate and applied_rate after
// calling this function.
//
// update will be set to TRUE if a seek should be performed to the segment
// position field. This field can be FALSE if, for example, only the rate has
// been changed but not the playback position.
//
// The function takes the following parameters:
//
//   - rate of the segment.
//   - format of the segment.
//   - flags: segment flags for the segment.
//   - startType: seek method.
//   - start: seek start value.
//   - stopType: seek method.
//   - stop: seek stop value.
//
// The function returns the following values:
//
//   - update (optional): boolean holding whether position was updated.
//   - ok: TRUE if the seek could be performed.
func (segment *Segment) DoSeek(rate float64, format Format, flags SeekFlags, startType SeekType, start uint64, stopType SeekType, stop uint64) (update bool, ok bool) {
	var _arg0 *C.GstSegment  // out
	var _arg1 C.gdouble      // out
	var _arg2 C.GstFormat    // out
	var _arg3 C.GstSeekFlags // out
	var _arg4 C.GstSeekType  // out
	var _arg5 C.guint64      // out
	var _arg6 C.GstSeekType  // out
	var _arg7 C.guint64      // out
	var _arg8 C.gboolean     // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.gdouble(rate)
	_arg2 = C.GstFormat(format)
	_arg3 = C.GstSeekFlags(flags)
	_arg4 = C.GstSeekType(startType)
	_arg5 = C.guint64(start)
	_arg6 = C.GstSeekType(stopType)
	_arg7 = C.guint64(stop)

	_cret = C.gst_segment_do_seek(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, &_arg8)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(rate)
	runtime.KeepAlive(format)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(startType)
	runtime.KeepAlive(start)
	runtime.KeepAlive(stopType)
	runtime.KeepAlive(stop)

	var _update bool // out
	var _ok bool     // out

	if _arg8 != 0 {
		_update = true
	}
	if _cret != 0 {
		_ok = true
	}

	return _update, _ok
}

// Init: start/position fields are set to 0 and the stop/duration fields are set
// to -1 (unknown). The default rate of 1.0 and no flags are set.
//
// Initialize segment to its default values.
//
// The function takes the following parameters:
//
//   - format of the segment.
func (segment *Segment) Init(format Format) {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)

	C.gst_segment_init(_arg0, _arg1)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
}

// IsEqual checks for two segments being equal. Equality here is defined as
// perfect equality, including floating point values.
//
// The function takes the following parameters:
//
//   - s1: Segment structure.
//
// The function returns the following values:
//
//   - ok: TRUE if the segments are equal, FALSE otherwise.
func (s0 *Segment) IsEqual(s1 *Segment) bool {
	var _arg0 *C.GstSegment // out
	var _arg1 *C.GstSegment // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(s0)))
	_arg1 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(s1)))

	_cret = C.gst_segment_is_equal(_arg0, _arg1)
	runtime.KeepAlive(s0)
	runtime.KeepAlive(s1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// OffsetRunningTime: adjust the values in segment so that offset is applied to
// all future running-time calculations.
//
// The function takes the following parameters:
//
//   - format of the segment.
//   - offset to apply in the segment.
//
// The function returns the following values:
//
//   - ok: TRUE if the segment could be updated successfully. If FALSE is
//     returned, offset is not in segment.
func (segment *Segment) OffsetRunningTime(format Format, offset int64) bool {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.gint64      // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.gint64(offset)

	_cret = C.gst_segment_offset_running_time(_arg0, _arg1, _arg2)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(offset)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PositionFromRunningTime: convert running_time into a position in the
// segment so that gst_segment_to_running_time() with that position returns
// running_time.
//
// The function takes the following parameters:
//
//   - format of the segment.
//   - runningTime: running_time in the segment.
//
// The function returns the following values:
//
//   - guint64: position in the segment for running_time. This function returns
//     -1 when running_time is -1 or when it is not inside segment.
func (segment *Segment) PositionFromRunningTime(format Format, runningTime uint64) uint64 {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _cret C.guint64     // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(runningTime)

	_cret = C.gst_segment_position_from_running_time(_arg0, _arg1, _arg2)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(runningTime)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// PositionFromRunningTimeFull: translate running_time to the segment
// position using the currently configured segment. Compared to
// gst_segment_position_from_running_time() this function can return negative
// segment position.
//
// This function is typically used by elements that need to synchronize buffers
// against the clock or each other.
//
// running_time can be any value and the result of this function for values
// outside of the segment is extrapolated.
//
// When 1 is returned, running_time resulted in a positive position returned in
// position.
//
// When this function returns -1, the returned position was < 0, and the value
// in the position variable should be negated to get the real negative segment
// position.
//
// The function takes the following parameters:
//
//   - format of the segment.
//   - runningTime: running-time.
//
// The function returns the following values:
//
//   - position: resulting position in the segment.
//   - gint: 1 or -1 on success, 0 on failure.
func (segment *Segment) PositionFromRunningTimeFull(format Format, runningTime uint64) (uint64, int) {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _arg3 C.guint64     // in
	var _cret C.gint        // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(runningTime)

	_cret = C.gst_segment_position_from_running_time_full(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(runningTime)

	var _position uint64 // out
	var _gint int        // out

	_position = uint64(_arg3)
	_gint = int(_cret)

	return _position, _gint
}

// PositionFromStreamTime: convert stream_time into a position in the segment so
// that gst_segment_to_stream_time() with that position returns stream_time.
//
// The function takes the following parameters:
//
//   - format of the segment.
//   - streamTime: stream_time in the segment.
//
// The function returns the following values:
//
//   - guint64: position in the segment for stream_time. This function returns
//     -1 when stream_time is -1 or when it is not inside segment.
func (segment *Segment) PositionFromStreamTime(format Format, streamTime uint64) uint64 {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _cret C.guint64     // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(streamTime)

	_cret = C.gst_segment_position_from_stream_time(_arg0, _arg1, _arg2)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(streamTime)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// PositionFromStreamTimeFull: translate stream_time to the segment
// position using the currently configured segment. Compared to
// gst_segment_position_from_stream_time() this function can return negative
// segment position.
//
// This function is typically used by elements that need to synchronize buffers
// against the clock or each other.
//
// stream_time can be any value and the result of this function for values
// outside of the segment is extrapolated.
//
// When 1 is returned, stream_time resulted in a positive position returned in
// position.
//
// When this function returns -1, the returned position should be negated to get
// the real negative segment position.
//
// The function takes the following parameters:
//
//   - format of the segment.
//   - streamTime: stream-time.
//
// The function returns the following values:
//
//   - position: resulting position in the segment.
//   - gint: 1 or -1 on success, 0 on failure.
func (segment *Segment) PositionFromStreamTimeFull(format Format, streamTime uint64) (uint64, int) {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _arg3 C.guint64     // in
	var _cret C.gint        // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(streamTime)

	_cret = C.gst_segment_position_from_stream_time_full(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(streamTime)

	var _position uint64 // out
	var _gint int        // out

	_position = uint64(_arg3)
	_gint = int(_cret)

	return _position, _gint
}

// SetRunningTime: adjust the start/stop and base values of segment such that
// the next valid buffer will be one with running_time.
//
// The function takes the following parameters:
//
//   - format of the segment.
//   - runningTime: running_time in the segment.
//
// The function returns the following values:
//
//   - ok: TRUE if the segment could be updated successfully. If FALSE is
//     returned, running_time is -1 or not in segment.
func (segment *Segment) SetRunningTime(format Format, runningTime uint64) bool {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(runningTime)

	_cret = C.gst_segment_set_running_time(_arg0, _arg1, _arg2)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(runningTime)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ToPosition: convert running_time into a position in the segment so that
// gst_segment_to_running_time() with that position returns running_time.
//
// Deprecated: Use gst_segment_position_from_running_time() instead.
//
// The function takes the following parameters:
//
//   - format of the segment.
//   - runningTime: running_time in the segment.
//
// The function returns the following values:
//
//   - guint64: position in the segment for running_time. This function returns
//     -1 when running_time is -1 or when it is not inside segment.
func (segment *Segment) ToPosition(format Format, runningTime uint64) uint64 {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _cret C.guint64     // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(runningTime)

	_cret = C.gst_segment_to_position(_arg0, _arg1, _arg2)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(runningTime)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// ToRunningTime: translate position to the total running time using the
// currently configured segment. Position is a value between segment start and
// stop time.
//
// This function is typically used by elements that need to synchronize to the
// global clock in a pipeline. The running time is a constantly increasing value
// starting from 0. When gst_segment_init() is called, this value will reset to
// 0.
//
// This function returns -1 if the position is outside of segment start and
// stop.
//
// The function takes the following parameters:
//
//   - format of the segment.
//   - position in the segment.
//
// The function returns the following values:
//
//   - guint64: position as the total running time or -1 when an invalid
//     position was given.
func (segment *Segment) ToRunningTime(format Format, position uint64) uint64 {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _cret C.guint64     // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(position)

	_cret = C.gst_segment_to_running_time(_arg0, _arg1, _arg2)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(position)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// ToRunningTimeFull: translate position to the total running time using the
// currently configured segment. Compared to gst_segment_to_running_time() this
// function can return negative running-time.
//
// This function is typically used by elements that need to synchronize buffers
// against the clock or each other.
//
// position can be any value and the result of this function for values outside
// of the segment is extrapolated.
//
// When 1 is returned, position resulted in a positive running-time returned in
// running_time.
//
// When this function returns -1, the returned running_time should be negated to
// get the real negative running time.
//
// The function takes the following parameters:
//
//   - format of the segment.
//   - position in the segment.
//
// The function returns the following values:
//
//   - runningTime (optional): result running-time.
//   - gint: 1 or -1 on success, 0 on failure.
func (segment *Segment) ToRunningTimeFull(format Format, position uint64) (uint64, int) {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _arg3 C.guint64     // in
	var _cret C.gint        // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(position)

	_cret = C.gst_segment_to_running_time_full(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(position)

	var _runningTime uint64 // out
	var _gint int           // out

	_runningTime = uint64(_arg3)
	_gint = int(_cret)

	return _runningTime, _gint
}

// ToStreamTime: translate position to stream time using the currently
// configured segment. The position value must be between segment start and stop
// value.
//
// This function is typically used by elements that need to operate on the
// stream time of the buffers it receives, such as effect plugins. In those
// use cases, position is typically the buffer timestamp or clock time that one
// wants to convert to the stream time. The stream time is always between 0 and
// the total duration of the media stream.
//
// The function takes the following parameters:
//
//   - format of the segment.
//   - position in the segment.
//
// The function returns the following values:
//
//   - guint64: position in stream_time or -1 when an invalid position was
//     given.
func (segment *Segment) ToStreamTime(format Format, position uint64) uint64 {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _cret C.guint64     // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(position)

	_cret = C.gst_segment_to_stream_time(_arg0, _arg1, _arg2)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(position)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// ToStreamTimeFull: translate position to the total stream time using the
// currently configured segment. Compared to gst_segment_to_stream_time() this
// function can return negative stream-time.
//
// This function is typically used by elements that need to synchronize buffers
// against the clock or each other.
//
// position can be any value and the result of this function for values outside
// of the segment is extrapolated.
//
// When 1 is returned, position resulted in a positive stream-time returned in
// stream_time.
//
// When this function returns -1, the returned stream_time should be negated to
// get the real negative stream time.
//
// The function takes the following parameters:
//
//   - format of the segment.
//   - position in the segment.
//
// The function returns the following values:
//
//   - streamTime: result stream-time.
//   - gint: 1 or -1 on success, 0 on failure.
func (segment *Segment) ToStreamTimeFull(format Format, position uint64) (uint64, int) {
	var _arg0 *C.GstSegment // out
	var _arg1 C.GstFormat   // out
	var _arg2 C.guint64     // out
	var _arg3 C.guint64     // in
	var _cret C.gint        // in

	_arg0 = (*C.GstSegment)(gextras.StructNative(unsafe.Pointer(segment)))
	_arg1 = C.GstFormat(format)
	_arg2 = C.guint64(position)

	_cret = C.gst_segment_to_stream_time_full(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(segment)
	runtime.KeepAlive(format)
	runtime.KeepAlive(position)

	var _streamTime uint64 // out
	var _gint int          // out

	_streamTime = uint64(_arg3)
	_gint = int(_cret)

	return _streamTime, _gint
}

// StaticCaps: data structure to initialize Caps from a string description
// usually used in conjunction with GST_STATIC_CAPS() and gst_static_caps_get()
// to instantiate a Caps.
//
// An instance of this type is always passed by reference.
type StaticCaps struct {
	*staticCaps
}

// staticCaps is the struct that's finalized.
type staticCaps struct {
	native *C.GstStaticCaps
}

func marshalStaticCaps(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &StaticCaps{&staticCaps{(*C.GstStaticCaps)(b)}}, nil
}

// Caps: cached Caps.
func (s *StaticCaps) Caps() *Caps {
	valptr := &s.native.caps
	var _v *Caps // out
	_v = (*Caps)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// String: string describing a caps.
func (s *StaticCaps) String() string {
	valptr := &s.native.string
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Cleanup cleans up the cached caps contained in static_caps.
func (staticCaps *StaticCaps) Cleanup() {
	var _arg0 *C.GstStaticCaps // out

	_arg0 = (*C.GstStaticCaps)(gextras.StructNative(unsafe.Pointer(staticCaps)))

	C.gst_static_caps_cleanup(_arg0)
	runtime.KeepAlive(staticCaps)
}

// Get converts a StaticCaps to a Caps.
//
// The function returns the following values:
//
//   - caps (optional): pointer to the Caps. Since the core holds an additional
//     ref to the returned caps, use gst_caps_make_writable() on the returned
//     caps to modify it.
func (staticCaps *StaticCaps) Get() *Caps {
	var _arg0 *C.GstStaticCaps // out
	var _cret *C.GstCaps       // in

	_arg0 = (*C.GstStaticCaps)(gextras.StructNative(unsafe.Pointer(staticCaps)))

	_cret = C.gst_static_caps_get(_arg0)
	runtime.KeepAlive(staticCaps)

	var _caps *Caps // out

	if _cret != nil {
		_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_caps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _caps
}

// StaticPadTemplate: structure describing the StaticPadTemplate.
//
// An instance of this type is always passed by reference.
type StaticPadTemplate struct {
	*staticPadTemplate
}

// staticPadTemplate is the struct that's finalized.
type staticPadTemplate struct {
	native *C.GstStaticPadTemplate
}

func marshalStaticPadTemplate(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &StaticPadTemplate{&staticPadTemplate{(*C.GstStaticPadTemplate)(b)}}, nil
}

// NameTemplate: name of the template.
func (s *StaticPadTemplate) NameTemplate() string {
	valptr := &s.native.name_template
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Direction: direction of the template.
func (s *StaticPadTemplate) Direction() PadDirection {
	valptr := &s.native.direction
	var _v PadDirection // out
	_v = PadDirection(*valptr)
	return _v
}

// Presence: presence of the template.
func (s *StaticPadTemplate) Presence() PadPresence {
	valptr := &s.native.presence
	var _v PadPresence // out
	_v = PadPresence(*valptr)
	return _v
}

// StaticCaps caps of the template.
func (s *StaticPadTemplate) StaticCaps() *StaticCaps {
	valptr := &s.native.static_caps
	var _v *StaticCaps // out
	_v = (*StaticCaps)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Get converts a StaticPadTemplate into a PadTemplate.
//
// The function returns the following values:
//
//   - padTemplate (optional): new PadTemplate.
func (padTemplate *StaticPadTemplate) Get() *PadTemplate {
	var _arg0 *C.GstStaticPadTemplate // out
	var _cret *C.GstPadTemplate       // in

	_arg0 = (*C.GstStaticPadTemplate)(gextras.StructNative(unsafe.Pointer(padTemplate)))

	_cret = C.gst_static_pad_template_get(_arg0)
	runtime.KeepAlive(padTemplate)

	var _padTemplate *PadTemplate // out

	if _cret != nil {
		_padTemplate = wrapPadTemplate(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _padTemplate
}

// Caps gets the capabilities of the static pad template.
//
// The function returns the following values:
//
//   - caps of the static pad template. Unref after usage. Since the core holds
//     an additional ref to the returned caps, use gst_caps_make_writable() on
//     the returned caps to modify it.
func (templ *StaticPadTemplate) Caps() *Caps {
	var _arg0 *C.GstStaticPadTemplate // out
	var _cret *C.GstCaps              // in

	_arg0 = (*C.GstStaticPadTemplate)(gextras.StructNative(unsafe.Pointer(templ)))

	_cret = C.gst_static_pad_template_get_caps(_arg0)
	runtime.KeepAlive(templ)

	var _caps *Caps // out

	_caps = (*Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _caps
}

// StreamClass: gstStream class structure
//
// An instance of this type is always passed by reference.
type StreamClass struct {
	*streamClass
}

// streamClass is the struct that's finalized.
type streamClass struct {
	native *C.GstStreamClass
}

// ParentClass: parent class structure.
func (s *StreamClass) ParentClass() *ObjectClass {
	valptr := &s.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// StreamCollectionClass: gstStreamCollection class structure
//
// An instance of this type is always passed by reference.
type StreamCollectionClass struct {
	*streamCollectionClass
}

// streamCollectionClass is the struct that's finalized.
type streamCollectionClass struct {
	native *C.GstStreamCollectionClass
}

// ParentClass: parent class structure.
func (s *StreamCollectionClass) ParentClass() *ObjectClass {
	valptr := &s.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Structure is a collection of key/value pairs. The keys are expressed as
// GQuarks and the values can be of any GType.
//
// In addition to the key/value pairs, a Structure also has a name. The name
// starts with a letter and can be filled by letters, numbers and any of
// "/-_.:".
//
// Structure is used by various GStreamer subsystems to store information in a
// flexible and extensible way. A Structure does not have a refcount because it
// usually is part of a higher level object such as Caps, Message, Event, Query.
// It provides a means to enforce mutability using the refcount of the parent
// with the gst_structure_set_parent_refcount() method.
//
// A Structure can be created with gst_structure_new_empty() or
// gst_structure_new(), which both take a name and an optional set of key/value
// pairs along with the types of the values.
//
// Field values can be changed with gst_structure_set_value() or
// gst_structure_set().
//
// Field values can be retrieved with gst_structure_get_value() or the more
// convenient gst_structure_get_*() functions.
//
// Fields can be removed with gst_structure_remove_field() or
// gst_structure_remove_fields().
//
// Strings in structures must be ASCII or UTF-8 encoded. Other encodings are not
// allowed. Strings may be NULL however.
//
// # The serialization format
//
// GstStructure serialization format serialize the GstStructure name,
// keys/GType/values in a comma separated list with the structure name as
// first field without value followed by separated key/value pairs in the form
// key=value, for example:
//
//	a-structure, key=value
//
// `
//
// The values type will be inferred if not explicitly specified with the
// (GTypeName)value syntax, for example the following struct will have one field
// called 'is-string' which has the string 'true' as a value:
//
//	a-struct, field-is-string=(string)true, field-is-boolean=true
//
// *Note*: without specifying (string), field-is-string` type would have been
// inferred as boolean.
//
// *Note*: we specified (string) as a type even if gchararray is the actual
// GType name as for convenience some well known types have been aliased or
// abbreviated.
//
// To avoid specifying the type, you can give some hints to the "type system".
// For example to specify a value as a double, you should add a decimal (ie.
// 1 is an int while 1.0 is a double).
//
// *Note*: when a structure is serialized with #gst_structure_to_string,
// all values are explicitly typed.
//
// Some types have special delimiters:
//
// - GstValueArray (GST_TYPE_ARRAY) are inside curly brackets ({ and }).
// For example a-structure, array={1, 2, 3}
//
// - Ranges are inside brackets ([ and ]). For example a-structure, range=[1,
// 6, 2] 1 being the min value, 6 the maximum and 2 the step. To specify a
// T_TYPE_INT64_RANGE you need to explicitly specify it like: a-structure,
// a-int64-range=(gint64) [1, 5]
//
// - GstValueList (GST_TYPE_LIST) are inside "less and greater than" (< and >).
// For example `a-structure, list=<1, 2, 3>
//
// Structures are delimited either by a null character \0 or a semicolon ; the
// latter allowing to store multiple structures in the same string (see Caps).
//
// Quotes are used as "default" delimiters and can be used around any types
// that don't use other delimiters (for example a-struct, i=(int)"1"). They
// are use to allow adding spaces or special characters (such as delimiters,
// semicolumns, etc..) inside strings and you can use backslashes \ to escape
// characters inside them, for example:
//
//	a-struct, special="\"{[(;)]}\" can be used inside quotes"
//
// They also allow for nested structure, such as:
//
//	a-struct, nested=(GstStructure)"nested-struct, nested=true"
//
// Since 1.20, nested structures and caps can be specified using brackets ([ and
// ]), for example:
//
//	a-struct, nested=[nested-struct, nested=true]
//
// > *note*: gst_structure_to_string() won't use that syntax for backward >
// compatibility reason, gst_structure_serialize_full() has been added for >
// that purpose.
//
// An instance of this type is always passed by reference.
type Structure struct {
	*structure
}

// structure is the struct that's finalized.
type structure struct {
	native *C.GstStructure
}

func marshalStructure(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Structure{&structure{(*C.GstStructure)(b)}}, nil
}

// NewStructureEmpty constructs a struct Structure.
func NewStructureEmpty(name string) *Structure {
	var _arg1 *C.gchar        // out
	var _cret *C.GstStructure // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_new_empty(_arg1)
	runtime.KeepAlive(name)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_structure)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_structure_free((*C.GstStructure)(intern.C))
		},
	)

	return _structure
}

// NewStructureIDEmpty constructs a struct Structure.
func NewStructureIDEmpty(quark glib.Quark) *Structure {
	var _arg1 C.GQuark        // out
	var _cret *C.GstStructure // in

	_arg1 = C.GQuark(quark)

	_cret = C.gst_structure_new_id_empty(_arg1)
	runtime.KeepAlive(quark)

	var _structure *Structure // out

	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_structure)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_structure_free((*C.GstStructure)(intern.C))
		},
	)

	return _structure
}

// Type of a structure.
func (s *Structure) Type() coreglib.Type {
	valptr := &s.native._type
	var _v coreglib.Type // out
	_v = coreglib.Type(*valptr)
	return _v
}

// CanIntersect tries intersecting struct1 and struct2 and reports whether the
// result would not be empty.
//
// The function takes the following parameters:
//
//   - struct2: Structure.
//
// The function returns the following values:
//
//   - ok: TRUE if intersection would not be empty.
func (struct1 *Structure) CanIntersect(struct2 *Structure) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.GstStructure // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(struct1)))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(struct2)))

	_cret = C.gst_structure_can_intersect(_arg0, _arg1)
	runtime.KeepAlive(struct1)
	runtime.KeepAlive(struct2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Copy duplicates a Structure and all its fields and values.
//
// Free-function: gst_structure_free.
//
// The function returns the following values:
//
//   - ret: new Structure.
func (structure *Structure) Copy() *Structure {
	var _arg0 *C.GstStructure // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))

	_cret = C.gst_structure_copy(_arg0)
	runtime.KeepAlive(structure)

	var _ret *Structure // out

	_ret = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_structure_free((*C.GstStructure)(intern.C))
		},
	)

	return _ret
}

// FilterAndMapInPlace calls the provided function once for each field in the
// Structure. In contrast to gst_structure_foreach(), the function may modify
// the fields. In contrast to gst_structure_map_in_place(), the field is removed
// from the structure if FALSE is returned from the function. The structure must
// be mutable.
//
// The function takes the following parameters:
//
//   - fn: function to call for each field.
func (structure *Structure) FilterAndMapInPlace(fn StructureFilterMapFunc) {
	var _arg0 *C.GstStructure             // out
	var _arg1 C.GstStructureFilterMapFunc // out
	var _arg2 C.gpointer

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*[0]byte)(C._gotk4_gst1_StructureFilterMapFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.gst_structure_filter_and_map_in_place(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fn)
}

// Fixate all values in structure using gst_value_fixate(). structure will be
// modified in-place and should be writable.
func (structure *Structure) Fixate() {
	var _arg0 *C.GstStructure // out

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))

	C.gst_structure_fixate(_arg0)
	runtime.KeepAlive(structure)
}

// FixateField fixates a Structure by changing the given field with its fixated
// value.
//
// The function takes the following parameters:
//
//   - fieldName: field in structure.
//
// The function returns the following values:
//
//   - ok: TRUE if the structure field could be fixated.
func (structure *Structure) FixateField(fieldName string) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.char         // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(fieldName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_fixate_field(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldName)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FixateFieldBoolean fixates a Structure by changing the given field_name field
// to the given target boolean if that field is not fixed yet.
//
// The function takes the following parameters:
//
//   - fieldName: field in structure.
//   - target value of the fixation.
//
// The function returns the following values:
//
//   - ok: TRUE if the structure could be fixated.
func (structure *Structure) FixateFieldBoolean(fieldName string, target bool) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.char         // out
	var _arg2 C.gboolean      // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(fieldName)))
	defer C.free(unsafe.Pointer(_arg1))
	if target {
		_arg2 = C.TRUE
	}

	_cret = C.gst_structure_fixate_field_boolean(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldName)
	runtime.KeepAlive(target)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FixateFieldNearestDouble fixates a Structure by changing the given field to
// the nearest double to target that is a subset of the existing field.
//
// The function takes the following parameters:
//
//   - fieldName: field in structure.
//   - target value of the fixation.
//
// The function returns the following values:
//
//   - ok: TRUE if the structure could be fixated.
func (structure *Structure) FixateFieldNearestDouble(fieldName string, target float64) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.char         // out
	var _arg2 C.double        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(fieldName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.double(target)

	_cret = C.gst_structure_fixate_field_nearest_double(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldName)
	runtime.KeepAlive(target)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FixateFieldNearestFraction fixates a Structure by changing the given field to
// the nearest fraction to target_numerator/target_denominator that is a subset
// of the existing field.
//
// The function takes the following parameters:
//
//   - fieldName: field in structure.
//   - targetNumerator: numerator of the target value of the fixation.
//   - targetDenominator: denominator of the target value of the fixation.
//
// The function returns the following values:
//
//   - ok: TRUE if the structure could be fixated.
func (structure *Structure) FixateFieldNearestFraction(fieldName string, targetNumerator int, targetDenominator int) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.char         // out
	var _arg2 C.gint          // out
	var _arg3 C.gint          // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(fieldName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(targetNumerator)
	_arg3 = C.gint(targetDenominator)

	_cret = C.gst_structure_fixate_field_nearest_fraction(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldName)
	runtime.KeepAlive(targetNumerator)
	runtime.KeepAlive(targetDenominator)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FixateFieldNearestInt fixates a Structure by changing the given field to the
// nearest integer to target that is a subset of the existing field.
//
// The function takes the following parameters:
//
//   - fieldName: field in structure.
//   - target value of the fixation.
//
// The function returns the following values:
//
//   - ok: TRUE if the structure could be fixated.
func (structure *Structure) FixateFieldNearestInt(fieldName string, target int) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.char         // out
	var _arg2 C.int           // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(fieldName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(target)

	_cret = C.gst_structure_fixate_field_nearest_int(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldName)
	runtime.KeepAlive(target)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FixateFieldString fixates a Structure by changing the given field_name field
// to the given target string if that field is not fixed yet.
//
// The function takes the following parameters:
//
//   - fieldName: field in structure.
//   - target value of the fixation.
//
// The function returns the following values:
//
//   - ok: TRUE if the structure could be fixated.
func (structure *Structure) FixateFieldString(fieldName string, target string) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.char         // out
	var _arg2 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(fieldName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(target)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_structure_fixate_field_string(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldName)
	runtime.KeepAlive(target)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForEach calls the provided function once for each field in the Structure. The
// function must not modify the fields. Also see gst_structure_map_in_place()
// and gst_structure_filter_and_map_in_place().
//
// The function takes the following parameters:
//
//   - fn: function to call for each field.
//
// The function returns the following values:
//
//   - ok: TRUE if the supplied function returns TRUE For each of the fields,
//     FALSE otherwise.
func (structure *Structure) ForEach(fn StructureForEachFunc) bool {
	var _arg0 *C.GstStructure           // out
	var _arg1 C.GstStructureForeachFunc // out
	var _arg2 C.gpointer
	var _cret C.gboolean // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*[0]byte)(C._gotk4_gst1_StructureForEachFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.gst_structure_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Boolean sets the boolean pointed to by value corresponding to the value of
// the given field. Caller is responsible for making sure the field exists and
// has the correct type.
//
// The function takes the following parameters:
//
//   - fieldname: name of a field.
//
// The function returns the following values:
//
//   - value: pointer to a #gboolean to set.
//   - ok: TRUE if the value could be set correctly. If there was no field with
//     fieldname or the existing field did not contain a boolean, this function
//     returns FALSE.
func (structure *Structure) Boolean(fieldname string) (value bool, ok bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gboolean      // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_boolean(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _value bool // out
	var _ok bool    // out

	if _arg2 != 0 {
		_value = true
	}
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// ClockTime sets the clock time pointed to by value corresponding to the clock
// time of the given field. Caller is responsible for making sure the field
// exists and has the correct type.
//
// The function takes the following parameters:
//
//   - fieldname: name of a field.
//
// The function returns the following values:
//
//   - value: pointer to a ClockTime to set.
//   - ok: TRUE if the value could be set correctly. If there was no field
//     with fieldname or the existing field did not contain a ClockTime,
//     this function returns FALSE.
func (structure *Structure) ClockTime(fieldname string) (ClockTime, bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.GstClockTime  // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_clock_time(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _value ClockTime // out
	var _ok bool         // out

	_value = ClockTime(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// DateTime sets the datetime pointed to by value corresponding to the datetime
// of the given field. Caller is responsible for making sure the field exists
// and has the correct type.
//
// On success value will point to a reference of the datetime which should be
// unreffed with gst_date_time_unref() when no longer needed (note: this is
// inconsistent with e.g. gst_structure_get_string() which doesn't return a copy
// of the string).
//
// The function takes the following parameters:
//
//   - fieldname: name of a field.
//
// The function returns the following values:
//
//   - value: pointer to a DateTime to set.
//   - ok: TRUE if the value could be set correctly. If there was no field with
//     fieldname or the existing field did not contain a data, this function
//     returns FALSE.
func (structure *Structure) DateTime(fieldname string) (*DateTime, bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GstDateTime  // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_date_time(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _value *DateTime // out
	var _ok bool         // out

	_value = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_value)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_date_time_unref((*C.GstDateTime)(intern.C))
		},
	)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Double sets the double pointed to by value corresponding to the value of the
// given field. Caller is responsible for making sure the field exists and has
// the correct type.
//
// The function takes the following parameters:
//
//   - fieldname: name of a field.
//
// The function returns the following values:
//
//   - value: pointer to a gdouble to set.
//   - ok: TRUE if the value could be set correctly. If there was no field with
//     fieldname or the existing field did not contain a double, this function
//     returns FALSE.
func (structure *Structure) Double(fieldname string) (float64, bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gdouble       // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_double(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _value float64 // out
	var _ok bool       // out

	_value = float64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Enum sets the int pointed to by value corresponding to the value of the
// given field. Caller is responsible for making sure the field exists, has the
// correct type and that the enumtype is correct.
//
// The function takes the following parameters:
//
//   - fieldname: name of a field.
//   - enumtype: enum type of a field.
//
// The function returns the following values:
//
//   - value: pointer to an int to set.
//   - ok: TRUE if the value could be set correctly. If there was no field with
//     fieldname or the existing field did not contain an enum of the given
//     type, this function returns FALSE.
func (structure *Structure) Enum(fieldname string, enumtype coreglib.Type) (int, bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.GType         // out
	var _arg3 C.gint          // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GType(enumtype)

	_cret = C.gst_structure_get_enum(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)
	runtime.KeepAlive(enumtype)

	var _value int // out
	var _ok bool   // out

	_value = int(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// FieldType finds the field with the given name, and returns the type of the
// value it contains. If the field is not found, G_TYPE_INVALID is returned.
//
// The function takes the following parameters:
//
//   - fieldname: name of the field.
//
// The function returns the following values:
//
//   - gType of the field.
func (structure *Structure) FieldType(fieldname string) coreglib.Type {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _cret C.GType         // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_field_type(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// Flags sets the unsigned int pointed to by value corresponding to the value
// of the given field. Caller is responsible for making sure the field exists,
// has the correct type and that the flagstype is correct.
//
// The function takes the following parameters:
//
//   - fieldname: name of a field.
//   - flagsType flags type of a field.
//
// The function returns the following values:
//
//   - value: pointer to an unsigned int to set.
//   - ok: TRUE if the value could be set correctly. If there was no field with
//     fieldname or the existing field did not contain flags or did not contain
//     flags of the given type, this function returns FALSE.
func (structure *Structure) Flags(fieldname string, flagsType coreglib.Type) (uint, bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.GType         // out
	var _arg3 C.guint         // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GType(flagsType)

	_cret = C.gst_structure_get_flags(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)
	runtime.KeepAlive(flagsType)

	var _value uint // out
	var _ok bool    // out

	_value = uint(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Flagset: read the GstFlagSet flags and mask out of the structure into the
// provided pointers.
//
// The function takes the following parameters:
//
//   - fieldname: name of a field.
//
// The function returns the following values:
//
//   - valueFlags (optional): pointer to a guint for the flags field.
//   - valueMask (optional): pointer to a guint for the mask field.
//   - ok: TRUE if the values could be set correctly. If there was no field
//     with fieldname or the existing field did not contain a GstFlagSet,
//     this function returns FALSE.
func (structure *Structure) Flagset(fieldname string) (valueFlags uint, valueMask uint, ok bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.guint         // in
	var _arg3 C.guint         // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_flagset(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _valueFlags uint // out
	var _valueMask uint  // out
	var _ok bool         // out

	_valueFlags = uint(_arg2)
	_valueMask = uint(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _valueFlags, _valueMask, _ok
}

// Fraction sets the integers pointed to by value_numerator and
// value_denominator corresponding to the value of the given field. Caller is
// responsible for making sure the field exists and has the correct type.
//
// The function takes the following parameters:
//
//   - fieldname: name of a field.
//
// The function returns the following values:
//
//   - valueNumerator: pointer to an int to set.
//   - valueDenominator: pointer to an int to set.
//   - ok: TRUE if the values could be set correctly. If there was no field
//     with fieldname or the existing field did not contain a GstFraction,
//     this function returns FALSE.
func (structure *Structure) Fraction(fieldname string) (valueNumerator int, valueDenominator int, ok bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gint          // in
	var _arg3 C.gint          // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_fraction(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _valueNumerator int   // out
	var _valueDenominator int // out
	var _ok bool              // out

	_valueNumerator = int(_arg2)
	_valueDenominator = int(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _valueNumerator, _valueDenominator, _ok
}

// Int sets the int pointed to by value corresponding to the value of the given
// field. Caller is responsible for making sure the field exists and has the
// correct type.
//
// The function takes the following parameters:
//
//   - fieldname: name of a field.
//
// The function returns the following values:
//
//   - value: pointer to an int to set.
//   - ok: TRUE if the value could be set correctly. If there was no field with
//     fieldname or the existing field did not contain an int, this function
//     returns FALSE.
func (structure *Structure) Int(fieldname string) (int, bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gint          // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_int(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _value int // out
	var _ok bool   // out

	_value = int(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Int64 sets the #gint64 pointed to by value corresponding to the value of the
// given field. Caller is responsible for making sure the field exists and has
// the correct type.
//
// The function takes the following parameters:
//
//   - fieldname: name of a field.
//
// The function returns the following values:
//
//   - value: pointer to a #gint64 to set.
//   - ok: TRUE if the value could be set correctly. If there was no field with
//     fieldname or the existing field did not contain a #gint64, this function
//     returns FALSE.
func (structure *Structure) Int64(fieldname string) (int64, bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gint64        // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_int64(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _value int64 // out
	var _ok bool     // out

	_value = int64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Name: get the name of structure as a string.
//
// The function returns the following values:
//
//   - utf8: name of the structure.
func (structure *Structure) Name() string {
	var _arg0 *C.GstStructure // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))

	_cret = C.gst_structure_get_name(_arg0)
	runtime.KeepAlive(structure)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// NameID: get the name of structure as a GQuark.
//
// The function returns the following values:
//
//   - quark representing the name of the structure.
func (structure *Structure) NameID() glib.Quark {
	var _arg0 *C.GstStructure // out
	var _cret C.GQuark        // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))

	_cret = C.gst_structure_get_name_id(_arg0)
	runtime.KeepAlive(structure)

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// String finds the field corresponding to fieldname, and returns the string
// contained in the field's value. Caller is responsible for making sure the
// field exists and has the correct type.
//
// The string should not be modified, and remains valid until the next call to a
// gst_structure_*() function with the given structure.
//
// The function takes the following parameters:
//
//   - fieldname: name of a field.
//
// The function returns the following values:
//
//   - utf8 (optional): pointer to the string or NULL when the field did not
//     exist or did not contain a string.
func (structure *Structure) String(fieldname string) string {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_string(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Uint sets the uint pointed to by value corresponding to the value of the
// given field. Caller is responsible for making sure the field exists and has
// the correct type.
//
// The function takes the following parameters:
//
//   - fieldname: name of a field.
//
// The function returns the following values:
//
//   - value: pointer to a uint to set.
//   - ok: TRUE if the value could be set correctly. If there was no field with
//     fieldname or the existing field did not contain a uint, this function
//     returns FALSE.
func (structure *Structure) Uint(fieldname string) (uint, bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.guint         // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_uint(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _value uint // out
	var _ok bool    // out

	_value = uint(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Uint64 sets the #guint64 pointed to by value corresponding to the value of
// the given field. Caller is responsible for making sure the field exists and
// has the correct type.
//
// The function takes the following parameters:
//
//   - fieldname: name of a field.
//
// The function returns the following values:
//
//   - value: pointer to a #guint64 to set.
//   - ok: TRUE if the value could be set correctly. If there was no field with
//     fieldname or the existing field did not contain a #guint64, this function
//     returns FALSE.
func (structure *Structure) Uint64(fieldname string) (uint64, bool) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.guint64       // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_uint64(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _value uint64 // out
	var _ok bool      // out

	_value = uint64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Value: get the value of the field with name fieldname.
//
// The function takes the following parameters:
//
//   - fieldname: name of the field to get.
//
// The function returns the following values:
//
//   - value (optional) corresponding to the field with the given name.
func (structure *Structure) Value(fieldname string) *coreglib.Value {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _cret *C.GValue       // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_get_value(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _value *coreglib.Value // out

	if _cret != nil {
		_value = coreglib.ValueFromNative(unsafe.Pointer(_cret))
	}

	return _value
}

// HasField: check if structure contains a field named fieldname.
//
// The function takes the following parameters:
//
//   - fieldname: name of a field.
//
// The function returns the following values:
//
//   - ok: TRUE if the structure contains a field with the given name.
func (structure *Structure) HasField(fieldname string) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_has_field(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasFieldTyped: check if structure contains a field named fieldname and with
// GType type.
//
// The function takes the following parameters:
//
//   - fieldname: name of a field.
//   - typ: type of a value.
//
// The function returns the following values:
//
//   - ok: TRUE if the structure contains a field with the given name and type.
func (structure *Structure) HasFieldTyped(fieldname string, typ coreglib.Type) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 C.GType         // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GType(typ)

	_cret = C.gst_structure_has_field_typed(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasName checks if the structure has the given name.
//
// The function takes the following parameters:
//
//   - name: structure name to check for.
//
// The function returns the following values:
//
//   - ok: TRUE if name matches the name of the structure.
func (structure *Structure) HasName(name string) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_structure_has_name(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IDGetValue: get the value of the field with GQuark field.
//
// The function takes the following parameters:
//
//   - field of the field to get.
//
// The function returns the following values:
//
//   - value (optional) corresponding to the field with the given name
//     identifier.
func (structure *Structure) IDGetValue(field glib.Quark) *coreglib.Value {
	var _arg0 *C.GstStructure // out
	var _arg1 C.GQuark        // out
	var _cret *C.GValue       // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = C.GQuark(field)

	_cret = C.gst_structure_id_get_value(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(field)

	var _value *coreglib.Value // out

	if _cret != nil {
		_value = coreglib.ValueFromNative(unsafe.Pointer(_cret))
	}

	return _value
}

// IDHasField: check if structure contains a field named field.
//
// The function takes the following parameters:
//
//   - field of the field name.
//
// The function returns the following values:
//
//   - ok: TRUE if the structure contains a field with the given name.
func (structure *Structure) IDHasField(field glib.Quark) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 C.GQuark        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = C.GQuark(field)

	_cret = C.gst_structure_id_has_field(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(field)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IDHasFieldTyped: check if structure contains a field named field and with
// GType type.
//
// The function takes the following parameters:
//
//   - field of the field name.
//   - typ: type of a value.
//
// The function returns the following values:
//
//   - ok: TRUE if the structure contains a field with the given name and type.
func (structure *Structure) IDHasFieldTyped(field glib.Quark, typ coreglib.Type) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 C.GQuark        // out
	var _arg2 C.GType         // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = C.GQuark(field)
	_arg2 = C.GType(typ)

	_cret = C.gst_structure_id_has_field_typed(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(field)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IDSetValue sets the field with the given GQuark field to value. If the field
// does not exist, it is created. If the field exists, the previous value is
// replaced and freed.
//
// The function takes the following parameters:
//
//   - field representing a field.
//   - value: new value of the field.
func (structure *Structure) IDSetValue(field glib.Quark, value *coreglib.Value) {
	var _arg0 *C.GstStructure // out
	var _arg1 C.GQuark        // out
	var _arg2 *C.GValue       // out

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = C.GQuark(field)
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gst_structure_id_set_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(field)
	runtime.KeepAlive(value)
}

// IDTakeValue sets the field with the given GQuark field to value. If the field
// does not exist, it is created. If the field exists, the previous value is
// replaced and freed.
//
// The function takes the following parameters:
//
//   - field representing a field.
//   - value: new value of the field.
func (structure *Structure) IDTakeValue(field glib.Quark, value *coreglib.Value) {
	var _arg0 *C.GstStructure // out
	var _arg1 C.GQuark        // out
	var _arg2 *C.GValue       // out

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = C.GQuark(field)
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gst_structure_id_take_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(field)
	runtime.KeepAlive(value)
}

// Intersect intersects struct1 and struct2 and returns the intersection.
//
// The function takes the following parameters:
//
//   - struct2: Structure.
//
// The function returns the following values:
//
//   - structure (optional): intersection of struct1 and struct2.
func (struct1 *Structure) Intersect(struct2 *Structure) *Structure {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.GstStructure // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(struct1)))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(struct2)))

	_cret = C.gst_structure_intersect(_arg0, _arg1)
	runtime.KeepAlive(struct1)
	runtime.KeepAlive(struct2)

	var _structure *Structure // out

	if _cret != nil {
		_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_structure)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_structure_free((*C.GstStructure)(intern.C))
			},
		)
	}

	return _structure
}

// IsEqual tests if the two Structure are equal.
//
// The function takes the following parameters:
//
//   - structure2: Structure.
//
// The function returns the following values:
//
//   - ok: TRUE if the two structures have the same name and field.
func (structure1 *Structure) IsEqual(structure2 *Structure) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.GstStructure // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure1)))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure2)))

	_cret = C.gst_structure_is_equal(_arg0, _arg1)
	runtime.KeepAlive(structure1)
	runtime.KeepAlive(structure2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSubset checks if subset is a subset of superset, i.e. has the same
// structure name and for all fields that are existing in superset, subset has a
// value that is a subset of the value in superset.
//
// The function takes the following parameters:
//
//   - superset: potentially greater Structure.
//
// The function returns the following values:
//
//   - ok: TRUE if subset is a subset of superset.
func (subset *Structure) IsSubset(superset *Structure) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.GstStructure // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(subset)))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(superset)))

	_cret = C.gst_structure_is_subset(_arg0, _arg1)
	runtime.KeepAlive(subset)
	runtime.KeepAlive(superset)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MapInPlace calls the provided function once for each field in the Structure.
// In contrast to gst_structure_foreach(), the function may modify but not
// delete the fields. The structure must be mutable.
//
// The function takes the following parameters:
//
//   - fn: function to call for each field.
//
// The function returns the following values:
//
//   - ok: TRUE if the supplied function returns TRUE For each of the fields,
//     FALSE otherwise.
func (structure *Structure) MapInPlace(fn StructureMapFunc) bool {
	var _arg0 *C.GstStructure       // out
	var _arg1 C.GstStructureMapFunc // out
	var _arg2 C.gpointer
	var _cret C.gboolean // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*[0]byte)(C._gotk4_gst1_StructureMapFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	_cret = C.gst_structure_map_in_place(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NFields: get the number of fields in the structure.
//
// The function returns the following values:
//
//   - gint: number of fields in the structure.
func (structure *Structure) NFields() int {
	var _arg0 *C.GstStructure // out
	var _cret C.gint          // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))

	_cret = C.gst_structure_n_fields(_arg0)
	runtime.KeepAlive(structure)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NthFieldName: get the name of the given field number, counting from 0
// onwards.
//
// The function takes the following parameters:
//
//   - index to get the name of.
//
// The function returns the following values:
//
//   - utf8: name of the given field number.
func (structure *Structure) NthFieldName(index uint) string {
	var _arg0 *C.GstStructure // out
	var _arg1 C.guint         // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = C.guint(index)

	_cret = C.gst_structure_nth_field_name(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(index)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// RemoveAllFields removes all fields in a GstStructure.
func (structure *Structure) RemoveAllFields() {
	var _arg0 *C.GstStructure // out

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))

	C.gst_structure_remove_all_fields(_arg0)
	runtime.KeepAlive(structure)
}

// RemoveField removes the field with the given name. If the field with the
// given name does not exist, the structure is unchanged.
//
// The function takes the following parameters:
//
//   - fieldname: name of the field to remove.
func (structure *Structure) RemoveField(fieldname string) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_structure_remove_field(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)
}

// Serialize converts structure to a human-readable string representation.
//
// This version of the caps serialization function introduces support for
// nested structures and caps but the resulting strings won't be parsable with
// GStreamer prior to 1.20 unless T_SERIALIZE_FLAG_BACKWARD_COMPAT is passed as
// flag.
//
// GST_SERIALIZE_FLAG_STRICT flags is not allowed because it would
// make this function nullable which is an API break for bindings. Use
// gst_structure_serialize_full() instead.
//
// Free-function: g_free
//
// Deprecated: Use gst_structure_serialize_full() instead.
//
// The function takes the following parameters:
//
//   - flags to use to serialize structure.
//
// The function returns the following values:
//
//   - utf8: pointer to string allocated by g_malloc(). g_free() after usage.
func (structure *Structure) Serialize(flags SerializeFlags) string {
	var _arg0 *C.GstStructure     // out
	var _arg1 C.GstSerializeFlags // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = C.GstSerializeFlags(flags)

	_cret = C.gst_structure_serialize(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(flags)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// SerializeFull alias for gst_structure_serialize() but with nullable
// annotation because it can return NULL when GST_SERIALIZE_FLAG_STRICT flag is
// set.
//
// The function takes the following parameters:
//
//   - flags to use to serialize structure.
//
// The function returns the following values:
//
//   - utf8 (optional): pointer to string allocated by g_malloc(). g_free()
//     after usage.
func (structure *Structure) SerializeFull(flags SerializeFlags) string {
	var _arg0 *C.GstStructure     // out
	var _arg1 C.GstSerializeFlags // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = C.GstSerializeFlags(flags)

	_cret = C.gst_structure_serialize_full(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(flags)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// SetName sets the name of the structure to the given name. The string provided
// is copied before being used. It must not be empty, start with a letter and
// can be followed by letters, numbers and any of "/-_.:".
//
// The function takes the following parameters:
//
//   - name: new name of the structure.
func (structure *Structure) SetName(name string) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_structure_set_name(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(name)
}

// SetParentRefcount sets the parent_refcount field of Structure. This field is
// used to determine whether a structure is mutable or not. This function should
// only be called by code implementing parent objects of Structure, as described
// in the MT Refcounting section of the design documents.
//
// The function takes the following parameters:
//
//   - refcount: pointer to the parent's refcount.
//
// The function returns the following values:
//
//   - ok: TRUE if the parent refcount could be set.
func (structure *Structure) SetParentRefcount(refcount *int) bool {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gint         // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gint)(unsafe.Pointer(refcount))

	_cret = C.gst_structure_set_parent_refcount(_arg0, _arg1)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(refcount)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetValue sets the field with the given name field to value. If the field does
// not exist, it is created. If the field exists, the previous value is replaced
// and freed.
//
// The function takes the following parameters:
//
//   - fieldname: name of the field to set.
//   - value: new value of the field.
func (structure *Structure) SetValue(fieldname string, value *coreglib.Value) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GValue       // out

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gst_structure_set_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)
	runtime.KeepAlive(value)
}

// TakeValue sets the field with the given name field to value. If the field
// does not exist, it is created. If the field exists, the previous value is
// replaced and freed. The function will take ownership of value.
//
// The function takes the following parameters:
//
//   - fieldname: name of the field to set.
//   - value: new value of the field.
func (structure *Structure) TakeValue(fieldname string, value *coreglib.Value) {
	var _arg0 *C.GstStructure // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GValue       // out

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fieldname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gst_structure_take_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(structure)
	runtime.KeepAlive(fieldname)
	runtime.KeepAlive(value)
}

// ToString converts structure to a human-readable string representation.
//
// For debugging purposes its easier to do something like this: |[<!--
// language="C" --> GST_LOG ("structure is %" GST_PTR_FORMAT, structure);
// ]| This prints the structure in human readable form.
//
// This function will lead to unexpected results when there are
// nested Caps / Structure deeper than one level, you should user
// gst_structure_serialize_full() instead for those cases.
//
// Free-function: g_free.
//
// The function returns the following values:
//
//   - utf8: pointer to string allocated by g_malloc(). g_free() after usage.
func (structure *Structure) ToString() string {
	var _arg0 *C.GstStructure // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(structure)))

	_cret = C.gst_structure_to_string(_arg0)
	runtime.KeepAlive(structure)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// SystemClockClass: instance of this type is always passed by reference.
type SystemClockClass struct {
	*systemClockClass
}

// systemClockClass is the struct that's finalized.
type systemClockClass struct {
	native *C.GstSystemClockClass
}

func (s *SystemClockClass) ParentClass() *ClockClass {
	valptr := &s.native.parent_class
	var _v *ClockClass // out
	_v = (*ClockClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// TagList: list of tags and values used to describe media metadata.
//
// Strings in structures must be ASCII or UTF-8 encoded. Other encodings are not
// allowed. Strings must not be empty or NULL.
//
// An instance of this type is always passed by reference.
type TagList struct {
	*tagList
}

// tagList is the struct that's finalized.
type tagList struct {
	native *C.GstTagList
}

func marshalTagList(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &TagList{&tagList{(*C.GstTagList)(b)}}, nil
}

// NewTagListEmpty constructs a struct TagList.
func NewTagListEmpty() *TagList {
	var _cret *C.GstTagList // in

	_cret = C.gst_tag_list_new_empty()

	var _tagList *TagList // out

	_tagList = (*TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_tagList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _tagList
}

// NewTagListFromString constructs a struct TagList.
func NewTagListFromString(str string) *TagList {
	var _arg1 *C.gchar      // out
	var _cret *C.GstTagList // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_list_new_from_string(_arg1)
	runtime.KeepAlive(str)

	var _tagList *TagList // out

	if _cret != nil {
		_tagList = (*TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_tagList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _tagList
}

// MiniObject: parent type.
func (t *TagList) MiniObject() *MiniObject {
	valptr := &t.native.mini_object
	var _v *MiniObject // out
	_v = (*MiniObject)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// AddValue sets the GValue for a given tag using the specified mode.
//
// The function takes the following parameters:
//
//   - mode to use.
//   - tag: tag.
//   - value: GValue for this tag.
func (list *TagList) AddValue(mode TagMergeMode, tag string, value *coreglib.Value) {
	var _arg0 *C.GstTagList     // out
	var _arg1 C.GstTagMergeMode // out
	var _arg2 *C.gchar          // out
	var _arg3 *C.GValue         // out

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = C.GstTagMergeMode(mode)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gst_tag_list_add_value(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(mode)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(value)
}

// Copy creates a new TagList as a copy of the old taglist. The new taglist will
// have a refcount of 1, owned by the caller, and will be writable as a result.
//
// Note that this function is the semantic equivalent of a gst_tag_list_ref()
// followed by a gst_tag_list_make_writable(). If you only want to hold on to a
// reference to the data, you should use gst_tag_list_ref().
//
// When you are finished with the taglist, call gst_tag_list_unref() on it.
//
// The function returns the following values:
//
//   - tagList: new TagList.
func (taglist *TagList) Copy() *TagList {
	var _arg0 *C.GstTagList // out
	var _cret *C.GstTagList // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(taglist)))

	_cret = C.gst_tag_list_copy(_arg0)
	runtime.KeepAlive(taglist)

	var _tagList *TagList // out

	_tagList = (*TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_tagList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _tagList
}

// ForEach calls the given function for each tag inside the tag list. Note that
// if there is no tag, the function won't be called at all.
//
// The function takes the following parameters:
//
//   - fn: function to be called for each tag.
func (list *TagList) ForEach(fn TagForEachFunc) {
	var _arg0 *C.GstTagList       // out
	var _arg1 C.GstTagForeachFunc // out
	var _arg2 C.gpointer

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*[0]byte)(C._gotk4_gst1_TagForEachFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.gst_tag_list_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(fn)
}

// Boolean copies the contents for the given tag into the value, merging
// multiple values into one if multiple values are associated with the tag.
//
// The function takes the following parameters:
//
//   - tag to read out.
//
// The function returns the following values:
//
//   - value: location for the result.
//   - ok: TRUE, if a value was copied, FALSE if the tag didn't exist in the
//     given list.
func (list *TagList) Boolean(tag string) (value bool, ok bool) {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gboolean    // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_list_get_boolean(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)

	var _value bool // out
	var _ok bool    // out

	if _arg2 != 0 {
		_value = true
	}
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// BooleanIndex gets the value that is at the given index for the given tag in
// the given list.
//
// The function takes the following parameters:
//
//   - tag to read out.
//   - index: number of entry to read out.
//
// The function returns the following values:
//
//   - value: location for the result.
//   - ok: TRUE, if a value was copied, FALSE if the tag didn't exist in the
//     given list.
func (list *TagList) BooleanIndex(tag string, index uint) (value bool, ok bool) {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _arg2 C.guint       // out
	var _arg3 C.gboolean    // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(index)

	_cret = C.gst_tag_list_get_boolean_index(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(index)

	var _value bool // out
	var _ok bool    // out

	if _arg3 != 0 {
		_value = true
	}
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// DateTime copies the first datetime for the given tag in the taglist into the
// variable pointed to by value. Unref the date with gst_date_time_unref() when
// it is no longer needed.
//
// Free-function: gst_date_time_unref.
//
// The function takes the following parameters:
//
//   - tag to read out.
//
// The function returns the following values:
//
//   - value address of a DateTime pointer variable to store the result into.
//   - ok: TRUE, if a datetime was copied, FALSE if the tag didn't exist in the
//     given list or if it was NULL.
func (list *TagList) DateTime(tag string) (*DateTime, bool) {
	var _arg0 *C.GstTagList  // out
	var _arg1 *C.gchar       // out
	var _arg2 *C.GstDateTime // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_list_get_date_time(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)

	var _value *DateTime // out
	var _ok bool         // out

	_value = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_value)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_date_time_unref((*C.GstDateTime)(intern.C))
		},
	)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// DateTimeIndex gets the datetime that is at the given index for the given
// tag in the given list and copies it into the variable pointed to by value.
// Unref the datetime with gst_date_time_unref() when it is no longer needed.
//
// Free-function: gst_date_time_unref.
//
// The function takes the following parameters:
//
//   - tag to read out.
//   - index: number of entry to read out.
//
// The function returns the following values:
//
//   - value: location for the result.
//   - ok: TRUE, if a value was copied, FALSE if the tag didn't exist in the
//     given list or if it was NULL.
func (list *TagList) DateTimeIndex(tag string, index uint) (*DateTime, bool) {
	var _arg0 *C.GstTagList  // out
	var _arg1 *C.gchar       // out
	var _arg2 C.guint        // out
	var _arg3 *C.GstDateTime // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(index)

	_cret = C.gst_tag_list_get_date_time_index(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(index)

	var _value *DateTime // out
	var _ok bool         // out

	_value = (*DateTime)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_value)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_date_time_unref((*C.GstDateTime)(intern.C))
		},
	)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Double copies the contents for the given tag into the value, merging multiple
// values into one if multiple values are associated with the tag.
//
// The function takes the following parameters:
//
//   - tag to read out.
//
// The function returns the following values:
//
//   - value: location for the result.
//   - ok: TRUE, if a value was copied, FALSE if the tag didn't exist in the
//     given list.
func (list *TagList) Double(tag string) (float64, bool) {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gdouble     // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_list_get_double(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)

	var _value float64 // out
	var _ok bool       // out

	_value = float64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// DoubleIndex gets the value that is at the given index for the given tag in
// the given list.
//
// The function takes the following parameters:
//
//   - tag to read out.
//   - index: number of entry to read out.
//
// The function returns the following values:
//
//   - value: location for the result.
//   - ok: TRUE, if a value was copied, FALSE if the tag didn't exist in the
//     given list.
func (list *TagList) DoubleIndex(tag string, index uint) (float64, bool) {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _arg2 C.guint       // out
	var _arg3 C.gdouble     // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(index)

	_cret = C.gst_tag_list_get_double_index(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(index)

	var _value float64 // out
	var _ok bool       // out

	_value = float64(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Float copies the contents for the given tag into the value, merging multiple
// values into one if multiple values are associated with the tag.
//
// The function takes the following parameters:
//
//   - tag to read out.
//
// The function returns the following values:
//
//   - value: location for the result.
//   - ok: TRUE, if a value was copied, FALSE if the tag didn't exist in the
//     given list.
func (list *TagList) Float(tag string) (float32, bool) {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gfloat      // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_list_get_float(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)

	var _value float32 // out
	var _ok bool       // out

	_value = float32(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// FloatIndex gets the value that is at the given index for the given tag in the
// given list.
//
// The function takes the following parameters:
//
//   - tag to read out.
//   - index: number of entry to read out.
//
// The function returns the following values:
//
//   - value: location for the result.
//   - ok: TRUE, if a value was copied, FALSE if the tag didn't exist in the
//     given list.
func (list *TagList) FloatIndex(tag string, index uint) (float32, bool) {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _arg2 C.guint       // out
	var _arg3 C.gfloat      // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(index)

	_cret = C.gst_tag_list_get_float_index(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(index)

	var _value float32 // out
	var _ok bool       // out

	_value = float32(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Int copies the contents for the given tag into the value, merging multiple
// values into one if multiple values are associated with the tag.
//
// The function takes the following parameters:
//
//   - tag to read out.
//
// The function returns the following values:
//
//   - value: location for the result.
//   - ok: TRUE, if a value was copied, FALSE if the tag didn't exist in the
//     given list.
func (list *TagList) Int(tag string) (int, bool) {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gint        // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_list_get_int(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)

	var _value int // out
	var _ok bool   // out

	_value = int(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Int64 copies the contents for the given tag into the value, merging multiple
// values into one if multiple values are associated with the tag.
//
// The function takes the following parameters:
//
//   - tag to read out.
//
// The function returns the following values:
//
//   - value: location for the result.
//   - ok: TRUE, if a value was copied, FALSE if the tag didn't exist in the
//     given list.
func (list *TagList) Int64(tag string) (int64, bool) {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gint64      // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_list_get_int64(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)

	var _value int64 // out
	var _ok bool     // out

	_value = int64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Int64Index gets the value that is at the given index for the given tag in the
// given list.
//
// The function takes the following parameters:
//
//   - tag to read out.
//   - index: number of entry to read out.
//
// The function returns the following values:
//
//   - value: location for the result.
//   - ok: TRUE, if a value was copied, FALSE if the tag didn't exist in the
//     given list.
func (list *TagList) Int64Index(tag string, index uint) (int64, bool) {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _arg2 C.guint       // out
	var _arg3 C.gint64      // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(index)

	_cret = C.gst_tag_list_get_int64_index(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(index)

	var _value int64 // out
	var _ok bool     // out

	_value = int64(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// IntIndex gets the value that is at the given index for the given tag in the
// given list.
//
// The function takes the following parameters:
//
//   - tag to read out.
//   - index: number of entry to read out.
//
// The function returns the following values:
//
//   - value: location for the result.
//   - ok: TRUE, if a value was copied, FALSE if the tag didn't exist in the
//     given list.
func (list *TagList) IntIndex(tag string, index uint) (int, bool) {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _arg2 C.guint       // out
	var _arg3 C.gint        // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(index)

	_cret = C.gst_tag_list_get_int_index(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(index)

	var _value int // out
	var _ok bool   // out

	_value = int(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Pointer copies the contents for the given tag into the value, merging
// multiple values into one if multiple values are associated with the tag.
//
// The function takes the following parameters:
//
//   - tag to read out.
//
// The function returns the following values:
//
//   - value (optional): location for the result.
//   - ok: TRUE, if a value was copied, FALSE if the tag didn't exist in the
//     given list.
func (list *TagList) Pointer(tag string) (unsafe.Pointer, bool) {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gpointer    // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_list_get_pointer(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)

	var _value unsafe.Pointer // out
	var _ok bool              // out

	_value = (unsafe.Pointer)(unsafe.Pointer(_arg2))
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// PointerIndex gets the value that is at the given index for the given tag in
// the given list.
//
// The function takes the following parameters:
//
//   - tag to read out.
//   - index: number of entry to read out.
//
// The function returns the following values:
//
//   - value (optional): location for the result.
//   - ok: TRUE, if a value was copied, FALSE if the tag didn't exist in the
//     given list.
func (list *TagList) PointerIndex(tag string, index uint) (unsafe.Pointer, bool) {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _arg2 C.guint       // out
	var _arg3 C.gpointer    // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(index)

	_cret = C.gst_tag_list_get_pointer_index(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(index)

	var _value unsafe.Pointer // out
	var _ok bool              // out

	_value = (unsafe.Pointer)(unsafe.Pointer(_arg3))
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Sample copies the first sample for the given tag in the taglist into the
// variable pointed to by sample. Free the sample with gst_sample_unref()
// when it is no longer needed. You can retrieve the buffer from the sample
// using gst_sample_get_buffer() and the associated caps (if any) with
// gst_sample_get_caps().
//
// Free-function: gst_sample_unref.
//
// The function takes the following parameters:
//
//   - tag to read out.
//
// The function returns the following values:
//
//   - sample address of a GstSample pointer variable to store the result into.
//   - ok: TRUE, if a sample was returned, FALSE if the tag didn't exist in the
//     given list or if it was NULL.
func (list *TagList) Sample(tag string) (*Sample, bool) {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GstSample  // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_list_get_sample(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)

	var _sample *Sample // out
	var _ok bool        // out

	_sample = (*Sample)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_sample)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	if _cret != 0 {
		_ok = true
	}

	return _sample, _ok
}

// SampleIndex gets the sample that is at the given index for the given tag in
// the given list and copies it into the variable pointed to by sample. Free the
// sample with gst_sample_unref() when it is no longer needed. You can retrieve
// the buffer from the sample using gst_sample_get_buffer() and the associated
// caps (if any) with gst_sample_get_caps().
//
// Free-function: gst_sample_unref.
//
// The function takes the following parameters:
//
//   - tag to read out.
//   - index: number of entry to read out.
//
// The function returns the following values:
//
//   - sample address of a GstSample pointer variable to store the result into.
//   - ok: TRUE, if a sample was copied, FALSE if the tag didn't exist in the
//     given list or if it was NULL.
func (list *TagList) SampleIndex(tag string, index uint) (*Sample, bool) {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _arg2 C.guint       // out
	var _arg3 *C.GstSample  // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(index)

	_cret = C.gst_tag_list_get_sample_index(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(index)

	var _sample *Sample // out
	var _ok bool        // out

	_sample = (*Sample)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_sample)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	if _cret != 0 {
		_ok = true
	}

	return _sample, _ok
}

// Scope gets the scope of list.
//
// The function returns the following values:
//
//   - tagScope: scope of list.
func (list *TagList) Scope() TagScope {
	var _arg0 *C.GstTagList // out
	var _cret C.GstTagScope // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))

	_cret = C.gst_tag_list_get_scope(_arg0)
	runtime.KeepAlive(list)

	var _tagScope TagScope // out

	_tagScope = TagScope(_cret)

	return _tagScope
}

// String copies the contents for the given tag into the value, possibly merging
// multiple values into one if multiple values are associated with the tag.
//
// Use gst_tag_list_get_string_index (list, tag, 0, value) if you want to
// retrieve the first string associated with this tag unmodified.
//
// The resulting string in value will be in UTF-8 encoding and should be freed
// by the caller using g_free when no longer needed. The returned string is also
// guaranteed to be non-NULL and non-empty.
//
// Free-function: g_free.
//
// The function takes the following parameters:
//
//   - tag to read out.
//
// The function returns the following values:
//
//   - value: location for the result.
//   - ok: TRUE, if a value was copied, FALSE if the tag didn't exist in the
//     given list.
func (list *TagList) String(tag string) (string, bool) {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.gchar      // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_list_get_string(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)

	var _value string // out
	var _ok bool      // out

	_value = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
	defer C.free(unsafe.Pointer(_arg2))
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// StringIndex gets the value that is at the given index for the given tag in
// the given list.
//
// The resulting string in value will be in UTF-8 encoding and should be freed
// by the caller using g_free when no longer needed. The returned string is also
// guaranteed to be non-NULL and non-empty.
//
// Free-function: g_free.
//
// The function takes the following parameters:
//
//   - tag to read out.
//   - index: number of entry to read out.
//
// The function returns the following values:
//
//   - value: location for the result.
//   - ok: TRUE, if a value was copied, FALSE if the tag didn't exist in the
//     given list.
func (list *TagList) StringIndex(tag string, index uint) (string, bool) {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _arg2 C.guint       // out
	var _arg3 *C.gchar      // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(index)

	_cret = C.gst_tag_list_get_string_index(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(index)

	var _value string // out
	var _ok bool      // out

	_value = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
	defer C.free(unsafe.Pointer(_arg3))
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// TagSize checks how many value are stored in this tag list for the given tag.
//
// The function takes the following parameters:
//
//   - tag to query.
//
// The function returns the following values:
//
//   - guint: number of tags stored.
func (list *TagList) TagSize(tag string) uint {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _cret C.guint       // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_list_get_tag_size(_arg0, _arg1)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Uint copies the contents for the given tag into the value, merging multiple
// values into one if multiple values are associated with the tag.
//
// The function takes the following parameters:
//
//   - tag to read out.
//
// The function returns the following values:
//
//   - value: location for the result.
//   - ok: TRUE, if a value was copied, FALSE if the tag didn't exist in the
//     given list.
func (list *TagList) Uint(tag string) (uint, bool) {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _arg2 C.guint       // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_list_get_uint(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)

	var _value uint // out
	var _ok bool    // out

	_value = uint(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Uint64 copies the contents for the given tag into the value, merging multiple
// values into one if multiple values are associated with the tag.
//
// The function takes the following parameters:
//
//   - tag to read out.
//
// The function returns the following values:
//
//   - value: location for the result.
//   - ok: TRUE, if a value was copied, FALSE if the tag didn't exist in the
//     given list.
func (list *TagList) Uint64(tag string) (uint64, bool) {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _arg2 C.guint64     // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_list_get_uint64(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)

	var _value uint64 // out
	var _ok bool      // out

	_value = uint64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Uint64Index gets the value that is at the given index for the given tag in
// the given list.
//
// The function takes the following parameters:
//
//   - tag to read out.
//   - index: number of entry to read out.
//
// The function returns the following values:
//
//   - value: location for the result.
//   - ok: TRUE, if a value was copied, FALSE if the tag didn't exist in the
//     given list.
func (list *TagList) Uint64Index(tag string, index uint) (uint64, bool) {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _arg2 C.guint       // out
	var _arg3 C.guint64     // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(index)

	_cret = C.gst_tag_list_get_uint64_index(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(index)

	var _value uint64 // out
	var _ok bool      // out

	_value = uint64(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// UintIndex gets the value that is at the given index for the given tag in the
// given list.
//
// The function takes the following parameters:
//
//   - tag to read out.
//   - index: number of entry to read out.
//
// The function returns the following values:
//
//   - value: location for the result.
//   - ok: TRUE, if a value was copied, FALSE if the tag didn't exist in the
//     given list.
func (list *TagList) UintIndex(tag string, index uint) (uint, bool) {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _arg2 C.guint       // out
	var _arg3 C.guint       // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(index)

	_cret = C.gst_tag_list_get_uint_index(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(index)

	var _value uint // out
	var _ok bool    // out

	_value = uint(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// ValueIndex gets the value that is at the given index for the given tag in the
// given list.
//
// The function takes the following parameters:
//
//   - tag to read out.
//   - index: number of entry to read out.
//
// The function returns the following values:
//
//   - value (optional): GValue for the specified entry or NULL if the tag
//     wasn't available or the tag doesn't have as many entries.
func (list *TagList) ValueIndex(tag string, index uint) *coreglib.Value {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _arg2 C.guint       // out
	var _cret *C.GValue     // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(index)

	_cret = C.gst_tag_list_get_value_index(_arg0, _arg1, _arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(index)

	var _value *coreglib.Value // out

	if _cret != nil {
		_value = coreglib.ValueFromNative(unsafe.Pointer(_cret))
	}

	return _value
}

// Insert inserts the tags of the from list into the first list using the given
// mode.
//
// The function takes the following parameters:
//
//   - from: list to merge from.
//   - mode to use.
func (into *TagList) Insert(from *TagList, mode TagMergeMode) {
	var _arg0 *C.GstTagList     // out
	var _arg1 *C.GstTagList     // out
	var _arg2 C.GstTagMergeMode // out

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(into)))
	_arg1 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(from)))
	_arg2 = C.GstTagMergeMode(mode)

	C.gst_tag_list_insert(_arg0, _arg1, _arg2)
	runtime.KeepAlive(into)
	runtime.KeepAlive(from)
	runtime.KeepAlive(mode)
}

// IsEmpty checks if the given taglist is empty.
//
// The function returns the following values:
//
//   - ok: TRUE if the taglist is empty, otherwise FALSE.
func (list *TagList) IsEmpty() bool {
	var _arg0 *C.GstTagList // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))

	_cret = C.gst_tag_list_is_empty(_arg0)
	runtime.KeepAlive(list)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEqual checks if the two given taglists are equal.
//
// The function takes the following parameters:
//
//   - list2: TagList.
//
// The function returns the following values:
//
//   - ok: TRUE if the taglists are equal, otherwise FALSE.
func (list1 *TagList) IsEqual(list2 *TagList) bool {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.GstTagList // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list1)))
	_arg1 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list2)))

	_cret = C.gst_tag_list_is_equal(_arg0, _arg1)
	runtime.KeepAlive(list1)
	runtime.KeepAlive(list2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Merge merges the two given lists into a new list. If one of the lists is
// NULL, a copy of the other is returned. If both lists are NULL, NULL is
// returned.
//
// Free-function: gst_tag_list_unref.
//
// The function takes the following parameters:
//
//   - list2 (optional): second list to merge.
//   - mode to use.
//
// The function returns the following values:
//
//   - tagList (optional): new list.
func (list1 *TagList) Merge(list2 *TagList, mode TagMergeMode) *TagList {
	var _arg0 *C.GstTagList     // out
	var _arg1 *C.GstTagList     // out
	var _arg2 C.GstTagMergeMode // out
	var _cret *C.GstTagList     // in

	if list1 != nil {
		_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list1)))
	}
	if list2 != nil {
		_arg1 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list2)))
	}
	_arg2 = C.GstTagMergeMode(mode)

	_cret = C.gst_tag_list_merge(_arg0, _arg1, _arg2)
	runtime.KeepAlive(list1)
	runtime.KeepAlive(list2)
	runtime.KeepAlive(mode)

	var _tagList *TagList // out

	if _cret != nil {
		_tagList = (*TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_tagList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _tagList
}

// NTags: get the number of tags in list.
//
// The function returns the following values:
//
//   - gint: number of tags in list.
func (list *TagList) NTags() int {
	var _arg0 *C.GstTagList // out
	var _cret C.gint        // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))

	_cret = C.gst_tag_list_n_tags(_arg0)
	runtime.KeepAlive(list)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NthTagName: get the name of the tag in list at index.
//
// The function takes the following parameters:
//
//   - index: index.
//
// The function returns the following values:
//
//   - utf8: name of the tag at index.
func (list *TagList) NthTagName(index uint) string {
	var _arg0 *C.GstTagList // out
	var _arg1 C.guint       // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = C.guint(index)

	_cret = C.gst_tag_list_nth_tag_name(_arg0, _arg1)
	runtime.KeepAlive(list)
	runtime.KeepAlive(index)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// PeekStringIndex peeks at the value that is at the given index for the given
// tag in the given list.
//
// The resulting string in value will be in UTF-8 encoding and doesn't need to
// be freed by the caller. The returned string is also guaranteed to be non-NULL
// and non-empty.
//
// The function takes the following parameters:
//
//   - tag to read out.
//   - index: number of entry to read out.
//
// The function returns the following values:
//
//   - value: location for the result.
//   - ok: TRUE, if a value was set, FALSE if the tag didn't exist in the given
//     list.
func (list *TagList) PeekStringIndex(tag string, index uint) (string, bool) {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out
	var _arg2 C.guint       // out
	var _arg3 *C.gchar      // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(index)

	_cret = C.gst_tag_list_peek_string_index(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(index)

	var _value string // out
	var _ok bool      // out

	_value = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// RemoveTag removes the given tag from the taglist.
//
// The function takes the following parameters:
//
//   - tag to remove.
func (list *TagList) RemoveTag(tag string) {
	var _arg0 *C.GstTagList // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_tag_list_remove_tag(_arg0, _arg1)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)
}

// SetScope sets the scope of list to scope. By default the scope of a taglist
// is stream scope.
//
// The function takes the following parameters:
//
//   - scope: new scope for list.
func (list *TagList) SetScope(scope TagScope) {
	var _arg0 *C.GstTagList // out
	var _arg1 C.GstTagScope // out

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg1 = C.GstTagScope(scope)

	C.gst_tag_list_set_scope(_arg0, _arg1)
	runtime.KeepAlive(list)
	runtime.KeepAlive(scope)
}

// ToString serializes a tag list to a string.
//
// The function returns the following values:
//
//   - utf8: newly-allocated string. The string must be freed with g_free() when
//     no longer needed.
func (list *TagList) ToString() string {
	var _arg0 *C.GstTagList // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))

	_cret = C.gst_tag_list_to_string(_arg0)
	runtime.KeepAlive(list)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// TagListCopyValue copies the contents for the given tag into the value,
// merging multiple values into one if multiple values are associated with the
// tag. You must g_value_unset() the value after use.
//
// The function takes the following parameters:
//
//   - list to get the tag from.
//   - tag to read out.
//
// The function returns the following values:
//
//   - dest: uninitialized #GValue to copy into.
//   - ok: TRUE, if a value was copied, FALSE if the tag didn't exist in the
//     given list.
func TagListCopyValue(list *TagList, tag string) (coreglib.Value, bool) {
	var _arg1 C.GValue      // in
	var _arg2 *C.GstTagList // out
	var _arg3 *C.gchar      // out
	var _cret C.gboolean    // in

	_arg2 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gst_tag_list_copy_value(&_arg1, _arg2, _arg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)

	var _dest coreglib.Value // out
	var _ok bool             // out

	_dest = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))
	if _cret != 0 {
		_ok = true
	}

	return _dest, _ok
}

// TagSetterInterface interface.
//
// An instance of this type is always passed by reference.
type TagSetterInterface struct {
	*tagSetterInterface
}

// tagSetterInterface is the struct that's finalized.
type tagSetterInterface struct {
	native *C.GstTagSetterInterface
}

// TaskClass: instance of this type is always passed by reference.
type TaskClass struct {
	*taskClass
}

// taskClass is the struct that's finalized.
type taskClass struct {
	native *C.GstTaskClass
}

func (t *TaskClass) ParentClass() *ObjectClass {
	valptr := &t.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// TimedValue: structure for storing a timestamp and a value.
//
// An instance of this type is always passed by reference.
type TimedValue struct {
	*timedValue
}

// timedValue is the struct that's finalized.
type timedValue struct {
	native *C.GstTimedValue
}

// Timestamp: timestamp of the value change.
func (t *TimedValue) Timestamp() ClockTime {
	valptr := &t.native.timestamp
	var _v ClockTime // out
	_v = ClockTime(*valptr)
	return _v
}

// Value: corresponding value.
func (t *TimedValue) Value() float64 {
	valptr := &t.native.value
	var _v float64 // out
	_v = float64(*valptr)
	return _v
}

// Value: corresponding value.
func (t *TimedValue) SetValue(value float64) {
	valptr := &t.native.value
	*valptr = C.gdouble(value)
}

// Toc functions are used to create/free Toc and TocEntry structures. Also they
// are used to convert Toc into Structure and vice versa.
//
// Toc lets you to inform other elements in pipeline or application that playing
// source has some kind of table of contents (TOC). These may be chapters,
// editions, angles or other types. For example: DVD chapters, Matroska chapters
// or cue sheet TOC. Such TOC will be useful for applications to display instead
// of just a playlist.
//
// Using TOC is very easy. Firstly, create Toc structure which represents
// root contents of the source. You can also attach TOC-specific tags to it.
// Then fill it with TocEntry entries by appending them to the Toc using
// gst_toc_append_entry(), and appending subentries to a TocEntry using
// gst_toc_entry_append_sub_entry().
//
// Note that root level of the TOC can contain only either editions or chapters.
// You should not mix them together at the same level. Otherwise you will get
// serialization /deserialization errors. Make sure that no one of the entries
// has negative start and stop values.
//
// Use gst_event_new_toc() to create a new TOC Event, and gst_event_parse_toc()
// to parse received TOC event. Use gst_event_new_toc_select() to create a new
// TOC select Event, and gst_event_parse_toc_select() to parse received TOC
// select event. The same rule for the Message: gst_message_new_toc() to create
// new TOC Message, and gst_message_parse_toc() to parse received TOC message.
//
// TOCs can have global scope or current scope. Global scope TOCs contain all
// entries that can possibly be selected using a toc select event, and are what
// an application is usually interested in. TOCs with current scope only contain
// the parts of the TOC relevant to the currently selected/playing stream;
// the current scope TOC is used by downstream elements such as muxers to write
// correct TOC entries when transcoding files, for example. When playing a DVD,
// the global TOC would contain a hierarchy of all titles, chapters and angles,
// for example, while the current TOC would only contain the chapters for the
// currently playing title if playback of a specific title was requested.
//
// Applications and plugins should not rely on TOCs having a certain kind
// of structure, but should allow for different alternatives. For example,
// a simple CUE sheet embedded in a file may be presented as a flat list
// of track entries, or could have a top-level edition node (or some other
// alternative type entry) with track entries underneath that node; or even
// multiple top-level edition nodes (or some other alternative type entries)
// each with track entries underneath, in case the source file has extracted a
// track listing from different sources).
//
// An instance of this type is always passed by reference.
type Toc struct {
	*toc
}

// toc is the struct that's finalized.
type toc struct {
	native *C.GstToc
}

func marshalToc(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Toc{&toc{(*C.GstToc)(b)}}, nil
}

// NewToc constructs a struct Toc.
func NewToc(scope TocScope) *Toc {
	var _arg1 C.GstTocScope // out
	var _cret *C.GstToc     // in

	_arg1 = C.GstTocScope(scope)

	_cret = C.gst_toc_new(_arg1)
	runtime.KeepAlive(scope)

	var _toc *Toc // out

	_toc = (*Toc)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_toc)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _toc
}

// AppendEntry appends the TocEntry entry to toc.
//
// The function takes the following parameters:
//
//   - entry: TocEntry.
func (toc *Toc) AppendEntry(entry *TocEntry) {
	var _arg0 *C.GstToc      // out
	var _arg1 *C.GstTocEntry // out

	_arg0 = (*C.GstToc)(gextras.StructNative(unsafe.Pointer(toc)))
	_arg1 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(entry)), nil)

	C.gst_toc_append_entry(_arg0, _arg1)
	runtime.KeepAlive(toc)
	runtime.KeepAlive(entry)
}

func (toc *Toc) Dump() {
	var _arg0 *C.GstToc // out

	_arg0 = (*C.GstToc)(gextras.StructNative(unsafe.Pointer(toc)))

	C.gst_toc_dump(_arg0)
	runtime.KeepAlive(toc)
}

// FindEntry: find TocEntry with given uid in the toc.
//
// The function takes the following parameters:
//
//   - uid: UID to find TocEntry with.
//
// The function returns the following values:
//
//   - tocEntry (optional) with specified uid from the toc, or NULL if not
//     found.
func (toc *Toc) FindEntry(uid string) *TocEntry {
	var _arg0 *C.GstToc      // out
	var _arg1 *C.gchar       // out
	var _cret *C.GstTocEntry // in

	_arg0 = (*C.GstToc)(gextras.StructNative(unsafe.Pointer(toc)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uid)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_toc_find_entry(_arg0, _arg1)
	runtime.KeepAlive(toc)
	runtime.KeepAlive(uid)

	var _tocEntry *TocEntry // out

	if _cret != nil {
		_tocEntry = (*TocEntry)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _tocEntry
}

// Entries gets the list of TocEntry of toc.
//
// The function returns the following values:
//
//   - list of TocEntry for entry.
func (toc *Toc) Entries() []*TocEntry {
	var _arg0 *C.GstToc // out
	var _cret *C.GList  // in

	_arg0 = (*C.GstToc)(gextras.StructNative(unsafe.Pointer(toc)))

	_cret = C.gst_toc_get_entries(_arg0)
	runtime.KeepAlive(toc)

	var _list []*TocEntry // out

	_list = make([]*TocEntry, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstTocEntry)(v)
		var dst *TocEntry // out
		dst = (*TocEntry)(gextras.NewStructNative(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// The function returns the following values:
//
//   - tocScope: scope of toc.
func (toc *Toc) Scope() TocScope {
	var _arg0 *C.GstToc     // out
	var _cret C.GstTocScope // in

	_arg0 = (*C.GstToc)(gextras.StructNative(unsafe.Pointer(toc)))

	_cret = C.gst_toc_get_scope(_arg0)
	runtime.KeepAlive(toc)

	var _tocScope TocScope // out

	_tocScope = TocScope(_cret)

	return _tocScope
}

// Tags gets the tags for toc.
//
// The function returns the following values:
//
//   - tagList (optional) for entry.
func (toc *Toc) Tags() *TagList {
	var _arg0 *C.GstToc     // out
	var _cret *C.GstTagList // in

	_arg0 = (*C.GstToc)(gextras.StructNative(unsafe.Pointer(toc)))

	_cret = C.gst_toc_get_tags(_arg0)
	runtime.KeepAlive(toc)

	var _tagList *TagList // out

	if _cret != nil {
		_tagList = (*TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _tagList
}

// MergeTags: merge tags into the existing tags of toc using mode.
//
// The function takes the following parameters:
//
//   - tags (optional) or NULL.
//   - mode: TagMergeMode.
func (toc *Toc) MergeTags(tags *TagList, mode TagMergeMode) {
	var _arg0 *C.GstToc         // out
	var _arg1 *C.GstTagList     // out
	var _arg2 C.GstTagMergeMode // out

	_arg0 = (*C.GstToc)(gextras.StructNative(unsafe.Pointer(toc)))
	if tags != nil {
		_arg1 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(tags)))
	}
	_arg2 = C.GstTagMergeMode(mode)

	C.gst_toc_merge_tags(_arg0, _arg1, _arg2)
	runtime.KeepAlive(toc)
	runtime.KeepAlive(tags)
	runtime.KeepAlive(mode)
}

// SetTags: set a TagList with tags for the complete toc.
//
// The function takes the following parameters:
//
//   - tags (optional) or NULL.
func (toc *Toc) SetTags(tags *TagList) {
	var _arg0 *C.GstToc     // out
	var _arg1 *C.GstTagList // out

	_arg0 = (*C.GstToc)(gextras.StructNative(unsafe.Pointer(toc)))
	if tags != nil {
		_arg1 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(tags)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(tags)), nil)
	}

	C.gst_toc_set_tags(_arg0, _arg1)
	runtime.KeepAlive(toc)
	runtime.KeepAlive(tags)
}

// TocEntry: instance of this type is always passed by reference.
type TocEntry struct {
	*tocEntry
}

// tocEntry is the struct that's finalized.
type tocEntry struct {
	native *C.GstTocEntry
}

func marshalTocEntry(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &TocEntry{&tocEntry{(*C.GstTocEntry)(b)}}, nil
}

// NewTocEntry constructs a struct TocEntry.
func NewTocEntry(typ TocEntryType, uid string) *TocEntry {
	var _arg1 C.GstTocEntryType // out
	var _arg2 *C.gchar          // out
	var _cret *C.GstTocEntry    // in

	_arg1 = C.GstTocEntryType(typ)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(uid)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_toc_entry_new(_arg1, _arg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(uid)

	var _tocEntry *TocEntry // out

	_tocEntry = (*TocEntry)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_tocEntry)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _tocEntry
}

// AppendSubEntry appends the TocEntry subentry to entry.
//
// The function takes the following parameters:
//
//   - subentry: TocEntry.
func (entry *TocEntry) AppendSubEntry(subentry *TocEntry) {
	var _arg0 *C.GstTocEntry // out
	var _arg1 *C.GstTocEntry // out

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))
	_arg1 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(subentry)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(subentry)), nil)

	C.gst_toc_entry_append_sub_entry(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(subentry)
}

// The function returns the following values:
//
//   - tocEntryType entry's entry type.
func (entry *TocEntry) EntryType() TocEntryType {
	var _arg0 *C.GstTocEntry    // out
	var _cret C.GstTocEntryType // in

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C.gst_toc_entry_get_entry_type(_arg0)
	runtime.KeepAlive(entry)

	var _tocEntryType TocEntryType // out

	_tocEntryType = TocEntryType(_cret)

	return _tocEntryType
}

// Loop: get loop_type and repeat_count values from the entry and write them
// into appropriate storages. Loops are e.g. used by sampled instruments.
// GStreamer is not automatically applying the loop. The application can process
// this meta data and use it e.g. to send a seek-event to loop a section.
//
// The function returns the following values:
//
//   - loopType (optional): storage for the loop_type value, leave NULL if not
//     need.
//   - repeatCount (optional): storage for the repeat_count value, leave NULL if
//     not need.
//   - ok: TRUE if all non-NULL storage pointers were filled with appropriate
//     values, FALSE otherwise.
func (entry *TocEntry) Loop() (TocLoopType, int, bool) {
	var _arg0 *C.GstTocEntry   // out
	var _arg1 C.GstTocLoopType // in
	var _arg2 C.gint           // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C.gst_toc_entry_get_loop(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(entry)

	var _loopType TocLoopType // out
	var _repeatCount int      // out
	var _ok bool              // out

	_loopType = TocLoopType(_arg1)
	_repeatCount = int(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _loopType, _repeatCount, _ok
}

// Parent gets the parent TocEntry of entry.
//
// The function returns the following values:
//
//   - tocEntry (optional): parent TocEntry of entry.
func (entry *TocEntry) Parent() *TocEntry {
	var _arg0 *C.GstTocEntry // out
	var _cret *C.GstTocEntry // in

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C.gst_toc_entry_get_parent(_arg0)
	runtime.KeepAlive(entry)

	var _tocEntry *TocEntry // out

	if _cret != nil {
		_tocEntry = (*TocEntry)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _tocEntry
}

// StartStopTimes: get start and stop values from the entry and write them into
// appropriate storages.
//
// The function returns the following values:
//
//   - start (optional): storage for the start value, leave NULL if not need.
//   - stop (optional): storage for the stop value, leave NULL if not need.
//   - ok: TRUE if all non-NULL storage pointers were filled with appropriate
//     values, FALSE otherwise.
func (entry *TocEntry) StartStopTimes() (start int64, stop int64, ok bool) {
	var _arg0 *C.GstTocEntry // out
	var _arg1 C.gint64       // in
	var _arg2 C.gint64       // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C.gst_toc_entry_get_start_stop_times(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(entry)

	var _start int64 // out
	var _stop int64  // out
	var _ok bool     // out

	_start = int64(_arg1)
	_stop = int64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _start, _stop, _ok
}

// SubEntries gets the sub-entries of entry.
//
// The function returns the following values:
//
//   - list of TocEntry of entry.
func (entry *TocEntry) SubEntries() []*TocEntry {
	var _arg0 *C.GstTocEntry // out
	var _cret *C.GList       // in

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C.gst_toc_entry_get_sub_entries(_arg0)
	runtime.KeepAlive(entry)

	var _list []*TocEntry // out

	_list = make([]*TocEntry, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstTocEntry)(v)
		var dst *TocEntry // out
		dst = (*TocEntry)(gextras.NewStructNative(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// Tags gets the tags for entry.
//
// The function returns the following values:
//
//   - tagList (optional) for entry.
func (entry *TocEntry) Tags() *TagList {
	var _arg0 *C.GstTocEntry // out
	var _cret *C.GstTagList  // in

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C.gst_toc_entry_get_tags(_arg0)
	runtime.KeepAlive(entry)

	var _tagList *TagList // out

	if _cret != nil {
		_tagList = (*TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _tagList
}

// Toc gets the parent Toc of entry.
//
// The function returns the following values:
//
//   - toc (optional): parent Toc of entry.
func (entry *TocEntry) Toc() *Toc {
	var _arg0 *C.GstTocEntry // out
	var _cret *C.GstToc      // in

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C.gst_toc_entry_get_toc(_arg0)
	runtime.KeepAlive(entry)

	var _toc *Toc // out

	if _cret != nil {
		_toc = (*Toc)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _toc
}

// Uid gets the UID of entry.
//
// The function returns the following values:
//
//   - utf8: UID of entry.
func (entry *TocEntry) Uid() string {
	var _arg0 *C.GstTocEntry // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C.gst_toc_entry_get_uid(_arg0)
	runtime.KeepAlive(entry)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
//   - ok: TRUE if entry's type is an alternative type, otherwise FALSE.
func (entry *TocEntry) IsAlternative() bool {
	var _arg0 *C.GstTocEntry // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C.gst_toc_entry_is_alternative(_arg0)
	runtime.KeepAlive(entry)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - ok: TRUE if entry's type is a sequence type, otherwise FALSE.
func (entry *TocEntry) IsSequence() bool {
	var _arg0 *C.GstTocEntry // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))

	_cret = C.gst_toc_entry_is_sequence(_arg0)
	runtime.KeepAlive(entry)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MergeTags: merge tags into the existing tags of entry using mode.
//
// The function takes the following parameters:
//
//   - tags (optional) or NULL.
//   - mode: TagMergeMode.
func (entry *TocEntry) MergeTags(tags *TagList, mode TagMergeMode) {
	var _arg0 *C.GstTocEntry    // out
	var _arg1 *C.GstTagList     // out
	var _arg2 C.GstTagMergeMode // out

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))
	if tags != nil {
		_arg1 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(tags)))
	}
	_arg2 = C.GstTagMergeMode(mode)

	C.gst_toc_entry_merge_tags(_arg0, _arg1, _arg2)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(tags)
	runtime.KeepAlive(mode)
}

// SetLoop: set loop_type and repeat_count values for the entry.
//
// The function takes the following parameters:
//
//   - loopType: loop_type value to set.
//   - repeatCount: repeat_count value to set.
func (entry *TocEntry) SetLoop(loopType TocLoopType, repeatCount int) {
	var _arg0 *C.GstTocEntry   // out
	var _arg1 C.GstTocLoopType // out
	var _arg2 C.gint           // out

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))
	_arg1 = C.GstTocLoopType(loopType)
	_arg2 = C.gint(repeatCount)

	C.gst_toc_entry_set_loop(_arg0, _arg1, _arg2)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(loopType)
	runtime.KeepAlive(repeatCount)
}

// SetStartStopTimes: set start and stop values for the entry.
//
// The function takes the following parameters:
//
//   - start value to set.
//   - stop value to set.
func (entry *TocEntry) SetStartStopTimes(start int64, stop int64) {
	var _arg0 *C.GstTocEntry // out
	var _arg1 C.gint64       // out
	var _arg2 C.gint64       // out

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))
	_arg1 = C.gint64(start)
	_arg2 = C.gint64(stop)

	C.gst_toc_entry_set_start_stop_times(_arg0, _arg1, _arg2)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(start)
	runtime.KeepAlive(stop)
}

// SetTags: set a TagList with tags for the complete entry.
//
// The function takes the following parameters:
//
//   - tags (optional) or NULL.
func (entry *TocEntry) SetTags(tags *TagList) {
	var _arg0 *C.GstTocEntry // out
	var _arg1 *C.GstTagList  // out

	_arg0 = (*C.GstTocEntry)(gextras.StructNative(unsafe.Pointer(entry)))
	if tags != nil {
		_arg1 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(tags)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(tags)), nil)
	}

	C.gst_toc_entry_set_tags(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(tags)
}

// TocSetterInterface interface.
//
// An instance of this type is always passed by reference.
type TocSetterInterface struct {
	*tocSetterInterface
}

// tocSetterInterface is the struct that's finalized.
type tocSetterInterface struct {
	native *C.GstTocSetterInterface
}

// TracerClass: instance of this type is always passed by reference.
type TracerClass struct {
	*tracerClass
}

// tracerClass is the struct that's finalized.
type tracerClass struct {
	native *C.GstTracerClass
}

func (t *TracerClass) ParentClass() *ObjectClass {
	valptr := &t.native.parent_class
	var _v *ObjectClass // out
	_v = (*ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// TypeFind: following functions allow you to detect the media type of an
// unknown stream.
//
// An instance of this type is always passed by reference.
type TypeFind struct {
	*typeFind
}

// typeFind is the struct that's finalized.
type typeFind struct {
	native *C.GstTypeFind
}

func marshalTypeFind(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &TypeFind{&typeFind{(*C.GstTypeFind)(b)}}, nil
}

// Data: data used by the caller of the typefinding function.
func (t *TypeFind) Data() unsafe.Pointer {
	valptr := &t.native.data
	var _v unsafe.Pointer // out
	_v = (unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

// Length: get the length of the data stream.
//
// The function returns the following values:
//
//   - guint64: length of the data stream, or 0 if it is not available.
func (find *TypeFind) Length() uint64 {
	var _arg0 *C.GstTypeFind // out
	var _cret C.guint64      // in

	_arg0 = (*C.GstTypeFind)(gextras.StructNative(unsafe.Pointer(find)))

	_cret = C.gst_type_find_get_length(_arg0)
	runtime.KeepAlive(find)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// Peek returns the size bytes of the stream to identify beginning at offset.
// If offset is a positive number, the offset is relative to the beginning of
// the stream, if offset is a negative number the offset is relative to the end
// of the stream. The returned memory is valid until the typefinding function
// returns and must not be freed.
//
// The function takes the following parameters:
//
//   - offset: offset.
//   - size: number of bytes to return.
//
// The function returns the following values:
//
//   - guint8 (optional): the requested data, or NULL if that data is not
//     available.
func (find *TypeFind) Peek(offset int64, size uint) *byte {
	var _arg0 *C.GstTypeFind // out
	var _arg1 C.gint64       // out
	var _arg2 C.guint        // out
	var _cret *C.guint8      // in

	_arg0 = (*C.GstTypeFind)(gextras.StructNative(unsafe.Pointer(find)))
	_arg1 = C.gint64(offset)
	_arg2 = C.guint(size)

	_cret = C.gst_type_find_peek(_arg0, _arg1, _arg2)
	runtime.KeepAlive(find)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _guint8 *byte // out

	if _cret != nil {
		_guint8 = (*byte)(unsafe.Pointer(_cret))
	}

	return _guint8
}

// Suggest: if a TypeFindFunction calls this function it suggests the caps with
// the given probability. A TypeFindFunction may supply different suggestions in
// one call. It is up to the caller of the TypeFindFunction to interpret these
// values.
//
// The function takes the following parameters:
//
//   - probability in percent that the suggestion is right.
//   - caps: fixed Caps to suggest.
func (find *TypeFind) Suggest(probability uint, caps *Caps) {
	var _arg0 *C.GstTypeFind // out
	var _arg1 C.guint        // out
	var _arg2 *C.GstCaps     // out

	_arg0 = (*C.GstTypeFind)(gextras.StructNative(unsafe.Pointer(find)))
	_arg1 = C.guint(probability)
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	C.gst_type_find_suggest(_arg0, _arg1, _arg2)
	runtime.KeepAlive(find)
	runtime.KeepAlive(probability)
	runtime.KeepAlive(caps)
}

// SuggestEmptySimple: if a TypeFindFunction calls this function it suggests
// caps of the given media_type with the given probability.
//
// This function is similar to gst_type_find_suggest_simple(), but uses a Caps
// with no fields.
//
// The function takes the following parameters:
//
//   - probability in percent that the suggestion is right.
//   - mediaType: media type of the suggested caps.
func (find *TypeFind) SuggestEmptySimple(probability uint, mediaType string) {
	var _arg0 *C.GstTypeFind // out
	var _arg1 C.guint        // out
	var _arg2 *C.char        // out

	_arg0 = (*C.GstTypeFind)(gextras.StructNative(unsafe.Pointer(find)))
	_arg1 = C.guint(probability)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(mediaType)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gst_type_find_suggest_empty_simple(_arg0, _arg1, _arg2)
	runtime.KeepAlive(find)
	runtime.KeepAlive(probability)
	runtime.KeepAlive(mediaType)
}

// TypeFindRegister registers a new typefind function to be used for
// typefinding. After registering this function will be available for
// typefinding. This function is typically called during an element's plugin
// initialization.
//
// The function takes the following parameters:
//
//   - plugin (optional) or NULL for a static typefind function.
//   - name for registering.
//   - rank (or importance) of this typefind function.
//   - fn to use.
//   - extensions (optional): optional comma-separated list of extensions that
//     could belong to this type.
//   - possibleCaps (optional): optionally the caps that could be returned when
//     typefinding succeeds.
//
// The function returns the following values:
//
//   - ok: TRUE on success, FALSE otherwise.
func TypeFindRegister(plugin *Plugin, name string, rank uint, fn TypeFindFunction, extensions string, possibleCaps *Caps) bool {
	var _arg1 *C.GstPlugin          // out
	var _arg2 *C.gchar              // out
	var _arg3 C.guint               // out
	var _arg4 C.GstTypeFindFunction // out
	var _arg7 C.gpointer
	var _arg8 C.GDestroyNotify
	var _arg5 *C.gchar   // out
	var _arg6 *C.GstCaps // out
	var _cret C.gboolean // in

	if plugin != nil {
		_arg1 = (*C.GstPlugin)(unsafe.Pointer(coreglib.InternObject(plugin).Native()))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.guint(rank)
	_arg4 = (*[0]byte)(C._gotk4_gst1_TypeFindFunction)
	_arg7 = C.gpointer(gbox.Assign(fn))
	_arg8 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	if extensions != "" {
		_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(extensions)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	if possibleCaps != nil {
		_arg6 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(possibleCaps)))
	}

	_cret = C.gst_type_find_register(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(plugin)
	runtime.KeepAlive(name)
	runtime.KeepAlive(rank)
	runtime.KeepAlive(fn)
	runtime.KeepAlive(extensions)
	runtime.KeepAlive(possibleCaps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// URIHandlerInterface: any Element using this interface should implement these
// methods.
//
// An instance of this type is always passed by reference.
type URIHandlerInterface struct {
	*uriHandlerInterface
}

// uriHandlerInterface is the struct that's finalized.
type uriHandlerInterface struct {
	native *C.GstURIHandlerInterface
}

// URI object can be used to parse and split a URI string into its constituent
// parts. Two Uri objects can be joined to make a new Uri using the algorithm
// described in RFC3986.
//
// An instance of this type is always passed by reference.
type URI struct {
	*urI
}

// urI is the struct that's finalized.
type urI struct {
	native *C.GstUri
}

func marshalURI(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &URI{&urI{(*C.GstUri)(b)}}, nil
}

// NewURI constructs a struct URI.
func NewURI(scheme string, userinfo string, host string, port uint, path string, query string, fragment string) *URI {
	var _arg1 *C.gchar  // out
	var _arg2 *C.gchar  // out
	var _arg3 *C.gchar  // out
	var _arg4 C.guint   // out
	var _arg5 *C.gchar  // out
	var _arg6 *C.gchar  // out
	var _arg7 *C.gchar  // out
	var _cret *C.GstUri // in

	if scheme != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if userinfo != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(userinfo)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if host != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	_arg4 = C.guint(port)
	if path != "" {
		_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	if query != "" {
		_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(query)))
		defer C.free(unsafe.Pointer(_arg6))
	}
	if fragment != "" {
		_arg7 = (*C.gchar)(unsafe.Pointer(C.CString(fragment)))
		defer C.free(unsafe.Pointer(_arg7))
	}

	_cret = C.gst_uri_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(userinfo)
	runtime.KeepAlive(host)
	runtime.KeepAlive(port)
	runtime.KeepAlive(path)
	runtime.KeepAlive(query)
	runtime.KeepAlive(fragment)

	var _uri *URI // out

	_uri = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_uri)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _uri
}

// AppendPath: append a path onto the end of the path in the URI. The path is
// not normalized, call #gst_uri_normalize() to normalize the path.
//
// The function takes the following parameters:
//
//   - relativePath (optional): relative path to append to the end of the
//     current path.
//
// The function returns the following values:
//
//   - ok: TRUE if the path was appended successfully.
func (uri *URI) AppendPath(relativePath string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	if relativePath != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(relativePath)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_uri_append_path(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(relativePath)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AppendPathSegment: append a single path segment onto the end of the URI path.
//
// The function takes the following parameters:
//
//   - pathSegment (optional): path segment string to append to the URI path.
//
// The function returns the following values:
//
//   - ok: TRUE if the path was appended successfully.
func (uri *URI) AppendPathSegment(pathSegment string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	if pathSegment != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(pathSegment)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_uri_append_path_segment(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(pathSegment)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Equal compares two Uri objects to see if they represent the same normalized
// URI.
//
// The function takes the following parameters:
//
//   - second: second Uri to compare.
//
// The function returns the following values:
//
//   - ok: TRUE if the normalized versions of the two URI's would be equal.
func (first *URI) Equal(second *URI) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.GstUri  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(first)))
	_arg1 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(second)))

	_cret = C.gst_uri_equal(_arg0, _arg1)
	runtime.KeepAlive(first)
	runtime.KeepAlive(second)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FromStringWithBase: like gst_uri_from_string() but also joins with a base
// URI.
//
// The function takes the following parameters:
//
//   - uri: URI string to parse.
//
// The function returns the following values:
//
//   - ret (optional): new Uri object.
func (base *URI) FromStringWithBase(uri string) *URI {
	var _arg0 *C.GstUri // out
	var _arg1 *C.gchar  // out
	var _cret *C.GstUri // in

	if base != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(base)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_from_string_with_base(_arg0, _arg1)
	runtime.KeepAlive(base)
	runtime.KeepAlive(uri)

	var _ret *URI // out

	if _cret != nil {
		_ret = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_ret)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _ret
}

// Fragment: get the fragment name from the URI or NULL if it doesn't exist.
// If uri is NULL then returns NULL.
//
// The function returns the following values:
//
//   - utf8 (optional): host name from the Uri object or NULL.
func (uri *URI) Fragment() string {
	var _arg0 *C.GstUri // out
	var _cret *C.gchar  // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_get_fragment(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Host: get the host name from the URI or NULL if it doesn't exist. If uri is
// NULL then returns NULL.
//
// The function returns the following values:
//
//   - utf8 (optional): host name from the Uri object or NULL.
func (uri *URI) Host() string {
	var _arg0 *C.GstUri // out
	var _cret *C.gchar  // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_get_host(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// MediaFragmentTable: get the media fragment table from the URI, as defined
// by "Media Fragments URI 1.0". Hash table returned by this API is a list of
// "key-value" pairs, and the each pair is generated by splitting "URI fragment"
// per "&" sub-delims, then "key" and "value" are split by "=" sub-delims.
// The "key" returned by this API may be undefined keyword by standard.
// A value may be NULL to indicate that the key should appear in the fragment
// string in the URI, but does not have a value. Free the returned Table with
// #g_hash_table_unref() when it is no longer required. Modifying this hash
// table does not affect the fragment in the URI.
//
// See more about Media Fragments URI 1.0 (W3C) at
// https://www.w3.org/TR/media-frags/.
//
// The function returns the following values:
//
//   - hashTable (optional): the fragment hash table from the URI.
func (uri *URI) MediaFragmentTable() map[string]string {
	var _arg0 *C.GstUri     // out
	var _cret *C.GHashTable // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_get_media_fragment_table(_arg0)
	runtime.KeepAlive(uri)

	var _hashTable map[string]string // out

	if _cret != nil {
		_hashTable = make(map[string]string, gextras.HashTableSize(unsafe.Pointer(_cret)))
		gextras.MoveHashTable(unsafe.Pointer(_cret), true, func(k, v unsafe.Pointer) {
			ksrc := *(**C.gchar)(k)
			vsrc := *(**C.gchar)(v)
			var kdst string // out
			var vdst string // out
			kdst = C.GoString((*C.gchar)(unsafe.Pointer(ksrc)))
			defer C.free(unsafe.Pointer(ksrc))
			vdst = C.GoString((*C.gchar)(unsafe.Pointer(vsrc)))
			defer C.free(unsafe.Pointer(vsrc))
			_hashTable[kdst] = vdst
		})
	}

	return _hashTable
}

// Path: extract the path string from the URI object.
//
// The function returns the following values:
//
//   - utf8 (optional): path from the URI. Once finished with the string should
//     be g_free()'d.
func (uri *URI) Path() string {
	var _arg0 *C.GstUri // out
	var _cret *C.gchar  // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_get_path(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// PathSegments: get a list of path segments from the URI.
//
// The function returns the following values:
//
//   - list of path segment strings or NULL if no path segments are available.
//     Free the list when no longer needed with g_list_free_full(list, g_free).
func (uri *URI) PathSegments() []string {
	var _arg0 *C.GstUri // out
	var _cret *C.GList  // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_get_path_segments(_arg0)
	runtime.KeepAlive(uri)

	var _list []string // out

	_list = make([]string, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.gchar)(v)
		var dst string // out
		dst = C.GoString((*C.gchar)(unsafe.Pointer(src)))
		defer C.free(unsafe.Pointer(src))
		_list = append(_list, dst)
	})

	return _list
}

// PathString: extract the path string from the URI object as a percent encoded
// URI path.
//
// The function returns the following values:
//
//   - utf8 (optional): path from the URI. Once finished with the string should
//     be g_free()'d.
func (uri *URI) PathString() string {
	var _arg0 *C.GstUri // out
	var _cret *C.gchar  // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_get_path_string(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// Port: get the port number from the URI or GST_URI_NO_PORT if it doesn't
// exist. If uri is NULL then returns GST_URI_NO_PORT.
//
// The function returns the following values:
//
//   - guint: port number from the Uri object or GST_URI_NO_PORT.
func (uri *URI) Port() uint {
	var _arg0 *C.GstUri // out
	var _cret C.guint   // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_get_port(_arg0)
	runtime.KeepAlive(uri)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// QueryKeys: get a list of the query keys from the URI.
//
// The function returns the following values:
//
//   - list of keys from the URI query. Free the list with g_list_free().
func (uri *URI) QueryKeys() []string {
	var _arg0 *C.GstUri // out
	var _cret *C.GList  // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_get_query_keys(_arg0)
	runtime.KeepAlive(uri)

	var _list []string // out

	_list = make([]string, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.gchar)(v)
		var dst string // out
		dst = C.GoString((*C.gchar)(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// QueryString: get a percent encoded URI query string from the uri.
//
// The function returns the following values:
//
//   - utf8 (optional): percent encoded query string. Use g_free() when no
//     longer needed.
func (uri *URI) QueryString() string {
	var _arg0 *C.GstUri // out
	var _cret *C.gchar  // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_get_query_string(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// QueryStringOrdered: get a percent encoded URI query string from the uri,
// with query parameters in the order provided by the keys list. Only parameter
// keys in the list will be added to the resulting URI string. This method can
// be used by retrieving the keys with gst_uri_get_query_keys() and then sorting
// the list, for example.
//
// The function takes the following parameters:
//
//   - keys (optional): GList containing the query argument key strings.
//
// The function returns the following values:
//
//   - utf8 (optional): percent encoded query string. Use g_free() when no
//     longer needed.
func (uri *URI) QueryStringOrdered(keys []string) string {
	var _arg0 *C.GstUri // out
	var _arg1 *C.GList  // out
	var _cret *C.gchar  // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	if keys != nil {
		for i := len(keys) - 1; i >= 0; i-- {
			src := keys[i]
			var dst *C.gchar // out
			dst = (*C.gchar)(unsafe.Pointer(C.CString(src)))
			defer C.free(unsafe.Pointer(dst))
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_list_free(_arg1)
	}

	_cret = C.gst_uri_get_query_string_ordered(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(keys)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// QueryTable: get the query table from the URI. Keys and values in the table
// are freed with g_free when they are deleted. A value may be NULL to indicate
// that the key should appear in the query string in the URI, but does not have
// a value. Free the returned Table with #g_hash_table_unref() when it is no
// longer required. Modifying this hash table will modify the query in the URI.
//
// The function returns the following values:
//
//   - hashTable (optional): query hash table from the URI.
func (uri *URI) QueryTable() map[string]string {
	var _arg0 *C.GstUri     // out
	var _cret *C.GHashTable // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_get_query_table(_arg0)
	runtime.KeepAlive(uri)

	var _hashTable map[string]string // out

	if _cret != nil {
		_hashTable = make(map[string]string, gextras.HashTableSize(unsafe.Pointer(_cret)))
		gextras.MoveHashTable(unsafe.Pointer(_cret), true, func(k, v unsafe.Pointer) {
			ksrc := *(**C.gchar)(k)
			vsrc := *(**C.gchar)(v)
			var kdst string // out
			var vdst string // out
			kdst = C.GoString((*C.gchar)(unsafe.Pointer(ksrc)))
			defer C.free(unsafe.Pointer(ksrc))
			vdst = C.GoString((*C.gchar)(unsafe.Pointer(vsrc)))
			defer C.free(unsafe.Pointer(vsrc))
			_hashTable[kdst] = vdst
		})
	}

	return _hashTable
}

// QueryValue: get the value associated with the query_key key. Will return NULL
// if the key has no value or if the key does not exist in the URI query table.
// Because NULL is returned for both missing keys and keys with no value,
// you should use gst_uri_query_has_key() to determine if a key is present in
// the URI query.
//
// The function takes the following parameters:
//
//   - queryKey: key to lookup.
//
// The function returns the following values:
//
//   - utf8 (optional): value for the given key, or NULL if not found.
func (uri *URI) QueryValue(queryKey string) string {
	var _arg0 *C.GstUri // out
	var _arg1 *C.gchar  // out
	var _cret *C.gchar  // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(queryKey)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_get_query_value(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(queryKey)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Scheme: get the scheme name from the URI or NULL if it doesn't exist.
// If uri is NULL then returns NULL.
//
// The function returns the following values:
//
//   - utf8 (optional): scheme from the Uri object or NULL.
func (uri *URI) Scheme() string {
	var _arg0 *C.GstUri // out
	var _cret *C.gchar  // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_get_scheme(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Userinfo: get the userinfo (usually in the form "username:password") from the
// URI or NULL if it doesn't exist. If uri is NULL then returns NULL.
//
// The function returns the following values:
//
//   - utf8 (optional): userinfo from the Uri object or NULL.
func (uri *URI) Userinfo() string {
	var _arg0 *C.GstUri // out
	var _cret *C.gchar  // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_get_userinfo(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// IsNormalized tests the uri to see if it is normalized. A NULL uri is
// considered to be normalized.
//
// The function returns the following values:
//
//   - ok: TRUE if the URI is normalized or is NULL.
func (uri *URI) IsNormalized() bool {
	var _arg0 *C.GstUri  // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}

	_cret = C.gst_uri_is_normalized(_arg0)
	runtime.KeepAlive(uri)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsWritable: check if it is safe to write to this Uri.
//
// Check if the refcount of uri is exactly 1, meaning that no other reference
// exists to the Uri and that the Uri is therefore writable.
//
// Modification of a Uri should only be done after verifying that it is
// writable.
//
// The function returns the following values:
//
//   - ok: TRUE if it is safe to write to the object.
func (uri *URI) IsWritable() bool {
	var _arg0 *C.GstUri  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.gst_uri_is_writable(_arg0)
	runtime.KeepAlive(uri)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Join a reference URI onto a base URI using the method from RFC 3986.
// If either URI is NULL then the other URI will be returned with the ref count
// increased.
//
// The function takes the following parameters:
//
//   - refUri (optional): reference URI to join onto the base URI.
//
// The function returns the following values:
//
//   - uri (optional) which represents the base with the reference URI joined
//     on.
func (baseUri *URI) Join(refUri *URI) *URI {
	var _arg0 *C.GstUri // out
	var _arg1 *C.GstUri // out
	var _cret *C.GstUri // in

	if baseUri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(baseUri)))
	}
	if refUri != nil {
		_arg1 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(refUri)))
	}

	_cret = C.gst_uri_join(_arg0, _arg1)
	runtime.KeepAlive(baseUri)
	runtime.KeepAlive(refUri)

	var _uri *URI // out

	if _cret != nil {
		_uri = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_uri)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _uri
}

// MakeWritable: make the Uri writable.
//
// Checks if uri is writable, and if so the original object is returned. If not,
// then a writable copy is made and returned. This gives away the reference
// to uri and returns a reference to the new Uri. If uri is NULL then NULL is
// returned.
//
// The function returns the following values:
//
//   - ret: writable version of uri.
func (uri *URI) MakeWritable() *URI {
	var _arg0 *C.GstUri // out
	var _cret *C.GstUri // in

	_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(uri)), nil)

	_cret = C.gst_uri_make_writable(_arg0)
	runtime.KeepAlive(uri)

	var _ret *URI // out

	_ret = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _ret
}

// NewWithBase: like gst_uri_new(), but joins the new URI onto a base URI.
//
// The function takes the following parameters:
//
//   - scheme (optional) for the new URI.
//   - userinfo (optional): user-info for the new URI.
//   - host (optional) name for the new URI.
//   - port number for the new URI or GST_URI_NO_PORT.
//   - path (optional) for the new URI with '/' separating path elements.
//   - query (optional) string for the new URI with '&' separating query
//     elements. Elements containing '&' characters should encode them as
//     "&percnt;26".
//   - fragment (optional) name for the new URI.
//
// The function returns the following values:
//
//   - uri: new URI joined onto base.
func (base *URI) NewWithBase(scheme string, userinfo string, host string, port uint, path string, query string, fragment string) *URI {
	var _arg0 *C.GstUri // out
	var _arg1 *C.gchar  // out
	var _arg2 *C.gchar  // out
	var _arg3 *C.gchar  // out
	var _arg4 C.guint   // out
	var _arg5 *C.gchar  // out
	var _arg6 *C.gchar  // out
	var _arg7 *C.gchar  // out
	var _cret *C.GstUri // in

	if base != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(base)))
	}
	if scheme != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if userinfo != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(userinfo)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if host != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	_arg4 = C.guint(port)
	if path != "" {
		_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	if query != "" {
		_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(query)))
		defer C.free(unsafe.Pointer(_arg6))
	}
	if fragment != "" {
		_arg7 = (*C.gchar)(unsafe.Pointer(C.CString(fragment)))
		defer C.free(unsafe.Pointer(_arg7))
	}

	_cret = C.gst_uri_new_with_base(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(base)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(userinfo)
	runtime.KeepAlive(host)
	runtime.KeepAlive(port)
	runtime.KeepAlive(path)
	runtime.KeepAlive(query)
	runtime.KeepAlive(fragment)

	var _uri *URI // out

	_uri = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_uri)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _uri
}

// Normalize: normalization will remove extra path segments ("." and "..") from
// the URI. It will also convert the scheme and host name to lower case and any
// percent-encoded values to uppercase.
//
// The Uri object must be writable. Check with gst_uri_is_writable() or use
// gst_uri_make_writable() first.
//
// The function returns the following values:
//
//   - ok: TRUE if the URI was modified.
func (uri *URI) Normalize() bool {
	var _arg0 *C.GstUri  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.gst_uri_normalize(_arg0)
	runtime.KeepAlive(uri)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QueryHasKey: check if there is a query table entry for the query_key key.
//
// The function takes the following parameters:
//
//   - queryKey: key to lookup.
//
// The function returns the following values:
//
//   - ok: TRUE if query_key exists in the URI query table.
func (uri *URI) QueryHasKey(queryKey string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(queryKey)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_query_has_key(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(queryKey)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveQueryKey: remove an entry from the query table by key.
//
// The function takes the following parameters:
//
//   - queryKey: key to remove.
//
// The function returns the following values:
//
//   - ok: TRUE if the key existed in the table and was removed.
func (uri *URI) RemoveQueryKey(queryKey string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(queryKey)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_remove_query_key(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(queryKey)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetFragment sets the fragment string in the URI. Use a value of NULL in
// fragment to unset the fragment string.
//
// The function takes the following parameters:
//
//   - fragment (optional) string to set.
//
// The function returns the following values:
//
//   - ok: TRUE if the fragment was set/unset successfully.
func (uri *URI) SetFragment(fragment string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	if fragment != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(fragment)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_uri_set_fragment(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(fragment)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetHost: set or unset the host for the URI.
//
// The function takes the following parameters:
//
//   - host: new host string to set or NULL to unset.
//
// The function returns the following values:
//
//   - ok: TRUE if the host was set/unset successfully.
func (uri *URI) SetHost(host string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_set_host(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(host)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetPath sets or unsets the path in the URI.
//
// The function takes the following parameters:
//
//   - path (optional): new path to set with path segments separated by '/',
//     or use NULL to unset the path.
//
// The function returns the following values:
//
//   - ok: TRUE if the path was set successfully.
func (uri *URI) SetPath(path string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	if path != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_uri_set_path(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetPathSegments: replace the path segments list in the URI.
//
// The function takes the following parameters:
//
//   - pathSegments (optional): new path list to set.
//
// The function returns the following values:
//
//   - ok: TRUE if the path segments were set successfully.
func (uri *URI) SetPathSegments(pathSegments []string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.GList   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	if pathSegments != nil {
		for i := len(pathSegments) - 1; i >= 0; i-- {
			src := pathSegments[i]
			var dst *C.gchar // out
			dst = (*C.gchar)(unsafe.Pointer(C.CString(src)))
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
	}

	_cret = C.gst_uri_set_path_segments(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(pathSegments)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetPathString sets or unsets the path in the URI.
//
// The function takes the following parameters:
//
//   - path: new percent encoded path to set with path segments separated by
//     '/', or use NULL to unset the path.
//
// The function returns the following values:
//
//   - ok: TRUE if the path was set successfully.
func (uri *URI) SetPathString(path string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_set_path_string(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetPort: set or unset the port number for the URI.
//
// The function takes the following parameters:
//
//   - port: new port number to set or GST_URI_NO_PORT to unset.
//
// The function returns the following values:
//
//   - ok: TRUE if the port number was set/unset successfully.
func (uri *URI) SetPort(port uint) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 C.guint    // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	_arg1 = C.guint(port)

	_cret = C.gst_uri_set_port(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(port)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetQueryString sets or unsets the query table in the URI.
//
// The function takes the following parameters:
//
//   - query (optional): new percent encoded query string to use to populate the
//     query table, or use NULL to unset the query table.
//
// The function returns the following values:
//
//   - ok: TRUE if the query table was set successfully.
func (uri *URI) SetQueryString(query string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	if query != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(query)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_uri_set_query_string(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetQueryTable: set the query table to use in the URI. The old table is
// unreferenced and a reference to the new one is used instead. A value if NULL
// for query_table will remove the query string from the URI.
//
// The function takes the following parameters:
//
//   - queryTable (optional): new query table to use.
//
// The function returns the following values:
//
//   - ok: TRUE if the new table was successfully used for the query table.
func (uri *URI) SetQueryTable(queryTable map[string]string) bool {
	var _arg0 *C.GstUri     // out
	var _arg1 *C.GHashTable // out
	var _cret C.gboolean    // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	if queryTable != nil {
		_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
		for ksrc, vsrc := range queryTable {
			var kdst *C.gchar // out
			var vdst *C.gchar // out
			kdst = (*C.gchar)(unsafe.Pointer(C.CString(ksrc)))
			defer C.free(unsafe.Pointer(kdst))
			vdst = (*C.gchar)(unsafe.Pointer(C.CString(vsrc)))
			defer C.free(unsafe.Pointer(vdst))
			C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
		}
		defer C.g_hash_table_unref(_arg1)
	}

	_cret = C.gst_uri_set_query_table(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(queryTable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetQueryValue: this inserts or replaces a key in the query table.
// A query_value of NULL indicates that the key has no associated value,
// but will still be present in the query string.
//
// The function takes the following parameters:
//
//   - queryKey: key for the query entry.
//   - queryValue (optional): value for the key.
//
// The function returns the following values:
//
//   - ok: TRUE if the query table was successfully updated.
func (uri *URI) SetQueryValue(queryKey string, queryValue string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _arg2 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(queryKey)))
	defer C.free(unsafe.Pointer(_arg1))
	if queryValue != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(queryValue)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gst_uri_set_query_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(queryKey)
	runtime.KeepAlive(queryValue)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetScheme: set or unset the scheme for the URI.
//
// The function takes the following parameters:
//
//   - scheme: new scheme to set or NULL to unset the scheme.
//
// The function returns the following values:
//
//   - ok: TRUE if the scheme was set/unset successfully.
func (uri *URI) SetScheme(scheme string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_set_scheme(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(scheme)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetUserinfo: set or unset the user information for the URI.
//
// The function takes the following parameters:
//
//   - userinfo: new user-information string to set or NULL to unset.
//
// The function returns the following values:
//
//   - ok: TRUE if the user information was set/unset successfully.
func (uri *URI) SetUserinfo(userinfo string) bool {
	var _arg0 *C.GstUri  // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(userinfo)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_set_userinfo(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(userinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// String: convert the URI to a string.
//
// Returns the URI as held in this object as a #gchar* nul-terminated string.
// The caller should g_free() the string once they are finished with it.
// The string is put together as described in RFC 3986.
//
// The function returns the following values:
//
//   - utf8: string version of the URI.
func (uri *URI) String() string {
	var _arg0 *C.GstUri // out
	var _cret *C.gchar  // in

	_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.gst_uri_to_string(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ToStringWithKeys: convert the URI to a string, with the query arguments in a
// specific order. Only the keys in the keys list will be added to the resulting
// string.
//
// Returns the URI as held in this object as a #gchar* nul-terminated string.
// The caller should g_free() the string once they are finished with it.
// The string is put together as described in RFC 3986.
//
// The function takes the following parameters:
//
//   - keys (optional): GList containing the query argument key strings.
//
// The function returns the following values:
//
//   - utf8: string version of the URI.
func (uri *URI) ToStringWithKeys(keys []string) string {
	var _arg0 *C.GstUri // out
	var _arg1 *C.GList  // out
	var _cret *C.gchar  // in

	if uri != nil {
		_arg0 = (*C.GstUri)(gextras.StructNative(unsafe.Pointer(uri)))
	}
	if keys != nil {
		for i := len(keys) - 1; i >= 0; i-- {
			src := keys[i]
			var dst *C.gchar // out
			dst = (*C.gchar)(unsafe.Pointer(C.CString(src)))
			defer C.free(unsafe.Pointer(dst))
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_list_free(_arg1)
	}

	_cret = C.gst_uri_to_string_with_keys(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(keys)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// URIConstruct constructs a URI for a given valid protocol and location.
//
// Free-function: g_free
//
// Deprecated: Use GstURI instead.
//
// The function takes the following parameters:
//
//   - protocol: protocol for URI.
//   - location: location for URI.
//
// The function returns the following values:
//
//   - utf8: new string for this URI.
func URIConstruct(protocol, location string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(location)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_uri_construct(_arg1, _arg2)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(location)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// URIFromString parses a URI string into a new Uri object. Will return NULL if
// the URI cannot be parsed.
//
// The function takes the following parameters:
//
//   - uri: URI string to parse.
//
// The function returns the following values:
//
//   - ret (optional): new Uri object, or NULL.
func URIFromString(uri string) *URI {
	var _arg1 *C.gchar  // out
	var _cret *C.GstUri // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_from_string(_arg1)
	runtime.KeepAlive(uri)

	var _ret *URI // out

	if _cret != nil {
		_ret = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_ret)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _ret
}

// URIFromStringEscaped parses a URI string into a new Uri object. Will return
// NULL if the URI cannot be parsed. This is identical to gst_uri_from_string()
// except that the userinfo and fragment components of the URI will not be
// unescaped while parsing.
//
// Use this when you need to extract a username and password from the
// userinfo such as https://user:passwordexample.com since either may contain
// a URI-escaped ':' character. gst_uri_from_string() will unescape the
// entire userinfo component, which will make it impossible to know which ':'
// delineates the username and password.
//
// The same applies to the fragment component of the URI, such as
// https://example.com/path#fragment which may contain a URI-escaped '#'.
//
// The function takes the following parameters:
//
//   - uri: URI string to parse.
//
// The function returns the following values:
//
//   - ret (optional): new Uri object, or NULL.
func URIFromStringEscaped(uri string) *URI {
	var _arg1 *C.gchar  // out
	var _cret *C.GstUri // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_from_string_escaped(_arg1)
	runtime.KeepAlive(uri)

	var _ret *URI // out

	if _cret != nil {
		_ret = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_ret)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _ret
}

// URIGetLocation extracts the location out of a given valid URI, ie. the
// protocol and "://" are stripped from the URI, which means that the location
// returned includes the hostname if one is specified. The returned string must
// be freed using g_free().
//
// Free-function: g_free.
//
// The function takes the following parameters:
//
//   - uri: URI string.
//
// The function returns the following values:
//
//   - utf8 (optional): location for this URI. Returns NULL if the URI isn't
//     valid. If the URI does not contain a location, an empty string is
//     returned.
func URIGetLocation(uri string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_get_location(_arg1)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// URIGetProtocol extracts the protocol out of a given valid URI. The returned
// string must be freed using g_free().
//
// The function takes the following parameters:
//
//   - uri: URI string.
//
// The function returns the following values:
//
//   - utf8 (optional): protocol for this URI.
func URIGetProtocol(uri string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_get_protocol(_arg1)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// URIHasProtocol checks if the protocol of a given valid URI matches protocol.
//
// The function takes the following parameters:
//
//   - uri: URI string.
//   - protocol string (e.g. "http").
//
// The function returns the following values:
//
//   - ok: TRUE if the protocol matches.
func URIHasProtocol(uri, protocol string) bool {
	var _arg1 *C.gchar   // out
	var _arg2 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_uri_has_protocol(_arg1, _arg2)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(protocol)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// URIIsValid tests if the given string is a valid URI identifier. URIs start
// with a valid scheme followed by ":" and maybe a string identifying the
// location.
//
// The function takes the following parameters:
//
//   - uri: URI string.
//
// The function returns the following values:
//
//   - ok: TRUE if the string is a valid URI.
func URIIsValid(uri string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_is_valid(_arg1)
	runtime.KeepAlive(uri)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// URIJoinStrings: this is a convenience function to join two URI strings and
// return the result. The returned string should be g_free()'d after use.
//
// The function takes the following parameters:
//
//   - baseUri: percent-encoded base URI.
//   - refUri: percent-encoded reference URI to join to the base_uri.
//
// The function returns the following values:
//
//   - utf8 (optional): string representing the percent-encoded join of the two
//     URIs.
func URIJoinStrings(baseUri, refUri string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(baseUri)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(refUri)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_uri_join_strings(_arg1, _arg2)
	runtime.KeepAlive(baseUri)
	runtime.KeepAlive(refUri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// URIProtocolIsSupported checks if an element exists that supports the given
// URI protocol. Note that a positive return value does not imply that a
// subsequent call to gst_element_make_from_uri() is guaranteed to work.
//
// The function takes the following parameters:
//
//   - typ: whether to check for a source or a sink.
//   - protocol: protocol that should be checked for (e.g. "http" or "smb").
//
// The function returns the following values:
//
//   - ok: TRUE.
func URIProtocolIsSupported(typ URIType, protocol string) bool {
	var _arg1 C.GstURIType // out
	var _arg2 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg1 = C.GstURIType(typ)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_uri_protocol_is_supported(_arg1, _arg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(protocol)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// URIProtocolIsValid tests if the given string is a valid protocol identifier.
// Protocols must consist of alphanumeric characters, '+', '-' and '.' and must
// start with a alphabetic character. See RFC 3986 Section 3.1.
//
// The function takes the following parameters:
//
//   - protocol: string.
//
// The function returns the following values:
//
//   - ok: TRUE if the string is a valid protocol identifier, FALSE otherwise.
func URIProtocolIsValid(protocol string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_uri_protocol_is_valid(_arg1)
	runtime.KeepAlive(protocol)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ValueTable: VTable for the #GValue type.
//
// An instance of this type is always passed by reference.
type ValueTable struct {
	*valueTable
}

// valueTable is the struct that's finalized.
type valueTable struct {
	native *C.GstValueTable
}
