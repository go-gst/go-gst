// Code generated by girgen. DO NOT EDIT.

package gstplay

import (
	"fmt"
	"runtime"
	_ "runtime/cgo"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/go-gst/go-gst/pkg/gst"
	"github.com/go-gst/go-gst/pkg/gstvideo"
)

// #cgo pkg-config: gstreamer-play-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/play/play.h>
// extern void _gotk4_gstplay1_PlaySignalAdapter_ConnectWarning(gpointer, GError*, GstStructure*, guintptr);
// extern void _gotk4_gstplay1_PlaySignalAdapter_ConnectVolumeChanged(gpointer, gdouble, guintptr);
// extern void _gotk4_gstplay1_PlaySignalAdapter_ConnectVideoDimensionsChanged(gpointer, guint, guint, guintptr);
// extern void _gotk4_gstplay1_PlaySignalAdapter_ConnectURILoaded(gpointer, gchar*, guintptr);
// extern void _gotk4_gstplay1_PlaySignalAdapter_ConnectStateChanged(gpointer, GstPlayState, guintptr);
// extern void _gotk4_gstplay1_PlaySignalAdapter_ConnectSeekDone(gpointer, guint64, guintptr);
// extern void _gotk4_gstplay1_PlaySignalAdapter_ConnectPositionUpdated(gpointer, guint64, guintptr);
// extern void _gotk4_gstplay1_PlaySignalAdapter_ConnectMuteChanged(gpointer, gboolean, guintptr);
// extern void _gotk4_gstplay1_PlaySignalAdapter_ConnectMediaInfoUpdated(gpointer, GstPlayMediaInfo*, guintptr);
// extern void _gotk4_gstplay1_PlaySignalAdapter_ConnectError(gpointer, GError*, GstStructure*, guintptr);
// extern void _gotk4_gstplay1_PlaySignalAdapter_ConnectEndOfStream(gpointer, guintptr);
// extern void _gotk4_gstplay1_PlaySignalAdapter_ConnectDurationChanged(gpointer, guint64, guintptr);
// extern void _gotk4_gstplay1_PlaySignalAdapter_ConnectBuffering(gpointer, gint, guintptr);
import "C"

// GType values.
var (
	GTypePlayColorBalanceType          = coreglib.Type(C.gst_play_color_balance_type_get_type())
	GTypePlayError                     = coreglib.Type(C.gst_play_error_get_type())
	GTypePlayMessage                   = coreglib.Type(C.gst_play_message_get_type())
	GTypePlayState                     = coreglib.Type(C.gst_play_state_get_type())
	GTypePlayVideoRenderer             = coreglib.Type(C.gst_play_video_renderer_get_type())
	GTypePlay                          = coreglib.Type(C.gst_play_get_type())
	GTypePlayAudioInfo                 = coreglib.Type(C.gst_play_audio_info_get_type())
	GTypePlayMediaInfo                 = coreglib.Type(C.gst_play_media_info_get_type())
	GTypePlaySignalAdapter             = coreglib.Type(C.gst_play_signal_adapter_get_type())
	GTypePlayStreamInfo                = coreglib.Type(C.gst_play_stream_info_get_type())
	GTypePlaySubtitleInfo              = coreglib.Type(C.gst_play_subtitle_info_get_type())
	GTypePlayVideoInfo                 = coreglib.Type(C.gst_play_video_info_get_type())
	GTypePlayVideoOverlayVideoRenderer = coreglib.Type(C.gst_play_video_overlay_video_renderer_get_type())
	GTypePlayVisualization             = coreglib.Type(C.gst_play_visualization_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypePlayColorBalanceType, F: marshalPlayColorBalanceType},
		coreglib.TypeMarshaler{T: GTypePlayError, F: marshalPlayError},
		coreglib.TypeMarshaler{T: GTypePlayMessage, F: marshalPlayMessage},
		coreglib.TypeMarshaler{T: GTypePlayState, F: marshalPlayState},
		coreglib.TypeMarshaler{T: GTypePlayVideoRenderer, F: marshalPlayVideoRenderer},
		coreglib.TypeMarshaler{T: GTypePlay, F: marshalPlay},
		coreglib.TypeMarshaler{T: GTypePlayAudioInfo, F: marshalPlayAudioInfo},
		coreglib.TypeMarshaler{T: GTypePlayMediaInfo, F: marshalPlayMediaInfo},
		coreglib.TypeMarshaler{T: GTypePlaySignalAdapter, F: marshalPlaySignalAdapter},
		coreglib.TypeMarshaler{T: GTypePlayStreamInfo, F: marshalPlayStreamInfo},
		coreglib.TypeMarshaler{T: GTypePlaySubtitleInfo, F: marshalPlaySubtitleInfo},
		coreglib.TypeMarshaler{T: GTypePlayVideoInfo, F: marshalPlayVideoInfo},
		coreglib.TypeMarshaler{T: GTypePlayVideoOverlayVideoRenderer, F: marshalPlayVideoOverlayVideoRenderer},
		coreglib.TypeMarshaler{T: GTypePlayVisualization, F: marshalPlayVisualization},
	})
}

type PlayColorBalanceType C.gint

const (
	// PlayColorBalanceHue: hue or color balance.
	PlayColorBalanceHue PlayColorBalanceType = 3
	// PlayColorBalanceBrightness brightness or black level.
	PlayColorBalanceBrightness PlayColorBalanceType = 0
	// PlayColorBalanceSaturation: color saturation or chroma gain.
	PlayColorBalanceSaturation PlayColorBalanceType = 2
	// PlayColorBalanceContrast: contrast or luma gain.
	PlayColorBalanceContrast PlayColorBalanceType = 1
)

func marshalPlayColorBalanceType(p uintptr) (interface{}, error) {
	return PlayColorBalanceType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PlayColorBalanceType.
func (p PlayColorBalanceType) String() string {
	switch p {
	case PlayColorBalanceHue:
		return "Hue"
	case PlayColorBalanceBrightness:
		return "Brightness"
	case PlayColorBalanceSaturation:
		return "Saturation"
	case PlayColorBalanceContrast:
		return "Contrast"
	default:
		return fmt.Sprintf("PlayColorBalanceType(%d)", p)
	}
}

// PlayColorBalanceTypeGetName gets a string representing the given color
// balance type.
//
// The function takes the following parameters:
//
//   - typ: PlayColorBalanceType.
//
// The function returns the following values:
//
//   - utf8: string with the name of the color balance type.
func PlayColorBalanceTypeGetName(typ PlayColorBalanceType) string {
	var _arg1 C.GstPlayColorBalanceType // out
	var _cret *C.gchar                  // in

	_arg1 = C.GstPlayColorBalanceType(typ)

	_cret = C.gst_play_color_balance_type_get_name(_arg1)
	runtime.KeepAlive(typ)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

type PlayError C.gint

const (
	// PlayErrorFailed: generic error.
	PlayErrorFailed PlayError = iota
)

func marshalPlayError(p uintptr) (interface{}, error) {
	return PlayError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PlayError.
func (p PlayError) String() string {
	switch p {
	case PlayErrorFailed:
		return "Failed"
	default:
		return fmt.Sprintf("PlayError(%d)", p)
	}
}

// PlayErrorGetName gets a string representing the given error.
//
// The function takes the following parameters:
//
//   - err: PlayError.
//
// The function returns the following values:
//
//   - utf8: string with the given error.
func PlayErrorGetName(err PlayError) string {
	var _arg1 C.GstPlayError // out
	var _cret *C.gchar       // in

	_arg1 = C.GstPlayError(err)

	_cret = C.gst_play_error_get_name(_arg1)
	runtime.KeepAlive(err)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

func PlayErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gst_play_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

type PlayMessage C.gint

const (
	// PlayMessageURILoaded: source element was initalized for set URI.
	PlayMessageURILoaded PlayMessage = iota
	// PlayMessagePositionUpdated: sink position changed.
	PlayMessagePositionUpdated
	// PlayMessageDurationChanged: duration of stream changed.
	PlayMessageDurationChanged
	// PlayMessageStateChanged: state changed, see PlayState.
	PlayMessageStateChanged
	// PlayMessageBuffering: pipeline is in buffering state, message contains
	// the percentage value of the decoding buffer.
	PlayMessageBuffering
	// PlayMessageEndOfStream: sink has received EOS.
	PlayMessageEndOfStream
	// PlayMessageError: message contains an error.
	PlayMessageError
	// PlayMessageWarning: message contains an error.
	PlayMessageWarning
	// PlayMessageVideoDimensionsChanged: video sink received format in
	// different dimensions than before.
	PlayMessageVideoDimensionsChanged
	// PlayMessageMediaInfoUpdated: media-info property has changed, message
	// contains current PlayMediaInfo.
	PlayMessageMediaInfoUpdated
	// PlayMessageVolumeChanged: volume of the audio ouput has changed.
	PlayMessageVolumeChanged
	// PlayMessageMuteChanged: audio muting flag has been toggled.
	PlayMessageMuteChanged
	// PlayMessageSeekDone: any pending seeking operation has been completed.
	PlayMessageSeekDone
)

func marshalPlayMessage(p uintptr) (interface{}, error) {
	return PlayMessage(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PlayMessage.
func (p PlayMessage) String() string {
	switch p {
	case PlayMessageURILoaded:
		return "URILoaded"
	case PlayMessagePositionUpdated:
		return "PositionUpdated"
	case PlayMessageDurationChanged:
		return "DurationChanged"
	case PlayMessageStateChanged:
		return "StateChanged"
	case PlayMessageBuffering:
		return "Buffering"
	case PlayMessageEndOfStream:
		return "EndOfStream"
	case PlayMessageError:
		return "Error"
	case PlayMessageWarning:
		return "Warning"
	case PlayMessageVideoDimensionsChanged:
		return "VideoDimensionsChanged"
	case PlayMessageMediaInfoUpdated:
		return "MediaInfoUpdated"
	case PlayMessageVolumeChanged:
		return "VolumeChanged"
	case PlayMessageMuteChanged:
		return "MuteChanged"
	case PlayMessageSeekDone:
		return "SeekDone"
	default:
		return fmt.Sprintf("PlayMessage(%d)", p)
	}
}

// The function takes the following parameters:
//
//   - messageType: PlayMessage.
//
// The function returns the following values:
//
//   - utf8: string with the name of the message.
func PlayMessageGetName(messageType PlayMessage) string {
	var _arg1 C.GstPlayMessage // out
	var _cret *C.gchar         // in

	_arg1 = C.GstPlayMessage(messageType)

	_cret = C.gst_play_message_get_name(_arg1)
	runtime.KeepAlive(messageType)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// PlayMessageParseBufferingPercent: parse the given buffering msg and extract
// the corresponding value.
//
// The function takes the following parameters:
//
//   - msg: Message.
//
// The function returns the following values:
//
//   - percent (optional): resulting buffering percent.
func PlayMessageParseBufferingPercent(msg *gst.Message) uint {
	var _arg1 *C.GstMessage // out
	var _arg2 C.guint       // in

	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(msg)))

	C.gst_play_message_parse_buffering_percent(_arg1, &_arg2)
	runtime.KeepAlive(msg)

	var _percent uint // out

	_percent = uint(_arg2)

	return _percent
}

// PlayMessageParseDurationUpdated: parse the given duration-changed msg and
// extract the corresponding ClockTime.
//
// The function takes the following parameters:
//
//   - msg: Message.
//
// The function returns the following values:
//
//   - duration (optional): resulting duration.
func PlayMessageParseDurationUpdated(msg *gst.Message) gst.ClockTime {
	var _arg1 *C.GstMessage  // out
	var _arg2 C.GstClockTime // in

	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(msg)))

	C.gst_play_message_parse_duration_updated(_arg1, &_arg2)
	runtime.KeepAlive(msg)

	var _duration gst.ClockTime // out

	_duration = gst.ClockTime(_arg2)

	return _duration
}

// PlayMessageParseError: parse the given error msg and extract the
// corresponding #GError.
//
// The function takes the following parameters:
//
//   - msg: Message.
//
// The function returns the following values:
//
//   - err (optional): resulting error.
//   - details (optional) containing additional details about the error.
func PlayMessageParseError(msg *gst.Message) (error, *gst.Structure) {
	var _arg1 *C.GstMessage   // out
	var _arg2 *C.GError       // in
	var _arg3 *C.GstStructure // in

	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(msg)))

	C.gst_play_message_parse_error(_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(msg)

	var _err error              // out
	var _details *gst.Structure // out

	if _arg2 != nil {
		_err = gerror.Take(unsafe.Pointer(_arg2))
	}
	if _arg3 != nil {
		_details = (*gst.Structure)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_details)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _err, _details
}

// PlayMessageParseMediaInfoUpdated: parse the given media-info-updated msg and
// extract the corresponding media information.
//
// The function takes the following parameters:
//
//   - msg: Message.
//
// The function returns the following values:
//
//   - info (optional): resulting media info.
func PlayMessageParseMediaInfoUpdated(msg *gst.Message) *PlayMediaInfo {
	var _arg1 *C.GstMessage       // out
	var _arg2 *C.GstPlayMediaInfo // in

	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(msg)))

	C.gst_play_message_parse_media_info_updated(_arg1, &_arg2)
	runtime.KeepAlive(msg)

	var _info *PlayMediaInfo // out

	if _arg2 != nil {
		_info = wrapPlayMediaInfo(coreglib.AssumeOwnership(unsafe.Pointer(_arg2)))
	}

	return _info
}

// PlayMessageParseMutedChanged: parse the given mute-changed msg and extract
// the corresponding audio muted state.
//
// The function takes the following parameters:
//
//   - msg: Message.
//
// The function returns the following values:
//
//   - muted (optional): resulting audio muted state.
func PlayMessageParseMutedChanged(msg *gst.Message) bool {
	var _arg1 *C.GstMessage // out
	var _arg2 C.gboolean    // in

	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(msg)))

	C.gst_play_message_parse_muted_changed(_arg1, &_arg2)
	runtime.KeepAlive(msg)

	var _muted bool // out

	if _arg2 != 0 {
		_muted = true
	}

	return _muted
}

// PlayMessageParsePositionUpdated: parse the given position-updated msg and
// extract the corresponding ClockTime.
//
// The function takes the following parameters:
//
//   - msg: Message.
//
// The function returns the following values:
//
//   - position (optional): resulting position.
func PlayMessageParsePositionUpdated(msg *gst.Message) gst.ClockTime {
	var _arg1 *C.GstMessage  // out
	var _arg2 C.GstClockTime // in

	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(msg)))

	C.gst_play_message_parse_position_updated(_arg1, &_arg2)
	runtime.KeepAlive(msg)

	var _position gst.ClockTime // out

	_position = gst.ClockTime(_arg2)

	return _position
}

// PlayMessageParseStateChanged: parse the given state-changed msg and extract
// the corresponding PlayState.
//
// The function takes the following parameters:
//
//   - msg: Message.
//
// The function returns the following values:
//
//   - state (optional): resulting play state.
func PlayMessageParseStateChanged(msg *gst.Message) PlayState {
	var _arg1 *C.GstMessage  // out
	var _arg2 C.GstPlayState // in

	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(msg)))

	C.gst_play_message_parse_state_changed(_arg1, &_arg2)
	runtime.KeepAlive(msg)

	var _state PlayState // out

	_state = PlayState(_arg2)

	return _state
}

// PlayMessageParseType: parse the given msg and extract its PlayMessage type.
//
// The function takes the following parameters:
//
//   - msg: Message.
//
// The function returns the following values:
//
//   - typ (optional): resulting message type.
func PlayMessageParseType(msg *gst.Message) PlayMessage {
	var _arg1 *C.GstMessage    // out
	var _arg2 C.GstPlayMessage // in

	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(msg)))

	C.gst_play_message_parse_type(_arg1, &_arg2)
	runtime.KeepAlive(msg)

	var _typ PlayMessage // out

	_typ = PlayMessage(_arg2)

	return _typ
}

// PlayMessageParseVideoDimensionsChanged: parse the given
// video-dimensions-changed msg and extract the corresponding video dimensions.
//
// The function takes the following parameters:
//
//   - msg: Message.
//
// The function returns the following values:
//
//   - width (optional): resulting video width.
//   - height (optional): resulting video height.
func PlayMessageParseVideoDimensionsChanged(msg *gst.Message) (width, height uint) {
	var _arg1 *C.GstMessage // out
	var _arg2 C.guint       // in
	var _arg3 C.guint       // in

	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(msg)))

	C.gst_play_message_parse_video_dimensions_changed(_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(msg)

	var _width uint  // out
	var _height uint // out

	_width = uint(_arg2)
	_height = uint(_arg3)

	return _width, _height
}

// PlayMessageParseVolumeChanged: parse the given volume-changed msg and extract
// the corresponding audio volume.
//
// The function takes the following parameters:
//
//   - msg: Message.
//
// The function returns the following values:
//
//   - volume (optional): resulting audio volume.
func PlayMessageParseVolumeChanged(msg *gst.Message) float64 {
	var _arg1 *C.GstMessage // out
	var _arg2 C.gdouble     // in

	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(msg)))

	C.gst_play_message_parse_volume_changed(_arg1, &_arg2)
	runtime.KeepAlive(msg)

	var _volume float64 // out

	_volume = float64(_arg2)

	return _volume
}

// PlayMessageParseWarning: parse the given warning msg and extract the
// corresponding #GError.
//
// The function takes the following parameters:
//
//   - msg: Message.
//
// The function returns the following values:
//
//   - err (optional): resulting warning.
//   - details (optional) containing additional details about the warning.
func PlayMessageParseWarning(msg *gst.Message) (error, *gst.Structure) {
	var _arg1 *C.GstMessage   // out
	var _arg2 *C.GError       // in
	var _arg3 *C.GstStructure // in

	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(msg)))

	C.gst_play_message_parse_warning(_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(msg)

	var _err error              // out
	var _details *gst.Structure // out

	if _arg2 != nil {
		_err = gerror.Take(unsafe.Pointer(_arg2))
	}
	if _arg3 != nil {
		_details = (*gst.Structure)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_details)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _err, _details
}

type PlaySnapshotFormat C.gint

const (
	// PlayThumbnailRawNative: raw native format.
	PlayThumbnailRawNative PlaySnapshotFormat = iota
	// PlayThumbnailRawXrgb: raw xRGB format.
	PlayThumbnailRawXrgb
	// PlayThumbnailRawBgrx: raw BGRx format.
	PlayThumbnailRawBgrx
	// PlayThumbnailJPG: jpeg format.
	PlayThumbnailJPG
	// PlayThumbnailPNG: png format.
	PlayThumbnailPNG
)

// String returns the name in string for PlaySnapshotFormat.
func (p PlaySnapshotFormat) String() string {
	switch p {
	case PlayThumbnailRawNative:
		return "RawNative"
	case PlayThumbnailRawXrgb:
		return "RawXrgb"
	case PlayThumbnailRawBgrx:
		return "RawBgrx"
	case PlayThumbnailJPG:
		return "JPG"
	case PlayThumbnailPNG:
		return "PNG"
	default:
		return fmt.Sprintf("PlaySnapshotFormat(%d)", p)
	}
}

type PlayState C.gint

const (
	// PlayStateStopped: play is stopped.
	PlayStateStopped PlayState = iota
	// PlayStateBuffering: play is buffering.
	PlayStateBuffering
	// PlayStatePaused: play is paused.
	PlayStatePaused
	// PlayStatePlaying: play is currently playing a stream.
	PlayStatePlaying
)

func marshalPlayState(p uintptr) (interface{}, error) {
	return PlayState(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PlayState.
func (p PlayState) String() string {
	switch p {
	case PlayStateStopped:
		return "Stopped"
	case PlayStateBuffering:
		return "Buffering"
	case PlayStatePaused:
		return "Paused"
	case PlayStatePlaying:
		return "Playing"
	default:
		return fmt.Sprintf("PlayState(%d)", p)
	}
}

// PlayStateGetName gets a string representing the given state.
//
// The function takes the following parameters:
//
//   - state: PlayState.
//
// The function returns the following values:
//
//   - utf8: string with the name of the state.
func PlayStateGetName(state PlayState) string {
	var _arg1 C.GstPlayState // out
	var _cret *C.gchar       // in

	_arg1 = C.GstPlayState(state)

	_cret = C.gst_play_state_get_name(_arg1)
	runtime.KeepAlive(state)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// PlayVideoRendererOverrider contains methods that are overridable.
type PlayVideoRendererOverrider interface {
}

//
// PlayVideoRenderer wraps an interface. This means the user can get the
// underlying type by calling Cast().
type PlayVideoRenderer struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*PlayVideoRenderer)(nil)
)

// PlayVideoRendererer describes PlayVideoRenderer's interface methods.
type PlayVideoRendererer interface {
	coreglib.Objector

	basePlayVideoRenderer() *PlayVideoRenderer
}

var _ PlayVideoRendererer = (*PlayVideoRenderer)(nil)

func ifaceInitPlayVideoRendererer(gifacePtr, data C.gpointer) {
}

func wrapPlayVideoRenderer(obj *coreglib.Object) *PlayVideoRenderer {
	return &PlayVideoRenderer{
		Object: obj,
	}
}

func marshalPlayVideoRenderer(p uintptr) (interface{}, error) {
	return wrapPlayVideoRenderer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *PlayVideoRenderer) basePlayVideoRenderer() *PlayVideoRenderer {
	return v
}

// BasePlayVideoRenderer returns the underlying base object.
func BasePlayVideoRenderer(obj PlayVideoRendererer) *PlayVideoRenderer {
	return obj.basePlayVideoRenderer()
}

// Play: goal of the GstPlay library is to ease the integration of multimedia
// playback features in applications. Thus, if you need to build a media player
// from the ground-up, GstPlay provides the features you will most likely need.
//
// An example player is available in gst-examples/playback/player/gst-play/.
//
// Internally the GstPlay makes use of the playbin3 element. The legacy playbin2
// can be selected if the GST_PLAY_USE_PLAYBIN3=0 environment variable has been
// set.
//
// **Important note**: If your application relies on the GstBus to get
// notifications from GstPlay, you need to add some explicit clean-up code in
// order to prevent the GstPlay object from leaking. See below for the details.
// If you use the GstPlaySignalAdapter, no special clean-up is required.
//
// When the GstPlaySignalAdapter is not used, the GstBus owned by GstPlay should
// be set to flushing state before any attempt to drop the last reference of the
// GstPlay object. An example in C:
//
//	...
//	GstBus *bus = gst_play_get_message_bus (player);
//	gst_bus_set_flushing (bus, TRUE);
//	gst_object_unref (bus);
//	gst_object_unref (player);
//
// The messages managed by the player contain a reference to itself, and if the
// bus watch is just removed together with dropping the player then the bus
// will simply keep them around forever (and the bus never goes away because the
// player has a strong reference to it, so there's a reference cycle as long as
// there are messages). Setting the bus to flushing state forces it to get rid
// of its queued messages, thus breaking any possible reference cycle.
type Play struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*Play)(nil)
)

func wrapPlay(obj *coreglib.Object) *Play {
	return &Play{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalPlay(p uintptr) (interface{}, error) {
	return wrapPlay(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewPlay creates a new Play instance.
//
// Video is going to be rendered by video_renderer, or if NULL is provided
// no special video set up will be done and some default handling will be
// performed.
//
// This also initializes GStreamer via gst_init() on the first call if this
// didn't happen before.
//
// The function takes the following parameters:
//
//   - videoRenderer (optional): gstPlayVideoRenderer to use.
//
// The function returns the following values:
//
//   - play: new Play instance.
func NewPlay(videoRenderer PlayVideoRendererer) *Play {
	var _arg1 *C.GstPlayVideoRenderer // out
	var _cret *C.GstPlay              // in

	if videoRenderer != nil {
		_arg1 = (*C.GstPlayVideoRenderer)(unsafe.Pointer(coreglib.BaseObject(videoRenderer).Native()))
		C.g_object_ref(C.gpointer(coreglib.BaseObject(videoRenderer).Native()))
	}

	_cret = C.gst_play_new(_arg1)
	runtime.KeepAlive(videoRenderer)

	var _play *Play // out

	_play = wrapPlay(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _play
}

// AudioVideoOffset: retrieve the current value of audio-video-offset property.
//
// The function returns the following values:
//
//   - gint64: current value of audio-video-offset in nanoseconds.
func (play *Play) AudioVideoOffset() int64 {
	var _arg0 *C.GstPlay // out
	var _cret C.gint64   // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	_cret = C.gst_play_get_audio_video_offset(_arg0)
	runtime.KeepAlive(play)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// ColorBalance: retrieve the current value of the indicated type.
//
// The function takes the following parameters:
//
//   - typ: PlayColorBalanceType.
//
// The function returns the following values:
//
//   - gdouble: current value of type, between [0,1]. In case of error -1 is
//     returned.
func (play *Play) ColorBalance(typ PlayColorBalanceType) float64 {
	var _arg0 *C.GstPlay                // out
	var _arg1 C.GstPlayColorBalanceType // out
	var _cret C.gdouble                 // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	_arg1 = C.GstPlayColorBalanceType(typ)

	_cret = C.gst_play_get_color_balance(_arg0, _arg1)
	runtime.KeepAlive(play)
	runtime.KeepAlive(typ)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Config: get a copy of the current configuration of the play. This
// configuration can either be modified and used for the gst_play_set_config()
// call or it must be freed after usage.
//
// The function returns the following values:
//
//   - structure: copy of the current configuration of play. Use
//     gst_structure_free() after usage or gst_play_set_config().
func (play *Play) Config() *gst.Structure {
	var _arg0 *C.GstPlay      // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	_cret = C.gst_play_get_config(_arg0)
	runtime.KeepAlive(play)

	var _structure *gst.Structure // out

	_structure = (*gst.Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_structure)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _structure
}

// CurrentAudioTrack: function to get current audio PlayAudioInfo instance.
//
// The function returns the following values:
//
//   - playAudioInfo (optional): current audio track.
//
//     The caller should free it with g_object_unref().
func (play *Play) CurrentAudioTrack() *PlayAudioInfo {
	var _arg0 *C.GstPlay          // out
	var _cret *C.GstPlayAudioInfo // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	_cret = C.gst_play_get_current_audio_track(_arg0)
	runtime.KeepAlive(play)

	var _playAudioInfo *PlayAudioInfo // out

	if _cret != nil {
		_playAudioInfo = wrapPlayAudioInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _playAudioInfo
}

// CurrentSubtitleTrack: function to get current subtitle PlaySubtitleInfo
// instance.
//
// The function returns the following values:
//
//   - playSubtitleInfo (optional): current subtitle track.
//
//     The caller should free it with g_object_unref().
func (play *Play) CurrentSubtitleTrack() *PlaySubtitleInfo {
	var _arg0 *C.GstPlay             // out
	var _cret *C.GstPlaySubtitleInfo // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	_cret = C.gst_play_get_current_subtitle_track(_arg0)
	runtime.KeepAlive(play)

	var _playSubtitleInfo *PlaySubtitleInfo // out

	if _cret != nil {
		_playSubtitleInfo = wrapPlaySubtitleInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _playSubtitleInfo
}

// CurrentVideoTrack: function to get current video PlayVideoInfo instance.
//
// The function returns the following values:
//
//   - playVideoInfo (optional): current video track.
//
//     The caller should free it with g_object_unref().
func (play *Play) CurrentVideoTrack() *PlayVideoInfo {
	var _arg0 *C.GstPlay          // out
	var _cret *C.GstPlayVideoInfo // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	_cret = C.gst_play_get_current_video_track(_arg0)
	runtime.KeepAlive(play)

	var _playVideoInfo *PlayVideoInfo // out

	if _cret != nil {
		_playVideoInfo = wrapPlayVideoInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _playVideoInfo
}

// The function returns the following values:
//
//   - utf8 (optional): name of the currently enabled visualization. g_free()
//     after usage.
func (play *Play) CurrentVisualization() string {
	var _arg0 *C.GstPlay // out
	var _cret *C.gchar   // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	_cret = C.gst_play_get_current_visualization(_arg0)
	runtime.KeepAlive(play)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// Duration retrieves the duration of the media stream that self represents.
//
// The function returns the following values:
//
//   - clockTime: duration of the currently-playing media stream, in
//     nanoseconds.
func (play *Play) Duration() gst.ClockTime {
	var _arg0 *C.GstPlay     // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	_cret = C.gst_play_get_duration(_arg0)
	runtime.KeepAlive(play)

	var _clockTime gst.ClockTime // out

	_clockTime = gst.ClockTime(_cret)

	return _clockTime
}

// MediaInfo: function to get the current media info PlayMediaInfo instance.
//
// The function returns the following values:
//
//   - playMediaInfo (optional): media info instance.
//
//     The caller should free it with g_object_unref().
func (play *Play) MediaInfo() *PlayMediaInfo {
	var _arg0 *C.GstPlay          // out
	var _cret *C.GstPlayMediaInfo // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	_cret = C.gst_play_get_media_info(_arg0)
	runtime.KeepAlive(play)

	var _playMediaInfo *PlayMediaInfo // out

	if _cret != nil {
		_playMediaInfo = wrapPlayMediaInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _playMediaInfo
}

// MessageBus: gstPlay API exposes a Bus instance which purpose is to provide
// data structures representing play-internal events in form of Message<!-- -->s
// of type GST_MESSAGE_APPLICATION.
//
// Each message carries a "play-message" field of type PlayMessage. Further
// fields of the message data are specific to each possible value of that
// enumeration.
//
// Applications can consume the messages asynchronously within their own
// event-loop / UI-thread etc. Note that in case the application does not
// consume the messages, the bus will accumulate these internally and eventually
// fill memory. To avoid that, the bus has to be set "flushing".
//
// The function returns the following values:
//
//   - bus: play message bus instance.
func (play *Play) MessageBus() *gst.Bus {
	var _arg0 *C.GstPlay // out
	var _cret *C.GstBus  // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	_cret = C.gst_play_get_message_bus(_arg0)
	runtime.KeepAlive(play)

	var _bus *gst.Bus // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_bus = &gst.Bus{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		}
	}

	return _bus
}

// MultiviewFlags: retrieve the current value of the indicated type.
//
// The function returns the following values:
//
//   - videoMultiviewFlags: current value of type, Default: 0x00000000 "none.
func (play *Play) MultiviewFlags() gstvideo.VideoMultiviewFlags {
	var _arg0 *C.GstPlay               // out
	var _cret C.GstVideoMultiviewFlags // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	_cret = C.gst_play_get_multiview_flags(_arg0)
	runtime.KeepAlive(play)

	var _videoMultiviewFlags gstvideo.VideoMultiviewFlags // out

	_videoMultiviewFlags = gstvideo.VideoMultiviewFlags(_cret)

	return _videoMultiviewFlags
}

// MultiviewMode: retrieve the current value of the indicated type.
//
// The function returns the following values:
//
//   - videoMultiviewFramePacking: current value of type, Default: -1 "none".
func (play *Play) MultiviewMode() gstvideo.VideoMultiviewFramePacking {
	var _arg0 *C.GstPlay                      // out
	var _cret C.GstVideoMultiviewFramePacking // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	_cret = C.gst_play_get_multiview_mode(_arg0)
	runtime.KeepAlive(play)

	var _videoMultiviewFramePacking gstvideo.VideoMultiviewFramePacking // out

	_videoMultiviewFramePacking = gstvideo.VideoMultiviewFramePacking(_cret)

	return _videoMultiviewFramePacking
}

// The function returns the following values:
//
//   - ok: TRUE if the currently-playing stream is muted.
func (play *Play) Mute() bool {
	var _arg0 *C.GstPlay // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	_cret = C.gst_play_get_mute(_arg0)
	runtime.KeepAlive(play)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - element: internal playbin instance.
//
//     The caller should free it with g_object_unref().
func (play *Play) Pipeline() gst.Elementer {
	var _arg0 *C.GstPlay    // out
	var _cret *C.GstElement // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	_cret = C.gst_play_get_pipeline(_arg0)
	runtime.KeepAlive(play)

	var _element gst.Elementer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gst.Elementer)
			return ok
		})
		rv, ok := casted.(gst.Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}

	return _element
}

// The function returns the following values:
//
//   - clockTime: absolute position time, in nanoseconds, of the
//     currently-playing stream.
func (play *Play) Position() gst.ClockTime {
	var _arg0 *C.GstPlay     // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	_cret = C.gst_play_get_position(_arg0)
	runtime.KeepAlive(play)

	var _clockTime gst.ClockTime // out

	_clockTime = gst.ClockTime(_cret)

	return _clockTime
}

// The function returns the following values:
//
//   - gdouble: current playback rate.
func (play *Play) Rate() float64 {
	var _arg0 *C.GstPlay // out
	var _cret C.gdouble  // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	_cret = C.gst_play_get_rate(_arg0)
	runtime.KeepAlive(play)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// SubtitleURI: current subtitle URI.
//
// The function returns the following values:
//
//   - utf8 (optional): URI of the current external subtitle. g_free() after
//     usage.
func (play *Play) SubtitleURI() string {
	var _arg0 *C.GstPlay // out
	var _cret *C.gchar   // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	_cret = C.gst_play_get_subtitle_uri(_arg0)
	runtime.KeepAlive(play)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// SubtitleVideoOffset: retrieve the current value of subtitle-video-offset
// property.
//
// The function returns the following values:
//
//   - gint64: current value of subtitle-video-offset in nanoseconds.
func (play *Play) SubtitleVideoOffset() int64 {
	var _arg0 *C.GstPlay // out
	var _cret C.gint64   // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	_cret = C.gst_play_get_subtitle_video_offset(_arg0)
	runtime.KeepAlive(play)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// URI gets the URI of the currently-playing stream.
//
// The function returns the following values:
//
//   - utf8 (optional): string containing the URI of the currently-playing
//     stream. g_free() after usage.
func (play *Play) URI() string {
	var _arg0 *C.GstPlay // out
	var _cret *C.gchar   // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	_cret = C.gst_play_get_uri(_arg0)
	runtime.KeepAlive(play)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// VideoSnapshot: get a snapshot of the currently selected video stream, if any.
// The format can be selected with format and optional configuration is possible
// with config. Currently supported settings are:
//
// - width, height of type G_TYPE_INT
//
// - pixel-aspect-ratio of type GST_TYPE_FRACTION Except for
// GST_PLAY_THUMBNAIL_RAW_NATIVE format, if no config is set, pixel-aspect-ratio
// would be 1/1.
//
// The function takes the following parameters:
//
//   - format: output format of the video snapshot.
//   - config (optional): additional configuration.
//
// The function returns the following values:
//
//   - sample (optional): current video snapshot sample or NULL on failure.
func (play *Play) VideoSnapshot(format PlaySnapshotFormat, config *gst.Structure) *gst.Sample {
	var _arg0 *C.GstPlay              // out
	var _arg1 C.GstPlaySnapshotFormat // out
	var _arg2 *C.GstStructure         // out
	var _cret *C.GstSample            // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	_arg1 = C.GstPlaySnapshotFormat(format)
	if config != nil {
		_arg2 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	}

	_cret = C.gst_play_get_video_snapshot(_arg0, _arg1, _arg2)
	runtime.KeepAlive(play)
	runtime.KeepAlive(format)
	runtime.KeepAlive(config)

	var _sample *gst.Sample // out

	if _cret != nil {
		_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_sample)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _sample
}

// Volume returns the current volume level, as a percentage between 0 and 1.
//
// The function returns the following values:
//
//   - gdouble: volume as percentage between 0 and 1.
func (play *Play) Volume() float64 {
	var _arg0 *C.GstPlay // out
	var _cret C.gdouble  // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	_cret = C.gst_play_get_volume(_arg0)
	runtime.KeepAlive(play)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// HasColorBalance checks whether the play has color balance support available.
//
// The function returns the following values:
//
//   - ok: TRUE if play has color balance support. Otherwise, FALSE.
func (play *Play) HasColorBalance() bool {
	var _arg0 *C.GstPlay // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	_cret = C.gst_play_has_color_balance(_arg0)
	runtime.KeepAlive(play)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Pause pauses the current stream.
func (play *Play) Pause() {
	var _arg0 *C.GstPlay // out

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	C.gst_play_pause(_arg0)
	runtime.KeepAlive(play)
}

// Play: request to play the loaded stream.
func (play *Play) Play() {
	var _arg0 *C.GstPlay // out

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	C.gst_play_play(_arg0)
	runtime.KeepAlive(play)
}

// Seek seeks the currently-playing stream to the absolute position time in
// nanoseconds.
//
// The function takes the following parameters:
//
//   - position to seek in nanoseconds.
func (play *Play) Seek(position gst.ClockTime) {
	var _arg0 *C.GstPlay     // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	_arg1 = C.GstClockTime(position)

	C.gst_play_seek(_arg0, _arg1)
	runtime.KeepAlive(play)
	runtime.KeepAlive(position)
}

// The function takes the following parameters:
//
//   - streamIndex: stream index.
//
// The function returns the following values:
//
//   - ok: TRUE or FALSE
//
//     Sets the audio track stream_index.
func (play *Play) SetAudioTrack(streamIndex int) bool {
	var _arg0 *C.GstPlay // out
	var _arg1 C.gint     // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	_arg1 = C.gint(streamIndex)

	_cret = C.gst_play_set_audio_track(_arg0, _arg1)
	runtime.KeepAlive(play)
	runtime.KeepAlive(streamIndex)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAudioTrackEnabled: enable or disable the current audio track.
//
// The function takes the following parameters:
//
//   - enabled: TRUE or FALSE.
func (play *Play) SetAudioTrackEnabled(enabled bool) {
	var _arg0 *C.GstPlay // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_play_set_audio_track_enabled(_arg0, _arg1)
	runtime.KeepAlive(play)
	runtime.KeepAlive(enabled)
}

// SetAudioVideoOffset sets audio-video-offset property by value of offset.
//
// The function takes the following parameters:
//
//   - offset in nanoseconds.
func (play *Play) SetAudioVideoOffset(offset int64) {
	var _arg0 *C.GstPlay // out
	var _arg1 C.gint64   // out

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	_arg1 = C.gint64(offset)

	C.gst_play_set_audio_video_offset(_arg0, _arg1)
	runtime.KeepAlive(play)
	runtime.KeepAlive(offset)
}

// SetColorBalance sets the current value of the indicated channel type to the
// passed value.
//
// The function takes the following parameters:
//
//   - typ: PlayColorBalanceType.
//   - value: new value for the type, ranged [0,1].
func (play *Play) SetColorBalance(typ PlayColorBalanceType, value float64) {
	var _arg0 *C.GstPlay                // out
	var _arg1 C.GstPlayColorBalanceType // out
	var _arg2 C.gdouble                 // out

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	_arg1 = C.GstPlayColorBalanceType(typ)
	_arg2 = C.gdouble(value)

	C.gst_play_set_color_balance(_arg0, _arg1, _arg2)
	runtime.KeepAlive(play)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(value)
}

// SetConfig: set the configuration of the play. If the play is already
// configured, and the configuration hasn't changed, this function will return
// TRUE. If the play is not in the GST_PLAY_STATE_STOPPED, this method will
// return FALSE and active configuration will remain.
//
// config is a Structure that contains the configuration parameters for the
// play.
//
// This function takes ownership of config.
//
// The function takes the following parameters:
//
//   - config: Structure.
//
// The function returns the following values:
//
//   - ok: TRUE when the configuration could be set.
func (play *Play) SetConfig(config *gst.Structure) bool {
	var _arg0 *C.GstPlay      // out
	var _arg1 *C.GstStructure // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(config)), nil)

	_cret = C.gst_play_set_config(_arg0, _arg1)
	runtime.KeepAlive(play)
	runtime.KeepAlive(config)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetMultiviewFlags sets the current value of the indicated mode type to the
// passed value.
//
// The function takes the following parameters:
//
//   - flags: new value for the type.
func (play *Play) SetMultiviewFlags(flags gstvideo.VideoMultiviewFlags) {
	var _arg0 *C.GstPlay               // out
	var _arg1 C.GstVideoMultiviewFlags // out

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	_arg1 = C.GstVideoMultiviewFlags(flags)

	C.gst_play_set_multiview_flags(_arg0, _arg1)
	runtime.KeepAlive(play)
	runtime.KeepAlive(flags)
}

// SetMultiviewMode sets the current value of the indicated mode type to the
// passed value.
//
// The function takes the following parameters:
//
//   - mode: new value for the type.
func (play *Play) SetMultiviewMode(mode gstvideo.VideoMultiviewFramePacking) {
	var _arg0 *C.GstPlay                      // out
	var _arg1 C.GstVideoMultiviewFramePacking // out

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	_arg1 = C.GstVideoMultiviewFramePacking(mode)

	C.gst_play_set_multiview_mode(_arg0, _arg1)
	runtime.KeepAlive(play)
	runtime.KeepAlive(mode)
}

// SetMute: TRUE if the currently-playing stream should be muted.
//
// The function takes the following parameters:
//
//   - val: mute state the should be set.
func (play *Play) SetMute(val bool) {
	var _arg0 *C.GstPlay // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	if val {
		_arg1 = C.TRUE
	}

	C.gst_play_set_mute(_arg0, _arg1)
	runtime.KeepAlive(play)
	runtime.KeepAlive(val)
}

// SetRate: playback at specified rate.
//
// The function takes the following parameters:
//
//   - rate: playback rate.
func (play *Play) SetRate(rate float64) {
	var _arg0 *C.GstPlay // out
	var _arg1 C.gdouble  // out

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	_arg1 = C.gdouble(rate)

	C.gst_play_set_rate(_arg0, _arg1)
	runtime.KeepAlive(play)
	runtime.KeepAlive(rate)
}

// The function takes the following parameters:
//
//   - streamIndex: stream index.
//
// The function returns the following values:
//
//   - ok: TRUE or FALSE
//
//     Sets the subtitle stack stream_index.
func (play *Play) SetSubtitleTrack(streamIndex int) bool {
	var _arg0 *C.GstPlay // out
	var _arg1 C.gint     // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	_arg1 = C.gint(streamIndex)

	_cret = C.gst_play_set_subtitle_track(_arg0, _arg1)
	runtime.KeepAlive(play)
	runtime.KeepAlive(streamIndex)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSubtitleTrackEnabled: enable or disable the current subtitle track.
//
// The function takes the following parameters:
//
//   - enabled: TRUE or FALSE.
func (play *Play) SetSubtitleTrackEnabled(enabled bool) {
	var _arg0 *C.GstPlay // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_play_set_subtitle_track_enabled(_arg0, _arg1)
	runtime.KeepAlive(play)
	runtime.KeepAlive(enabled)
}

// SetSubtitleURI sets the external subtitle URI. This should be combined with a
// call to gst_play_set_subtitle_track_enabled(play, TRUE) so the subtitles are
// actually rendered.
//
// The function takes the following parameters:
//
//   - uri (optional): subtitle URI.
func (play *Play) SetSubtitleURI(uri string) {
	var _arg0 *C.GstPlay // out
	var _arg1 *C.gchar   // out

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	if uri != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gst_play_set_subtitle_uri(_arg0, _arg1)
	runtime.KeepAlive(play)
	runtime.KeepAlive(uri)
}

// SetSubtitleVideoOffset sets subtitle-video-offset property by value of
// offset.
//
// The function takes the following parameters:
//
//   - offset in nanoseconds.
func (play *Play) SetSubtitleVideoOffset(offset int64) {
	var _arg0 *C.GstPlay // out
	var _arg1 C.gint64   // out

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	_arg1 = C.gint64(offset)

	C.gst_play_set_subtitle_video_offset(_arg0, _arg1)
	runtime.KeepAlive(play)
	runtime.KeepAlive(offset)
}

// SetURI sets the next URI to play.
//
// The function takes the following parameters:
//
//   - uri (optional): next URI to play.
func (play *Play) SetURI(uri string) {
	var _arg0 *C.GstPlay // out
	var _arg1 *C.gchar   // out

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	if uri != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gst_play_set_uri(_arg0, _arg1)
	runtime.KeepAlive(play)
	runtime.KeepAlive(uri)
}

// The function takes the following parameters:
//
//   - streamIndex: stream index.
//
// The function returns the following values:
//
//   - ok: TRUE or FALSE
//
//     Sets the video track stream_index.
func (play *Play) SetVideoTrack(streamIndex int) bool {
	var _arg0 *C.GstPlay // out
	var _arg1 C.gint     // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	_arg1 = C.gint(streamIndex)

	_cret = C.gst_play_set_video_track(_arg0, _arg1)
	runtime.KeepAlive(play)
	runtime.KeepAlive(streamIndex)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetVideoTrackEnabled: enable or disable the current video track.
//
// The function takes the following parameters:
//
//   - enabled: TRUE or FALSE.
func (play *Play) SetVideoTrackEnabled(enabled bool) {
	var _arg0 *C.GstPlay // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_play_set_video_track_enabled(_arg0, _arg1)
	runtime.KeepAlive(play)
	runtime.KeepAlive(enabled)
}

// The function takes the following parameters:
//
//   - name (optional): visualization element obtained from
//     #gst_play_visualizations_get().
//
// The function returns the following values:
//
//   - ok: TRUE if the visualization was set correctly. Otherwise, FALSE.
func (play *Play) SetVisualization(name string) bool {
	var _arg0 *C.GstPlay // out
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_play_set_visualization(_arg0, _arg1)
	runtime.KeepAlive(play)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetVisualizationEnabled: enable or disable the visualization.
//
// The function takes the following parameters:
//
//   - enabled: TRUE or FALSE.
func (play *Play) SetVisualizationEnabled(enabled bool) {
	var _arg0 *C.GstPlay // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_play_set_visualization_enabled(_arg0, _arg1)
	runtime.KeepAlive(play)
	runtime.KeepAlive(enabled)
}

// SetVolume sets the volume level of the stream as a percentage between 0 and
// 1.
//
// The function takes the following parameters:
//
//   - val: new volume level, as a percentage between 0 and 1.
func (play *Play) SetVolume(val float64) {
	var _arg0 *C.GstPlay // out
	var _arg1 C.gdouble  // out

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	_arg1 = C.gdouble(val)

	C.gst_play_set_volume(_arg0, _arg1)
	runtime.KeepAlive(play)
	runtime.KeepAlive(val)
}

// Stop stops playing the current stream and resets to the first position in the
// stream.
func (play *Play) Stop() {
	var _arg0 *C.GstPlay // out

	_arg0 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	C.gst_play_stop(_arg0)
	runtime.KeepAlive(play)
}

// The function takes the following parameters:
//
//   - config: Play configuration.
//
// The function returns the following values:
//
//   - ok: TRUE if pipeline dumps are included in Play error message details.
func PlayConfigGetPipelineDumpInErrorDetails(config *gst.Structure) bool {
	var _arg1 *C.GstStructure // out
	var _cret C.gboolean      // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))

	_cret = C.gst_play_config_get_pipeline_dump_in_error_details(_arg1)
	runtime.KeepAlive(config)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - config: Play configuration.
//
// The function returns the following values:
//
//   - guint: current position update interval in milliseconds.
func PlayConfigGetPositionUpdateInterval(config *gst.Structure) uint {
	var _arg1 *C.GstStructure // out
	var _cret C.guint         // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))

	_cret = C.gst_play_config_get_position_update_interval(_arg1)
	runtime.KeepAlive(config)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function takes the following parameters:
//
//   - config: Play configuration.
//
// The function returns the following values:
//
//   - ok: TRUE if accurate seeking is enabled.
func PlayConfigGetSeekAccurate(config *gst.Structure) bool {
	var _arg1 *C.GstStructure // out
	var _cret C.gboolean      // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))

	_cret = C.gst_play_config_get_seek_accurate(_arg1)
	runtime.KeepAlive(config)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PlayConfigGetUserAgent: return the user agent which has been configured using
// gst_play_config_set_user_agent() if any.
//
// The function takes the following parameters:
//
//   - config: Play configuration.
//
// The function returns the following values:
//
//   - utf8 (optional): configured agent, or NULL.
func PlayConfigGetUserAgent(config *gst.Structure) string {
	var _arg1 *C.GstStructure // out
	var _cret *C.gchar        // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))

	_cret = C.gst_play_config_get_user_agent(_arg1)
	runtime.KeepAlive(config)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// PlayConfigSetPipelineDumpInErrorDetails: when enabled, the error message
// emitted by Play will include a pipeline dump (in Graphviz DOT format) in the
// error details Structure. The field name is pipeline-dump.
//
// This option is disabled by default.
//
// The function takes the following parameters:
//
//   - config: Play configuration.
//   - value: include pipeline dumps in error details, or not.
func PlayConfigSetPipelineDumpInErrorDetails(config *gst.Structure, value bool) {
	var _arg1 *C.GstStructure // out
	var _arg2 C.gboolean      // out

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	if value {
		_arg2 = C.TRUE
	}

	C.gst_play_config_set_pipeline_dump_in_error_details(_arg1, _arg2)
	runtime.KeepAlive(config)
	runtime.KeepAlive(value)
}

// PlayConfigSetPositionUpdateInterval: set desired interval in milliseconds
// between two position-updated messages. Pass 0 to stop updating the position.
//
// The function takes the following parameters:
//
//   - config: Play configuration.
//   - interval in ms.
func PlayConfigSetPositionUpdateInterval(config *gst.Structure, interval uint) {
	var _arg1 *C.GstStructure // out
	var _arg2 C.guint         // out

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	_arg2 = C.guint(interval)

	C.gst_play_config_set_position_update_interval(_arg1, _arg2)
	runtime.KeepAlive(config)
	runtime.KeepAlive(interval)
}

// PlayConfigSetSeekAccurate: enable or disable accurate seeking. When enabled,
// elements will try harder to seek as accurately as possible to the requested
// seek position. Generally it will be slower especially for formats that don't
// have any indexes or timestamp markers in the stream.
//
// If accurate seeking is disabled, elements will seek as close as the request
// position without slowing down seeking too much.
//
// Accurate seeking is disabled by default.
//
// The function takes the following parameters:
//
//   - config: Play configuration.
//   - accurate seek or not.
func PlayConfigSetSeekAccurate(config *gst.Structure, accurate bool) {
	var _arg1 *C.GstStructure // out
	var _arg2 C.gboolean      // out

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	if accurate {
		_arg2 = C.TRUE
	}

	C.gst_play_config_set_seek_accurate(_arg1, _arg2)
	runtime.KeepAlive(config)
	runtime.KeepAlive(accurate)
}

// PlayConfigSetUserAgent: set the user agent to pass to the server if play
// needs to connect to a server during playback. This is typically used when
// playing HTTP or RTSP streams.
//
// The function takes the following parameters:
//
//   - config: Play configuration.
//   - agent (optional): string to use as user agent.
func PlayConfigSetUserAgent(config *gst.Structure, agent string) {
	var _arg1 *C.GstStructure // out
	var _arg2 *C.gchar        // out

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	if agent != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(agent)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.gst_play_config_set_user_agent(_arg1, _arg2)
	runtime.KeepAlive(config)
	runtime.KeepAlive(agent)
}

// The function takes the following parameters:
//
//   - info: PlayMediaInfo.
//
// The function returns the following values:
//
//   - list of matching PlayAudioInfo.
func PlayGetAudioStreams(info *PlayMediaInfo) []*PlayAudioInfo {
	var _arg1 *C.GstPlayMediaInfo // out
	var _cret *C.GList            // in

	_arg1 = (*C.GstPlayMediaInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_get_audio_streams(_arg1)
	runtime.KeepAlive(info)

	var _list []*PlayAudioInfo // out

	_list = make([]*PlayAudioInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstPlayAudioInfo)(v)
		var dst *PlayAudioInfo // out
		dst = wrapPlayAudioInfo(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// The function takes the following parameters:
//
//   - info: PlayMediaInfo.
//
// The function returns the following values:
//
//   - list of matching PlaySubtitleInfo.
func PlayGetSubtitleStreams(info *PlayMediaInfo) []*PlaySubtitleInfo {
	var _arg1 *C.GstPlayMediaInfo // out
	var _cret *C.GList            // in

	_arg1 = (*C.GstPlayMediaInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_get_subtitle_streams(_arg1)
	runtime.KeepAlive(info)

	var _list []*PlaySubtitleInfo // out

	_list = make([]*PlaySubtitleInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstPlaySubtitleInfo)(v)
		var dst *PlaySubtitleInfo // out
		dst = wrapPlaySubtitleInfo(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// The function takes the following parameters:
//
//   - info: PlayMediaInfo.
//
// The function returns the following values:
//
//   - list of matching PlayVideoInfo.
func PlayGetVideoStreams(info *PlayMediaInfo) []*PlayVideoInfo {
	var _arg1 *C.GstPlayMediaInfo // out
	var _cret *C.GList            // in

	_arg1 = (*C.GstPlayMediaInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_get_video_streams(_arg1)
	runtime.KeepAlive(info)

	var _list []*PlayVideoInfo // out

	_list = make([]*PlayVideoInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstPlayVideoInfo)(v)
		var dst *PlayVideoInfo // out
		dst = wrapPlayVideoInfo(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// The function takes the following parameters:
//
//   - msg: Message.
//
// The function returns the following values:
//
//   - ok indicating whether the passed message represents a Play message or
//     not.
func PlayIsPlayMessage(msg *gst.Message) bool {
	var _arg1 *C.GstMessage // out
	var _cret C.gboolean    // in

	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(msg)))

	_cret = C.gst_play_is_play_message(_arg1)
	runtime.KeepAlive(msg)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - playVisualizations: a NULL terminated array containing all available
//     visualizations. Use gst_play_visualizations_free() after usage.
func PlayVisualizationsGet() []*PlayVisualization {
	var _cret **C.GstPlayVisualization // in

	_cret = C.gst_play_visualizations_get()

	var _playVisualizations []*PlayVisualization // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.GstPlayVisualization
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_playVisualizations = make([]*PlayVisualization, i)
		for i := range src {
			_playVisualizations[i] = (*PlayVisualization)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_playVisualizations[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.gst_play_visualization_free((*C.GstPlayVisualization)(intern.C))
				},
			)
		}
	}

	return _playVisualizations
}

// PlayAudioInfo specific to audio streams.
type PlayAudioInfo struct {
	_ [0]func() // equal guard
	PlayStreamInfo
}

var (
	_ PlayStreamInfor = (*PlayAudioInfo)(nil)
)

func wrapPlayAudioInfo(obj *coreglib.Object) *PlayAudioInfo {
	return &PlayAudioInfo{
		PlayStreamInfo: PlayStreamInfo{
			Object: obj,
		},
	}
}

func marshalPlayAudioInfo(p uintptr) (interface{}, error) {
	return wrapPlayAudioInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function returns the following values:
//
//   - gint: audio bitrate in PlayAudioInfo or -1 if unknown.
func (info *PlayAudioInfo) Bitrate() int {
	var _arg0 *C.GstPlayAudioInfo // out
	var _cret C.gint              // in

	_arg0 = (*C.GstPlayAudioInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_audio_info_get_bitrate(_arg0)
	runtime.KeepAlive(info)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
//   - gint: number of audio channels in PlayAudioInfo or 0 if unknown.
func (info *PlayAudioInfo) Channels() int {
	var _arg0 *C.GstPlayAudioInfo // out
	var _cret C.gint              // in

	_arg0 = (*C.GstPlayAudioInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_audio_info_get_channels(_arg0)
	runtime.KeepAlive(info)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
//   - utf8 (optional): language of the stream, or NULL if unknown.
func (info *PlayAudioInfo) Language() string {
	var _arg0 *C.GstPlayAudioInfo // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GstPlayAudioInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_audio_info_get_language(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// The function returns the following values:
//
//   - gint: audio maximum bitrate in PlayAudioInfo or -1 if unknown.
func (info *PlayAudioInfo) MaxBitrate() int {
	var _arg0 *C.GstPlayAudioInfo // out
	var _cret C.gint              // in

	_arg0 = (*C.GstPlayAudioInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_audio_info_get_max_bitrate(_arg0)
	runtime.KeepAlive(info)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
//   - gint: audio sample rate in PlayAudioInfo or 0 if unknown.
func (info *PlayAudioInfo) SampleRate() int {
	var _arg0 *C.GstPlayAudioInfo // out
	var _cret C.gint              // in

	_arg0 = (*C.GstPlayAudioInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_audio_info_get_sample_rate(_arg0)
	runtime.KeepAlive(info)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PlayMediaInfo: structure containing the media information of a URI.
type PlayMediaInfo struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*PlayMediaInfo)(nil)
)

func wrapPlayMediaInfo(obj *coreglib.Object) *PlayMediaInfo {
	return &PlayMediaInfo{
		Object: obj,
	}
}

func marshalPlayMediaInfo(p uintptr) (interface{}, error) {
	return wrapPlayMediaInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function returns the following values:
//
//   - list of matching PlayAudioInfo.
func (info *PlayMediaInfo) AudioStreams() []*PlayAudioInfo {
	var _arg0 *C.GstPlayMediaInfo // out
	var _cret *C.GList            // in

	_arg0 = (*C.GstPlayMediaInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_media_info_get_audio_streams(_arg0)
	runtime.KeepAlive(info)

	var _list []*PlayAudioInfo // out

	_list = make([]*PlayAudioInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstPlayAudioInfo)(v)
		var dst *PlayAudioInfo // out
		dst = wrapPlayAudioInfo(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// The function returns the following values:
//
//   - utf8 (optional): container format or NULL if unknown.
func (info *PlayMediaInfo) ContainerFormat() string {
	var _arg0 *C.GstPlayMediaInfo // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GstPlayMediaInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_media_info_get_container_format(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// The function returns the following values:
//
//   - clockTime: duration of the media.
func (info *PlayMediaInfo) Duration() gst.ClockTime {
	var _arg0 *C.GstPlayMediaInfo // out
	var _cret C.GstClockTime      // in

	_arg0 = (*C.GstPlayMediaInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_media_info_get_duration(_arg0)
	runtime.KeepAlive(info)

	var _clockTime gst.ClockTime // out

	_clockTime = gst.ClockTime(_cret)

	return _clockTime
}

// ImageSample: function to get the image (or preview-image) stored in taglist.
// Application can use gst_sample_*_() API's to get caps, buffer etc.
//
// The function returns the following values:
//
//   - sample (optional): gstSample or NULL.
func (info *PlayMediaInfo) ImageSample() *gst.Sample {
	var _arg0 *C.GstPlayMediaInfo // out
	var _cret *C.GstSample        // in

	_arg0 = (*C.GstPlayMediaInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_media_info_get_image_sample(_arg0)
	runtime.KeepAlive(info)

	var _sample *gst.Sample // out

	if _cret != nil {
		_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.gst_mini_object_ref((*C.GstMiniObject)(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_sample)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _sample
}

// The function returns the following values:
//
//   - guint: number of audio streams.
func (info *PlayMediaInfo) NumberOfAudioStreams() uint {
	var _arg0 *C.GstPlayMediaInfo // out
	var _cret C.guint             // in

	_arg0 = (*C.GstPlayMediaInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_media_info_get_number_of_audio_streams(_arg0)
	runtime.KeepAlive(info)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - guint: number of total streams.
func (info *PlayMediaInfo) NumberOfStreams() uint {
	var _arg0 *C.GstPlayMediaInfo // out
	var _cret C.guint             // in

	_arg0 = (*C.GstPlayMediaInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_media_info_get_number_of_streams(_arg0)
	runtime.KeepAlive(info)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - guint: number of subtitle streams.
func (info *PlayMediaInfo) NumberOfSubtitleStreams() uint {
	var _arg0 *C.GstPlayMediaInfo // out
	var _cret C.guint             // in

	_arg0 = (*C.GstPlayMediaInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_media_info_get_number_of_subtitle_streams(_arg0)
	runtime.KeepAlive(info)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - guint: number of video streams.
func (info *PlayMediaInfo) NumberOfVideoStreams() uint {
	var _arg0 *C.GstPlayMediaInfo // out
	var _cret C.guint             // in

	_arg0 = (*C.GstPlayMediaInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_media_info_get_number_of_video_streams(_arg0)
	runtime.KeepAlive(info)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - list of matching PlayStreamInfo.
func (info *PlayMediaInfo) StreamList() []PlayStreamInfor {
	var _arg0 *C.GstPlayMediaInfo // out
	var _cret *C.GList            // in

	_arg0 = (*C.GstPlayMediaInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_media_info_get_stream_list(_arg0)
	runtime.KeepAlive(info)

	var _list []PlayStreamInfor // out

	_list = make([]PlayStreamInfor, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstPlayStreamInfo)(v)
		var dst PlayStreamInfor // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gstplay.PlayStreamInfor is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(PlayStreamInfor)
				return ok
			})
			rv, ok := casted.(PlayStreamInfor)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstplay.PlayStreamInfor")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// The function returns the following values:
//
//   - list of matching PlaySubtitleInfo.
func (info *PlayMediaInfo) SubtitleStreams() []*PlaySubtitleInfo {
	var _arg0 *C.GstPlayMediaInfo // out
	var _cret *C.GList            // in

	_arg0 = (*C.GstPlayMediaInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_media_info_get_subtitle_streams(_arg0)
	runtime.KeepAlive(info)

	var _list []*PlaySubtitleInfo // out

	_list = make([]*PlaySubtitleInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstPlaySubtitleInfo)(v)
		var dst *PlaySubtitleInfo // out
		dst = wrapPlaySubtitleInfo(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// The function returns the following values:
//
//   - tagList (optional) tags contained in media info.
func (info *PlayMediaInfo) Tags() *gst.TagList {
	var _arg0 *C.GstPlayMediaInfo // out
	var _cret *C.GstTagList       // in

	_arg0 = (*C.GstPlayMediaInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_media_info_get_tags(_arg0)
	runtime.KeepAlive(info)

	var _tagList *gst.TagList // out

	if _cret != nil {
		_tagList = (*gst.TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _tagList
}

// The function returns the following values:
//
//   - utf8 (optional): media title or NULL if unknown.
func (info *PlayMediaInfo) Title() string {
	var _arg0 *C.GstPlayMediaInfo // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GstPlayMediaInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_media_info_get_title(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// The function returns the following values:
//
//   - utf8: URI associated with PlayMediaInfo.
func (info *PlayMediaInfo) URI() string {
	var _arg0 *C.GstPlayMediaInfo // out
	var _cret *C.gchar            // in

	_arg0 = (*C.GstPlayMediaInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_media_info_get_uri(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
//   - list of matching PlayVideoInfo.
func (info *PlayMediaInfo) VideoStreams() []*PlayVideoInfo {
	var _arg0 *C.GstPlayMediaInfo // out
	var _cret *C.GList            // in

	_arg0 = (*C.GstPlayMediaInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_media_info_get_video_streams(_arg0)
	runtime.KeepAlive(info)

	var _list []*PlayVideoInfo // out

	_list = make([]*PlayVideoInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstPlayVideoInfo)(v)
		var dst *PlayVideoInfo // out
		dst = wrapPlayVideoInfo(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// The function returns the following values:
//
//   - ok: TRUE if the media is live.
func (info *PlayMediaInfo) IsLive() bool {
	var _arg0 *C.GstPlayMediaInfo // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstPlayMediaInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_media_info_is_live(_arg0)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - ok: TRUE if the media is seekable.
func (info *PlayMediaInfo) IsSeekable() bool {
	var _arg0 *C.GstPlayMediaInfo // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstPlayMediaInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_media_info_is_seekable(_arg0)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

type PlaySignalAdapter struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*PlaySignalAdapter)(nil)
)

func wrapPlaySignalAdapter(obj *coreglib.Object) *PlaySignalAdapter {
	return &PlaySignalAdapter{
		Object: obj,
	}
}

func marshalPlaySignalAdapter(p uintptr) (interface{}, error) {
	return wrapPlaySignalAdapter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (adapter *PlaySignalAdapter) ConnectBuffering(f func(object int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(adapter, "buffering", false, unsafe.Pointer(C._gotk4_gstplay1_PlaySignalAdapter_ConnectBuffering), f)
}

func (adapter *PlaySignalAdapter) ConnectDurationChanged(f func(object uint64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(adapter, "duration-changed", false, unsafe.Pointer(C._gotk4_gstplay1_PlaySignalAdapter_ConnectDurationChanged), f)
}

func (adapter *PlaySignalAdapter) ConnectEndOfStream(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(adapter, "end-of-stream", false, unsafe.Pointer(C._gotk4_gstplay1_PlaySignalAdapter_ConnectEndOfStream), f)
}

// ConnectError is emitted on errors.
func (adapter *PlaySignalAdapter) ConnectError(f func(err error, details *gst.Structure)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(adapter, "error", false, unsafe.Pointer(C._gotk4_gstplay1_PlaySignalAdapter_ConnectError), f)
}

func (adapter *PlaySignalAdapter) ConnectMediaInfoUpdated(f func(object *PlayMediaInfo)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(adapter, "media-info-updated", false, unsafe.Pointer(C._gotk4_gstplay1_PlaySignalAdapter_ConnectMediaInfoUpdated), f)
}

func (adapter *PlaySignalAdapter) ConnectMuteChanged(f func(object bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(adapter, "mute-changed", false, unsafe.Pointer(C._gotk4_gstplay1_PlaySignalAdapter_ConnectMuteChanged), f)
}

func (adapter *PlaySignalAdapter) ConnectPositionUpdated(f func(object uint64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(adapter, "position-updated", false, unsafe.Pointer(C._gotk4_gstplay1_PlaySignalAdapter_ConnectPositionUpdated), f)
}

func (adapter *PlaySignalAdapter) ConnectSeekDone(f func(object uint64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(adapter, "seek-done", false, unsafe.Pointer(C._gotk4_gstplay1_PlaySignalAdapter_ConnectSeekDone), f)
}

func (adapter *PlaySignalAdapter) ConnectStateChanged(f func(object PlayState)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(adapter, "state-changed", false, unsafe.Pointer(C._gotk4_gstplay1_PlaySignalAdapter_ConnectStateChanged), f)
}

func (adapter *PlaySignalAdapter) ConnectURILoaded(f func(object string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(adapter, "uri-loaded", false, unsafe.Pointer(C._gotk4_gstplay1_PlaySignalAdapter_ConnectURILoaded), f)
}

func (adapter *PlaySignalAdapter) ConnectVideoDimensionsChanged(f func(object, p0 uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(adapter, "video-dimensions-changed", false, unsafe.Pointer(C._gotk4_gstplay1_PlaySignalAdapter_ConnectVideoDimensionsChanged), f)
}

func (adapter *PlaySignalAdapter) ConnectVolumeChanged(f func(object float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(adapter, "volume-changed", false, unsafe.Pointer(C._gotk4_gstplay1_PlaySignalAdapter_ConnectVolumeChanged), f)
}

// ConnectWarning is emitted on warnings.
func (adapter *PlaySignalAdapter) ConnectWarning(f func(err error, details *gst.Structure)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(adapter, "warning", false, unsafe.Pointer(C._gotk4_gstplay1_PlaySignalAdapter_ConnectWarning), f)
}

// NewPlaySignalAdapter: bus-watching #GSource will be created and attached
// to the the thread-default Context. The attached callback will emit the
// corresponding signal for the message received. Matching signals for play
// messages from the bus will be emitted by it on the created adapter object.
//
// The function takes the following parameters:
//
//   - play instance to emit signals for.
//
// The function returns the following values:
//
//   - playSignalAdapter: new PlaySignalAdapter to connect signal handlers to.
func NewPlaySignalAdapter(play *Play) *PlaySignalAdapter {
	var _arg1 *C.GstPlay              // out
	var _cret *C.GstPlaySignalAdapter // in

	_arg1 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	_cret = C.gst_play_signal_adapter_new(_arg1)
	runtime.KeepAlive(play)

	var _playSignalAdapter *PlaySignalAdapter // out

	_playSignalAdapter = wrapPlaySignalAdapter(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _playSignalAdapter
}

// NewPlaySignalAdapterSyncEmit: create an adapter that synchronously emits its
// signals, from the thread in which the messages have been posted.
//
// The function takes the following parameters:
//
//   - play instance to emit signals for.
//
// The function returns the following values:
//
//   - playSignalAdapter: new PlaySignalAdapter to connect signal handlers to.
func NewPlaySignalAdapterSyncEmit(play *Play) *PlaySignalAdapter {
	var _arg1 *C.GstPlay              // out
	var _cret *C.GstPlaySignalAdapter // in

	_arg1 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))

	_cret = C.gst_play_signal_adapter_new_sync_emit(_arg1)
	runtime.KeepAlive(play)

	var _playSignalAdapter *PlaySignalAdapter // out

	_playSignalAdapter = wrapPlaySignalAdapter(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _playSignalAdapter
}

// NewPlaySignalAdapterWithMainContext: bus-watching #GSource will be
// created and attached to the context. The attached callback will emit the
// corresponding signal for the message received. Matching signals for play
// messages from the bus will be emitted by it on the created adapter object.
//
// The function takes the following parameters:
//
//   - play instance to emit signals for.
//   - context on which the main-loop will process play bus messages on.
//
// The function returns the following values:
//
//   - playSignalAdapter: new PlaySignalAdapter to connect signal handlers to.
func NewPlaySignalAdapterWithMainContext(play *Play, context *glib.MainContext) *PlaySignalAdapter {
	var _arg1 *C.GstPlay              // out
	var _arg2 *C.GMainContext         // out
	var _cret *C.GstPlaySignalAdapter // in

	_arg1 = (*C.GstPlay)(unsafe.Pointer(coreglib.BaseObject(play).Native()))
	_arg2 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.gst_play_signal_adapter_new_with_main_context(_arg1, _arg2)
	runtime.KeepAlive(play)
	runtime.KeepAlive(context)

	var _playSignalAdapter *PlaySignalAdapter // out

	_playSignalAdapter = wrapPlaySignalAdapter(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _playSignalAdapter
}

// The function returns the following values:
//
//   - play owning this signal adapter.
func (adapter *PlaySignalAdapter) Play() *Play {
	var _arg0 *C.GstPlaySignalAdapter // out
	var _cret *C.GstPlay              // in

	_arg0 = (*C.GstPlaySignalAdapter)(unsafe.Pointer(coreglib.BaseObject(adapter).Native()))

	_cret = C.gst_play_signal_adapter_get_play(_arg0)
	runtime.KeepAlive(adapter)

	var _play *Play // out

	_play = wrapPlay(coreglib.Take(unsafe.Pointer(_cret)))

	return _play
}

// PlayStreamInfo: base structure for information concerning a media stream.
// Depending on the stream type, one can find more media-specific information in
// PlayVideoInfo, PlayAudioInfo, PlaySubtitleInfo.
type PlayStreamInfo struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*PlayStreamInfo)(nil)
)

// PlayStreamInfor describes types inherited from class PlayStreamInfo.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type PlayStreamInfor interface {
	coreglib.Objector
	basePlayStreamInfo() *PlayStreamInfo
}

var _ PlayStreamInfor = (*PlayStreamInfo)(nil)

func wrapPlayStreamInfo(obj *coreglib.Object) *PlayStreamInfo {
	return &PlayStreamInfo{
		Object: obj,
	}
}

func marshalPlayStreamInfo(p uintptr) (interface{}, error) {
	return wrapPlayStreamInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (info *PlayStreamInfo) basePlayStreamInfo() *PlayStreamInfo {
	return info
}

// BasePlayStreamInfo returns the underlying base object.
func BasePlayStreamInfo(obj PlayStreamInfor) *PlayStreamInfo {
	return obj.basePlayStreamInfo()
}

// The function returns the following values:
//
//   - caps (optional) of the stream or NULL if unknown.
func (info *PlayStreamInfo) Caps() *gst.Caps {
	var _arg0 *C.GstPlayStreamInfo // out
	var _cret *C.GstCaps           // in

	_arg0 = (*C.GstPlayStreamInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_stream_info_get_caps(_arg0)
	runtime.KeepAlive(info)

	var _caps *gst.Caps // out

	if _cret != nil {
		_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.gst_mini_object_ref((*C.GstMiniObject)(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_caps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _caps
}

// Codec: string describing codec used in PlayStreamInfo.
//
// The function returns the following values:
//
//   - utf8 (optional): codec string or NULL on unknown.
func (info *PlayStreamInfo) Codec() string {
	var _arg0 *C.GstPlayStreamInfo // out
	var _cret *C.gchar             // in

	_arg0 = (*C.GstPlayStreamInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_stream_info_get_codec(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Index: function to get stream index from PlayStreamInfo instance or -1 if
// unknown.
//
// The function returns the following values:
//
//   - gint: stream index of this stream.
func (info *PlayStreamInfo) Index() int {
	var _arg0 *C.GstPlayStreamInfo // out
	var _cret C.gint               // in

	_arg0 = (*C.GstPlayStreamInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_stream_info_get_index(_arg0)
	runtime.KeepAlive(info)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// StreamType: function to return human readable name for the stream type of the
// given info (ex: "audio", "video", "subtitle").
//
// The function returns the following values:
//
//   - utf8: human readable name.
func (info *PlayStreamInfo) StreamType() string {
	var _arg0 *C.GstPlayStreamInfo // out
	var _cret *C.gchar             // in

	_arg0 = (*C.GstPlayStreamInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_stream_info_get_stream_type(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
//   - tagList (optional) tags contained in this stream.
func (info *PlayStreamInfo) Tags() *gst.TagList {
	var _arg0 *C.GstPlayStreamInfo // out
	var _cret *C.GstTagList        // in

	_arg0 = (*C.GstPlayStreamInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_stream_info_get_tags(_arg0)
	runtime.KeepAlive(info)

	var _tagList *gst.TagList // out

	if _cret != nil {
		_tagList = (*gst.TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _tagList
}

// PlaySubtitleInfo specific to subtitle streams.
type PlaySubtitleInfo struct {
	_ [0]func() // equal guard
	PlayStreamInfo
}

var (
	_ PlayStreamInfor = (*PlaySubtitleInfo)(nil)
)

func wrapPlaySubtitleInfo(obj *coreglib.Object) *PlaySubtitleInfo {
	return &PlaySubtitleInfo{
		PlayStreamInfo: PlayStreamInfo{
			Object: obj,
		},
	}
}

func marshalPlaySubtitleInfo(p uintptr) (interface{}, error) {
	return wrapPlaySubtitleInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function returns the following values:
//
//   - utf8 (optional): language of the stream, or NULL if unknown.
func (info *PlaySubtitleInfo) Language() string {
	var _arg0 *C.GstPlaySubtitleInfo // out
	var _cret *C.gchar               // in

	_arg0 = (*C.GstPlaySubtitleInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_subtitle_info_get_language(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// PlayVideoInfo specific to video streams.
type PlayVideoInfo struct {
	_ [0]func() // equal guard
	PlayStreamInfo
}

var (
	_ PlayStreamInfor = (*PlayVideoInfo)(nil)
)

func wrapPlayVideoInfo(obj *coreglib.Object) *PlayVideoInfo {
	return &PlayVideoInfo{
		PlayStreamInfo: PlayStreamInfo{
			Object: obj,
		},
	}
}

func marshalPlayVideoInfo(p uintptr) (interface{}, error) {
	return wrapPlayVideoInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function returns the following values:
//
//   - gint: current bitrate of video in PlayVideoInfo or -1 if unknown.
func (info *PlayVideoInfo) Bitrate() int {
	var _arg0 *C.GstPlayVideoInfo // out
	var _cret C.gint              // in

	_arg0 = (*C.GstPlayVideoInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_video_info_get_bitrate(_arg0)
	runtime.KeepAlive(info)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
//   - fpsN: numerator of frame rate.
//   - fpsD: denominator of frame rate.
func (info *PlayVideoInfo) Framerate() (fpsN, fpsD int) {
	var _arg0 *C.GstPlayVideoInfo // out
	var _arg1 C.gint              // in
	var _arg2 C.gint              // in

	_arg0 = (*C.GstPlayVideoInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	C.gst_play_video_info_get_framerate(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(info)

	var _fpsN int // out
	var _fpsD int // out

	_fpsN = int(_arg1)
	_fpsD = int(_arg2)

	return _fpsN, _fpsD
}

// The function returns the following values:
//
//   - gint: height of video in PlayVideoInfo or -1 if unknown.
func (info *PlayVideoInfo) Height() int {
	var _arg0 *C.GstPlayVideoInfo // out
	var _cret C.gint              // in

	_arg0 = (*C.GstPlayVideoInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_video_info_get_height(_arg0)
	runtime.KeepAlive(info)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
//   - gint: maximum bitrate of video in PlayVideoInfo or -1 if unknown.
func (info *PlayVideoInfo) MaxBitrate() int {
	var _arg0 *C.GstPlayVideoInfo // out
	var _cret C.gint              // in

	_arg0 = (*C.GstPlayVideoInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_video_info_get_max_bitrate(_arg0)
	runtime.KeepAlive(info)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PixelAspectRatio returns the pixel aspect ratio in par_n and par_d.
//
// The function returns the following values:
//
//   - parN: numerator.
//   - parD: denominator.
func (info *PlayVideoInfo) PixelAspectRatio() (parN, parD uint) {
	var _arg0 *C.GstPlayVideoInfo // out
	var _arg1 C.guint             // in
	var _arg2 C.guint             // in

	_arg0 = (*C.GstPlayVideoInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	C.gst_play_video_info_get_pixel_aspect_ratio(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(info)

	var _parN uint // out
	var _parD uint // out

	_parN = uint(_arg1)
	_parD = uint(_arg2)

	return _parN, _parD
}

// The function returns the following values:
//
//   - gint: width of video in PlayVideoInfo or -1 if unknown.
func (info *PlayVideoInfo) Width() int {
	var _arg0 *C.GstPlayVideoInfo // out
	var _cret C.gint              // in

	_arg0 = (*C.GstPlayVideoInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_play_video_info_get_width(_arg0)
	runtime.KeepAlive(info)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

type PlayVideoOverlayVideoRenderer struct {
	_ [0]func() // equal guard
	*coreglib.Object

	PlayVideoRenderer
}

var (
	_ coreglib.Objector = (*PlayVideoOverlayVideoRenderer)(nil)
)

func wrapPlayVideoOverlayVideoRenderer(obj *coreglib.Object) *PlayVideoOverlayVideoRenderer {
	return &PlayVideoOverlayVideoRenderer{
		Object: obj,
		PlayVideoRenderer: PlayVideoRenderer{
			Object: obj,
		},
	}
}

func marshalPlayVideoOverlayVideoRenderer(p uintptr) (interface{}, error) {
	return wrapPlayVideoOverlayVideoRenderer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Expose: tell an overlay that it has been exposed. This will redraw the
// current frame in the drawable even if the pipeline is PAUSED.
func (self *PlayVideoOverlayVideoRenderer) Expose() {
	var _arg0 *C.GstPlayVideoOverlayVideoRenderer // out

	_arg0 = (*C.GstPlayVideoOverlayVideoRenderer)(unsafe.Pointer(coreglib.BaseObject(self).Native()))

	C.gst_play_video_overlay_video_renderer_expose(_arg0)
	runtime.KeepAlive(self)
}

// RenderRectangle: return the currently configured render rectangle. See
// gst_play_video_overlay_video_renderer_set_render_rectangle() for details.
//
// The function returns the following values:
//
//   - x (optional): horizontal offset of the render area inside the window.
//   - y (optional): vertical offset of the render area inside the window.
//   - width (optional) of the render area inside the window.
//   - height (optional) of the render area inside the window.
func (self *PlayVideoOverlayVideoRenderer) RenderRectangle() (x, y, width, height int) {
	var _arg0 *C.GstPlayVideoOverlayVideoRenderer // out
	var _arg1 C.gint                              // in
	var _arg2 C.gint                              // in
	var _arg3 C.gint                              // in
	var _arg4 C.gint                              // in

	_arg0 = (*C.GstPlayVideoOverlayVideoRenderer)(unsafe.Pointer(coreglib.BaseObject(self).Native()))

	C.gst_play_video_overlay_video_renderer_get_render_rectangle(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(self)

	var _x int      // out
	var _y int      // out
	var _width int  // out
	var _height int // out

	_x = int(_arg1)
	_y = int(_arg2)
	_width = int(_arg3)
	_height = int(_arg4)

	return _x, _y, _width, _height
}

// The function returns the following values:
//
//   - gpointer (optional): currently set, platform specific window handle.
func (self *PlayVideoOverlayVideoRenderer) WindowHandle() unsafe.Pointer {
	var _arg0 *C.GstPlayVideoOverlayVideoRenderer // out
	var _cret C.gpointer                          // in

	_arg0 = (*C.GstPlayVideoOverlayVideoRenderer)(unsafe.Pointer(coreglib.BaseObject(self).Native()))

	_cret = C.gst_play_video_overlay_video_renderer_get_window_handle(_arg0)
	runtime.KeepAlive(self)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// SetRenderRectangle: configure a subregion as a video target within the window
// set by gst_play_video_overlay_video_renderer_set_window_handle(). If this is
// not used or not supported the video will fill the area of the window set as
// the overlay to 100%. By specifying the rectangle, the video can be overlaid
// to a specific region of that window only. After setting the new rectangle one
// should call gst_play_video_overlay_video_renderer_expose() to force a redraw.
// To unset the region pass -1 for the width and height parameters.
//
// This method is needed for non fullscreen video overlay in UI toolkits that do
// not support subwindows.
//
// The function takes the following parameters:
//
//   - x: horizontal offset of the render area inside the window.
//   - y: vertical offset of the render area inside the window.
//   - width of the render area inside the window.
//   - height of the render area inside the window.
func (self *PlayVideoOverlayVideoRenderer) SetRenderRectangle(x, y, width, height int) {
	var _arg0 *C.GstPlayVideoOverlayVideoRenderer // out
	var _arg1 C.gint                              // out
	var _arg2 C.gint                              // out
	var _arg3 C.gint                              // out
	var _arg4 C.gint                              // out

	_arg0 = (*C.GstPlayVideoOverlayVideoRenderer)(unsafe.Pointer(coreglib.BaseObject(self).Native()))
	_arg1 = C.gint(x)
	_arg2 = C.gint(y)
	_arg3 = C.gint(width)
	_arg4 = C.gint(height)

	C.gst_play_video_overlay_video_renderer_set_render_rectangle(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(self)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// SetWindowHandle sets the platform specific window handle into which the video
// should be rendered.
//
// The function takes the following parameters:
//
//   - windowHandle (optional): handle referencing to the platform specific
//     window.
func (self *PlayVideoOverlayVideoRenderer) SetWindowHandle(windowHandle unsafe.Pointer) {
	var _arg0 *C.GstPlayVideoOverlayVideoRenderer // out
	var _arg1 C.gpointer                          // out

	_arg0 = (*C.GstPlayVideoOverlayVideoRenderer)(unsafe.Pointer(coreglib.BaseObject(self).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(windowHandle))

	C.gst_play_video_overlay_video_renderer_set_window_handle(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(windowHandle)
}

// The function takes the following parameters:
//
//   - windowHandle (optional): window handle to use or NULL.
func NewPlayVideoOverlayVideoRenderer(windowHandle unsafe.Pointer) *PlayVideoRenderer {
	var _arg1 C.gpointer              // out
	var _cret *C.GstPlayVideoRenderer // in

	_arg1 = (C.gpointer)(unsafe.Pointer(windowHandle))

	_cret = C.gst_play_video_overlay_video_renderer_new(_arg1)
	runtime.KeepAlive(windowHandle)

	var _playVideoRenderer *PlayVideoRenderer // out

	_playVideoRenderer = wrapPlayVideoRenderer(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _playVideoRenderer
}

// The function takes the following parameters:
//
//   - windowHandle (optional): window handle to use or NULL.
//   - videoSink: custom video_sink element to be set for the video renderer.
func NewPlayVideoOverlayVideoRendererWithSink(windowHandle unsafe.Pointer, videoSink gst.Elementer) *PlayVideoRenderer {
	var _arg1 C.gpointer              // out
	var _arg2 *C.GstElement           // out
	var _cret *C.GstPlayVideoRenderer // in

	_arg1 = (C.gpointer)(unsafe.Pointer(windowHandle))
	_arg2 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(videoSink).Native()))

	_cret = C.gst_play_video_overlay_video_renderer_new_with_sink(_arg1, _arg2)
	runtime.KeepAlive(windowHandle)
	runtime.KeepAlive(videoSink)

	var _playVideoRenderer *PlayVideoRenderer // out

	_playVideoRenderer = wrapPlayVideoRenderer(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _playVideoRenderer
}

// PlayVideoRendererInterface: instance of this type is always passed by
// reference.
type PlayVideoRendererInterface struct {
	*playVideoRendererInterface
}

// playVideoRendererInterface is the struct that's finalized.
type playVideoRendererInterface struct {
	native *C.GstPlayVideoRendererInterface
}

// PlayVisualization descriptor.
//
// An instance of this type is always passed by reference.
type PlayVisualization struct {
	*playVisualization
}

// playVisualization is the struct that's finalized.
type playVisualization struct {
	native *C.GstPlayVisualization
}

func marshalPlayVisualization(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &PlayVisualization{&playVisualization{(*C.GstPlayVisualization)(b)}}, nil
}

// Name: name of the visualization.
func (p *PlayVisualization) Name() string {
	valptr := &p.native.name
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Description: description of the visualization.
func (p *PlayVisualization) Description() string {
	valptr := &p.native.description
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Copy makes a copy of the PlayVisualization. The result must be freed using
// gst_play_visualization_free().
//
// The function returns the following values:
//
//   - playVisualization: allocated copy of vis.
func (vis *PlayVisualization) Copy() *PlayVisualization {
	var _arg0 *C.GstPlayVisualization // out
	var _cret *C.GstPlayVisualization // in

	_arg0 = (*C.GstPlayVisualization)(gextras.StructNative(unsafe.Pointer(vis)))

	_cret = C.gst_play_visualization_copy(_arg0)
	runtime.KeepAlive(vis)

	var _playVisualization *PlayVisualization // out

	_playVisualization = (*PlayVisualization)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_playVisualization)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_play_visualization_free((*C.GstPlayVisualization)(intern.C))
		},
	)

	return _playVisualization
}
