// Code generated by girgen. DO NOT EDIT.

package gst

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gst.h>
import "C"

//export _gotk4_gst1_BufferForEachMetaFunc
func _gotk4_gst1_BufferForEachMetaFunc(arg1 *C.GstBuffer, arg2 **C.GstMeta, arg3 C.gpointer) (cret C.gboolean) {
	var fn BufferForEachMetaFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(BufferForEachMetaFunc)
	}

	var _buffer *Buffer // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.gst_mini_object_ref((*C.GstMiniObject)(unsafe.Pointer(arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	meta, ok := fn(_buffer)

	var _ *Meta
	var _ bool

	if meta != nil {
		*arg2 = (*C.GstMeta)(gextras.StructNative(unsafe.Pointer(meta)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(meta)), nil)
	}
	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_BufferListFunc
func _gotk4_gst1_BufferListFunc(arg1 **C.GstBuffer, arg2 C.guint, arg3 C.gpointer) (cret C.gboolean) {
	var fn BufferListFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(BufferListFunc)
	}

	var _idx uint // out

	_idx = uint(arg2)

	buffer, ok := fn(_idx)

	var _ *Buffer
	var _ bool

	if buffer != nil {
		*arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)
	}
	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_BusFunc
func _gotk4_gst1_BusFunc(arg1 *C.GstBus, arg2 *C.GstMessage, arg3 C.gpointer) (cret C.gboolean) {
	var fn BusFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(BusFunc)
	}

	var _bus *Bus         // out
	var _message *Message // out

	_bus = wrapBus(coreglib.Take(unsafe.Pointer(arg1)))
	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	C.gst_mini_object_ref((*C.GstMiniObject)(unsafe.Pointer(arg2)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	ok := fn(_bus, _message)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_BusSyncHandler
func _gotk4_gst1_BusSyncHandler(arg1 *C.GstBus, arg2 *C.GstMessage, arg3 C.gpointer) (cret C.GstBusSyncReply) {
	var fn BusSyncHandler
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(BusSyncHandler)
	}

	var _bus *Bus         // out
	var _message *Message // out

	_bus = wrapBus(coreglib.Take(unsafe.Pointer(arg1)))
	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	C.gst_mini_object_ref((*C.GstMiniObject)(unsafe.Pointer(arg2)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	busSyncReply := fn(_bus, _message)

	var _ BusSyncReply

	cret = C.GstBusSyncReply(busSyncReply)

	return cret
}

//export _gotk4_gst1_CapsFilterMapFunc
func _gotk4_gst1_CapsFilterMapFunc(arg1 *C.GstCapsFeatures, arg2 *C.GstStructure, arg3 C.gpointer) (cret C.gboolean) {
	var fn CapsFilterMapFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(CapsFilterMapFunc)
	}

	var _features *CapsFeatures // out
	var _structure *Structure   // out

	_features = (*CapsFeatures)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	C.gst_mini_object_ref((*C.GstMiniObject)(unsafe.Pointer(arg2)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_structure)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	ok := fn(_features, _structure)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_CapsForEachFunc
func _gotk4_gst1_CapsForEachFunc(arg1 *C.GstCapsFeatures, arg2 *C.GstStructure, arg3 C.gpointer) (cret C.gboolean) {
	var fn CapsForEachFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(CapsForEachFunc)
	}

	var _features *CapsFeatures // out
	var _structure *Structure   // out

	_features = (*CapsFeatures)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	C.gst_mini_object_ref((*C.GstMiniObject)(unsafe.Pointer(arg2)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_structure)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	ok := fn(_features, _structure)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_CapsMapFunc
func _gotk4_gst1_CapsMapFunc(arg1 *C.GstCapsFeatures, arg2 *C.GstStructure, arg3 C.gpointer) (cret C.gboolean) {
	var fn CapsMapFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(CapsMapFunc)
	}

	var _features *CapsFeatures // out
	var _structure *Structure   // out

	_features = (*CapsFeatures)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_structure = (*Structure)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	C.gst_mini_object_ref((*C.GstMiniObject)(unsafe.Pointer(arg2)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_structure)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	ok := fn(_features, _structure)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_ClockCallback
func _gotk4_gst1_ClockCallback(arg1 *C.GstClock, arg2 C.GstClockTime, arg3 C.GstClockID, arg4 C.gpointer) (cret C.gboolean) {
	var fn ClockCallback
	{
		v := gbox.Get(uintptr(arg4))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(ClockCallback)
	}

	var _clock Clocker  // out
	var _time ClockTime // out
	var _id ClockID     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gst.Clocker is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Clocker)
			return ok
		})
		rv, ok := casted.(Clocker)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Clocker")
		}
		_clock = rv
	}
	_time = ClockTime(arg2)
	_id = (ClockID)(unsafe.Pointer(arg3))

	ok := fn(_clock, _time, _id)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_CustomMetaTransformFunction
func _gotk4_gst1_CustomMetaTransformFunction(arg1 *C.GstBuffer, arg2 *C.GstCustomMeta, arg3 *C.GstBuffer, arg4 C.GQuark, arg5 C.gpointer, arg6 C.gpointer) (cret C.gboolean) {
	var fn CustomMetaTransformFunction
	{
		v := gbox.Get(uintptr(arg6))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(CustomMetaTransformFunction)
	}

	var _transbuf *Buffer    // out
	var _meta *CustomMeta    // out
	var _buffer *Buffer      // out
	var _typ glib.Quark      // out
	var _data unsafe.Pointer // out

	_transbuf = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.gst_mini_object_ref((*C.GstMiniObject)(unsafe.Pointer(arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transbuf)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})
	_meta = (*CustomMeta)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	C.gst_mini_object_ref((*C.GstMiniObject)(unsafe.Pointer(arg3)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})
	_typ = glib.Quark(arg4)
	_data = (unsafe.Pointer)(unsafe.Pointer(arg5))

	ok := fn(_transbuf, _meta, _buffer, _typ, _data)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_ElementCallAsyncFunc
func _gotk4_gst1_ElementCallAsyncFunc(arg1 *C.GstElement, arg2 C.gpointer) {
	var fn ElementCallAsyncFunc
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(ElementCallAsyncFunc)
	}

	var _element Elementer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}

	fn(_element)
}

//export _gotk4_gst1_ElementForEachPadFunc
func _gotk4_gst1_ElementForEachPadFunc(arg1 *C.GstElement, arg2 *C.GstPad, arg3 C.gpointer) (cret C.gboolean) {
	var fn ElementForEachPadFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(ElementForEachPadFunc)
	}

	var _element Elementer // out
	var _pad *Pad          // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}
	_pad = wrapPad(coreglib.Take(unsafe.Pointer(arg2)))

	ok := fn(_element, _pad)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_IteratorFoldFunction
func _gotk4_gst1_IteratorFoldFunction(arg1 *C.GValue, arg2 *C.GValue, arg3 C.gpointer) (cret C.gboolean) {
	var fn IteratorFoldFunction
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(IteratorFoldFunction)
	}

	var _item *coreglib.Value // out
	var _ret *coreglib.Value  // out

	_item = coreglib.ValueFromNative(unsafe.Pointer(arg1))
	_ret = coreglib.ValueFromNative(unsafe.Pointer(arg2))

	ok := fn(_item, _ret)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_IteratorForEachFunction
func _gotk4_gst1_IteratorForEachFunction(arg1 *C.GValue, arg2 C.gpointer) {
	var fn IteratorForEachFunction
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(IteratorForEachFunction)
	}

	var _item *coreglib.Value // out

	_item = coreglib.ValueFromNative(unsafe.Pointer(arg1))

	fn(_item)
}

//export _gotk4_gst1_MiniObjectNotify
func _gotk4_gst1_MiniObjectNotify(arg1 C.gpointer, arg2 *C.GstMiniObject) {
	var fn MiniObjectNotify
	{
		v := gbox.Get(uintptr(arg1))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(MiniObjectNotify)
	}

	var _obj *MiniObject // out

	_obj = (*MiniObject)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	C.gst_mini_object_ref((*C.GstMiniObject)(unsafe.Pointer(arg2)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_obj)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	fn(_obj)
}

//export _gotk4_gst1_PadForwardFunction
func _gotk4_gst1_PadForwardFunction(arg1 *C.GstPad, arg2 C.gpointer) (cret C.gboolean) {
	var fn PadForwardFunction
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(PadForwardFunction)
	}

	var _pad *Pad // out

	_pad = wrapPad(coreglib.Take(unsafe.Pointer(arg1)))

	ok := fn(_pad)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_PadProbeCallback
func _gotk4_gst1_PadProbeCallback(arg1 *C.GstPad, arg2 *C.GstPadProbeInfo, arg3 C.gpointer) (cret C.GstPadProbeReturn) {
	var fn PadProbeCallback
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(PadProbeCallback)
	}

	var _pad *Pad           // out
	var _info *PadProbeInfo // out

	_pad = wrapPad(coreglib.Take(unsafe.Pointer(arg1)))
	_info = (*PadProbeInfo)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	padProbeReturn := fn(_pad, _info)

	var _ PadProbeReturn

	cret = C.GstPadProbeReturn(padProbeReturn)

	return cret
}

//export _gotk4_gst1_PadStickyEventsForEachFunction
func _gotk4_gst1_PadStickyEventsForEachFunction(arg1 *C.GstPad, arg2 **C.GstEvent, arg3 C.gpointer) (cret C.gboolean) {
	var fn PadStickyEventsForEachFunction
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(PadStickyEventsForEachFunction)
	}

	var _pad *Pad     // out
	var _event *Event // out

	_pad = wrapPad(coreglib.Take(unsafe.Pointer(arg1)))
	if arg2 != nil {
		_event = (*Event)(gextras.NewStructNative(unsafe.Pointer((*arg2))))
	}

	ok := fn(_pad, _event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_PluginFeatureFilter
func _gotk4_gst1_PluginFeatureFilter(arg1 *C.GstPluginFeature, arg2 C.gpointer) (cret C.gboolean) {
	var fn PluginFeatureFilter
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(PluginFeatureFilter)
	}

	var _feature PluginFeaturer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gst.PluginFeaturer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(PluginFeaturer)
			return ok
		})
		rv, ok := casted.(PluginFeaturer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.PluginFeaturer")
		}
		_feature = rv
	}

	ok := fn(_feature)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_PluginFilter
func _gotk4_gst1_PluginFilter(arg1 *C.GstPlugin, arg2 C.gpointer) (cret C.gboolean) {
	var fn PluginFilter
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(PluginFilter)
	}

	var _plugin *Plugin // out

	_plugin = wrapPlugin(coreglib.Take(unsafe.Pointer(arg1)))

	ok := fn(_plugin)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_PluginInitFullFunc
func _gotk4_gst1_PluginInitFullFunc(arg1 *C.GstPlugin, arg2 C.gpointer) (cret C.gboolean) {
	var fn PluginInitFullFunc
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(PluginInitFullFunc)
	}

	var _plugin *Plugin // out

	_plugin = wrapPlugin(coreglib.Take(unsafe.Pointer(arg1)))

	ok := fn(_plugin)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_PromiseChangeFunc
func _gotk4_gst1_PromiseChangeFunc(arg1 *C.GstPromise, arg2 C.gpointer) {
	var fn PromiseChangeFunc
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(PromiseChangeFunc)
	}

	var _promise *Promise // out

	_promise = (*Promise)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	fn(_promise)
}

//export _gotk4_gst1_StructureFilterMapFunc
func _gotk4_gst1_StructureFilterMapFunc(arg1 C.GQuark, arg2 *C.GValue, arg3 C.gpointer) (cret C.gboolean) {
	var fn StructureFilterMapFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(StructureFilterMapFunc)
	}

	var _fieldId glib.Quark    // out
	var _value *coreglib.Value // out

	_fieldId = glib.Quark(arg1)
	_value = coreglib.ValueFromNative(unsafe.Pointer(arg2))

	ok := fn(_fieldId, _value)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_StructureForEachFunc
func _gotk4_gst1_StructureForEachFunc(arg1 C.GQuark, arg2 *C.GValue, arg3 C.gpointer) (cret C.gboolean) {
	var fn StructureForEachFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(StructureForEachFunc)
	}

	var _fieldId glib.Quark    // out
	var _value *coreglib.Value // out

	_fieldId = glib.Quark(arg1)
	_value = coreglib.ValueFromNative(unsafe.Pointer(arg2))

	ok := fn(_fieldId, _value)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_StructureMapFunc
func _gotk4_gst1_StructureMapFunc(arg1 C.GQuark, arg2 *C.GValue, arg3 C.gpointer) (cret C.gboolean) {
	var fn StructureMapFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(StructureMapFunc)
	}

	var _fieldId glib.Quark    // out
	var _value *coreglib.Value // out

	_fieldId = glib.Quark(arg1)
	_value = coreglib.ValueFromNative(unsafe.Pointer(arg2))

	ok := fn(_fieldId, _value)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_TagForEachFunc
func _gotk4_gst1_TagForEachFunc(arg1 *C.GstTagList, arg2 *C.gchar, arg3 C.gpointer) {
	var fn TagForEachFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TagForEachFunc)
	}

	var _list *TagList // out
	var _tag string    // out

	_list = (*TagList)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_tag = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	fn(_list, _tag)
}

//export _gotk4_gst1_TaskFunction
func _gotk4_gst1_TaskFunction(arg1 C.gpointer) {
	var fn TaskFunction
	{
		v := gbox.Get(uintptr(arg1))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TaskFunction)
	}

	fn()
}

//export _gotk4_gst1_TypeFindFunction
func _gotk4_gst1_TypeFindFunction(arg1 *C.GstTypeFind, arg2 C.gpointer) {
	var fn TypeFindFunction
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TypeFindFunction)
	}

	var _find *TypeFind // out

	_find = (*TypeFind)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	fn(_find)
}

//export _gotk4_gst1_ChildProxy_ConnectChildAdded
func _gotk4_gst1_ChildProxy_ConnectChildAdded(arg0 C.gpointer, arg1 *C.GObject, arg2 *C.gchar, arg3 C.guintptr) {
	var f func(object *coreglib.Object, name string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object *coreglib.Object, name string))
	}

	var _object *coreglib.Object // out
	var _name string             // out

	_object = coreglib.Take(unsafe.Pointer(arg1))
	_name = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	f(_object, _name)
}

//export _gotk4_gst1_ChildProxy_ConnectChildRemoved
func _gotk4_gst1_ChildProxy_ConnectChildRemoved(arg0 C.gpointer, arg1 *C.GObject, arg2 *C.gchar, arg3 C.guintptr) {
	var f func(object *coreglib.Object, name string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object *coreglib.Object, name string))
	}

	var _object *coreglib.Object // out
	var _name string             // out

	_object = coreglib.Take(unsafe.Pointer(arg1))
	_name = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	f(_object, _name)
}

//export _gotk4_gst1_AllocatorClass_alloc
func _gotk4_gst1_AllocatorClass_alloc(arg0 *C.GstAllocator, arg1 C.gsize, arg2 *C.GstAllocationParams) (cret *C.GstMemory) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AllocatorOverrides](instance0)
	if overrides.Alloc == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AllocatorOverrides.Alloc, got none")
	}

	var _size uint                // out
	var _params *AllocationParams // out

	_size = uint(arg1)
	if arg2 != nil {
		_params = (*AllocationParams)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	}

	memory := overrides.Alloc(_size, _params)

	var _ *Memory

	if memory != nil {
		cret = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(memory)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(memory)), nil)
	}

	return cret
}

//export _gotk4_gst1_BinClass_add_element
func _gotk4_gst1_BinClass_add_element(arg0 *C.GstBin, arg1 *C.GstElement) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BinOverrides](instance0)
	if overrides.AddElement == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BinOverrides.AddElement, got none")
	}

	var _element Elementer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}

	ok := overrides.AddElement(_element)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_BinClass_deep_element_added
func _gotk4_gst1_BinClass_deep_element_added(arg0 *C.GstBin, arg1 *C.GstBin, arg2 *C.GstElement) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BinOverrides](instance0)
	if overrides.DeepElementAdded == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BinOverrides.DeepElementAdded, got none")
	}

	var _subBin *Bin     // out
	var _child Elementer // out

	_subBin = wrapBin(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_child = rv
	}

	overrides.DeepElementAdded(_subBin, _child)
}

//export _gotk4_gst1_BinClass_deep_element_removed
func _gotk4_gst1_BinClass_deep_element_removed(arg0 *C.GstBin, arg1 *C.GstBin, arg2 *C.GstElement) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BinOverrides](instance0)
	if overrides.DeepElementRemoved == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BinOverrides.DeepElementRemoved, got none")
	}

	var _subBin *Bin     // out
	var _child Elementer // out

	_subBin = wrapBin(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_child = rv
	}

	overrides.DeepElementRemoved(_subBin, _child)
}

//export _gotk4_gst1_BinClass_do_latency
func _gotk4_gst1_BinClass_do_latency(arg0 *C.GstBin) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BinOverrides](instance0)
	if overrides.DoLatency == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BinOverrides.DoLatency, got none")
	}

	ok := overrides.DoLatency()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_BinClass_element_added
func _gotk4_gst1_BinClass_element_added(arg0 *C.GstBin, arg1 *C.GstElement) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BinOverrides](instance0)
	if overrides.ElementAdded == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BinOverrides.ElementAdded, got none")
	}

	var _child Elementer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_child = rv
	}

	overrides.ElementAdded(_child)
}

//export _gotk4_gst1_BinClass_element_removed
func _gotk4_gst1_BinClass_element_removed(arg0 *C.GstBin, arg1 *C.GstElement) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BinOverrides](instance0)
	if overrides.ElementRemoved == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BinOverrides.ElementRemoved, got none")
	}

	var _child Elementer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_child = rv
	}

	overrides.ElementRemoved(_child)
}

//export _gotk4_gst1_BinClass_handle_message
func _gotk4_gst1_BinClass_handle_message(arg0 *C.GstBin, arg1 *C.GstMessage) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BinOverrides](instance0)
	if overrides.HandleMessage == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BinOverrides.HandleMessage, got none")
	}

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	overrides.HandleMessage(_message)
}

//export _gotk4_gst1_BinClass_remove_element
func _gotk4_gst1_BinClass_remove_element(arg0 *C.GstBin, arg1 *C.GstElement) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BinOverrides](instance0)
	if overrides.RemoveElement == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BinOverrides.RemoveElement, got none")
	}

	var _element Elementer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}

	ok := overrides.RemoveElement(_element)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_Bin_ConnectDeepElementAdded
func _gotk4_gst1_Bin_ConnectDeepElementAdded(arg0 C.gpointer, arg1 *C.GstBin, arg2 *C.GstElement, arg3 C.guintptr) {
	var f func(subBin *Bin, element Elementer)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(subBin *Bin, element Elementer))
	}

	var _subBin *Bin       // out
	var _element Elementer // out

	_subBin = wrapBin(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}

	f(_subBin, _element)
}

//export _gotk4_gst1_Bin_ConnectDeepElementRemoved
func _gotk4_gst1_Bin_ConnectDeepElementRemoved(arg0 C.gpointer, arg1 *C.GstBin, arg2 *C.GstElement, arg3 C.guintptr) {
	var f func(subBin *Bin, element Elementer)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(subBin *Bin, element Elementer))
	}

	var _subBin *Bin       // out
	var _element Elementer // out

	_subBin = wrapBin(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}

	f(_subBin, _element)
}

//export _gotk4_gst1_Bin_ConnectDoLatency
func _gotk4_gst1_Bin_ConnectDoLatency(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_Bin_ConnectElementAdded
func _gotk4_gst1_Bin_ConnectElementAdded(arg0 C.gpointer, arg1 *C.GstElement, arg2 C.guintptr) {
	var f func(element Elementer)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(element Elementer))
	}

	var _element Elementer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}

	f(_element)
}

//export _gotk4_gst1_Bin_ConnectElementRemoved
func _gotk4_gst1_Bin_ConnectElementRemoved(arg0 C.gpointer, arg1 *C.GstElement, arg2 C.guintptr) {
	var f func(element Elementer)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(element Elementer))
	}

	var _element Elementer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}

	f(_element)
}

//export _gotk4_gst1_BufferPoolClass_acquire_buffer
func _gotk4_gst1_BufferPoolClass_acquire_buffer(arg0 *C.GstBufferPool, arg1 **C.GstBuffer, arg2 *C.GstBufferPoolAcquireParams) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BufferPoolOverrides](instance0)
	if overrides.AcquireBuffer == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BufferPoolOverrides.AcquireBuffer, got none")
	}

	var _params *BufferPoolAcquireParams // out

	if arg2 != nil {
		_params = (*BufferPoolAcquireParams)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	}

	buffer, flowReturn := overrides.AcquireBuffer(_params)

	var _ *Buffer
	var _ FlowReturn

	if buffer != nil {
		*arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)
	}
	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gst1_BufferPoolClass_alloc_buffer
func _gotk4_gst1_BufferPoolClass_alloc_buffer(arg0 *C.GstBufferPool, arg1 **C.GstBuffer, arg2 *C.GstBufferPoolAcquireParams) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BufferPoolOverrides](instance0)
	if overrides.AllocBuffer == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BufferPoolOverrides.AllocBuffer, got none")
	}

	var _params *BufferPoolAcquireParams // out

	if arg2 != nil {
		_params = (*BufferPoolAcquireParams)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	}

	buffer, flowReturn := overrides.AllocBuffer(_params)

	var _ *Buffer
	var _ FlowReturn

	if buffer != nil {
		*arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)
	}
	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gst1_BufferPoolClass_flush_start
func _gotk4_gst1_BufferPoolClass_flush_start(arg0 *C.GstBufferPool) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BufferPoolOverrides](instance0)
	if overrides.FlushStart == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BufferPoolOverrides.FlushStart, got none")
	}

	overrides.FlushStart()
}

//export _gotk4_gst1_BufferPoolClass_flush_stop
func _gotk4_gst1_BufferPoolClass_flush_stop(arg0 *C.GstBufferPool) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BufferPoolOverrides](instance0)
	if overrides.FlushStop == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BufferPoolOverrides.FlushStop, got none")
	}

	overrides.FlushStop()
}

//export _gotk4_gst1_BufferPoolClass_free_buffer
func _gotk4_gst1_BufferPoolClass_free_buffer(arg0 *C.GstBufferPool, arg1 *C.GstBuffer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BufferPoolOverrides](instance0)
	if overrides.FreeBuffer == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BufferPoolOverrides.FreeBuffer, got none")
	}

	var _buffer *Buffer // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.gst_mini_object_ref((*C.GstMiniObject)(unsafe.Pointer(arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	overrides.FreeBuffer(_buffer)
}

//export _gotk4_gst1_BufferPoolClass_get_options
func _gotk4_gst1_BufferPoolClass_get_options(arg0 *C.GstBufferPool) (cret **C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BufferPoolOverrides](instance0)
	if overrides.Options == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BufferPoolOverrides.Options, got none")
	}

	utf8s := overrides.Options()

	var _ []string

	{
		cret = (**C.gchar)(C.calloc(C.size_t((len(utf8s) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(cret))
		{
			out := unsafe.Slice(cret, len(utf8s)+1)
			var zero *C.gchar
			out[len(utf8s)] = zero
			for i := range utf8s {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(utf8s[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	return cret
}

//export _gotk4_gst1_BufferPoolClass_release_buffer
func _gotk4_gst1_BufferPoolClass_release_buffer(arg0 *C.GstBufferPool, arg1 *C.GstBuffer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BufferPoolOverrides](instance0)
	if overrides.ReleaseBuffer == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BufferPoolOverrides.ReleaseBuffer, got none")
	}

	var _buffer *Buffer // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	overrides.ReleaseBuffer(_buffer)
}

//export _gotk4_gst1_BufferPoolClass_reset_buffer
func _gotk4_gst1_BufferPoolClass_reset_buffer(arg0 *C.GstBufferPool, arg1 *C.GstBuffer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BufferPoolOverrides](instance0)
	if overrides.ResetBuffer == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BufferPoolOverrides.ResetBuffer, got none")
	}

	var _buffer *Buffer // out

	_buffer = (*Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.gst_mini_object_ref((*C.GstMiniObject)(unsafe.Pointer(arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	overrides.ResetBuffer(_buffer)
}

//export _gotk4_gst1_BufferPoolClass_set_config
func _gotk4_gst1_BufferPoolClass_set_config(arg0 *C.GstBufferPool, arg1 *C.GstStructure) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BufferPoolOverrides](instance0)
	if overrides.SetConfig == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BufferPoolOverrides.SetConfig, got none")
	}

	var _config *Structure // out

	_config = (*Structure)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_config)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	ok := overrides.SetConfig(_config)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_BufferPoolClass_start
func _gotk4_gst1_BufferPoolClass_start(arg0 *C.GstBufferPool) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BufferPoolOverrides](instance0)
	if overrides.Start == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BufferPoolOverrides.Start, got none")
	}

	ok := overrides.Start()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_BufferPoolClass_stop
func _gotk4_gst1_BufferPoolClass_stop(arg0 *C.GstBufferPool) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BufferPoolOverrides](instance0)
	if overrides.Stop == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BufferPoolOverrides.Stop, got none")
	}

	ok := overrides.Stop()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_BusClass_message
func _gotk4_gst1_BusClass_message(arg0 *C.GstBus, arg1 *C.GstMessage) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BusOverrides](instance0)
	if overrides.Message == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BusOverrides.Message, got none")
	}

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.gst_mini_object_ref((*C.GstMiniObject)(unsafe.Pointer(arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	overrides.Message(_message)
}

//export _gotk4_gst1_BusClass_sync_message
func _gotk4_gst1_BusClass_sync_message(arg0 *C.GstBus, arg1 *C.GstMessage) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BusOverrides](instance0)
	if overrides.SyncMessage == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BusOverrides.SyncMessage, got none")
	}

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.gst_mini_object_ref((*C.GstMiniObject)(unsafe.Pointer(arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	overrides.SyncMessage(_message)
}

//export _gotk4_gst1_Bus_ConnectMessage
func _gotk4_gst1_Bus_ConnectMessage(arg0 C.gpointer, arg1 *C.GstMessage, arg2 C.guintptr) {
	var f func(message *Message)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(message *Message))
	}

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.gst_mini_object_ref((*C.GstMiniObject)(unsafe.Pointer(arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	f(_message)
}

//export _gotk4_gst1_Bus_ConnectSyncMessage
func _gotk4_gst1_Bus_ConnectSyncMessage(arg0 C.gpointer, arg1 *C.GstMessage, arg2 C.guintptr) {
	var f func(message *Message)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(message *Message))
	}

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.gst_mini_object_ref((*C.GstMiniObject)(unsafe.Pointer(arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	f(_message)
}

//export _gotk4_gst1_ClockClass_change_resolution
func _gotk4_gst1_ClockClass_change_resolution(arg0 *C.GstClock, arg1 C.GstClockTime, arg2 C.GstClockTime) (cret C.GstClockTime) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ClockOverrides](instance0)
	if overrides.ChangeResolution == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ClockOverrides.ChangeResolution, got none")
	}

	var _oldResolution ClockTime // out
	var _newResolution ClockTime // out

	_oldResolution = ClockTime(arg1)
	_newResolution = ClockTime(arg2)

	clockTime := overrides.ChangeResolution(_oldResolution, _newResolution)

	var _ ClockTime

	cret = C.GstClockTime(clockTime)

	return cret
}

//export _gotk4_gst1_ClockClass_get_internal_time
func _gotk4_gst1_ClockClass_get_internal_time(arg0 *C.GstClock) (cret C.GstClockTime) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ClockOverrides](instance0)
	if overrides.InternalTime == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ClockOverrides.InternalTime, got none")
	}

	clockTime := overrides.InternalTime()

	var _ ClockTime

	cret = C.GstClockTime(clockTime)

	return cret
}

//export _gotk4_gst1_ClockClass_get_resolution
func _gotk4_gst1_ClockClass_get_resolution(arg0 *C.GstClock) (cret C.GstClockTime) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ClockOverrides](instance0)
	if overrides.Resolution == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ClockOverrides.Resolution, got none")
	}

	clockTime := overrides.Resolution()

	var _ ClockTime

	cret = C.GstClockTime(clockTime)

	return cret
}

//export _gotk4_gst1_ClockClass_unschedule
func _gotk4_gst1_ClockClass_unschedule(arg0 *C.GstClock, arg1 *C.GstClockEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ClockOverrides](instance0)
	if overrides.Unschedule == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ClockOverrides.Unschedule, got none")
	}

	var _entry *ClockEntry // out

	_entry = (*ClockEntry)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	overrides.Unschedule(_entry)
}

//export _gotk4_gst1_ClockClass_wait
func _gotk4_gst1_ClockClass_wait(arg0 *C.GstClock, arg1 *C.GstClockEntry, arg2 *C.GstClockTimeDiff) (cret C.GstClockReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ClockOverrides](instance0)
	if overrides.Wait == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ClockOverrides.Wait, got none")
	}

	var _entry *ClockEntry // out

	_entry = (*ClockEntry)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	jitter, clockReturn := overrides.Wait(_entry)

	var _ ClockTimeDiff
	var _ ClockReturn

	*arg2 = C.GstClockTimeDiff(jitter)
	cret = C.GstClockReturn(clockReturn)

	return cret
}

//export _gotk4_gst1_ClockClass_wait_async
func _gotk4_gst1_ClockClass_wait_async(arg0 *C.GstClock, arg1 *C.GstClockEntry) (cret C.GstClockReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ClockOverrides](instance0)
	if overrides.WaitAsync == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ClockOverrides.WaitAsync, got none")
	}

	var _entry *ClockEntry // out

	_entry = (*ClockEntry)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	clockReturn := overrides.WaitAsync(_entry)

	var _ ClockReturn

	cret = C.GstClockReturn(clockReturn)

	return cret
}

//export _gotk4_gst1_Clock_ConnectSynced
func _gotk4_gst1_Clock_ConnectSynced(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) {
	var f func(synced bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(synced bool))
	}

	var _synced bool // out

	if arg1 != 0 {
		_synced = true
	}

	f(_synced)
}

//export _gotk4_gst1_ControlBindingClass_get_g_value_array
func _gotk4_gst1_ControlBindingClass_get_g_value_array(arg0 *C.GstControlBinding, arg1 C.GstClockTime, arg2 C.GstClockTime, arg3 C.guint, arg4 *C.GValue) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ControlBindingOverrides](instance0)
	if overrides.GValueArray == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ControlBindingOverrides.GValueArray, got none")
	}

	var _timestamp ClockTime     // out
	var _interval ClockTime      // out
	var _values []coreglib.Value // out

	_timestamp = ClockTime(arg1)
	_interval = ClockTime(arg2)
	{
		src := unsafe.Slice((*C.GValue)(arg4), arg3)
		_values = make([]coreglib.Value, arg3)
		for i := 0; i < int(arg3); i++ {
			_values[i] = *coreglib.ValueFromNative(unsafe.Pointer((&src[i])))
		}
	}

	ok := overrides.GValueArray(_timestamp, _interval, _values)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_ControlBindingClass_get_value
func _gotk4_gst1_ControlBindingClass_get_value(arg0 *C.GstControlBinding, arg1 C.GstClockTime) (cret *C.GValue) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ControlBindingOverrides](instance0)
	if overrides.Value == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ControlBindingOverrides.Value, got none")
	}

	var _timestamp ClockTime // out

	_timestamp = ClockTime(arg1)

	value := overrides.Value(_timestamp)

	var _ *coreglib.Value

	if value != nil {
		cret = (*C.GValue)(unsafe.Pointer(value.Native()))
	}

	return cret
}

//export _gotk4_gst1_ControlBindingClass_sync_values
func _gotk4_gst1_ControlBindingClass_sync_values(arg0 *C.GstControlBinding, arg1 *C.GstObject, arg2 C.GstClockTime, arg3 C.GstClockTime) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ControlBindingOverrides](instance0)
	if overrides.SyncValues == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ControlBindingOverrides.SyncValues, got none")
	}

	var _object GstObjector  // out
	var _timestamp ClockTime // out
	var _lastSync ClockTime  // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gst.GstObjector is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(GstObjector)
			return ok
		})
		rv, ok := casted.(GstObjector)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.GstObjector")
		}
		_object = rv
	}
	_timestamp = ClockTime(arg2)
	_lastSync = ClockTime(arg3)

	ok := overrides.SyncValues(_object, _timestamp, _lastSync)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_DeviceClass_create_element
func _gotk4_gst1_DeviceClass_create_element(arg0 *C.GstDevice, arg1 *C.gchar) (cret *C.GstElement) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[DeviceOverrides](instance0)
	if overrides.CreateElement == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected DeviceOverrides.CreateElement, got none")
	}

	var _name string // out

	if arg1 != nil {
		_name = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	}

	element := overrides.CreateElement(_name)

	var _ Elementer

	if element != nil {
		cret = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	}

	return cret
}

//export _gotk4_gst1_DeviceClass_reconfigure_element
func _gotk4_gst1_DeviceClass_reconfigure_element(arg0 *C.GstDevice, arg1 *C.GstElement) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[DeviceOverrides](instance0)
	if overrides.ReconfigureElement == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected DeviceOverrides.ReconfigureElement, got none")
	}

	var _element Elementer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Elementer)
			return ok
		})
		rv, ok := casted.(Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}

	ok := overrides.ReconfigureElement(_element)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_Device_ConnectRemoved
func _gotk4_gst1_Device_ConnectRemoved(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gst1_DeviceProviderClass_start
func _gotk4_gst1_DeviceProviderClass_start(arg0 *C.GstDeviceProvider) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[DeviceProviderOverrides](instance0)
	if overrides.Start == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected DeviceProviderOverrides.Start, got none")
	}

	ok := overrides.Start()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_DeviceProviderClass_stop
func _gotk4_gst1_DeviceProviderClass_stop(arg0 *C.GstDeviceProvider) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[DeviceProviderOverrides](instance0)
	if overrides.Stop == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected DeviceProviderOverrides.Stop, got none")
	}

	overrides.Stop()
}

//export _gotk4_gst1_DeviceProvider_ConnectProviderHidden
func _gotk4_gst1_DeviceProvider_ConnectProviderHidden(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(object string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object string))
	}

	var _object string // out

	_object = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_object)
}

//export _gotk4_gst1_DeviceProvider_ConnectProviderUnhidden
func _gotk4_gst1_DeviceProvider_ConnectProviderUnhidden(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(object string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object string))
	}

	var _object string // out

	_object = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_object)
}

//export _gotk4_gst1_ElementClass_change_state
func _gotk4_gst1_ElementClass_change_state(arg0 *C.GstElement, arg1 C.GstStateChange) (cret C.GstStateChangeReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ElementOverrides](instance0)
	if overrides.ChangeState == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ElementOverrides.ChangeState, got none")
	}

	var _transition StateChange // out

	_transition = StateChange(arg1)

	stateChangeReturn := overrides.ChangeState(_transition)

	var _ StateChangeReturn

	cret = C.GstStateChangeReturn(stateChangeReturn)

	return cret
}

//export _gotk4_gst1_ElementClass_get_state
func _gotk4_gst1_ElementClass_get_state(arg0 *C.GstElement, arg1 *C.GstState, arg2 *C.GstState, arg3 C.GstClockTime) (cret C.GstStateChangeReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ElementOverrides](instance0)
	if overrides.State == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ElementOverrides.State, got none")
	}

	var _timeout ClockTime // out

	_timeout = ClockTime(arg3)

	state, pending, stateChangeReturn := overrides.State(_timeout)

	var _ State
	var _ State
	var _ StateChangeReturn

	*arg1 = C.GstState(state)
	*arg2 = C.GstState(pending)
	cret = C.GstStateChangeReturn(stateChangeReturn)

	return cret
}

//export _gotk4_gst1_ElementClass_no_more_pads
func _gotk4_gst1_ElementClass_no_more_pads(arg0 *C.GstElement) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ElementOverrides](instance0)
	if overrides.NoMorePads == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ElementOverrides.NoMorePads, got none")
	}

	overrides.NoMorePads()
}

//export _gotk4_gst1_ElementClass_pad_added
func _gotk4_gst1_ElementClass_pad_added(arg0 *C.GstElement, arg1 *C.GstPad) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ElementOverrides](instance0)
	if overrides.PadAdded == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ElementOverrides.PadAdded, got none")
	}

	var _pad *Pad // out

	_pad = wrapPad(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.PadAdded(_pad)
}

//export _gotk4_gst1_ElementClass_pad_removed
func _gotk4_gst1_ElementClass_pad_removed(arg0 *C.GstElement, arg1 *C.GstPad) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ElementOverrides](instance0)
	if overrides.PadRemoved == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ElementOverrides.PadRemoved, got none")
	}

	var _pad *Pad // out

	_pad = wrapPad(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.PadRemoved(_pad)
}

//export _gotk4_gst1_ElementClass_post_message
func _gotk4_gst1_ElementClass_post_message(arg0 *C.GstElement, arg1 *C.GstMessage) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ElementOverrides](instance0)
	if overrides.PostMessage == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ElementOverrides.PostMessage, got none")
	}

	var _message *Message // out

	_message = (*Message)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	ok := overrides.PostMessage(_message)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_ElementClass_provide_clock
func _gotk4_gst1_ElementClass_provide_clock(arg0 *C.GstElement) (cret *C.GstClock) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ElementOverrides](instance0)
	if overrides.ProvideClock == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ElementOverrides.ProvideClock, got none")
	}

	clock := overrides.ProvideClock()

	var _ Clocker

	if clock != nil {
		cret = (*C.GstClock)(unsafe.Pointer(coreglib.InternObject(clock).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(clock).Native()))
	}

	return cret
}

//export _gotk4_gst1_ElementClass_query
func _gotk4_gst1_ElementClass_query(arg0 *C.GstElement, arg1 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ElementOverrides](instance0)
	if overrides.Query == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ElementOverrides.Query, got none")
	}

	var _query *Query // out

	_query = (*Query)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.gst_mini_object_ref((*C.GstMiniObject)(unsafe.Pointer(arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_query)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	ok := overrides.Query(_query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_ElementClass_release_pad
func _gotk4_gst1_ElementClass_release_pad(arg0 *C.GstElement, arg1 *C.GstPad) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ElementOverrides](instance0)
	if overrides.ReleasePad == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ElementOverrides.ReleasePad, got none")
	}

	var _pad *Pad // out

	_pad = wrapPad(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.ReleasePad(_pad)
}

//export _gotk4_gst1_ElementClass_send_event
func _gotk4_gst1_ElementClass_send_event(arg0 *C.GstElement, arg1 *C.GstEvent) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ElementOverrides](instance0)
	if overrides.SendEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ElementOverrides.SendEvent, got none")
	}

	var _event *Event // out

	_event = (*Event)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	ok := overrides.SendEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_ElementClass_set_bus
func _gotk4_gst1_ElementClass_set_bus(arg0 *C.GstElement, arg1 *C.GstBus) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ElementOverrides](instance0)
	if overrides.SetBus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ElementOverrides.SetBus, got none")
	}

	var _bus *Bus // out

	if arg1 != nil {
		_bus = wrapBus(coreglib.Take(unsafe.Pointer(arg1)))
	}

	overrides.SetBus(_bus)
}

//export _gotk4_gst1_ElementClass_set_clock
func _gotk4_gst1_ElementClass_set_clock(arg0 *C.GstElement, arg1 *C.GstClock) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ElementOverrides](instance0)
	if overrides.SetClock == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ElementOverrides.SetClock, got none")
	}

	var _clock Clocker // out

	if arg1 != nil {
		{
			objptr := unsafe.Pointer(arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Clocker)
				return ok
			})
			rv, ok := casted.(Clocker)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Clocker")
			}
			_clock = rv
		}
	}

	ok := overrides.SetClock(_clock)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gst1_ElementClass_set_context
func _gotk4_gst1_ElementClass_set_context(arg0 *C.GstElement, arg1 *C.GstContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ElementOverrides](instance0)
	if overrides.SetContext == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ElementOverrides.SetContext, got none")
	}

	var _context *Context // out

	_context = (*Context)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	overrides.SetContext(_context)
}

//export _gotk4_gst1_ElementClass_set_state
func _gotk4_gst1_ElementClass_set_state(arg0 *C.GstElement, arg1 C.GstState) (cret C.GstStateChangeReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ElementOverrides](instance0)
	if overrides.SetState == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ElementOverrides.SetState, got none")
	}

	var _state State // out

	_state = State(arg1)

	stateChangeReturn := overrides.SetState(_state)

	var _ StateChangeReturn

	cret = C.GstStateChangeReturn(stateChangeReturn)

	return cret
}

//export _gotk4_gst1_ElementClass_state_changed
func _gotk4_gst1_ElementClass_state_changed(arg0 *C.GstElement, arg1 C.GstState, arg2 C.GstState, arg3 C.GstState) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ElementOverrides](instance0)
	if overrides.StateChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ElementOverrides.StateChanged, got none")
	}

	var _oldstate State // out
	var _newstate State // out
	var _pending State  // out

	_oldstate = State(arg1)
	_newstate = State(arg2)
	_pending = State(arg3)

	overrides.StateChanged(_oldstate, _newstate, _pending)
}

//export _gotk4_gst1_Element_ConnectNoMorePads
func _gotk4_gst1_Element_ConnectNoMorePads(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gst1_Element_ConnectPadAdded
func _gotk4_gst1_Element_ConnectPadAdded(arg0 C.gpointer, arg1 *C.GstPad, arg2 C.guintptr) {
	var f func(newPad *Pad)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(newPad *Pad))
	}

	var _newPad *Pad // out

	_newPad = wrapPad(coreglib.Take(unsafe.Pointer(arg1)))

	f(_newPad)
}

//export _gotk4_gst1_Element_ConnectPadRemoved
func _gotk4_gst1_Element_ConnectPadRemoved(arg0 C.gpointer, arg1 *C.GstPad, arg2 C.guintptr) {
	var f func(oldPad *Pad)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(oldPad *Pad))
	}

	var _oldPad *Pad // out

	_oldPad = wrapPad(coreglib.Take(unsafe.Pointer(arg1)))

	f(_oldPad)
}

//export _gotk4_gst1_PadClass_linked
func _gotk4_gst1_PadClass_linked(arg0 *C.GstPad, arg1 *C.GstPad) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PadOverrides](instance0)
	if overrides.Linked == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PadOverrides.Linked, got none")
	}

	var _peer *Pad // out

	_peer = wrapPad(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.Linked(_peer)
}

//export _gotk4_gst1_PadClass_unlinked
func _gotk4_gst1_PadClass_unlinked(arg0 *C.GstPad, arg1 *C.GstPad) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PadOverrides](instance0)
	if overrides.Unlinked == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PadOverrides.Unlinked, got none")
	}

	var _peer *Pad // out

	_peer = wrapPad(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.Unlinked(_peer)
}

//export _gotk4_gst1_Pad_ConnectLinked
func _gotk4_gst1_Pad_ConnectLinked(arg0 C.gpointer, arg1 *C.GstPad, arg2 C.guintptr) {
	var f func(peer *Pad)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(peer *Pad))
	}

	var _peer *Pad // out

	_peer = wrapPad(coreglib.Take(unsafe.Pointer(arg1)))

	f(_peer)
}

//export _gotk4_gst1_Pad_ConnectUnlinked
func _gotk4_gst1_Pad_ConnectUnlinked(arg0 C.gpointer, arg1 *C.GstPad, arg2 C.guintptr) {
	var f func(peer *Pad)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(peer *Pad))
	}

	var _peer *Pad // out

	_peer = wrapPad(coreglib.Take(unsafe.Pointer(arg1)))

	f(_peer)
}

//export _gotk4_gst1_PadTemplateClass_pad_created
func _gotk4_gst1_PadTemplateClass_pad_created(arg0 *C.GstPadTemplate, arg1 *C.GstPad) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PadTemplateOverrides](instance0)
	if overrides.PadCreated == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PadTemplateOverrides.PadCreated, got none")
	}

	var _pad *Pad // out

	_pad = wrapPad(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.PadCreated(_pad)
}

//export _gotk4_gst1_PadTemplate_ConnectPadCreated
func _gotk4_gst1_PadTemplate_ConnectPadCreated(arg0 C.gpointer, arg1 *C.GstPad, arg2 C.guintptr) {
	var f func(pad *Pad)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(pad *Pad))
	}

	var _pad *Pad // out

	_pad = wrapPad(coreglib.Take(unsafe.Pointer(arg1)))

	f(_pad)
}

//export _gotk4_gst1_Registry_ConnectFeatureAdded
func _gotk4_gst1_Registry_ConnectFeatureAdded(arg0 C.gpointer, arg1 *C.GstPluginFeature, arg2 C.guintptr) {
	var f func(feature PluginFeaturer)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(feature PluginFeaturer))
	}

	var _feature PluginFeaturer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gst.PluginFeaturer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(PluginFeaturer)
			return ok
		})
		rv, ok := casted.(PluginFeaturer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.PluginFeaturer")
		}
		_feature = rv
	}

	f(_feature)
}

//export _gotk4_gst1_Registry_ConnectPluginAdded
func _gotk4_gst1_Registry_ConnectPluginAdded(arg0 C.gpointer, arg1 *C.GstPlugin, arg2 C.guintptr) {
	var f func(plugin *Plugin)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(plugin *Plugin))
	}

	var _plugin *Plugin // out

	_plugin = wrapPlugin(coreglib.Take(unsafe.Pointer(arg1)))

	f(_plugin)
}
