// Code generated by girgen. DO NOT EDIT.

package gstplayer

import (
	"fmt"
	"runtime"
	_ "runtime/cgo"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/go-gst/go-gst/pkg/gst"
	"github.com/go-gst/go-gst/pkg/gstvideo"
)

// #cgo pkg-config: gstreamer-player-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/player/player.h>
// extern void _gotk4_gstplayer1_Player_ConnectWarning(gpointer, GError*, guintptr);
// extern void _gotk4_gstplayer1_Player_ConnectVolumeChanged(gpointer, guintptr);
// extern void _gotk4_gstplayer1_Player_ConnectVideoDimensionsChanged(gpointer, gint, gint, guintptr);
// extern void _gotk4_gstplayer1_Player_ConnectURILoaded(gpointer, gchar*, guintptr);
// extern void _gotk4_gstplayer1_Player_ConnectStateChanged(gpointer, GstPlayerState, guintptr);
// extern void _gotk4_gstplayer1_Player_ConnectSeekDone(gpointer, guint64, guintptr);
// extern void _gotk4_gstplayer1_Player_ConnectPositionUpdated(gpointer, guint64, guintptr);
// extern void _gotk4_gstplayer1_Player_ConnectMuteChanged(gpointer, guintptr);
// extern void _gotk4_gstplayer1_Player_ConnectMediaInfoUpdated(gpointer, GstPlayerMediaInfo*, guintptr);
// extern void _gotk4_gstplayer1_Player_ConnectError(gpointer, GError*, guintptr);
// extern void _gotk4_gstplayer1_Player_ConnectEndOfStream(gpointer, guintptr);
// extern void _gotk4_gstplayer1_Player_ConnectDurationChanged(gpointer, guint64, guintptr);
// extern void _gotk4_gstplayer1_Player_ConnectBuffering(gpointer, gint, guintptr);
import "C"

// GType values.
var (
	GTypePlayerColorBalanceType             = coreglib.Type(C.gst_player_color_balance_type_get_type())
	GTypePlayerError                        = coreglib.Type(C.gst_player_error_get_type())
	GTypePlayerState                        = coreglib.Type(C.gst_player_state_get_type())
	GTypePlayerSignalDispatcher             = coreglib.Type(C.gst_player_signal_dispatcher_get_type())
	GTypePlayerVideoRenderer                = coreglib.Type(C.gst_player_video_renderer_get_type())
	GTypePlayer                             = coreglib.Type(C.gst_player_get_type())
	GTypePlayerAudioInfo                    = coreglib.Type(C.gst_player_audio_info_get_type())
	GTypePlayerGMainContextSignalDispatcher = coreglib.Type(C.gst_player_g_main_context_signal_dispatcher_get_type())
	GTypePlayerMediaInfo                    = coreglib.Type(C.gst_player_media_info_get_type())
	GTypePlayerStreamInfo                   = coreglib.Type(C.gst_player_stream_info_get_type())
	GTypePlayerSubtitleInfo                 = coreglib.Type(C.gst_player_subtitle_info_get_type())
	GTypePlayerVideoInfo                    = coreglib.Type(C.gst_player_video_info_get_type())
	GTypePlayerVideoOverlayVideoRenderer    = coreglib.Type(C.gst_player_video_overlay_video_renderer_get_type())
	GTypePlayerVisualization                = coreglib.Type(C.gst_player_visualization_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypePlayerColorBalanceType, F: marshalPlayerColorBalanceType},
		coreglib.TypeMarshaler{T: GTypePlayerError, F: marshalPlayerError},
		coreglib.TypeMarshaler{T: GTypePlayerState, F: marshalPlayerState},
		coreglib.TypeMarshaler{T: GTypePlayerSignalDispatcher, F: marshalPlayerSignalDispatcher},
		coreglib.TypeMarshaler{T: GTypePlayerVideoRenderer, F: marshalPlayerVideoRenderer},
		coreglib.TypeMarshaler{T: GTypePlayer, F: marshalPlayer},
		coreglib.TypeMarshaler{T: GTypePlayerAudioInfo, F: marshalPlayerAudioInfo},
		coreglib.TypeMarshaler{T: GTypePlayerGMainContextSignalDispatcher, F: marshalPlayerGMainContextSignalDispatcher},
		coreglib.TypeMarshaler{T: GTypePlayerMediaInfo, F: marshalPlayerMediaInfo},
		coreglib.TypeMarshaler{T: GTypePlayerStreamInfo, F: marshalPlayerStreamInfo},
		coreglib.TypeMarshaler{T: GTypePlayerSubtitleInfo, F: marshalPlayerSubtitleInfo},
		coreglib.TypeMarshaler{T: GTypePlayerVideoInfo, F: marshalPlayerVideoInfo},
		coreglib.TypeMarshaler{T: GTypePlayerVideoOverlayVideoRenderer, F: marshalPlayerVideoOverlayVideoRenderer},
		coreglib.TypeMarshaler{T: GTypePlayerVisualization, F: marshalPlayerVisualization},
	})
}

type PlayerColorBalanceType C.gint

const (
	// PlayerColorBalanceHue: hue or color balance.
	PlayerColorBalanceHue PlayerColorBalanceType = 3
	// PlayerColorBalanceBrightness brightness or black level.
	PlayerColorBalanceBrightness PlayerColorBalanceType = 0
	// PlayerColorBalanceSaturation: color saturation or chroma gain.
	PlayerColorBalanceSaturation PlayerColorBalanceType = 2
	// PlayerColorBalanceContrast: contrast or luma gain.
	PlayerColorBalanceContrast PlayerColorBalanceType = 1
)

func marshalPlayerColorBalanceType(p uintptr) (interface{}, error) {
	return PlayerColorBalanceType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PlayerColorBalanceType.
func (p PlayerColorBalanceType) String() string {
	switch p {
	case PlayerColorBalanceHue:
		return "Hue"
	case PlayerColorBalanceBrightness:
		return "Brightness"
	case PlayerColorBalanceSaturation:
		return "Saturation"
	case PlayerColorBalanceContrast:
		return "Contrast"
	default:
		return fmt.Sprintf("PlayerColorBalanceType(%d)", p)
	}
}

// PlayerColorBalanceTypeGetName gets a string representing the given color
// balance type.
//
// The function takes the following parameters:
//
//   - typ: PlayerColorBalanceType.
//
// The function returns the following values:
//
//   - utf8: string with the name of the color balance type.
func PlayerColorBalanceTypeGetName(typ PlayerColorBalanceType) string {
	var _arg1 C.GstPlayerColorBalanceType // out
	var _cret *C.gchar                    // in

	_arg1 = C.GstPlayerColorBalanceType(typ)

	_cret = C.gst_player_color_balance_type_get_name(_arg1)
	runtime.KeepAlive(typ)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

type PlayerError C.gint

const (
	// PlayerErrorFailed: generic error.
	PlayerErrorFailed PlayerError = iota
)

func marshalPlayerError(p uintptr) (interface{}, error) {
	return PlayerError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PlayerError.
func (p PlayerError) String() string {
	switch p {
	case PlayerErrorFailed:
		return "Failed"
	default:
		return fmt.Sprintf("PlayerError(%d)", p)
	}
}

// PlayerErrorGetName gets a string representing the given error.
//
// The function takes the following parameters:
//
//   - err: PlayerError.
//
// The function returns the following values:
//
//   - utf8: string with the given error.
func PlayerErrorGetName(err PlayerError) string {
	var _arg1 C.GstPlayerError // out
	var _cret *C.gchar         // in

	_arg1 = C.GstPlayerError(err)

	_cret = C.gst_player_error_get_name(_arg1)
	runtime.KeepAlive(err)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

func PlayerErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gst_player_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

type PlayerSnapshotFormat C.gint

const (
	PlayerThumbnailRawNative PlayerSnapshotFormat = iota
	PlayerThumbnailRawXrgb
	PlayerThumbnailRawBgrx
	PlayerThumbnailJPG
	PlayerThumbnailPNG
)

// String returns the name in string for PlayerSnapshotFormat.
func (p PlayerSnapshotFormat) String() string {
	switch p {
	case PlayerThumbnailRawNative:
		return "RawNative"
	case PlayerThumbnailRawXrgb:
		return "RawXrgb"
	case PlayerThumbnailRawBgrx:
		return "RawBgrx"
	case PlayerThumbnailJPG:
		return "JPG"
	case PlayerThumbnailPNG:
		return "PNG"
	default:
		return fmt.Sprintf("PlayerSnapshotFormat(%d)", p)
	}
}

type PlayerState C.gint

const (
	// PlayerStateStopped: player is stopped.
	PlayerStateStopped PlayerState = iota
	// PlayerStateBuffering: player is buffering.
	PlayerStateBuffering
	// PlayerStatePaused: player is paused.
	PlayerStatePaused
	// PlayerStatePlaying: player is currently playing a stream.
	PlayerStatePlaying
)

func marshalPlayerState(p uintptr) (interface{}, error) {
	return PlayerState(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PlayerState.
func (p PlayerState) String() string {
	switch p {
	case PlayerStateStopped:
		return "Stopped"
	case PlayerStateBuffering:
		return "Buffering"
	case PlayerStatePaused:
		return "Paused"
	case PlayerStatePlaying:
		return "Playing"
	default:
		return fmt.Sprintf("PlayerState(%d)", p)
	}
}

// PlayerStateGetName gets a string representing the given state.
//
// The function takes the following parameters:
//
//   - state: PlayerState.
//
// The function returns the following values:
//
//   - utf8: string with the name of the state.
func PlayerStateGetName(state PlayerState) string {
	var _arg1 C.GstPlayerState // out
	var _cret *C.gchar         // in

	_arg1 = C.GstPlayerState(state)

	_cret = C.gst_player_state_get_name(_arg1)
	runtime.KeepAlive(state)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// PlayerSignalDispatcherOverrider contains methods that are overridable.
type PlayerSignalDispatcherOverrider interface {
}

//
// PlayerSignalDispatcher wraps an interface. This means the user can get the
// underlying type by calling Cast().
type PlayerSignalDispatcher struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*PlayerSignalDispatcher)(nil)
)

// PlayerSignalDispatcherer describes PlayerSignalDispatcher's interface methods.
type PlayerSignalDispatcherer interface {
	coreglib.Objector

	basePlayerSignalDispatcher() *PlayerSignalDispatcher
}

var _ PlayerSignalDispatcherer = (*PlayerSignalDispatcher)(nil)

func ifaceInitPlayerSignalDispatcherer(gifacePtr, data C.gpointer) {
}

func wrapPlayerSignalDispatcher(obj *coreglib.Object) *PlayerSignalDispatcher {
	return &PlayerSignalDispatcher{
		Object: obj,
	}
}

func marshalPlayerSignalDispatcher(p uintptr) (interface{}, error) {
	return wrapPlayerSignalDispatcher(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *PlayerSignalDispatcher) basePlayerSignalDispatcher() *PlayerSignalDispatcher {
	return v
}

// BasePlayerSignalDispatcher returns the underlying base object.
func BasePlayerSignalDispatcher(obj PlayerSignalDispatcherer) *PlayerSignalDispatcher {
	return obj.basePlayerSignalDispatcher()
}

// PlayerVideoRendererOverrider contains methods that are overridable.
type PlayerVideoRendererOverrider interface {
}

//
// PlayerVideoRenderer wraps an interface. This means the user can get the
// underlying type by calling Cast().
type PlayerVideoRenderer struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*PlayerVideoRenderer)(nil)
)

// PlayerVideoRendererer describes PlayerVideoRenderer's interface methods.
type PlayerVideoRendererer interface {
	coreglib.Objector

	basePlayerVideoRenderer() *PlayerVideoRenderer
}

var _ PlayerVideoRendererer = (*PlayerVideoRenderer)(nil)

func ifaceInitPlayerVideoRendererer(gifacePtr, data C.gpointer) {
}

func wrapPlayerVideoRenderer(obj *coreglib.Object) *PlayerVideoRenderer {
	return &PlayerVideoRenderer{
		Object: obj,
	}
}

func marshalPlayerVideoRenderer(p uintptr) (interface{}, error) {
	return wrapPlayerVideoRenderer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *PlayerVideoRenderer) basePlayerVideoRenderer() *PlayerVideoRenderer {
	return v
}

// BasePlayerVideoRenderer returns the underlying base object.
func BasePlayerVideoRenderer(obj PlayerVideoRendererer) *PlayerVideoRenderer {
	return obj.basePlayerVideoRenderer()
}

// Player: starting from GStreamer 1.20, application developers are strongly
// advised to migrate to Play. Player will be deprecated in 1.20 and most likely
// removed by 1.24.
type Player struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*Player)(nil)
)

func wrapPlayer(obj *coreglib.Object) *Player {
	return &Player{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalPlayer(p uintptr) (interface{}, error) {
	return wrapPlayer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (player *Player) ConnectBuffering(f func(object int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(player, "buffering", false, unsafe.Pointer(C._gotk4_gstplayer1_Player_ConnectBuffering), f)
}

func (player *Player) ConnectDurationChanged(f func(object uint64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(player, "duration-changed", false, unsafe.Pointer(C._gotk4_gstplayer1_Player_ConnectDurationChanged), f)
}

func (player *Player) ConnectEndOfStream(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(player, "end-of-stream", false, unsafe.Pointer(C._gotk4_gstplayer1_Player_ConnectEndOfStream), f)
}

func (player *Player) ConnectError(f func(object error)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(player, "error", false, unsafe.Pointer(C._gotk4_gstplayer1_Player_ConnectError), f)
}

func (player *Player) ConnectMediaInfoUpdated(f func(object *PlayerMediaInfo)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(player, "media-info-updated", false, unsafe.Pointer(C._gotk4_gstplayer1_Player_ConnectMediaInfoUpdated), f)
}

func (player *Player) ConnectMuteChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(player, "mute-changed", false, unsafe.Pointer(C._gotk4_gstplayer1_Player_ConnectMuteChanged), f)
}

func (player *Player) ConnectPositionUpdated(f func(object uint64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(player, "position-updated", false, unsafe.Pointer(C._gotk4_gstplayer1_Player_ConnectPositionUpdated), f)
}

func (player *Player) ConnectSeekDone(f func(object uint64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(player, "seek-done", false, unsafe.Pointer(C._gotk4_gstplayer1_Player_ConnectSeekDone), f)
}

func (player *Player) ConnectStateChanged(f func(object PlayerState)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(player, "state-changed", false, unsafe.Pointer(C._gotk4_gstplayer1_Player_ConnectStateChanged), f)
}

func (player *Player) ConnectURILoaded(f func(object string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(player, "uri-loaded", false, unsafe.Pointer(C._gotk4_gstplayer1_Player_ConnectURILoaded), f)
}

func (player *Player) ConnectVideoDimensionsChanged(f func(object, p0 int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(player, "video-dimensions-changed", false, unsafe.Pointer(C._gotk4_gstplayer1_Player_ConnectVideoDimensionsChanged), f)
}

func (player *Player) ConnectVolumeChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(player, "volume-changed", false, unsafe.Pointer(C._gotk4_gstplayer1_Player_ConnectVolumeChanged), f)
}

func (player *Player) ConnectWarning(f func(object error)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(player, "warning", false, unsafe.Pointer(C._gotk4_gstplayer1_Player_ConnectWarning), f)
}

// NewPlayer creates a new Player instance that uses signal_dispatcher to
// dispatch signals to some event loop system, or emits signals directly if NULL
// is passed. See gst_player_g_main_context_signal_dispatcher_new().
//
// Video is going to be rendered by video_renderer, or if NULL is provided
// no special video set up will be done and some default handling will be
// performed.
//
// This also initializes GStreamer via gst_init() on the first call if this
// didn't happen before.
//
// The function takes the following parameters:
//
//   - videoRenderer (optional): gstPlayerVideoRenderer to use.
//   - signalDispatcher (optional): gstPlayerSignalDispatcher to use.
//
// The function returns the following values:
//
//   - player: new Player instance.
func NewPlayer(videoRenderer PlayerVideoRendererer, signalDispatcher PlayerSignalDispatcherer) *Player {
	var _arg1 *C.GstPlayerVideoRenderer    // out
	var _arg2 *C.GstPlayerSignalDispatcher // out
	var _cret *C.GstPlayer                 // in

	if videoRenderer != nil {
		_arg1 = (*C.GstPlayerVideoRenderer)(unsafe.Pointer(coreglib.InternObject(videoRenderer).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(videoRenderer).Native()))
	}
	if signalDispatcher != nil {
		_arg2 = (*C.GstPlayerSignalDispatcher)(unsafe.Pointer(coreglib.InternObject(signalDispatcher).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(signalDispatcher).Native()))
	}

	_cret = C.gst_player_new(_arg1, _arg2)
	runtime.KeepAlive(videoRenderer)
	runtime.KeepAlive(signalDispatcher)

	var _player *Player // out

	_player = wrapPlayer(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _player
}

// AudioVideoOffset: retrieve the current value of audio-video-offset property.
//
// The function returns the following values:
//
//   - gint64: current value of audio-video-offset in nanoseconds.
func (player *Player) AudioVideoOffset() int64 {
	var _arg0 *C.GstPlayer // out
	var _cret C.gint64     // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))

	_cret = C.gst_player_get_audio_video_offset(_arg0)
	runtime.KeepAlive(player)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// ColorBalance: retrieve the current value of the indicated type.
//
// The function takes the following parameters:
//
//   - typ: PlayerColorBalanceType.
//
// The function returns the following values:
//
//   - gdouble: current value of type, between [0,1]. In case of error -1 is
//     returned.
func (player *Player) ColorBalance(typ PlayerColorBalanceType) float64 {
	var _arg0 *C.GstPlayer                // out
	var _arg1 C.GstPlayerColorBalanceType // out
	var _cret C.gdouble                   // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))
	_arg1 = C.GstPlayerColorBalanceType(typ)

	_cret = C.gst_player_get_color_balance(_arg0, _arg1)
	runtime.KeepAlive(player)
	runtime.KeepAlive(typ)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Config: get a copy of the current configuration of the player. This
// configuration can either be modified and used for the gst_player_set_config()
// call or it must be freed after usage.
//
// The function returns the following values:
//
//   - structure: copy of the current configuration of player. Use
//     gst_structure_free() after usage or gst_player_set_config().
func (player *Player) Config() *gst.Structure {
	var _arg0 *C.GstPlayer    // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))

	_cret = C.gst_player_get_config(_arg0)
	runtime.KeepAlive(player)

	var _structure *gst.Structure // out

	_structure = (*gst.Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_structure)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _structure
}

// CurrentAudioTrack: function to get current audio PlayerAudioInfo instance.
//
// The function returns the following values:
//
//   - playerAudioInfo (optional): current audio track.
//
//     The caller should free it with g_object_unref().
func (player *Player) CurrentAudioTrack() *PlayerAudioInfo {
	var _arg0 *C.GstPlayer          // out
	var _cret *C.GstPlayerAudioInfo // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))

	_cret = C.gst_player_get_current_audio_track(_arg0)
	runtime.KeepAlive(player)

	var _playerAudioInfo *PlayerAudioInfo // out

	if _cret != nil {
		_playerAudioInfo = wrapPlayerAudioInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _playerAudioInfo
}

// CurrentSubtitleTrack: function to get current subtitle PlayerSubtitleInfo
// instance.
//
// The function returns the following values:
//
//   - playerSubtitleInfo (optional): current subtitle track.
//
//     The caller should free it with g_object_unref().
func (player *Player) CurrentSubtitleTrack() *PlayerSubtitleInfo {
	var _arg0 *C.GstPlayer             // out
	var _cret *C.GstPlayerSubtitleInfo // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))

	_cret = C.gst_player_get_current_subtitle_track(_arg0)
	runtime.KeepAlive(player)

	var _playerSubtitleInfo *PlayerSubtitleInfo // out

	if _cret != nil {
		_playerSubtitleInfo = wrapPlayerSubtitleInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _playerSubtitleInfo
}

// CurrentVideoTrack: function to get current video PlayerVideoInfo instance.
//
// The function returns the following values:
//
//   - playerVideoInfo (optional): current video track.
//
//     The caller should free it with g_object_unref().
func (player *Player) CurrentVideoTrack() *PlayerVideoInfo {
	var _arg0 *C.GstPlayer          // out
	var _cret *C.GstPlayerVideoInfo // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))

	_cret = C.gst_player_get_current_video_track(_arg0)
	runtime.KeepAlive(player)

	var _playerVideoInfo *PlayerVideoInfo // out

	if _cret != nil {
		_playerVideoInfo = wrapPlayerVideoInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _playerVideoInfo
}

// The function returns the following values:
//
//   - utf8 (optional): name of the currently enabled visualization. g_free()
//     after usage.
func (player *Player) CurrentVisualization() string {
	var _arg0 *C.GstPlayer // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))

	_cret = C.gst_player_get_current_visualization(_arg0)
	runtime.KeepAlive(player)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// Duration retrieves the duration of the media stream that self represents.
//
// The function returns the following values:
//
//   - clockTime: duration of the currently-playing media stream, in
//     nanoseconds.
func (player *Player) Duration() gst.ClockTime {
	var _arg0 *C.GstPlayer   // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))

	_cret = C.gst_player_get_duration(_arg0)
	runtime.KeepAlive(player)

	var _clockTime gst.ClockTime // out

	_clockTime = gst.ClockTime(_cret)

	return _clockTime
}

// MediaInfo: function to get the current media info PlayerMediaInfo instance.
//
// The function returns the following values:
//
//   - playerMediaInfo (optional): media info instance.
//
//     The caller should free it with g_object_unref().
func (player *Player) MediaInfo() *PlayerMediaInfo {
	var _arg0 *C.GstPlayer          // out
	var _cret *C.GstPlayerMediaInfo // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))

	_cret = C.gst_player_get_media_info(_arg0)
	runtime.KeepAlive(player)

	var _playerMediaInfo *PlayerMediaInfo // out

	if _cret != nil {
		_playerMediaInfo = wrapPlayerMediaInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _playerMediaInfo
}

// MultiviewFlags: retrieve the current value of the indicated type.
//
// The function returns the following values:
//
//   - videoMultiviewFlags: current value of type, Default: 0x00000000 "none.
func (player *Player) MultiviewFlags() gstvideo.VideoMultiviewFlags {
	var _arg0 *C.GstPlayer             // out
	var _cret C.GstVideoMultiviewFlags // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))

	_cret = C.gst_player_get_multiview_flags(_arg0)
	runtime.KeepAlive(player)

	var _videoMultiviewFlags gstvideo.VideoMultiviewFlags // out

	_videoMultiviewFlags = gstvideo.VideoMultiviewFlags(_cret)

	return _videoMultiviewFlags
}

// MultiviewMode: retrieve the current value of the indicated type.
//
// The function returns the following values:
//
//   - videoMultiviewFramePacking: current value of type, Default: -1 "none".
func (player *Player) MultiviewMode() gstvideo.VideoMultiviewFramePacking {
	var _arg0 *C.GstPlayer                    // out
	var _cret C.GstVideoMultiviewFramePacking // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))

	_cret = C.gst_player_get_multiview_mode(_arg0)
	runtime.KeepAlive(player)

	var _videoMultiviewFramePacking gstvideo.VideoMultiviewFramePacking // out

	_videoMultiviewFramePacking = gstvideo.VideoMultiviewFramePacking(_cret)

	return _videoMultiviewFramePacking
}

// The function returns the following values:
//
//   - ok: TRUE if the currently-playing stream is muted.
func (player *Player) Mute() bool {
	var _arg0 *C.GstPlayer // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))

	_cret = C.gst_player_get_mute(_arg0)
	runtime.KeepAlive(player)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - element: internal playbin instance.
//
//     The caller should free it with g_object_unref().
func (player *Player) Pipeline() gst.Elementer {
	var _arg0 *C.GstPlayer  // out
	var _cret *C.GstElement // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))

	_cret = C.gst_player_get_pipeline(_arg0)
	runtime.KeepAlive(player)

	var _element gst.Elementer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gst.Elementer)
			return ok
		})
		rv, ok := casted.(gst.Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}

	return _element
}

// The function returns the following values:
//
//   - clockTime: absolute position time, in nanoseconds, of the
//     currently-playing stream.
func (player *Player) Position() gst.ClockTime {
	var _arg0 *C.GstPlayer   // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))

	_cret = C.gst_player_get_position(_arg0)
	runtime.KeepAlive(player)

	var _clockTime gst.ClockTime // out

	_clockTime = gst.ClockTime(_cret)

	return _clockTime
}

// The function returns the following values:
//
//   - gdouble: current playback rate.
func (player *Player) Rate() float64 {
	var _arg0 *C.GstPlayer // out
	var _cret C.gdouble    // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))

	_cret = C.gst_player_get_rate(_arg0)
	runtime.KeepAlive(player)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// SubtitleURI: current subtitle URI.
//
// The function returns the following values:
//
//   - utf8 (optional): URI of the current external subtitle. g_free() after
//     usage.
func (player *Player) SubtitleURI() string {
	var _arg0 *C.GstPlayer // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))

	_cret = C.gst_player_get_subtitle_uri(_arg0)
	runtime.KeepAlive(player)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// SubtitleVideoOffset: retrieve the current value of subtitle-video-offset
// property.
//
// The function returns the following values:
//
//   - gint64: current value of subtitle-video-offset in nanoseconds.
func (player *Player) SubtitleVideoOffset() int64 {
	var _arg0 *C.GstPlayer // out
	var _cret C.gint64     // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))

	_cret = C.gst_player_get_subtitle_video_offset(_arg0)
	runtime.KeepAlive(player)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// URI gets the URI of the currently-playing stream.
//
// The function returns the following values:
//
//   - utf8 (optional): string containing the URI of the currently-playing
//     stream. g_free() after usage.
func (player *Player) URI() string {
	var _arg0 *C.GstPlayer // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))

	_cret = C.gst_player_get_uri(_arg0)
	runtime.KeepAlive(player)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// VideoSnapshot: get a snapshot of the currently selected video stream, if any.
// The format can be selected with format and optional configuration is possible
// with config Currently supported settings are:
//
// - width, height of type G_TYPE_INT
//
// - pixel-aspect-ratio of type GST_TYPE_FRACTION Except for
// GST_PLAYER_THUMBNAIL_RAW_NATIVE format, if no config is set,
// pixel-aspect-ratio would be 1/1.
//
// The function takes the following parameters:
//
//   - format: output format of the video snapshot.
//   - config (optional): additional configuration.
//
// The function returns the following values:
//
//   - sample (optional): current video snapshot sample or NULL on failure.
func (player *Player) VideoSnapshot(format PlayerSnapshotFormat, config *gst.Structure) *gst.Sample {
	var _arg0 *C.GstPlayer              // out
	var _arg1 C.GstPlayerSnapshotFormat // out
	var _arg2 *C.GstStructure           // out
	var _cret *C.GstSample              // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))
	_arg1 = C.GstPlayerSnapshotFormat(format)
	if config != nil {
		_arg2 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	}

	_cret = C.gst_player_get_video_snapshot(_arg0, _arg1, _arg2)
	runtime.KeepAlive(player)
	runtime.KeepAlive(format)
	runtime.KeepAlive(config)

	var _sample *gst.Sample // out

	if _cret != nil {
		_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_sample)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _sample
}

// Volume returns the current volume level, as a percentage between 0 and 1.
//
// The function returns the following values:
//
//   - gdouble: volume as percentage between 0 and 1.
func (player *Player) Volume() float64 {
	var _arg0 *C.GstPlayer // out
	var _cret C.gdouble    // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))

	_cret = C.gst_player_get_volume(_arg0)
	runtime.KeepAlive(player)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// HasColorBalance checks whether the player has color balance support
// available.
//
// The function returns the following values:
//
//   - ok: TRUE if player has color balance support. Otherwise, FALSE.
func (player *Player) HasColorBalance() bool {
	var _arg0 *C.GstPlayer // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))

	_cret = C.gst_player_has_color_balance(_arg0)
	runtime.KeepAlive(player)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Pause pauses the current stream.
func (player *Player) Pause() {
	var _arg0 *C.GstPlayer // out

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))

	C.gst_player_pause(_arg0)
	runtime.KeepAlive(player)
}

// Play: request to play the loaded stream.
func (player *Player) Play() {
	var _arg0 *C.GstPlayer // out

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))

	C.gst_player_play(_arg0)
	runtime.KeepAlive(player)
}

// Seek seeks the currently-playing stream to the absolute position time in
// nanoseconds.
//
// The function takes the following parameters:
//
//   - position to seek in nanoseconds.
func (player *Player) Seek(position gst.ClockTime) {
	var _arg0 *C.GstPlayer   // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))
	_arg1 = C.GstClockTime(position)

	C.gst_player_seek(_arg0, _arg1)
	runtime.KeepAlive(player)
	runtime.KeepAlive(position)
}

// The function takes the following parameters:
//
//   - streamIndex: stream index.
//
// The function returns the following values:
//
//   - ok: TRUE or FALSE
//
//     Sets the audio track stream_idex.
func (player *Player) SetAudioTrack(streamIndex int) bool {
	var _arg0 *C.GstPlayer // out
	var _arg1 C.gint       // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))
	_arg1 = C.gint(streamIndex)

	_cret = C.gst_player_set_audio_track(_arg0, _arg1)
	runtime.KeepAlive(player)
	runtime.KeepAlive(streamIndex)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAudioTrackEnabled: enable or disable the current audio track.
//
// The function takes the following parameters:
//
//   - enabled: TRUE or FALSE.
func (player *Player) SetAudioTrackEnabled(enabled bool) {
	var _arg0 *C.GstPlayer // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_player_set_audio_track_enabled(_arg0, _arg1)
	runtime.KeepAlive(player)
	runtime.KeepAlive(enabled)
}

// SetAudioVideoOffset sets audio-video-offset property by value of offset.
//
// The function takes the following parameters:
//
//   - offset in nanoseconds.
func (player *Player) SetAudioVideoOffset(offset int64) {
	var _arg0 *C.GstPlayer // out
	var _arg1 C.gint64     // out

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))
	_arg1 = C.gint64(offset)

	C.gst_player_set_audio_video_offset(_arg0, _arg1)
	runtime.KeepAlive(player)
	runtime.KeepAlive(offset)
}

// SetColorBalance sets the current value of the indicated channel type to the
// passed value.
//
// The function takes the following parameters:
//
//   - typ: PlayerColorBalanceType.
//   - value: new value for the type, ranged [0,1].
func (player *Player) SetColorBalance(typ PlayerColorBalanceType, value float64) {
	var _arg0 *C.GstPlayer                // out
	var _arg1 C.GstPlayerColorBalanceType // out
	var _arg2 C.gdouble                   // out

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))
	_arg1 = C.GstPlayerColorBalanceType(typ)
	_arg2 = C.gdouble(value)

	C.gst_player_set_color_balance(_arg0, _arg1, _arg2)
	runtime.KeepAlive(player)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(value)
}

// SetConfig: set the configuration of the player. If the player is already
// configured, and the configuration haven't change, this function will return
// TRUE. If the player is not in the GST_PLAYER_STATE_STOPPED, this method will
// return FALSE and active configuration will remain.
//
// config is a Structure that contains the configuration parameters for the
// player.
//
// This function takes ownership of config.
//
// The function takes the following parameters:
//
//   - config: Structure.
//
// The function returns the following values:
//
//   - ok: TRUE when the configuration could be set.
func (player *Player) SetConfig(config *gst.Structure) bool {
	var _arg0 *C.GstPlayer    // out
	var _arg1 *C.GstStructure // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(config)), nil)

	_cret = C.gst_player_set_config(_arg0, _arg1)
	runtime.KeepAlive(player)
	runtime.KeepAlive(config)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetMultiviewFlags sets the current value of the indicated mode type to the
// passed value.
//
// The function takes the following parameters:
//
//   - flags: new value for the type.
func (player *Player) SetMultiviewFlags(flags gstvideo.VideoMultiviewFlags) {
	var _arg0 *C.GstPlayer             // out
	var _arg1 C.GstVideoMultiviewFlags // out

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))
	_arg1 = C.GstVideoMultiviewFlags(flags)

	C.gst_player_set_multiview_flags(_arg0, _arg1)
	runtime.KeepAlive(player)
	runtime.KeepAlive(flags)
}

// SetMultiviewMode sets the current value of the indicated mode type to the
// passed value.
//
// The function takes the following parameters:
//
//   - mode: new value for the type.
func (player *Player) SetMultiviewMode(mode gstvideo.VideoMultiviewFramePacking) {
	var _arg0 *C.GstPlayer                    // out
	var _arg1 C.GstVideoMultiviewFramePacking // out

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))
	_arg1 = C.GstVideoMultiviewFramePacking(mode)

	C.gst_player_set_multiview_mode(_arg0, _arg1)
	runtime.KeepAlive(player)
	runtime.KeepAlive(mode)
}

// SetMute: TRUE if the currently-playing stream should be muted.
//
// The function takes the following parameters:
//
//   - val: mute state the should be set.
func (player *Player) SetMute(val bool) {
	var _arg0 *C.GstPlayer // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))
	if val {
		_arg1 = C.TRUE
	}

	C.gst_player_set_mute(_arg0, _arg1)
	runtime.KeepAlive(player)
	runtime.KeepAlive(val)
}

// SetRate: playback at specified rate.
//
// The function takes the following parameters:
//
//   - rate: playback rate.
func (player *Player) SetRate(rate float64) {
	var _arg0 *C.GstPlayer // out
	var _arg1 C.gdouble    // out

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))
	_arg1 = C.gdouble(rate)

	C.gst_player_set_rate(_arg0, _arg1)
	runtime.KeepAlive(player)
	runtime.KeepAlive(rate)
}

// The function takes the following parameters:
//
//   - streamIndex: stream index.
//
// The function returns the following values:
//
//   - ok: TRUE or FALSE
//
//     Sets the subtitle stack stream_index.
func (player *Player) SetSubtitleTrack(streamIndex int) bool {
	var _arg0 *C.GstPlayer // out
	var _arg1 C.gint       // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))
	_arg1 = C.gint(streamIndex)

	_cret = C.gst_player_set_subtitle_track(_arg0, _arg1)
	runtime.KeepAlive(player)
	runtime.KeepAlive(streamIndex)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSubtitleTrackEnabled: enable or disable the current subtitle track.
//
// The function takes the following parameters:
//
//   - enabled: TRUE or FALSE.
func (player *Player) SetSubtitleTrackEnabled(enabled bool) {
	var _arg0 *C.GstPlayer // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_player_set_subtitle_track_enabled(_arg0, _arg1)
	runtime.KeepAlive(player)
	runtime.KeepAlive(enabled)
}

// SetSubtitleURI sets the external subtitle URI. This should be combined with a
// call to gst_player_set_subtitle_track_enabled(player, TRUE) so the subtitles
// are actually rendered.
//
// The function takes the following parameters:
//
//   - uri (optional): subtitle URI.
func (player *Player) SetSubtitleURI(uri string) {
	var _arg0 *C.GstPlayer // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))
	if uri != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gst_player_set_subtitle_uri(_arg0, _arg1)
	runtime.KeepAlive(player)
	runtime.KeepAlive(uri)
}

// SetSubtitleVideoOffset sets subtitle-video-offset property by value of
// offset.
//
// The function takes the following parameters:
//
//   - offset in nanoseconds.
func (player *Player) SetSubtitleVideoOffset(offset int64) {
	var _arg0 *C.GstPlayer // out
	var _arg1 C.gint64     // out

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))
	_arg1 = C.gint64(offset)

	C.gst_player_set_subtitle_video_offset(_arg0, _arg1)
	runtime.KeepAlive(player)
	runtime.KeepAlive(offset)
}

// SetURI sets the next URI to play.
//
// The function takes the following parameters:
//
//   - uri (optional): next URI to play.
func (player *Player) SetURI(uri string) {
	var _arg0 *C.GstPlayer // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))
	if uri != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gst_player_set_uri(_arg0, _arg1)
	runtime.KeepAlive(player)
	runtime.KeepAlive(uri)
}

// The function takes the following parameters:
//
//   - streamIndex: stream index.
//
// The function returns the following values:
//
//   - ok: TRUE or FALSE
//
//     Sets the video track stream_index.
func (player *Player) SetVideoTrack(streamIndex int) bool {
	var _arg0 *C.GstPlayer // out
	var _arg1 C.gint       // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))
	_arg1 = C.gint(streamIndex)

	_cret = C.gst_player_set_video_track(_arg0, _arg1)
	runtime.KeepAlive(player)
	runtime.KeepAlive(streamIndex)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetVideoTrackEnabled: enable or disable the current video track.
//
// The function takes the following parameters:
//
//   - enabled: TRUE or FALSE.
func (player *Player) SetVideoTrackEnabled(enabled bool) {
	var _arg0 *C.GstPlayer // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_player_set_video_track_enabled(_arg0, _arg1)
	runtime.KeepAlive(player)
	runtime.KeepAlive(enabled)
}

// The function takes the following parameters:
//
//   - name (optional): visualization element obtained from
//     #gst_player_visualizations_get().
//
// The function returns the following values:
//
//   - ok: TRUE if the visualizations was set correctly. Otherwise, FALSE.
func (player *Player) SetVisualization(name string) bool {
	var _arg0 *C.GstPlayer // out
	var _arg1 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))
	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_player_set_visualization(_arg0, _arg1)
	runtime.KeepAlive(player)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetVisualizationEnabled: enable or disable the visualization.
//
// The function takes the following parameters:
//
//   - enabled: TRUE or FALSE.
func (player *Player) SetVisualizationEnabled(enabled bool) {
	var _arg0 *C.GstPlayer // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_player_set_visualization_enabled(_arg0, _arg1)
	runtime.KeepAlive(player)
	runtime.KeepAlive(enabled)
}

// SetVolume sets the volume level of the stream as a percentage between 0 and
// 1.
//
// This volume is a linear factor. For showing the volume in a GUI it might make
// sense to first convert from a different format. Volume sliders should usually
// use a cubic volume. See gst_stream_volume_convert_volume().
//
// The function takes the following parameters:
//
//   - val: new volume level, as a percentage between 0 and 1.
func (player *Player) SetVolume(val float64) {
	var _arg0 *C.GstPlayer // out
	var _arg1 C.gdouble    // out

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))
	_arg1 = C.gdouble(val)

	C.gst_player_set_volume(_arg0, _arg1)
	runtime.KeepAlive(player)
	runtime.KeepAlive(val)
}

// Stop stops playing the current stream and resets to the first position in the
// stream.
func (player *Player) Stop() {
	var _arg0 *C.GstPlayer // out

	_arg0 = (*C.GstPlayer)(unsafe.Pointer(coreglib.InternObject(player).Native()))

	C.gst_player_stop(_arg0)
	runtime.KeepAlive(player)
}

// The function takes the following parameters:
//
//   - config: Player configuration.
//
// The function returns the following values:
//
//   - guint: current position update interval in milliseconds.
func PlayerConfigGetPositionUpdateInterval(config *gst.Structure) uint {
	var _arg1 *C.GstStructure // out
	var _cret C.guint         // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))

	_cret = C.gst_player_config_get_position_update_interval(_arg1)
	runtime.KeepAlive(config)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function takes the following parameters:
//
//   - config: Player configuration.
//
// The function returns the following values:
//
//   - ok: TRUE if accurate seeking is enabled.
func PlayerConfigGetSeekAccurate(config *gst.Structure) bool {
	var _arg1 *C.GstStructure // out
	var _cret C.gboolean      // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))

	_cret = C.gst_player_config_get_seek_accurate(_arg1)
	runtime.KeepAlive(config)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PlayerConfigGetUserAgent: return the user agent which has been configured
// using gst_player_config_set_user_agent() if any.
//
// The function takes the following parameters:
//
//   - config: Player configuration.
//
// The function returns the following values:
//
//   - utf8 (optional): configured agent, or NULL.
func PlayerConfigGetUserAgent(config *gst.Structure) string {
	var _arg1 *C.GstStructure // out
	var _cret *C.gchar        // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))

	_cret = C.gst_player_config_get_user_agent(_arg1)
	runtime.KeepAlive(config)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// PlayerConfigSetPositionUpdateInterval: set interval in milliseconds between
// two position-updated signals. pass 0 to stop updating the position.
//
// The function takes the following parameters:
//
//   - config: Player configuration.
//   - interval in ms.
func PlayerConfigSetPositionUpdateInterval(config *gst.Structure, interval uint) {
	var _arg1 *C.GstStructure // out
	var _arg2 C.guint         // out

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	_arg2 = C.guint(interval)

	C.gst_player_config_set_position_update_interval(_arg1, _arg2)
	runtime.KeepAlive(config)
	runtime.KeepAlive(interval)
}

// PlayerConfigSetSeekAccurate: enable or disable accurate seeking. When
// enabled, elements will try harder to seek as accurately as possible to the
// requested seek position. Generally it will be slower especially for formats
// that don't have any indexes or timestamp markers in the stream.
//
// If accurate seeking is disabled, elements will seek as close as the request
// position without slowing down seeking too much.
//
// Accurate seeking is disabled by default.
//
// The function takes the following parameters:
//
//   - config: Player configuration.
//   - accurate seek or not.
func PlayerConfigSetSeekAccurate(config *gst.Structure, accurate bool) {
	var _arg1 *C.GstStructure // out
	var _arg2 C.gboolean      // out

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	if accurate {
		_arg2 = C.TRUE
	}

	C.gst_player_config_set_seek_accurate(_arg1, _arg2)
	runtime.KeepAlive(config)
	runtime.KeepAlive(accurate)
}

// PlayerConfigSetUserAgent: set the user agent to pass to the server if player
// needs to connect to a server during playback. This is typically used when
// playing HTTP or RTSP streams.
//
// The function takes the following parameters:
//
//   - config: Player configuration.
//   - agent (optional): string to use as user agent.
func PlayerConfigSetUserAgent(config *gst.Structure, agent string) {
	var _arg1 *C.GstStructure // out
	var _arg2 *C.gchar        // out

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	if agent != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(agent)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.gst_player_config_set_user_agent(_arg1, _arg2)
	runtime.KeepAlive(config)
	runtime.KeepAlive(agent)
}

// The function takes the following parameters:
//
//   - info: PlayerMediaInfo.
//
// The function returns the following values:
//
//   - list of matching PlayerAudioInfo.
func PlayerGetAudioStreams(info *PlayerMediaInfo) []*PlayerAudioInfo {
	var _arg1 *C.GstPlayerMediaInfo // out
	var _cret *C.GList              // in

	_arg1 = (*C.GstPlayerMediaInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_get_audio_streams(_arg1)
	runtime.KeepAlive(info)

	var _list []*PlayerAudioInfo // out

	_list = make([]*PlayerAudioInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstPlayerAudioInfo)(v)
		var dst *PlayerAudioInfo // out
		dst = wrapPlayerAudioInfo(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// The function takes the following parameters:
//
//   - info: PlayerMediaInfo.
//
// The function returns the following values:
//
//   - list of matching PlayerSubtitleInfo.
func PlayerGetSubtitleStreams(info *PlayerMediaInfo) []*PlayerSubtitleInfo {
	var _arg1 *C.GstPlayerMediaInfo // out
	var _cret *C.GList              // in

	_arg1 = (*C.GstPlayerMediaInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_get_subtitle_streams(_arg1)
	runtime.KeepAlive(info)

	var _list []*PlayerSubtitleInfo // out

	_list = make([]*PlayerSubtitleInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstPlayerSubtitleInfo)(v)
		var dst *PlayerSubtitleInfo // out
		dst = wrapPlayerSubtitleInfo(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// The function takes the following parameters:
//
//   - info: PlayerMediaInfo.
//
// The function returns the following values:
//
//   - list of matching PlayerVideoInfo.
func PlayerGetVideoStreams(info *PlayerMediaInfo) []*PlayerVideoInfo {
	var _arg1 *C.GstPlayerMediaInfo // out
	var _cret *C.GList              // in

	_arg1 = (*C.GstPlayerMediaInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_get_video_streams(_arg1)
	runtime.KeepAlive(info)

	var _list []*PlayerVideoInfo // out

	_list = make([]*PlayerVideoInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstPlayerVideoInfo)(v)
		var dst *PlayerVideoInfo // out
		dst = wrapPlayerVideoInfo(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// The function returns the following values:
//
//   - playerVisualizations: a NULL terminated array containing all available
//     visualizations. Use gst_player_visualizations_free() after usage.
func PlayerVisualizationsGet() []*PlayerVisualization {
	var _cret **C.GstPlayerVisualization // in

	_cret = C.gst_player_visualizations_get()

	var _playerVisualizations []*PlayerVisualization // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.GstPlayerVisualization
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_playerVisualizations = make([]*PlayerVisualization, i)
		for i := range src {
			_playerVisualizations[i] = (*PlayerVisualization)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_playerVisualizations[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.gst_player_visualization_free((*C.GstPlayerVisualization)(intern.C))
				},
			)
		}
	}

	return _playerVisualizations
}

// PlayerAudioInfo specific to audio streams.
type PlayerAudioInfo struct {
	_ [0]func() // equal guard
	PlayerStreamInfo
}

var (
	_ PlayerStreamInfor = (*PlayerAudioInfo)(nil)
)

func wrapPlayerAudioInfo(obj *coreglib.Object) *PlayerAudioInfo {
	return &PlayerAudioInfo{
		PlayerStreamInfo: PlayerStreamInfo{
			Object: obj,
		},
	}
}

func marshalPlayerAudioInfo(p uintptr) (interface{}, error) {
	return wrapPlayerAudioInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function returns the following values:
//
//   - gint: audio bitrate in PlayerAudioInfo or -1 if unknown.
func (info *PlayerAudioInfo) Bitrate() int {
	var _arg0 *C.GstPlayerAudioInfo // out
	var _cret C.gint                // in

	_arg0 = (*C.GstPlayerAudioInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_audio_info_get_bitrate(_arg0)
	runtime.KeepAlive(info)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
//   - gint: number of audio channels in PlayerAudioInfo or 0 if unknown.
func (info *PlayerAudioInfo) Channels() int {
	var _arg0 *C.GstPlayerAudioInfo // out
	var _cret C.gint                // in

	_arg0 = (*C.GstPlayerAudioInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_audio_info_get_channels(_arg0)
	runtime.KeepAlive(info)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
//   - utf8 (optional): language of the stream, or NULL if unknown.
func (info *PlayerAudioInfo) Language() string {
	var _arg0 *C.GstPlayerAudioInfo // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GstPlayerAudioInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_audio_info_get_language(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// The function returns the following values:
//
//   - gint: audio maximum bitrate in PlayerAudioInfo or -1 if unknown.
func (info *PlayerAudioInfo) MaxBitrate() int {
	var _arg0 *C.GstPlayerAudioInfo // out
	var _cret C.gint                // in

	_arg0 = (*C.GstPlayerAudioInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_audio_info_get_max_bitrate(_arg0)
	runtime.KeepAlive(info)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
//   - gint: audio sample rate in PlayerAudioInfo or 0 if unknown.
func (info *PlayerAudioInfo) SampleRate() int {
	var _arg0 *C.GstPlayerAudioInfo // out
	var _cret C.gint                // in

	_arg0 = (*C.GstPlayerAudioInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_audio_info_get_sample_rate(_arg0)
	runtime.KeepAlive(info)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

type PlayerGMainContextSignalDispatcher struct {
	_ [0]func() // equal guard
	*coreglib.Object

	PlayerSignalDispatcher
}

var (
	_ coreglib.Objector = (*PlayerGMainContextSignalDispatcher)(nil)
)

func wrapPlayerGMainContextSignalDispatcher(obj *coreglib.Object) *PlayerGMainContextSignalDispatcher {
	return &PlayerGMainContextSignalDispatcher{
		Object: obj,
		PlayerSignalDispatcher: PlayerSignalDispatcher{
			Object: obj,
		},
	}
}

func marshalPlayerGMainContextSignalDispatcher(p uintptr) (interface{}, error) {
	return wrapPlayerGMainContextSignalDispatcher(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewPlayerGMainContextSignalDispatcher creates a new GstPlayerSignalDispatcher
// that uses application_context, or the thread default one if NULL is used.
// See gst_player_new().
//
// The function takes the following parameters:
//
//   - applicationContext (optional): GMainContext to use or NULL.
//
// The function returns the following values:
//
//   - playerSignalDispatcher: new GstPlayerSignalDispatcher.
func NewPlayerGMainContextSignalDispatcher(applicationContext *glib.MainContext) *PlayerSignalDispatcher {
	var _arg1 *C.GMainContext              // out
	var _cret *C.GstPlayerSignalDispatcher // in

	if applicationContext != nil {
		_arg1 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(applicationContext)))
	}

	_cret = C.gst_player_g_main_context_signal_dispatcher_new(_arg1)
	runtime.KeepAlive(applicationContext)

	var _playerSignalDispatcher *PlayerSignalDispatcher // out

	_playerSignalDispatcher = wrapPlayerSignalDispatcher(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _playerSignalDispatcher
}

// PlayerMediaInfo: structure containing the media information of a URI.
type PlayerMediaInfo struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*PlayerMediaInfo)(nil)
)

func wrapPlayerMediaInfo(obj *coreglib.Object) *PlayerMediaInfo {
	return &PlayerMediaInfo{
		Object: obj,
	}
}

func marshalPlayerMediaInfo(p uintptr) (interface{}, error) {
	return wrapPlayerMediaInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function returns the following values:
//
//   - list of matching PlayerAudioInfo.
func (info *PlayerMediaInfo) AudioStreams() []*PlayerAudioInfo {
	var _arg0 *C.GstPlayerMediaInfo // out
	var _cret *C.GList              // in

	_arg0 = (*C.GstPlayerMediaInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_media_info_get_audio_streams(_arg0)
	runtime.KeepAlive(info)

	var _list []*PlayerAudioInfo // out

	_list = make([]*PlayerAudioInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstPlayerAudioInfo)(v)
		var dst *PlayerAudioInfo // out
		dst = wrapPlayerAudioInfo(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// The function returns the following values:
//
//   - utf8 (optional): container format or NULL if unknown.
func (info *PlayerMediaInfo) ContainerFormat() string {
	var _arg0 *C.GstPlayerMediaInfo // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GstPlayerMediaInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_media_info_get_container_format(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// The function returns the following values:
//
//   - clockTime: duration of the media or GST_CLOCK_TIME_NONE if unknown.
func (info *PlayerMediaInfo) Duration() gst.ClockTime {
	var _arg0 *C.GstPlayerMediaInfo // out
	var _cret C.GstClockTime        // in

	_arg0 = (*C.GstPlayerMediaInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_media_info_get_duration(_arg0)
	runtime.KeepAlive(info)

	var _clockTime gst.ClockTime // out

	_clockTime = gst.ClockTime(_cret)

	return _clockTime
}

// ImageSample: function to get the image (or preview-image) stored in taglist.
// Application can use gst_sample_*_() API's to get caps, buffer etc.
//
// The function returns the following values:
//
//   - sample (optional): gstSample or NULL.
func (info *PlayerMediaInfo) ImageSample() *gst.Sample {
	var _arg0 *C.GstPlayerMediaInfo // out
	var _cret *C.GstSample          // in

	_arg0 = (*C.GstPlayerMediaInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_media_info_get_image_sample(_arg0)
	runtime.KeepAlive(info)

	var _sample *gst.Sample // out

	if _cret != nil {
		_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.gst_mini_object_ref((*C.GstMiniObject)(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_sample)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _sample
}

// The function returns the following values:
//
//   - guint: number of audio streams or 0 if unknown.
func (info *PlayerMediaInfo) NumberOfAudioStreams() uint {
	var _arg0 *C.GstPlayerMediaInfo // out
	var _cret C.guint               // in

	_arg0 = (*C.GstPlayerMediaInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_media_info_get_number_of_audio_streams(_arg0)
	runtime.KeepAlive(info)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - guint: number of total streams or 0 if unknown.
func (info *PlayerMediaInfo) NumberOfStreams() uint {
	var _arg0 *C.GstPlayerMediaInfo // out
	var _cret C.guint               // in

	_arg0 = (*C.GstPlayerMediaInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_media_info_get_number_of_streams(_arg0)
	runtime.KeepAlive(info)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - guint: number of subtitle streams or 0 if unknown.
func (info *PlayerMediaInfo) NumberOfSubtitleStreams() uint {
	var _arg0 *C.GstPlayerMediaInfo // out
	var _cret C.guint               // in

	_arg0 = (*C.GstPlayerMediaInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_media_info_get_number_of_subtitle_streams(_arg0)
	runtime.KeepAlive(info)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - guint: number of video streams or 0 if unknown.
func (info *PlayerMediaInfo) NumberOfVideoStreams() uint {
	var _arg0 *C.GstPlayerMediaInfo // out
	var _cret C.guint               // in

	_arg0 = (*C.GstPlayerMediaInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_media_info_get_number_of_video_streams(_arg0)
	runtime.KeepAlive(info)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - list of matching PlayerStreamInfo.
func (info *PlayerMediaInfo) StreamList() []PlayerStreamInfor {
	var _arg0 *C.GstPlayerMediaInfo // out
	var _cret *C.GList              // in

	_arg0 = (*C.GstPlayerMediaInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_media_info_get_stream_list(_arg0)
	runtime.KeepAlive(info)

	var _list []PlayerStreamInfor // out

	_list = make([]PlayerStreamInfor, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstPlayerStreamInfo)(v)
		var dst PlayerStreamInfor // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gstplayer.PlayerStreamInfor is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(PlayerStreamInfor)
				return ok
			})
			rv, ok := casted.(PlayerStreamInfor)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstplayer.PlayerStreamInfor")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// The function returns the following values:
//
//   - list of matching PlayerSubtitleInfo.
func (info *PlayerMediaInfo) SubtitleStreams() []*PlayerSubtitleInfo {
	var _arg0 *C.GstPlayerMediaInfo // out
	var _cret *C.GList              // in

	_arg0 = (*C.GstPlayerMediaInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_media_info_get_subtitle_streams(_arg0)
	runtime.KeepAlive(info)

	var _list []*PlayerSubtitleInfo // out

	_list = make([]*PlayerSubtitleInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstPlayerSubtitleInfo)(v)
		var dst *PlayerSubtitleInfo // out
		dst = wrapPlayerSubtitleInfo(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// The function returns the following values:
//
//   - tagList (optional) tags contained in media info.
func (info *PlayerMediaInfo) Tags() *gst.TagList {
	var _arg0 *C.GstPlayerMediaInfo // out
	var _cret *C.GstTagList         // in

	_arg0 = (*C.GstPlayerMediaInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_media_info_get_tags(_arg0)
	runtime.KeepAlive(info)

	var _tagList *gst.TagList // out

	if _cret != nil {
		_tagList = (*gst.TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _tagList
}

// The function returns the following values:
//
//   - utf8 (optional): media title or NULL if unknown.
func (info *PlayerMediaInfo) Title() string {
	var _arg0 *C.GstPlayerMediaInfo // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GstPlayerMediaInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_media_info_get_title(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// The function returns the following values:
//
//   - utf8: URI associated with PlayerMediaInfo.
func (info *PlayerMediaInfo) URI() string {
	var _arg0 *C.GstPlayerMediaInfo // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GstPlayerMediaInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_media_info_get_uri(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
//   - list of matching PlayerVideoInfo.
func (info *PlayerMediaInfo) VideoStreams() []*PlayerVideoInfo {
	var _arg0 *C.GstPlayerMediaInfo // out
	var _cret *C.GList              // in

	_arg0 = (*C.GstPlayerMediaInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_media_info_get_video_streams(_arg0)
	runtime.KeepAlive(info)

	var _list []*PlayerVideoInfo // out

	_list = make([]*PlayerVideoInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstPlayerVideoInfo)(v)
		var dst *PlayerVideoInfo // out
		dst = wrapPlayerVideoInfo(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// The function returns the following values:
//
//   - ok: TRUE if the media is live.
func (info *PlayerMediaInfo) IsLive() bool {
	var _arg0 *C.GstPlayerMediaInfo // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstPlayerMediaInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_media_info_is_live(_arg0)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - ok: TRUE if the media is seekable.
func (info *PlayerMediaInfo) IsSeekable() bool {
	var _arg0 *C.GstPlayerMediaInfo // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstPlayerMediaInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_media_info_is_seekable(_arg0)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PlayerStreamInfo: base structure for information concerning a media stream.
// Depending on the stream type, one can find more media-specific information in
// PlayerVideoInfo, PlayerAudioInfo, PlayerSubtitleInfo.
type PlayerStreamInfo struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*PlayerStreamInfo)(nil)
)

// PlayerStreamInfor describes types inherited from class PlayerStreamInfo.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type PlayerStreamInfor interface {
	coreglib.Objector
	basePlayerStreamInfo() *PlayerStreamInfo
}

var _ PlayerStreamInfor = (*PlayerStreamInfo)(nil)

func wrapPlayerStreamInfo(obj *coreglib.Object) *PlayerStreamInfo {
	return &PlayerStreamInfo{
		Object: obj,
	}
}

func marshalPlayerStreamInfo(p uintptr) (interface{}, error) {
	return wrapPlayerStreamInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (info *PlayerStreamInfo) basePlayerStreamInfo() *PlayerStreamInfo {
	return info
}

// BasePlayerStreamInfo returns the underlying base object.
func BasePlayerStreamInfo(obj PlayerStreamInfor) *PlayerStreamInfo {
	return obj.basePlayerStreamInfo()
}

// The function returns the following values:
//
//   - caps (optional) of the stream.
func (info *PlayerStreamInfo) Caps() *gst.Caps {
	var _arg0 *C.GstPlayerStreamInfo // out
	var _cret *C.GstCaps             // in

	_arg0 = (*C.GstPlayerStreamInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_stream_info_get_caps(_arg0)
	runtime.KeepAlive(info)

	var _caps *gst.Caps // out

	if _cret != nil {
		_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.gst_mini_object_ref((*C.GstMiniObject)(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_caps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _caps
}

// Codec: string describing codec used in PlayerStreamInfo.
//
// The function returns the following values:
//
//   - utf8 (optional): codec string or NULL on unknown.
func (info *PlayerStreamInfo) Codec() string {
	var _arg0 *C.GstPlayerStreamInfo // out
	var _cret *C.gchar               // in

	_arg0 = (*C.GstPlayerStreamInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_stream_info_get_codec(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Index: function to get stream index from PlayerStreamInfo instance or -1 if
// unknown.
//
// The function returns the following values:
//
//   - gint: stream index of this stream.
func (info *PlayerStreamInfo) Index() int {
	var _arg0 *C.GstPlayerStreamInfo // out
	var _cret C.gint                 // in

	_arg0 = (*C.GstPlayerStreamInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_stream_info_get_index(_arg0)
	runtime.KeepAlive(info)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// StreamType: function to return human readable name for the stream type of the
// given info (ex: "audio", "video", "subtitle").
//
// The function returns the following values:
//
//   - utf8: human readable name.
func (info *PlayerStreamInfo) StreamType() string {
	var _arg0 *C.GstPlayerStreamInfo // out
	var _cret *C.gchar               // in

	_arg0 = (*C.GstPlayerStreamInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_stream_info_get_stream_type(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
//   - tagList (optional) tags contained in this stream.
func (info *PlayerStreamInfo) Tags() *gst.TagList {
	var _arg0 *C.GstPlayerStreamInfo // out
	var _cret *C.GstTagList          // in

	_arg0 = (*C.GstPlayerStreamInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_stream_info_get_tags(_arg0)
	runtime.KeepAlive(info)

	var _tagList *gst.TagList // out

	if _cret != nil {
		_tagList = (*gst.TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _tagList
}

// PlayerSubtitleInfo specific to subtitle streams.
type PlayerSubtitleInfo struct {
	_ [0]func() // equal guard
	PlayerStreamInfo
}

var (
	_ PlayerStreamInfor = (*PlayerSubtitleInfo)(nil)
)

func wrapPlayerSubtitleInfo(obj *coreglib.Object) *PlayerSubtitleInfo {
	return &PlayerSubtitleInfo{
		PlayerStreamInfo: PlayerStreamInfo{
			Object: obj,
		},
	}
}

func marshalPlayerSubtitleInfo(p uintptr) (interface{}, error) {
	return wrapPlayerSubtitleInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function returns the following values:
//
//   - utf8 (optional): language of the stream, or NULL if unknown.
func (info *PlayerSubtitleInfo) Language() string {
	var _arg0 *C.GstPlayerSubtitleInfo // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GstPlayerSubtitleInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_subtitle_info_get_language(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// PlayerVideoInfo specific to video streams.
type PlayerVideoInfo struct {
	_ [0]func() // equal guard
	PlayerStreamInfo
}

var (
	_ PlayerStreamInfor = (*PlayerVideoInfo)(nil)
)

func wrapPlayerVideoInfo(obj *coreglib.Object) *PlayerVideoInfo {
	return &PlayerVideoInfo{
		PlayerStreamInfo: PlayerStreamInfo{
			Object: obj,
		},
	}
}

func marshalPlayerVideoInfo(p uintptr) (interface{}, error) {
	return wrapPlayerVideoInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function returns the following values:
//
//   - gint: current bitrate of video in PlayerVideoInfo or -1 if unknown.
func (info *PlayerVideoInfo) Bitrate() int {
	var _arg0 *C.GstPlayerVideoInfo // out
	var _cret C.gint                // in

	_arg0 = (*C.GstPlayerVideoInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_video_info_get_bitrate(_arg0)
	runtime.KeepAlive(info)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
//   - fpsN: numerator of frame rate.
//   - fpsD: denominator of frame rate.
func (info *PlayerVideoInfo) Framerate() (fpsN, fpsD int) {
	var _arg0 *C.GstPlayerVideoInfo // out
	var _arg1 C.gint                // in
	var _arg2 C.gint                // in

	_arg0 = (*C.GstPlayerVideoInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	C.gst_player_video_info_get_framerate(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(info)

	var _fpsN int // out
	var _fpsD int // out

	_fpsN = int(_arg1)
	_fpsD = int(_arg2)

	return _fpsN, _fpsD
}

// The function returns the following values:
//
//   - gint: height of video in PlayerVideoInfo or -1 if unknown.
func (info *PlayerVideoInfo) Height() int {
	var _arg0 *C.GstPlayerVideoInfo // out
	var _cret C.gint                // in

	_arg0 = (*C.GstPlayerVideoInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_video_info_get_height(_arg0)
	runtime.KeepAlive(info)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
//   - gint: maximum bitrate of video in PlayerVideoInfo or -1 if unknown.
func (info *PlayerVideoInfo) MaxBitrate() int {
	var _arg0 *C.GstPlayerVideoInfo // out
	var _cret C.gint                // in

	_arg0 = (*C.GstPlayerVideoInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_video_info_get_max_bitrate(_arg0)
	runtime.KeepAlive(info)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PixelAspectRatio returns the pixel aspect ratio in par_n and par_d.
//
// The function returns the following values:
//
//   - parN: numerator.
//   - parD: denominator.
func (info *PlayerVideoInfo) PixelAspectRatio() (parN, parD uint) {
	var _arg0 *C.GstPlayerVideoInfo // out
	var _arg1 C.guint               // in
	var _arg2 C.guint               // in

	_arg0 = (*C.GstPlayerVideoInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	C.gst_player_video_info_get_pixel_aspect_ratio(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(info)

	var _parN uint // out
	var _parD uint // out

	_parN = uint(_arg1)
	_parD = uint(_arg2)

	return _parN, _parD
}

// The function returns the following values:
//
//   - gint: width of video in PlayerVideoInfo or -1 if unknown.
func (info *PlayerVideoInfo) Width() int {
	var _arg0 *C.GstPlayerVideoInfo // out
	var _cret C.gint                // in

	_arg0 = (*C.GstPlayerVideoInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))

	_cret = C.gst_player_video_info_get_width(_arg0)
	runtime.KeepAlive(info)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

type PlayerVideoOverlayVideoRenderer struct {
	_ [0]func() // equal guard
	*coreglib.Object

	PlayerVideoRenderer
}

var (
	_ coreglib.Objector = (*PlayerVideoOverlayVideoRenderer)(nil)
)

func wrapPlayerVideoOverlayVideoRenderer(obj *coreglib.Object) *PlayerVideoOverlayVideoRenderer {
	return &PlayerVideoOverlayVideoRenderer{
		Object: obj,
		PlayerVideoRenderer: PlayerVideoRenderer{
			Object: obj,
		},
	}
}

func marshalPlayerVideoOverlayVideoRenderer(p uintptr) (interface{}, error) {
	return wrapPlayerVideoOverlayVideoRenderer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Expose: tell an overlay that it has been exposed. This will redraw the
// current frame in the drawable even if the pipeline is PAUSED.
func (self *PlayerVideoOverlayVideoRenderer) Expose() {
	var _arg0 *C.GstPlayerVideoOverlayVideoRenderer // out

	_arg0 = (*C.GstPlayerVideoOverlayVideoRenderer)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gst_player_video_overlay_video_renderer_expose(_arg0)
	runtime.KeepAlive(self)
}

// RenderRectangle: return the currently configured render rectangle. See
// gst_player_video_overlay_video_renderer_set_render_rectangle() for details.
//
// The function returns the following values:
//
//   - x (optional): horizontal offset of the render area inside the window.
//   - y (optional): vertical offset of the render area inside the window.
//   - width (optional) of the render area inside the window.
//   - height (optional) of the render area inside the window.
func (self *PlayerVideoOverlayVideoRenderer) RenderRectangle() (x, y, width, height int) {
	var _arg0 *C.GstPlayerVideoOverlayVideoRenderer // out
	var _arg1 C.gint                                // in
	var _arg2 C.gint                                // in
	var _arg3 C.gint                                // in
	var _arg4 C.gint                                // in

	_arg0 = (*C.GstPlayerVideoOverlayVideoRenderer)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gst_player_video_overlay_video_renderer_get_render_rectangle(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(self)

	var _x int      // out
	var _y int      // out
	var _width int  // out
	var _height int // out

	_x = int(_arg1)
	_y = int(_arg2)
	_width = int(_arg3)
	_height = int(_arg4)

	return _x, _y, _width, _height
}

// The function returns the following values:
//
//   - gpointer (optional): currently set, platform specific window handle.
func (self *PlayerVideoOverlayVideoRenderer) WindowHandle() unsafe.Pointer {
	var _arg0 *C.GstPlayerVideoOverlayVideoRenderer // out
	var _cret C.gpointer                            // in

	_arg0 = (*C.GstPlayerVideoOverlayVideoRenderer)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gst_player_video_overlay_video_renderer_get_window_handle(_arg0)
	runtime.KeepAlive(self)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// SetRenderRectangle: configure a subregion as a video target within the
// window set by gst_player_video_overlay_video_renderer_set_window_handle().
// If this is not used or not supported the video will fill the area of the
// window set as the overlay to 100%. By specifying the rectangle, the video can
// be overlaid to a specific region of that window only. After setting the new
// rectangle one should call gst_player_video_overlay_video_renderer_expose()
// to force a redraw. To unset the region pass -1 for the width and height
// parameters.
//
// This method is needed for non fullscreen video overlay in UI toolkits that do
// not support subwindows.
//
// The function takes the following parameters:
//
//   - x: horizontal offset of the render area inside the window.
//   - y: vertical offset of the render area inside the window.
//   - width of the render area inside the window.
//   - height of the render area inside the window.
func (self *PlayerVideoOverlayVideoRenderer) SetRenderRectangle(x, y, width, height int) {
	var _arg0 *C.GstPlayerVideoOverlayVideoRenderer // out
	var _arg1 C.gint                                // out
	var _arg2 C.gint                                // out
	var _arg3 C.gint                                // out
	var _arg4 C.gint                                // out

	_arg0 = (*C.GstPlayerVideoOverlayVideoRenderer)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.gint(x)
	_arg2 = C.gint(y)
	_arg3 = C.gint(width)
	_arg4 = C.gint(height)

	C.gst_player_video_overlay_video_renderer_set_render_rectangle(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(self)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// SetWindowHandle sets the platform specific window handle into which the video
// should be rendered.
//
// The function takes the following parameters:
//
//   - windowHandle (optional): handle referencing to the platform specific
//     window.
func (self *PlayerVideoOverlayVideoRenderer) SetWindowHandle(windowHandle unsafe.Pointer) {
	var _arg0 *C.GstPlayerVideoOverlayVideoRenderer // out
	var _arg1 C.gpointer                            // out

	_arg0 = (*C.GstPlayerVideoOverlayVideoRenderer)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(windowHandle))

	C.gst_player_video_overlay_video_renderer_set_window_handle(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(windowHandle)
}

// The function takes the following parameters:
//
//   - windowHandle (optional): window handle to use or NULL.
func NewPlayerVideoOverlayVideoRenderer(windowHandle unsafe.Pointer) *PlayerVideoRenderer {
	var _arg1 C.gpointer                // out
	var _cret *C.GstPlayerVideoRenderer // in

	_arg1 = (C.gpointer)(unsafe.Pointer(windowHandle))

	_cret = C.gst_player_video_overlay_video_renderer_new(_arg1)
	runtime.KeepAlive(windowHandle)

	var _playerVideoRenderer *PlayerVideoRenderer // out

	_playerVideoRenderer = wrapPlayerVideoRenderer(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _playerVideoRenderer
}

// The function takes the following parameters:
//
//   - windowHandle (optional): window handle to use or NULL.
//   - videoSink: custom video_sink element to be set for the video renderer.
func NewPlayerVideoOverlayVideoRendererWithSink(windowHandle unsafe.Pointer, videoSink gst.Elementer) *PlayerVideoRenderer {
	var _arg1 C.gpointer                // out
	var _arg2 *C.GstElement             // out
	var _cret *C.GstPlayerVideoRenderer // in

	_arg1 = (C.gpointer)(unsafe.Pointer(windowHandle))
	_arg2 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(videoSink).Native()))

	_cret = C.gst_player_video_overlay_video_renderer_new_with_sink(_arg1, _arg2)
	runtime.KeepAlive(windowHandle)
	runtime.KeepAlive(videoSink)

	var _playerVideoRenderer *PlayerVideoRenderer // out

	_playerVideoRenderer = wrapPlayerVideoRenderer(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _playerVideoRenderer
}

// PlayerSignalDispatcherInterface: instance of this type is always passed by
// reference.
type PlayerSignalDispatcherInterface struct {
	*playerSignalDispatcherInterface
}

// playerSignalDispatcherInterface is the struct that's finalized.
type playerSignalDispatcherInterface struct {
	native *C.GstPlayerSignalDispatcherInterface
}

// PlayerVideoRendererInterface: instance of this type is always passed by
// reference.
type PlayerVideoRendererInterface struct {
	*playerVideoRendererInterface
}

// playerVideoRendererInterface is the struct that's finalized.
type playerVideoRendererInterface struct {
	native *C.GstPlayerVideoRendererInterface
}

// PlayerVisualization descriptor.
//
// An instance of this type is always passed by reference.
type PlayerVisualization struct {
	*playerVisualization
}

// playerVisualization is the struct that's finalized.
type playerVisualization struct {
	native *C.GstPlayerVisualization
}

func marshalPlayerVisualization(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &PlayerVisualization{&playerVisualization{(*C.GstPlayerVisualization)(b)}}, nil
}

// Name: name of the visualization.
func (p *PlayerVisualization) Name() string {
	valptr := &p.native.name
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Description: description of the visualization.
func (p *PlayerVisualization) Description() string {
	valptr := &p.native.description
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Copy makes a copy of the PlayerVisualization. The result must be freed using
// gst_player_visualization_free().
//
// The function returns the following values:
//
//   - playerVisualization: allocated copy of vis.
func (vis *PlayerVisualization) Copy() *PlayerVisualization {
	var _arg0 *C.GstPlayerVisualization // out
	var _cret *C.GstPlayerVisualization // in

	_arg0 = (*C.GstPlayerVisualization)(gextras.StructNative(unsafe.Pointer(vis)))

	_cret = C.gst_player_visualization_copy(_arg0)
	runtime.KeepAlive(vis)

	var _playerVisualization *PlayerVisualization // out

	_playerVisualization = (*PlayerVisualization)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_playerVisualization)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_player_visualization_free((*C.GstPlayerVisualization)(intern.C))
		},
	)

	return _playerVisualization
}
