// Code generated by girgen. DO NOT EDIT.

package gstcheck

import (
	"runtime"
	_ "runtime/cgo"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/go-gst/go-gst/pkg/gst"
)

// #cgo pkg-config: gstreamer-check-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/check/check.h>
// extern void callbackDelete(gpointer);
// extern GstPadProbeReturn _gotk4_gstcheck1_PadProbeCallback(GstPad*, GstPadProbeInfo*, gpointer);
// extern GstPadProbeReturn _gotk4_gst1_PadProbeCallback(GstPad*, GstPadProbeInfo*, gpointer);
import "C"

// GType values.
var (
	GTypeTestClock = coreglib.Type(C.gst_test_clock_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTestClock, F: marshalTestClock},
	})
}

// CheckLogFilterFunc: function that is called for messages matching the filter
// added by gst_check_add_log_filter.
type CheckLogFilterFunc func(logDomain string, logLevel glib.LogLevelFlags, message string) (ok bool)

// BufferStrawGetBuffer (gst_buffer_straw_get_buffer): get one buffer from pad.
// Implemented via buffer probes. This function will block until the pipeline
// passes a buffer over pad, so for robust behavior in unit tests, you need to
// use check's timeout to fail out in the case that a buffer never arrives.
//
// You must have previously called gst_buffer_straw_start_pipeline() on pipeline
// and pad.
//
// The function takes the following parameters:
//
//   - bin: pipeline previously started via gst_buffer_straw_start_pipeline().
//   - pad previously passed to gst_buffer_straw_start_pipeline().
//
// The function returns the following values:
//
//   - buffer: captured Buffer.
func BufferStrawGetBuffer(bin gst.Elementer, pad *gst.Pad) *gst.Buffer {
	var _arg1 *C.GstElement // out
	var _arg2 *C.GstPad     // out
	var _cret *C.GstBuffer  // in

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(bin).Native()))
	_arg2 = (*C.GstPad)(unsafe.Pointer(coreglib.BaseObject(pad).Native()))

	_cret = C.gst_buffer_straw_get_buffer(_arg1, _arg2)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(pad)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _buffer
}

// BufferStrawStartPipeline (gst_buffer_straw_start_pipeline) sets up a pipeline
// for buffer sucking. This will allow you to call gst_buffer_straw_get_buffer()
// to access buffers as they pass over pad.
//
// This function is normally used in unit tests that want to verify that a
// particular element is outputting correct buffers. For example, you would make
// a pipeline via gst_parse_launch(), pull out the pad you want to monitor, then
// call gst_buffer_straw_get_buffer() to get the buffers that pass through pad.
// The pipeline will block until you have sucked off the buffers.
//
// This function will set the state of bin to PLAYING; to clean up, be sure to
// call gst_buffer_straw_stop_pipeline().
//
// Note that you may not start two buffer straws at the same time. This function
// is intended for unit tests, not general API use. In fact it calls fail_if
// from libcheck, so you cannot use it outside unit tests.
//
// The function takes the following parameters:
//
//   - bin: pipeline to run.
//   - pad on an element in bin.
func BufferStrawStartPipeline(bin gst.Elementer, pad *gst.Pad) {
	var _arg1 *C.GstElement // out
	var _arg2 *C.GstPad     // out

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(bin).Native()))
	_arg2 = (*C.GstPad)(unsafe.Pointer(coreglib.BaseObject(pad).Native()))

	C.gst_buffer_straw_start_pipeline(_arg1, _arg2)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(pad)
}

// BufferStrawStopPipeline (gst_buffer_straw_stop_pipeline):
// set bin to T_STATE_NULL and release resource allocated in
// gst_buffer_straw_start_pipeline().
//
// You must have previously called gst_buffer_straw_start_pipeline() on pipeline
// and pad.
//
// The function takes the following parameters:
//
//   - bin: pipeline previously started via gst_buffer_straw_start_pipeline().
//   - pad previously passed to gst_buffer_straw_start_pipeline().
func BufferStrawStopPipeline(bin gst.Elementer, pad *gst.Pad) {
	var _arg1 *C.GstElement // out
	var _arg2 *C.GstPad     // out

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(bin).Native()))
	_arg2 = (*C.GstPad)(unsafe.Pointer(coreglib.BaseObject(pad).Native()))

	C.gst_buffer_straw_stop_pipeline(_arg1, _arg2)
	runtime.KeepAlive(bin)
	runtime.KeepAlive(pad)
}

// CheckAbiList (gst_check_abi_list) verifies that reference values and current
// values are equals in list.
//
// The function takes the following parameters:
//
//   - list of GstCheckABIStruct to be verified.
//   - haveAbiSizes: whether there is a reference ABI size already specified,
//     if it is FALSE and the GST_ABI environment variable is set, usable code
//     for list will be printed.
func CheckAbiList(list *CheckABIStruct, haveAbiSizes bool) {
	var _arg1 *C.GstCheckABIStruct // out
	var _arg2 C.gboolean           // out

	_arg1 = (*C.GstCheckABIStruct)(gextras.StructNative(unsafe.Pointer(list)))
	if haveAbiSizes {
		_arg2 = C.TRUE
	}

	C.gst_check_abi_list(_arg1, _arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(haveAbiSizes)
}

// CheckBufferData (gst_check_buffer_data): compare the buffer contents with
// data and size.
//
// The function takes the following parameters:
//
//   - buffer to compare.
//   - data (optional) to compare to.
//   - size of data to compare.
func CheckBufferData(buffer *gst.Buffer, data unsafe.Pointer, size uint) {
	var _arg1 *C.GstBuffer    // out
	var _arg2 C.gconstpointer // out
	var _arg3 C.gsize         // out

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = (C.gconstpointer)(unsafe.Pointer(data))
	_arg3 = C.gsize(size)

	C.gst_check_buffer_data(_arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(data)
	runtime.KeepAlive(size)
}

// CheckCapsEqual (gst_check_caps_equal): compare two caps with
// gst_caps_is_equal and fail unless they are equal.
//
// The function takes the following parameters:
//
//   - caps1: first caps to compare.
//   - caps2: second caps to compare.
func CheckCapsEqual(caps1, caps2 *gst.Caps) {
	var _arg1 *C.GstCaps // out
	var _arg2 *C.GstCaps // out

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps1)))
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps2)))

	C.gst_check_caps_equal(_arg1, _arg2)
	runtime.KeepAlive(caps1)
	runtime.KeepAlive(caps2)
}

// CheckChainFunc (gst_check_chain_func): fake chain function that appends the
// buffer to the internal list of buffers.
//
// The function takes the following parameters:
//
//   - pad
//   - parent
//   - buffer
func CheckChainFunc(pad *gst.Pad, parent gst.GstObjector, buffer *gst.Buffer) gst.FlowReturn {
	var _arg1 *C.GstPad       // out
	var _arg2 *C.GstObject    // out
	var _arg3 *C.GstBuffer    // out
	var _cret C.GstFlowReturn // in

	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.BaseObject(pad).Native()))
	_arg2 = (*C.GstObject)(unsafe.Pointer(coreglib.BaseObject(parent).Native()))
	_arg3 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_check_chain_func(_arg1, _arg2, _arg3)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(buffer)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// CheckClearLogFilter (gst_check_clear_log_filter): clear all filters added by
// gst_check_add_log_filter.
//
// MT safe.
func CheckClearLogFilter() {
	C.gst_check_clear_log_filter()
}

// CheckDropBuffers (gst_check_drop_buffers): unref and remove all buffers that
// are in the global buffers GList, emptying the list.
func CheckDropBuffers() {
	C.gst_check_drop_buffers()
}

// CheckElementPushBuffer (gst_check_element_push_buffer): create an element
// using the factory providing the element_name and push the buffer_in to this
// element. The element should create one buffer and this will be compared with
// buffer_out. We only check the caps and the data of the buffers. This function
// unrefs the buffers.
//
// The function takes the following parameters:
//
//   - elementName: name of the element that needs to be created.
//   - bufferIn: push this buffer to the element.
//   - capsIn expected of the sinkpad of the element.
//   - bufferOut: compare the result with this buffer.
//   - capsOut expected of the srcpad of the element.
func CheckElementPushBuffer(elementName string, bufferIn *gst.Buffer, capsIn *gst.Caps, bufferOut *gst.Buffer, capsOut *gst.Caps) {
	var _arg1 *C.gchar     // out
	var _arg2 *C.GstBuffer // out
	var _arg3 *C.GstCaps   // out
	var _arg4 *C.GstBuffer // out
	var _arg5 *C.GstCaps   // out

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(elementName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(bufferIn)))
	_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(capsIn)))
	_arg4 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(bufferOut)))
	_arg5 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(capsOut)))

	C.gst_check_element_push_buffer(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(elementName)
	runtime.KeepAlive(bufferIn)
	runtime.KeepAlive(capsIn)
	runtime.KeepAlive(bufferOut)
	runtime.KeepAlive(capsOut)
}

// CheckElementPushBufferList (gst_check_element_push_buffer_list): create an
// element using the factory providing the element_name and push the buffers in
// buffer_in to this element. The element should create the buffers equal to the
// buffers in buffer_out. We only check the size and the data of the buffers.
// This function unrefs the buffers in the two lists. The last_flow_return
// parameter indicates the expected flow return value from pushing the final
// buffer in the list. This can be used to set up a test which pushes some
// buffers and then an invalid buffer, when the final buffer is expected to
// fail, for example.
//
// The function takes the following parameters:
//
//   - elementName: name of the element that needs to be created.
//   - bufferIn: list of buffers that needs to be pushed to the element.
//   - capsIn expected of the sinkpad of the element.
//   - bufferOut: list of buffers that we expect from the element.
//   - capsOut expected of the srcpad of the element.
//   - lastFlowReturn: last buffer push needs to give this GstFlowReturn.
func CheckElementPushBufferList(elementName string, bufferIn []*gst.Buffer, capsIn *gst.Caps, bufferOut []*gst.Buffer, capsOut *gst.Caps, lastFlowReturn gst.FlowReturn) {
	var _arg1 *C.gchar        // out
	var _arg2 *C.GList        // out
	var _arg3 *C.GstCaps      // out
	var _arg4 *C.GList        // out
	var _arg5 *C.GstCaps      // out
	var _arg6 C.GstFlowReturn // out

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(elementName)))
	defer C.free(unsafe.Pointer(_arg1))
	for i := len(bufferIn) - 1; i >= 0; i-- {
		src := bufferIn[i]
		var dst *C.GstBuffer // out
		dst = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(src)), nil)
		_arg2 = C.g_list_prepend(_arg2, C.gpointer(unsafe.Pointer(dst)))
	}
	_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(capsIn)))
	for i := len(bufferOut) - 1; i >= 0; i-- {
		src := bufferOut[i]
		var dst *C.GstBuffer // out
		dst = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(src)), nil)
		_arg4 = C.g_list_prepend(_arg4, C.gpointer(unsafe.Pointer(dst)))
	}
	_arg5 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(capsOut)))
	_arg6 = C.GstFlowReturn(lastFlowReturn)

	C.gst_check_element_push_buffer_list(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(elementName)
	runtime.KeepAlive(bufferIn)
	runtime.KeepAlive(capsIn)
	runtime.KeepAlive(bufferOut)
	runtime.KeepAlive(capsOut)
	runtime.KeepAlive(lastFlowReturn)
}

// The function takes the following parameters:
//
//   - message
//   - typ
//   - domain
//   - code
func CheckMessageError(message *gst.Message, typ gst.MessageType, domain glib.Quark, code int) {
	var _arg1 *C.GstMessage    // out
	var _arg2 C.GstMessageType // out
	var _arg3 C.GQuark         // out
	var _arg4 C.gint           // out

	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(message)))
	_arg2 = C.GstMessageType(typ)
	_arg3 = C.GQuark(domain)
	_arg4 = C.gint(code)

	C.gst_check_message_error(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(message)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(code)
}

// CheckSetupElement (gst_check_setup_element): setup an element for a filter
// test with mysrcpad and mysinkpad.
//
// The function takes the following parameters:
//
//   - factory: factory.
//
// The function returns the following values:
//
//   - element: new element.
func CheckSetupElement(factory string) gst.Elementer {
	var _arg1 *C.gchar      // out
	var _cret *C.GstElement // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(factory)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_check_setup_element(_arg1)
	runtime.KeepAlive(factory)

	var _element gst.Elementer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gst.Elementer)
			return ok
		})
		rv, ok := casted.(gst.Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_element = rv
	}

	return _element
}

// CheckSetupEvents (gst_check_setup_events): push stream-start, caps and
// segment event, which consist of the minimum required events to allow
// streaming. Caps is optional to allow raw src testing. If element has more
// than one src or sink pad, use gst_check_setup_events_with_stream_id()
// instead.
//
// The function takes the following parameters:
//
//   - srcpad: src Pad to push on.
//   - element use to create the stream id.
//   - caps (optional) in case caps event must be sent.
//   - format of the default segment to send.
func CheckSetupEvents(srcpad *gst.Pad, element gst.Elementer, caps *gst.Caps, format gst.Format) {
	var _arg1 *C.GstPad     // out
	var _arg2 *C.GstElement // out
	var _arg3 *C.GstCaps    // out
	var _arg4 C.GstFormat   // out

	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.BaseObject(srcpad).Native()))
	_arg2 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(element).Native()))
	if caps != nil {
		_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}
	_arg4 = C.GstFormat(format)

	C.gst_check_setup_events(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(srcpad)
	runtime.KeepAlive(element)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(format)
}

// CheckSetupEventsWithStreamID (gst_check_setup_events_with_stream_id): push
// stream-start, caps and segment event, which consist of the minimum required
// events to allow streaming. Caps is optional to allow raw src testing.
//
// The function takes the following parameters:
//
//   - srcpad: src Pad to push on.
//   - element use to create the stream id.
//   - caps (optional) in case caps event must be sent.
//   - format of the default segment to send.
//   - streamId: unique identifier for the stream.
func CheckSetupEventsWithStreamID(srcpad *gst.Pad, element gst.Elementer, caps *gst.Caps, format gst.Format, streamId string) {
	var _arg1 *C.GstPad     // out
	var _arg2 *C.GstElement // out
	var _arg3 *C.GstCaps    // out
	var _arg4 C.GstFormat   // out
	var _arg5 *C.gchar      // out

	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.BaseObject(srcpad).Native()))
	_arg2 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(element).Native()))
	if caps != nil {
		_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}
	_arg4 = C.GstFormat(format)
	_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(streamId)))
	defer C.free(unsafe.Pointer(_arg5))

	C.gst_check_setup_events_with_stream_id(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(srcpad)
	runtime.KeepAlive(element)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(format)
	runtime.KeepAlive(streamId)
}

// CheckSetupSinkPad (gst_check_setup_sink_pad) does the same as
// #gst_check_setup_sink_pad_by_name with the <emphasis> name </emphasis>
// parameter equal to "src".
//
// The function takes the following parameters:
//
//   - element to setup pad on.
//   - tmpl: pad template.
//
// The function returns the following values:
//
//   - pad: new pad that can be used to check the output of element.
func CheckSetupSinkPad(element gst.Elementer, tmpl *gst.StaticPadTemplate) *gst.Pad {
	var _arg1 *C.GstElement           // out
	var _arg2 *C.GstStaticPadTemplate // out
	var _cret *C.GstPad               // in

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(element).Native()))
	_arg2 = (*C.GstStaticPadTemplate)(gextras.StructNative(unsafe.Pointer(tmpl)))

	_cret = C.gst_check_setup_sink_pad(_arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(tmpl)

	var _pad *gst.Pad // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pad = &gst.Pad{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		}
	}

	return _pad
}

// CheckSetupSinkPadByName (gst_check_setup_sink_pad_by_name) creates a new sink
// pad (based on the given tmpl) and links it to the given element src pad (the
// pad that matches the given name). You can set event/chain/query functions on
// this pad to check the output of the element.
//
// The function takes the following parameters:
//
//   - element to setup pad on.
//   - tmpl: pad template.
//   - name: name of the element src pad that will be linked to the sink pad
//     that will be setup.
//
// The function returns the following values:
//
//   - pad: new pad that can be used to check the output of element.
func CheckSetupSinkPadByName(element gst.Elementer, tmpl *gst.StaticPadTemplate, name string) *gst.Pad {
	var _arg1 *C.GstElement           // out
	var _arg2 *C.GstStaticPadTemplate // out
	var _arg3 *C.gchar                // out
	var _cret *C.GstPad               // in

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(element).Native()))
	_arg2 = (*C.GstStaticPadTemplate)(gextras.StructNative(unsafe.Pointer(tmpl)))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gst_check_setup_sink_pad_by_name(_arg1, _arg2, _arg3)
	runtime.KeepAlive(element)
	runtime.KeepAlive(tmpl)
	runtime.KeepAlive(name)

	var _pad *gst.Pad // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pad = &gst.Pad{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		}
	}

	return _pad
}

// The function takes the following parameters:
//
//   - element to setup pad on.
//   - tmpl: pad template.
//   - name: name.
//
// The function returns the following values:
//
//   - pad: new pad.
func CheckSetupSinkPadByNameFromTemplate(element gst.Elementer, tmpl *gst.PadTemplate, name string) *gst.Pad {
	var _arg1 *C.GstElement     // out
	var _arg2 *C.GstPadTemplate // out
	var _arg3 *C.gchar          // out
	var _cret *C.GstPad         // in

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(element).Native()))
	_arg2 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.BaseObject(tmpl).Native()))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gst_check_setup_sink_pad_by_name_from_template(_arg1, _arg2, _arg3)
	runtime.KeepAlive(element)
	runtime.KeepAlive(tmpl)
	runtime.KeepAlive(name)

	var _pad *gst.Pad // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pad = &gst.Pad{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		}
	}

	return _pad
}

// The function takes the following parameters:
//
//   - element to setup pad on.
//   - tmpl: pad template.
//
// The function returns the following values:
//
//   - pad: new pad.
func CheckSetupSinkPadFromTemplate(element gst.Elementer, tmpl *gst.PadTemplate) *gst.Pad {
	var _arg1 *C.GstElement     // out
	var _arg2 *C.GstPadTemplate // out
	var _cret *C.GstPad         // in

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(element).Native()))
	_arg2 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.BaseObject(tmpl).Native()))

	_cret = C.gst_check_setup_sink_pad_from_template(_arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(tmpl)

	var _pad *gst.Pad // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pad = &gst.Pad{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		}
	}

	return _pad
}

// CheckSetupSrcPad (gst_check_setup_src_pad) does the same as
// #gst_check_setup_src_pad_by_name with the <emphasis> name </emphasis>
// parameter equal to "sink".
//
// The function takes the following parameters:
//
//   - element to setup pad on.
//   - tmpl: pad template.
//
// The function returns the following values:
//
//   - pad: new pad that can be used to inject data on element.
func CheckSetupSrcPad(element gst.Elementer, tmpl *gst.StaticPadTemplate) *gst.Pad {
	var _arg1 *C.GstElement           // out
	var _arg2 *C.GstStaticPadTemplate // out
	var _cret *C.GstPad               // in

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(element).Native()))
	_arg2 = (*C.GstStaticPadTemplate)(gextras.StructNative(unsafe.Pointer(tmpl)))

	_cret = C.gst_check_setup_src_pad(_arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(tmpl)

	var _pad *gst.Pad // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pad = &gst.Pad{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		}
	}

	return _pad
}

// CheckSetupSrcPadByName (gst_check_setup_src_pad_by_name) creates a new src
// pad (based on the given tmpl) and links it to the given element sink pad (the
// pad that matches the given name). Before using the src pad to push data on
// element you need to call #gst_check_setup_events on the created src pad.
//
// Example of how to push a buffer on element:
//
//	static GstStaticPadTemplate sinktemplate = GST_STATIC_PAD_TEMPLATE ("sink",
//	GST_PAD_SINK,
//	GST_PAD_ALWAYS,
//	GST_STATIC_CAPS (YOUR_CAPS_TEMPLATE_STRING)
//	);
//	static GstStaticPadTemplate srctemplate = GST_STATIC_PAD_TEMPLATE ("src",
//	GST_PAD_SRC,
//	GST_PAD_ALWAYS,
//	GST_STATIC_CAPS (YOUR_CAPS_TEMPLATE_STRING)
//	);
//
//	GstElement * element = gst_check_setup_element ("element");
//	GstPad * mysrcpad = gst_check_setup_src_pad (element, &srctemplate);
//	GstPad * mysinkpad = gst_check_setup_sink_pad (element, &sinktemplate);
//
//	gst_pad_set_active (mysrcpad, TRUE);
//	gst_pad_set_active (mysinkpad, TRUE);
//	fail_unless (gst_element_set_state (element, GST_STATE_PLAYING) == GST_STATE_CHANGE_SUCCESS, "could not set to playing");
//
//	GstCaps * caps = gst_caps_from_string (YOUR_DESIRED_SINK_CAPS);
//	gst_check_setup_events (mysrcpad, element, caps, GST_FORMAT_TIME);
//	gst_caps_unref (caps);
//
//	fail_unless (gst_pad_push (mysrcpad, gst_buffer_new_and_alloc(2)) == GST_FLOW_OK);
//
// For very simple input/output test scenarios checkout
// #gst_check_element_push_buffer_list and #gst_check_element_push_buffer.
//
// The function takes the following parameters:
//
//   - element to setup src pad on.
//   - tmpl: pad template.
//   - name: name of the element sink pad that will be linked to the src pad
//     that will be setup.
//
// The function returns the following values:
//
//   - pad: new pad that can be used to inject data on element.
func CheckSetupSrcPadByName(element gst.Elementer, tmpl *gst.StaticPadTemplate, name string) *gst.Pad {
	var _arg1 *C.GstElement           // out
	var _arg2 *C.GstStaticPadTemplate // out
	var _arg3 *C.gchar                // out
	var _cret *C.GstPad               // in

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(element).Native()))
	_arg2 = (*C.GstStaticPadTemplate)(gextras.StructNative(unsafe.Pointer(tmpl)))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gst_check_setup_src_pad_by_name(_arg1, _arg2, _arg3)
	runtime.KeepAlive(element)
	runtime.KeepAlive(tmpl)
	runtime.KeepAlive(name)

	var _pad *gst.Pad // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pad = &gst.Pad{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		}
	}

	return _pad
}

// The function takes the following parameters:
//
//   - element to setup pad on.
//   - tmpl: pad template.
//   - name: name.
//
// The function returns the following values:
//
//   - pad: new pad.
func CheckSetupSrcPadByNameFromTemplate(element gst.Elementer, tmpl *gst.PadTemplate, name string) *gst.Pad {
	var _arg1 *C.GstElement     // out
	var _arg2 *C.GstPadTemplate // out
	var _arg3 *C.gchar          // out
	var _cret *C.GstPad         // in

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(element).Native()))
	_arg2 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.BaseObject(tmpl).Native()))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gst_check_setup_src_pad_by_name_from_template(_arg1, _arg2, _arg3)
	runtime.KeepAlive(element)
	runtime.KeepAlive(tmpl)
	runtime.KeepAlive(name)

	var _pad *gst.Pad // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pad = &gst.Pad{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		}
	}

	return _pad
}

// The function takes the following parameters:
//
//   - element to setup pad on.
//   - tmpl: pad template.
//
// The function returns the following values:
//
//   - pad: new pad.
func CheckSetupSrcPadFromTemplate(element gst.Elementer, tmpl *gst.PadTemplate) *gst.Pad {
	var _arg1 *C.GstElement     // out
	var _arg2 *C.GstPadTemplate // out
	var _cret *C.GstPad         // in

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(element).Native()))
	_arg2 = (*C.GstPadTemplate)(unsafe.Pointer(coreglib.BaseObject(tmpl).Native()))

	_cret = C.gst_check_setup_src_pad_from_template(_arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(tmpl)

	var _pad *gst.Pad // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pad = &gst.Pad{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		}
	}

	return _pad
}

func CheckTeardownElement(element gst.Elementer) {
	var _arg1 *C.GstElement // out

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(element).Native()))

	C.gst_check_teardown_element(_arg1)
	runtime.KeepAlive(element)
}

// The function takes the following parameters:
//
//   - element
//   - name
func CheckTeardownPadByName(element gst.Elementer, name string) {
	var _arg1 *C.GstElement // out
	var _arg2 *C.gchar      // out

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(element).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gst_check_teardown_pad_by_name(_arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(name)
}

func CheckTeardownSinkPad(element gst.Elementer) {
	var _arg1 *C.GstElement // out

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(element).Native()))

	C.gst_check_teardown_sink_pad(_arg1)
	runtime.KeepAlive(element)
}

func CheckTeardownSrcPad(element gst.Elementer) {
	var _arg1 *C.GstElement // out

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(element).Native()))

	C.gst_check_teardown_src_pad(_arg1)
	runtime.KeepAlive(element)
}

// TestClockOverrides contains methods that are overridable.
type TestClockOverrides struct {
}

func defaultTestClockOverrides(v *TestClock) TestClockOverrides {
	return TestClockOverrides{}
}

// TestClock (GstTestClock) is an implementation of Clock which has different
// behaviour compared to SystemClock. Time for SystemClock advances
// according to the system time, while time for TestClock changes only when
// gst_test_clock_set_time() or gst_test_clock_advance_time() are called.
// TestClock provides unit tests with the possibility to precisely advance the
// time in a deterministic manner, independent of the system time or any other
// external factors.
//
// Advancing the time of a TestClock
//
//	#include <gst/gst.h>
//	#include <gst/check/gstcheck.h>
//	#include <gst/check/gsttestclock.h>
//
//	GstClockTime latency;
//	GstElement *element;
//	GstPad *srcpad;
//	GstClock *clock;
//	GstTestClock *test_clock;
//	GstBuffer buf;
//	GstClockID pending_id;
//	GstClockID processed_id;
//
//	latency = 42 * GST_MSECOND;
//	element = create_element (latency, ...);
//	srcpad = get_source_pad (element);
//
//	clock = gst_test_clock_new ();
//	test_clock = GST_TEST_CLOCK (clock);
//	gst_element_set_clock (element, clock);
//
//	GST_INFO ("Set time, create and push the first buffer\n");
//	gst_test_clock_set_time (test_clock, 0);
//	buf = create_test_buffer (gst_clock_get_time (clock), ...);
//	gst_assert_cmpint (gst_pad_push (srcpad, buf), ==, GST_FLOW_OK);
//
//	GST_INFO ("Block until element is waiting for a clock notification\n");
//	gst_test_clock_wait_for_next_pending_id (test_clock, &pending_id);
//	GST_INFO ("Advance to the requested time of the clock notification\n");
//	gst_test_clock_advance_time (test_clock, latency);
//	GST_INFO ("Release the next blocking wait and make sure it is the one from element\n");
//	processed_id = gst_test_clock_process_next_clock_id (test_clock);
//	g_assert (processed_id == pending_id);
//	g_assert_cmpint (GST_CLOCK_ENTRY_STATUS (processed_id), ==, GST_CLOCK_OK);
//	gst_clock_id_unref (pending_id);
//	gst_clock_id_unref (processed_id);
//
//	GST_INFO ("Validate that element produced an output buffer and check its timestamp\n");
//	g_assert_cmpint (get_number_of_output_buffer (...), ==, 1);
//	buf = get_buffer_pushed_by_element (element, ...);
//	g_assert_cmpint (GST_BUFFER_TIMESTAMP (buf), ==, latency);
//	gst_buffer_unref (buf);
//	GST_INFO ("Check that element does not wait for any clock notification\n");
//	g_assert (!gst_test_clock_peek_next_pending_id (test_clock, NULL));
//
//	GST_INFO ("Set time, create and push the second buffer\n");
//	gst_test_clock_advance_time (test_clock, 10 * GST_SECOND);
//	buf = create_test_buffer (gst_clock_get_time (clock), ...);
//	gst_assert_cmpint (gst_pad_push (srcpad, buf), ==, GST_FLOW_OK);
//
//	GST_INFO ("Block until element is waiting for a new clock notification\n");
//	(gst_test_clock_wait_for_next_pending_id (test_clock, &pending_id);
//	GST_INFO ("Advance past 7ms beyond the requested time of the clock notification\n");
//	gst_test_clock_advance_time (test_clock, latency + 7 * GST_MSECOND);
//	GST_INFO ("Release the next blocking wait and make sure it is the one from element\n");
//	processed_id = gst_test_clock_process_next_clock_id (test_clock);
//	g_assert (processed_id == pending_id);
//	g_assert_cmpint (GST_CLOCK_ENTRY_STATUS (processed_id), ==, GST_CLOCK_OK);
//	gst_clock_id_unref (pending_id);
//	gst_clock_id_unref (processed_id);
//
//	GST_INFO ("Validate that element produced an output buffer and check its timestamp\n");
//	g_assert_cmpint (get_number_of_output_buffer (...), ==, 1);
//	buf = get_buffer_pushed_by_element (element, ...);
//	g_assert_cmpint (GST_BUFFER_TIMESTAMP (buf), ==,
//	    10 * GST_SECOND + latency + 7 * GST_MSECOND);
//	gst_buffer_unref (buf);
//	GST_INFO ("Check that element does not wait for any clock notification\n");
//	g_assert (!gst_test_clock_peek_next_pending_id (test_clock, NULL));
//	...
//
// Since TestClock is only supposed to be used in unit tests it calls
// g_assert(), g_assert_cmpint() or g_assert_cmpuint() to validate all function
// arguments. This will highlight any issues with the unit test code itself.
type TestClock struct {
	_ [0]func() // equal guard
	gst.Clock
}

var (
	_ gst.Clocker = (*TestClock)(nil)
)

// TestClocker describes types inherited from TestClock.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type TestClocker interface {
	gst.Clocker

	// AdvanceTime (gst_test_clock_advance_time) advances the time of the
	// test_clock by the amount given by delta.
	AdvanceTime(delta gst.ClockTimeDiff)
	// Crank (gst_test_clock_crank): "crank" consists of three steps: 1:
	// Wait for a ClockID to be registered with the TestClock.
	Crank() bool
	// NextEntryTime (gst_test_clock_get_next_entry_time): retrieve the
	// requested time for the next pending clock notification.
	NextEntryTime() gst.ClockTime
	// HasID (gst_test_clock_has_id) checks whether test_clock was requested to
	// provide the clock notification given by id.
	HasID(id gst.ClockID) bool
	// PeekIDCount (gst_test_clock_peek_id_count): determine the number of
	// pending clock notifications that have been requested from the test_clock.
	PeekIDCount() uint
	// PeekNextPendingID (gst_test_clock_peek_next_pending_id) determines if the
	// pending_id is the next clock notification scheduled to be triggered given
	// the current time of the test_clock.
	PeekNextPendingID() (gst.ClockID, bool)
	// ProcessID (gst_test_clock_process_id) processes and releases the pending
	// ID.
	ProcessID(pendingId gst.ClockID) bool
	// ProcessIDList (gst_test_clock_process_id_list) processes and releases the
	// pending IDs in the list.
	ProcessIDList(pendingList []gst.ClockID) uint
	// ProcessNextClockID (gst_test_clock_process_next_clock_id): MT safe.
	ProcessNextClockID() gst.ClockID
	// SetTime (gst_test_clock_set_time) sets the time of test_clock to the time
	// given by new_time.
	SetTime(newTime gst.ClockTime)
	// TimedWaitForMultiplePendingIDs
	// (gst_test_clock_timed_wait_for_multiple_pending_ids) blocks until at
	// least count clock notifications have been requested from test_clock,
	// or the timeout expires.
	TimedWaitForMultiplePendingIDs(count, timeoutMs uint) ([]gst.ClockID, bool)
	// WaitForMultiplePendingIDs (gst_test_clock_wait_for_multiple_pending_ids)
	// blocks until at least count clock notifications have been requested from
	// test_clock.
	WaitForMultiplePendingIDs(count uint) []gst.ClockID
	// WaitForNextPendingID (gst_test_clock_wait_for_next_pending_id) waits
	// until a clock notification is requested from test_clock.
	WaitForNextPendingID() gst.ClockID
	// WaitForPendingIDCount (gst_test_clock_wait_for_pending_id_count) blocks
	// until at least count clock notifications have been requested from
	// test_clock.
	WaitForPendingIDCount(count uint)

	baseTestClock() *TestClock
}

var _ TestClocker = (*TestClock)(nil)

func init() {
	coreglib.RegisterClassInfo[*TestClock, *TestClockClass, TestClockOverrides](
		GTypeTestClock,
		initTestClockClass,
		wrapTestClock,
		defaultTestClockOverrides,
	)
}

func initTestClockClass(gclass unsafe.Pointer, overrides TestClockOverrides, classInitFunc func(*TestClockClass)) {
	if classInitFunc != nil {
		class := (*TestClockClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTestClock(obj *coreglib.Object) *TestClock {
	return &TestClock{
		Clock: gst.Clock{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalTestClock(p uintptr) (interface{}, error) {
	return wrapTestClock(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (testClock *TestClock) baseTestClock() *TestClock {
	return testClock
}

// BaseTestClock returns the underlying base object.
func BaseTestClock(obj TestClocker) *TestClock {
	return obj.baseTestClock()
}

// NewTestClock (gst_test_clock_new) creates a new test clock with its time set
// to zero.
//
// MT safe.
//
// The function returns the following values:
//
//   - testClock cast to Clock.
func NewTestClock() *TestClock {
	var _cret *C.GstClock // in

	_cret = C.gst_test_clock_new()

	var _testClock *TestClock // out

	_testClock = wrapTestClock(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _testClock
}

// NewTestClockWithStartTime (gst_test_clock_new_with_start_time) creates a new
// test clock with its time set to the specified time.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - startTime set to the desired start time of the clock.
//
// The function returns the following values:
//
//   - testClock cast to Clock.
func NewTestClockWithStartTime(startTime gst.ClockTime) *TestClock {
	var _arg1 C.GstClockTime // out
	var _cret *C.GstClock    // in

	_arg1 = C.GstClockTime(startTime)

	_cret = C.gst_test_clock_new_with_start_time(_arg1)
	runtime.KeepAlive(startTime)

	var _testClock *TestClock // out

	_testClock = wrapTestClock(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _testClock
}

// AdvanceTime (gst_test_clock_advance_time) advances the time of the test_clock
// by the amount given by delta. The time of test_clock is monotonically
// increasing, therefore providing a delta which is negative or zero is a
// programming error.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - delta: positive ClockTimeDiff to be added to the time of the clock.
func (testClock *TestClock) AdvanceTime(delta gst.ClockTimeDiff) {
	var _arg0 *C.GstTestClock    // out
	var _arg1 C.GstClockTimeDiff // out

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.BaseObject(testClock).Native()))
	_arg1 = C.GstClockTimeDiff(delta)

	C.gst_test_clock_advance_time(_arg0, _arg1)
	runtime.KeepAlive(testClock)
	runtime.KeepAlive(delta)
}

// Crank (gst_test_clock_crank): "crank" consists of three steps: 1: Wait for
// a ClockID to be registered with the TestClock. 2: Advance the TestClock to
// the time the ClockID is waiting, unless the clock time is already passed the
// clock id (Since: 1.18). 3: Release the ClockID wait. A "crank" can be though
// of as the notion of manually driving the clock forward to its next logical
// step.
//
// The function returns the following values:
//
//   - ok: TRUE if the crank was successful, FALSE otherwise.
//
//     MT safe.
func (testClock *TestClock) Crank() bool {
	var _arg0 *C.GstTestClock // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.BaseObject(testClock).Native()))

	_cret = C.gst_test_clock_crank(_arg0)
	runtime.KeepAlive(testClock)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NextEntryTime (gst_test_clock_get_next_entry_time): retrieve the requested
// time for the next pending clock notification.
//
// MT safe.
//
// The function returns the following values:
//
//   - clockTime set to the time of the next pending clock notification.
//     If no clock notifications have been requested GST_CLOCK_TIME_NONE will be
//     returned.
func (testClock *TestClock) NextEntryTime() gst.ClockTime {
	var _arg0 *C.GstTestClock // out
	var _cret C.GstClockTime  // in

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.BaseObject(testClock).Native()))

	_cret = C.gst_test_clock_get_next_entry_time(_arg0)
	runtime.KeepAlive(testClock)

	var _clockTime gst.ClockTime // out

	_clockTime = gst.ClockTime(_cret)

	return _clockTime
}

// HasID (gst_test_clock_has_id) checks whether test_clock was requested to
// provide the clock notification given by id.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - id clock notification.
//
// The function returns the following values:
//
//   - ok: TRUE if the clock has been asked to provide the given clock
//     notification, FALSE otherwise.
func (testClock *TestClock) HasID(id gst.ClockID) bool {
	var _arg0 *C.GstTestClock // out
	var _arg1 C.GstClockID    // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.BaseObject(testClock).Native()))
	_arg1 = (C.GstClockID)(unsafe.Pointer(id))

	_cret = C.gst_test_clock_has_id(_arg0, _arg1)
	runtime.KeepAlive(testClock)
	runtime.KeepAlive(id)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PeekIDCount (gst_test_clock_peek_id_count): determine the number of pending
// clock notifications that have been requested from the test_clock.
//
// MT safe.
//
// The function returns the following values:
//
//   - guint: number of pending clock notifications.
func (testClock *TestClock) PeekIDCount() uint {
	var _arg0 *C.GstTestClock // out
	var _cret C.guint         // in

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.BaseObject(testClock).Native()))

	_cret = C.gst_test_clock_peek_id_count(_arg0)
	runtime.KeepAlive(testClock)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// PeekNextPendingID (gst_test_clock_peek_next_pending_id) determines if the
// pending_id is the next clock notification scheduled to be triggered given the
// current time of the test_clock.
//
// MT safe.
//
// The function returns the following values:
//
//   - pendingId (optional) clock notification to look for.
//   - ok: TRUE if pending_id is the next clock notification to be triggered,
//     FALSE otherwise.
func (testClock *TestClock) PeekNextPendingID() (gst.ClockID, bool) {
	var _arg0 *C.GstTestClock // out
	var _arg1 C.GstClockID    // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.BaseObject(testClock).Native()))

	_cret = C.gst_test_clock_peek_next_pending_id(_arg0, &_arg1)
	runtime.KeepAlive(testClock)

	var _pendingId gst.ClockID // out
	var _ok bool               // out

	_pendingId = (gst.ClockID)(unsafe.Pointer(_arg1))
	if _cret != 0 {
		_ok = true
	}

	return _pendingId, _ok
}

// ProcessID (gst_test_clock_process_id) processes and releases the pending ID.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - pendingId: ClockID.
func (testClock *TestClock) ProcessID(pendingId gst.ClockID) bool {
	var _arg0 *C.GstTestClock // out
	var _arg1 C.GstClockID    // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.BaseObject(testClock).Native()))
	_arg1 = (C.GstClockID)(unsafe.Pointer(pendingId))

	_cret = C.gst_test_clock_process_id(_arg0, _arg1)
	runtime.KeepAlive(testClock)
	runtime.KeepAlive(pendingId)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ProcessIDList (gst_test_clock_process_id_list) processes and releases the
// pending IDs in the list.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - pendingList (optional): list of pending ClockIDs.
func (testClock *TestClock) ProcessIDList(pendingList []gst.ClockID) uint {
	var _arg0 *C.GstTestClock // out
	var _arg1 *C.GList        // out
	var _cret C.guint         // in

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.BaseObject(testClock).Native()))
	if pendingList != nil {
		for i := len(pendingList) - 1; i >= 0; i-- {
			src := pendingList[i]
			var dst C.GstClockID // out
			dst = (C.GstClockID)(unsafe.Pointer(src))
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_list_free(_arg1)
	}

	_cret = C.gst_test_clock_process_id_list(_arg0, _arg1)
	runtime.KeepAlive(testClock)
	runtime.KeepAlive(pendingList)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ProcessNextClockID (gst_test_clock_process_next_clock_id): MT safe.
//
// The function returns the following values:
//
//   - clockID (optional) containing the next pending clock notification.
func (testClock *TestClock) ProcessNextClockID() gst.ClockID {
	var _arg0 *C.GstTestClock // out
	var _cret C.GstClockID    // in

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.BaseObject(testClock).Native()))

	_cret = C.gst_test_clock_process_next_clock_id(_arg0)
	runtime.KeepAlive(testClock)

	var _clockID gst.ClockID // out

	_clockID = (gst.ClockID)(unsafe.Pointer(_cret))

	return _clockID
}

// SetTime (gst_test_clock_set_time) sets the time of test_clock to the time
// given by new_time. The time of test_clock is monotonically increasing,
// therefore providing a new_time which is earlier or equal to the time of the
// clock as given by gst_clock_get_time() is a programming error.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - newTime later than that returned by gst_clock_get_time().
func (testClock *TestClock) SetTime(newTime gst.ClockTime) {
	var _arg0 *C.GstTestClock // out
	var _arg1 C.GstClockTime  // out

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.BaseObject(testClock).Native()))
	_arg1 = C.GstClockTime(newTime)

	C.gst_test_clock_set_time(_arg0, _arg1)
	runtime.KeepAlive(testClock)
	runtime.KeepAlive(newTime)
}

// TimedWaitForMultiplePendingIDs
// (gst_test_clock_timed_wait_for_multiple_pending_ids) blocks until at least
// count clock notifications have been requested from test_clock, or the timeout
// expires.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - count: number of pending clock notifications to wait for.
//   - timeoutMs: timeout in milliseconds.
//
// The function returns the following values:
//
//   - pendingList (optional): address of a #GList pointer variable to store the
//     list of pending ClockIDs that expired, or NULL.
//   - ok: gboolean TRUE if the waits have been registered, FALSE if not. (Could
//     be that it timed out waiting or that more waits than waits was found).
func (testClock *TestClock) TimedWaitForMultiplePendingIDs(count, timeoutMs uint) ([]gst.ClockID, bool) {
	var _arg0 *C.GstTestClock // out
	var _arg1 C.guint         // out
	var _arg2 C.guint         // out
	var _arg3 *C.GList        // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.BaseObject(testClock).Native()))
	_arg1 = C.guint(count)
	_arg2 = C.guint(timeoutMs)

	_cret = C.gst_test_clock_timed_wait_for_multiple_pending_ids(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(testClock)
	runtime.KeepAlive(count)
	runtime.KeepAlive(timeoutMs)

	var _pendingList []gst.ClockID // out
	var _ok bool                   // out

	if _arg3 != nil {
		_pendingList = make([]gst.ClockID, 0, gextras.ListSize(unsafe.Pointer(_arg3)))
		gextras.MoveList(unsafe.Pointer(_arg3), true, func(v unsafe.Pointer) {
			src := (C.GstClockID)(v)
			var dst gst.ClockID // out
			dst = (gst.ClockID)(unsafe.Pointer(src))
			_pendingList = append(_pendingList, dst)
		})
	}
	if _cret != 0 {
		_ok = true
	}

	return _pendingList, _ok
}

// WaitForMultiplePendingIDs (gst_test_clock_wait_for_multiple_pending_ids)
// blocks until at least count clock notifications have been requested from
// test_clock. There is no timeout for this wait, see the main description of
// TestClock.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - count: number of pending clock notifications to wait for.
//
// The function returns the following values:
//
//   - pendingList (optional): address of a #GList pointer variable to store the
//     list of pending ClockIDs that expired, or NULL.
func (testClock *TestClock) WaitForMultiplePendingIDs(count uint) []gst.ClockID {
	var _arg0 *C.GstTestClock // out
	var _arg1 C.guint         // out
	var _arg2 *C.GList        // in

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.BaseObject(testClock).Native()))
	_arg1 = C.guint(count)

	C.gst_test_clock_wait_for_multiple_pending_ids(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(testClock)
	runtime.KeepAlive(count)

	var _pendingList []gst.ClockID // out

	if _arg2 != nil {
		_pendingList = make([]gst.ClockID, 0, gextras.ListSize(unsafe.Pointer(_arg2)))
		gextras.MoveList(unsafe.Pointer(_arg2), true, func(v unsafe.Pointer) {
			src := (C.GstClockID)(v)
			var dst gst.ClockID // out
			dst = (gst.ClockID)(unsafe.Pointer(src))
			_pendingList = append(_pendingList, dst)
		})
	}

	return _pendingList
}

// WaitForNextPendingID (gst_test_clock_wait_for_next_pending_id) waits until a
// clock notification is requested from test_clock. There is no timeout for this
// wait, see the main description of TestClock. A reference to the pending clock
// notification is stored in pending_id.
//
// MT safe.
//
// The function returns the following values:
//
//   - pendingId (optional) information about the pending clock notification.
func (testClock *TestClock) WaitForNextPendingID() gst.ClockID {
	var _arg0 *C.GstTestClock // out
	var _arg1 C.GstClockID    // in

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.BaseObject(testClock).Native()))

	C.gst_test_clock_wait_for_next_pending_id(_arg0, &_arg1)
	runtime.KeepAlive(testClock)

	var _pendingId gst.ClockID // out

	_pendingId = (gst.ClockID)(unsafe.Pointer(_arg1))

	return _pendingId
}

// WaitForPendingIDCount (gst_test_clock_wait_for_pending_id_count) blocks until
// at least count clock notifications have been requested from test_clock.
// There is no timeout for this wait, see the main description of TestClock.
//
// Deprecated: use gst_test_clock_wait_for_multiple_pending_ids() instead.
//
// The function takes the following parameters:
//
//   - count: number of pending clock notifications to wait for.
func (testClock *TestClock) WaitForPendingIDCount(count uint) {
	var _arg0 *C.GstTestClock // out
	var _arg1 C.guint         // out

	_arg0 = (*C.GstTestClock)(unsafe.Pointer(coreglib.BaseObject(testClock).Native()))
	_arg1 = C.guint(count)

	C.gst_test_clock_wait_for_pending_id_count(_arg0, _arg1)
	runtime.KeepAlive(testClock)
	runtime.KeepAlive(count)
}

// TestClockIDListGetLatestTime (gst_test_clock_id_list_get_latest_time) finds
// the latest time inside the list.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - pendingList (optional): list of of pending ClockIDs.
func TestClockIDListGetLatestTime(pendingList []gst.ClockID) gst.ClockTime {
	var _arg1 *C.GList       // out
	var _cret C.GstClockTime // in

	if pendingList != nil {
		for i := len(pendingList) - 1; i >= 0; i-- {
			src := pendingList[i]
			var dst C.GstClockID // out
			dst = (C.GstClockID)(unsafe.Pointer(src))
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_list_free(_arg1)
	}

	_cret = C.gst_test_clock_id_list_get_latest_time(_arg1)
	runtime.KeepAlive(pendingList)

	var _clockTime gst.ClockTime // out

	_clockTime = gst.ClockTime(_cret)

	return _clockTime
}

// CheckABIStruct (GstCheckABIStruct): instance of this type is always passed by
// reference.
type CheckABIStruct struct {
	*checkABIStruct
}

// checkABIStruct is the struct that's finalized.
type checkABIStruct struct {
	native *C.GstCheckABIStruct
}

// Name: name of the structure.
func (c *CheckABIStruct) Name() string {
	valptr := &c.native.name
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Size: current size of a structure.
func (c *CheckABIStruct) Size() int {
	valptr := &c.native.size
	var _v int // out
	_v = int(*valptr)
	return _v
}

// AbiSize: reference size of the structure.
func (c *CheckABIStruct) AbiSize() int {
	valptr := &c.native.abi_size
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Size: current size of a structure.
func (c *CheckABIStruct) SetSize(size int) {
	valptr := &c.native.size
	*valptr = C.int(size)
}

// AbiSize: reference size of the structure.
func (c *CheckABIStruct) SetAbiSize(abiSize int) {
	valptr := &c.native.abi_size
	*valptr = C.int(abiSize)
}

// Harness (GstHarness) is meant to make writing unit test for GStreamer much
// easier. It can be thought of as a way of treating a Element as a black box,
// deterministically feeding it data, and controlling what data it outputs.
//
// The basic structure of Harness is two "floating" Pads that connect to the
// harnessed Element src and sink Pads like so:
//
//	          __________________________
//	 _____   |  _____            _____  |   _____
//	|     |  | |     |          |     | |  |     |
//	| src |--+-| sink|  Element | src |-+--| sink|
//	|_____|  | |_____|          |_____| |  |_____|
//	         |__________________________|
//
// With this, you can now simulate any environment the Element might find
// itself in. By specifying the Caps of the harness Pads, using functions like
// gst_harness_set_src_caps() or gst_harness_set_sink_caps_str(), you can test
// how the Element interacts with different caps sets.
//
// Your harnessed Element can of course also be a bin, and using
// gst_harness_new_parse() supporting standard gst-launch syntax, you can easily
// test a whole pipeline instead of just one element.
//
// You can then go on to push Buffers and Events on to the srcpad,
// using functions like gst_harness_push() and gst_harness_push_event(),
// and then pull them out to examine them with gst_harness_pull() and
// gst_harness_pull_event().
//
// A simple buffer-in buffer-out example
//
//	gst_harness_push_from_src (h);
//
// An instance of this type is always passed by reference.
type Harness struct {
	*harness
}

// harness is the struct that's finalized.
type harness struct {
	native *C.GstHarness
}

// Element: element inside the harness.
func (h *Harness) Element() gst.Elementer {
	valptr := &h.native.element
	var _v gst.Elementer // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gst.Elementer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gst.Elementer)
			return ok
		})
		rv, ok := casted.(gst.Elementer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
		}
		_v = rv
	}
	return _v
}

// Srcpad: internal harness source pad.
func (h *Harness) Srcpad() *gst.Pad {
	valptr := &h.native.srcpad
	var _v *gst.Pad // out
	{
		obj := coreglib.Take(unsafe.Pointer(*valptr))
		_v = &gst.Pad{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		}
	}
	return _v
}

// Sinkpad: internal harness sink pad.
func (h *Harness) Sinkpad() *gst.Pad {
	valptr := &h.native.sinkpad
	var _v *gst.Pad // out
	{
		obj := coreglib.Take(unsafe.Pointer(*valptr))
		_v = &gst.Pad{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		}
	}
	return _v
}

// SrcHarness: source (input) harness (if any).
func (h *Harness) SrcHarness() *Harness {
	valptr := &h.native.src_harness
	var _v *Harness // out
	_v = (*Harness)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// SinkHarness: sink (output) harness (if any).
func (h *Harness) SinkHarness() *Harness {
	valptr := &h.native.sink_harness
	var _v *Harness // out
	_v = (*Harness)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// AddElementSinkPad (gst_harness_add_element_sink_pad) links the specified Pad
// the GstHarness srcpad.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - sinkpad to link to the harness srcpad.
func (h *Harness) AddElementSinkPad(sinkpad *gst.Pad) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.GstPad     // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.BaseObject(sinkpad).Native()))

	C.gst_harness_add_element_sink_pad(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(sinkpad)
}

// AddElementSrcPad (gst_harness_add_element_src_pad) links the specified Pad
// the GstHarness sinkpad. This can be useful if perhaps the srcpad did not
// exist at the time of creating the harness, like a demuxer that provides a
// sometimes-pad after receiving data.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - srcpad to link to the harness sinkpad.
func (h *Harness) AddElementSrcPad(srcpad *gst.Pad) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.GstPad     // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.BaseObject(srcpad).Native()))

	C.gst_harness_add_element_src_pad(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(srcpad)
}

// AddProbe (gst_harness_add_probe): convenience function to allows you to call
// gst_pad_add_probe on a Pad of a Element that are residing inside the Harness,
// by using normal gst_pad_add_probe syntax
//
// MT safe.
//
// The function takes the following parameters:
//
//   - elementName with a ElementFactory name.
//   - padName with the name of the pad to attach the probe to.
//   - mask (see gst_pad_add_probe).
//   - callback (see gst_pad_add_probe).
func (h *Harness) AddProbe(elementName string, padName string, mask gst.PadProbeType, callback gst.PadProbeCallback) {
	var _arg0 *C.GstHarness         // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.gchar              // out
	var _arg3 C.GstPadProbeType     // out
	var _arg4 C.GstPadProbeCallback // out
	var _arg5 C.gpointer
	var _arg6 C.GDestroyNotify

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(elementName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(padName)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.GstPadProbeType(mask)
	_arg4 = (*[0]byte)(C._gotk4_gst1_PadProbeCallback)
	_arg5 = C.gpointer(gbox.Assign(callback))
	_arg6 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.gst_harness_add_probe(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(h)
	runtime.KeepAlive(elementName)
	runtime.KeepAlive(padName)
	runtime.KeepAlive(mask)
	runtime.KeepAlive(callback)
}

// AddProposeAllocationMeta (gst_harness_add_propose_allocation_meta): add api
// with params as one of the supported metadata API to propose when receiving an
// allocation query.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - api: metadata API.
//   - params (optional): API specific parameters.
func (h *Harness) AddProposeAllocationMeta(api coreglib.Type, params *gst.Structure) {
	var _arg0 *C.GstHarness   // out
	var _arg1 C.GType         // out
	var _arg2 *C.GstStructure // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = C.GType(api)
	if params != nil {
		_arg2 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(params)))
	}

	C.gst_harness_add_propose_allocation_meta(_arg0, _arg1, _arg2)
	runtime.KeepAlive(h)
	runtime.KeepAlive(api)
	runtime.KeepAlive(params)
}

// AddSink (gst_harness_add_sink): similar to gst_harness_add_sink_harness,
// this is a convenience to directly create a sink-harness using the
// sink_element_name name specified.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - sinkElementName with the name of a Element.
func (h *Harness) AddSink(sinkElementName string) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(sinkElementName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_harness_add_sink(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(sinkElementName)
}

// AddSinkHarness (gst_harness_add_sink_harness): similar to
// gst_harness_add_src, this allows you to send the data coming out of your
// harnessed Element to a sink-element, allowing to test different responses
// the element output might create in sink elements. An example might be an
// existing sink providing some analytical data on the input it receives that
// can be useful to your testing. If the goal is to test a sink-element itself,
// this is better achieved using gst_harness_new directly on the sink.
//
// If a sink-harness already exists it will be replaced.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - sinkHarness to be added as a sink-harness.
func (h *Harness) AddSinkHarness(sinkHarness *Harness) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.GstHarness // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(sinkHarness)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(sinkHarness)), nil)

	C.gst_harness_add_sink_harness(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(sinkHarness)
}

// AddSinkParse (gst_harness_add_sink_parse): similar to gst_harness_add_sink,
// this allows you to specify a launch-line instead of just an element name.
// See gst_harness_add_src_parse for details.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - launchline with the name of a Element.
func (h *Harness) AddSinkParse(launchline string) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(launchline)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_harness_add_sink_parse(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(launchline)
}

// AddSrc (gst_harness_add_src): similar to gst_harness_add_src_harness, this
// is a convenience to directly create a src-harness using the src_element_name
// name specified.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - srcElementName with the name of a Element.
//   - hasClockWait specifying if the Element uses gst_clock_wait_id internally.
func (h *Harness) AddSrc(srcElementName string, hasClockWait bool) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gboolean    // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(srcElementName)))
	defer C.free(unsafe.Pointer(_arg1))
	if hasClockWait {
		_arg2 = C.TRUE
	}

	C.gst_harness_add_src(_arg0, _arg1, _arg2)
	runtime.KeepAlive(h)
	runtime.KeepAlive(srcElementName)
	runtime.KeepAlive(hasClockWait)
}

// AddSrcHarness (gst_harness_add_src_harness) src-harness is a great
// way of providing the Harness with data. By adding a src-type Element,
// it is then easy to use functions like gst_harness_push_from_src or
// gst_harness_src_crank_and_push_many to provide your harnessed element with
// input. The has_clock_wait variable is a great way to control you src-element
// with, in that you can have it produce a buffer for you by simply cranking
// the clock, and not have it spin out of control producing buffers as fast as
// possible.
//
// If a src-harness already exists it will be replaced.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - srcHarness to be added as a src-harness.
//   - hasClockWait specifying if the Element uses gst_clock_wait_id internally.
func (h *Harness) AddSrcHarness(srcHarness *Harness, hasClockWait bool) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.GstHarness // out
	var _arg2 C.gboolean    // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(srcHarness)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(srcHarness)), nil)
	if hasClockWait {
		_arg2 = C.TRUE
	}

	C.gst_harness_add_src_harness(_arg0, _arg1, _arg2)
	runtime.KeepAlive(h)
	runtime.KeepAlive(srcHarness)
	runtime.KeepAlive(hasClockWait)
}

// AddSrcParse (gst_harness_add_src_parse): similar to gst_harness_add_src,
// this allows you to specify a launch-line, which can be useful for both having
// more then one Element acting as your src (Like a src producing raw buffers,
// and then an encoder, providing encoded data), but also by allowing you to set
// properties like "is-live" directly on the elements.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - launchline describing a gst-launch type line.
//   - hasClockWait specifying if the Element uses gst_clock_wait_id internally.
func (h *Harness) AddSrcParse(launchline string, hasClockWait bool) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gboolean    // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(launchline)))
	defer C.free(unsafe.Pointer(_arg1))
	if hasClockWait {
		_arg2 = C.TRUE
	}

	C.gst_harness_add_src_parse(_arg0, _arg1, _arg2)
	runtime.KeepAlive(h)
	runtime.KeepAlive(launchline)
	runtime.KeepAlive(hasClockWait)
}

// BuffersInQueue (gst_harness_buffers_in_queue): number of Buffers currently in
// the Harness sinkpad Queue
//
// MT safe.
//
// The function returns the following values:
//
//   - guint number of buffers in the queue.
func (h *Harness) BuffersInQueue() uint {
	var _arg0 *C.GstHarness // out
	var _cret C.guint       // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_buffers_in_queue(_arg0)
	runtime.KeepAlive(h)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// BuffersReceived (gst_harness_buffers_received): total number of Buffers that
// has arrived on the Harness sinkpad. This number includes buffers that have
// been dropped as well as buffers that have already been pulled out.
//
// MT safe.
//
// The function returns the following values:
//
//   - guint number of buffers received.
func (h *Harness) BuffersReceived() uint {
	var _arg0 *C.GstHarness // out
	var _cret C.guint       // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_buffers_received(_arg0)
	runtime.KeepAlive(h)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// CrankMultipleClockWaits (gst_harness_crank_multiple_clock_waits): similar to
// gst_harness_crank_single_clock_wait(), this is the function to use if your
// harnessed element(s) are using more then one gst_clock_id_wait. Failing to
// do so can (and will) make it racy which ClockID you actually are releasing,
// where as this function will process all the waits at the same time, ensuring
// that one thread can't register another wait before both are released.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - waits describing the number of ClockIDs to crank.
//
// The function returns the following values:
//
//   - ok: gboolean TRUE if the "crank" was successful, FALSE if not.
func (h *Harness) CrankMultipleClockWaits(waits uint) bool {
	var _arg0 *C.GstHarness // out
	var _arg1 C.guint       // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = C.guint(waits)

	_cret = C.gst_harness_crank_multiple_clock_waits(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(waits)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CrankSingleClockWait (gst_harness_crank_single_clock_wait): "crank" consists
// of three steps: 1: Wait for a ClockID to be registered with the TestClock.
// 2: Advance the TestClock to the time the ClockID is waiting for. 3:
// Release the ClockID wait. Together, this provides an easy way to not have to
// think about the details around clocks and time, but still being able to write
// deterministic tests that are dependent on this. A "crank" can be though of as
// the notion of manually driving the clock forward to its next logical step.
//
// MT safe.
//
// The function returns the following values:
//
//   - ok: gboolean TRUE if the "crank" was successful, FALSE if not.
func (h *Harness) CrankSingleClockWait() bool {
	var _arg0 *C.GstHarness // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_crank_single_clock_wait(_arg0)
	runtime.KeepAlive(h)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CreateBuffer (gst_harness_create_buffer) allocates a buffer using
// a BufferPool if present, or else using the configured Allocator and
// AllocationParams
//
// MT safe.
//
// The function takes the following parameters:
//
//   - size specifying the size of the buffer.
//
// The function returns the following values:
//
//   - buffer of size size.
func (h *Harness) CreateBuffer(size uint) *gst.Buffer {
	var _arg0 *C.GstHarness // out
	var _arg1 C.gsize       // out
	var _cret *C.GstBuffer  // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = C.gsize(size)

	_cret = C.gst_harness_create_buffer(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(size)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _buffer
}

// DumpToFile (gst_harness_dump_to_file) allows you to dump the Buffers the
// Harness sinkpad Queue to a file.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - filename with a the name of a file.
func (h *Harness) DumpToFile(filename string) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_harness_dump_to_file(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(filename)
}

// EventsInQueue (gst_harness_events_in_queue): number of Events currently in
// the Harness sinkpad Queue
//
// MT safe.
//
// The function returns the following values:
//
//   - guint number of events in the queue.
func (h *Harness) EventsInQueue() uint {
	var _arg0 *C.GstHarness // out
	var _cret C.guint       // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_events_in_queue(_arg0)
	runtime.KeepAlive(h)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// EventsReceived (gst_harness_events_received): total number of Events that
// has arrived on the Harness sinkpad This number includes events handled by the
// harness as well as events that have already been pulled out.
//
// MT safe.
//
// The function returns the following values:
//
//   - guint number of events received.
func (h *Harness) EventsReceived() uint {
	var _arg0 *C.GstHarness // out
	var _cret C.guint       // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_events_received(_arg0)
	runtime.KeepAlive(h)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// FindElement (gst_harness_find_element): most useful in conjunction with
// gst_harness_new_parse, this will scan the Elements inside the Harness,
// and check if any of them matches element_name. Typical usecase being that you
// need to access one of the harnessed elements for properties and/or signals.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - elementName with a ElementFactory name.
//
// The function returns the following values:
//
//   - element (optional) or NULL if not found.
func (h *Harness) FindElement(elementName string) gst.Elementer {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.gchar      // out
	var _cret *C.GstElement // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(elementName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_harness_find_element(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(elementName)

	var _element gst.Elementer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gst.Elementer)
				return ok
			})
			rv, ok := casted.(gst.Elementer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Elementer")
			}
			_element = rv
		}
	}

	return _element
}

// Allocator (gst_harness_get_allocator) gets the allocator and its params that
// has been decided to use after an allocation query.
//
// MT safe.
//
// The function returns the following values:
//
//   - allocator (optional): Allocator used.
//   - params (optional) of allocator.
func (h *Harness) Allocator() (gst.Allocatorrer, *gst.AllocationParams) {
	var _arg0 *C.GstHarness         // out
	var _arg1 *C.GstAllocator       // in
	var _arg2 C.GstAllocationParams // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	C.gst_harness_get_allocator(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(h)

	var _allocator gst.Allocatorrer   // out
	var _params *gst.AllocationParams // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gst.Allocatorrer)
				return ok
			})
			rv, ok := casted.(gst.Allocatorrer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Allocatorrer")
			}
			_allocator = rv
		}
	}
	_params = (*gst.AllocationParams)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _allocator, _params
}

// LastPushedTimestamp (gst_harness_get_last_pushed_timestamp): get the
// timestamp of the last Buffer pushed on the Harness srcpad, typically with
// gst_harness_push or gst_harness_push_from_src.
//
// MT safe.
//
// The function returns the following values:
//
//   - clockTime with the timestamp or GST_CLOCK_TIME_NONE if no Buffer has been
//     pushed on the Harness srcpad.
func (h *Harness) LastPushedTimestamp() gst.ClockTime {
	var _arg0 *C.GstHarness  // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_get_last_pushed_timestamp(_arg0)
	runtime.KeepAlive(h)

	var _clockTime gst.ClockTime // out

	_clockTime = gst.ClockTime(_cret)

	return _clockTime
}

// Testclock (gst_harness_get_testclock): get the TestClock. Useful if specific
// operations on the testclock is needed.
//
// MT safe.
//
// The function returns the following values:
//
//   - testClock (optional) or NULL if the testclock is not present.
func (h *Harness) Testclock() *TestClock {
	var _arg0 *C.GstHarness   // out
	var _cret *C.GstTestClock // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_get_testclock(_arg0)
	runtime.KeepAlive(h)

	var _testClock *TestClock // out

	if _cret != nil {
		_testClock = wrapTestClock(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _testClock
}

// Play (gst_harness_play): this will set the harnessed Element
// to GST_STATE_PLAYING. Elements without a sink-Pad and with the
// GST_ELEMENT_FLAG_SOURCE flag set is considered a src Element Non-src Elements
// (like sinks and filters) are automatically set to playing by the Harness,
// but src Elements are not to avoid them starting to produce buffers. Hence,
// for src Element you must call gst_harness_play() explicitly.
//
// MT safe.
func (h *Harness) Play() {
	var _arg0 *C.GstHarness // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	C.gst_harness_play(_arg0)
	runtime.KeepAlive(h)
}

// Pull (gst_harness_pull) pulls a Buffer from the Queue on the Harness sinkpad.
// The pull will timeout in 60 seconds. This is the standard way of getting a
// buffer from a harnessed Element.
//
// MT safe.
//
// The function returns the following values:
//
//   - buffer (optional) or NULL if timed out.
func (h *Harness) Pull() *gst.Buffer {
	var _arg0 *C.GstHarness // out
	var _cret *C.GstBuffer  // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_pull(_arg0)
	runtime.KeepAlive(h)

	var _buffer *gst.Buffer // out

	if _cret != nil {
		_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_buffer)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _buffer
}

// PullEvent (gst_harness_pull_event) pulls an Event from the Queue on the
// Harness sinkpad. Timeouts after 60 seconds similar to gst_harness_pull.
//
// MT safe.
//
// The function returns the following values:
//
//   - event (optional) or NULL if timed out.
func (h *Harness) PullEvent() *gst.Event {
	var _arg0 *C.GstHarness // out
	var _cret *C.GstEvent   // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_pull_event(_arg0)
	runtime.KeepAlive(h)

	var _event *gst.Event // out

	if _cret != nil {
		_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_event)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _event
}

// PullUntilEos (gst_harness_pull_until_eos) pulls a Buffer from the Queue on
// the Harness sinkpad. The pull will block until an EOS event is received,
// or timeout in 60 seconds. MT safe.
//
// The function returns the following values:
//
//   - buf (optional) or NULL if EOS or timeout occures first.
//   - ok: TRUE on success, FALSE on timeout.
func (h *Harness) PullUntilEos() (*gst.Buffer, bool) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.GstBuffer  // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_pull_until_eos(_arg0, &_arg1)
	runtime.KeepAlive(h)

	var _buf *gst.Buffer // out
	var _ok bool         // out

	if _arg1 != nil {
		_buf = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_buf)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}
	if _cret != 0 {
		_ok = true
	}

	return _buf, _ok
}

// PullUpstreamEvent (gst_harness_pull_upstream_event) pulls an Event from
// the Queue on the Harness srcpad. Timeouts after 60 seconds similar to
// gst_harness_pull.
//
// MT safe.
//
// The function returns the following values:
//
//   - event (optional) or NULL if timed out.
func (h *Harness) PullUpstreamEvent() *gst.Event {
	var _arg0 *C.GstHarness // out
	var _cret *C.GstEvent   // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_pull_upstream_event(_arg0)
	runtime.KeepAlive(h)

	var _event *gst.Event // out

	if _cret != nil {
		_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_event)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _event
}

// Push (gst_harness_push) pushes a Buffer on the Harness srcpad. The standard
// way of interacting with an harnessed element.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - buffer to push.
//
// The function returns the following values:
//
//   - flowReturn with the result from the push.
func (h *Harness) Push(buffer *gst.Buffer) gst.FlowReturn {
	var _arg0 *C.GstHarness   // out
	var _arg1 *C.GstBuffer    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	_cret = C.gst_harness_push(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(buffer)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// PushAndPull (gst_harness_push_and_pull): basically a gst_harness_push and
// a gst_harness_pull in one line. Reflects the fact that you often want to do
// exactly this in your test: Push one buffer in, and inspect the outcome.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - buffer to push.
//
// The function returns the following values:
//
//   - ret (optional) or NULL if timed out.
func (h *Harness) PushAndPull(buffer *gst.Buffer) *gst.Buffer {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.GstBuffer  // out
	var _cret *C.GstBuffer  // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	_cret = C.gst_harness_push_and_pull(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(buffer)

	var _ret *gst.Buffer // out

	if _cret != nil {
		_ret = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_ret)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _ret
}

// PushEvent (gst_harness_push_event) pushes an Event on the Harness srcpad.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - event to push.
//
// The function returns the following values:
//
//   - ok with the result from the push.
func (h *Harness) PushEvent(event *gst.Event) bool {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.GstEvent   // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(event)), nil)

	_cret = C.gst_harness_push_event(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PushFromSrc (gst_harness_push_from_src): transfer data from the
// src-Harness to the main-Harness. It consists of 4 steps: 1: Make sure
// the src is started. (see: gst_harness_play) 2: Crank the clock (see:
// gst_harness_crank_single_clock_wait) 3: Pull a Buffer from the src-Harness
// (see: gst_harness_pull) 4: Push the same Buffer into the main-Harness (see:
// gst_harness_push)
//
// MT safe.
//
// The function returns the following values:
//
//   - flowReturn with the result of the push.
func (h *Harness) PushFromSrc() gst.FlowReturn {
	var _arg0 *C.GstHarness   // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_push_from_src(_arg0)
	runtime.KeepAlive(h)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// PushToSink (gst_harness_push_to_sink): transfer one Buffer from the
// main-Harness to the sink-Harness. See gst_harness_push_from_src for details.
//
// MT safe.
//
// The function returns the following values:
//
//   - flowReturn with the result of the push.
func (h *Harness) PushToSink() gst.FlowReturn {
	var _arg0 *C.GstHarness   // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_push_to_sink(_arg0)
	runtime.KeepAlive(h)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// PushUpstreamEvent (gst_harness_push_upstream_event) pushes an Event on the
// Harness sinkpad.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - event to push.
//
// The function returns the following values:
//
//   - ok with the result from the push.
func (h *Harness) PushUpstreamEvent(event *gst.Event) bool {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.GstEvent   // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(event)), nil)

	_cret = C.gst_harness_push_upstream_event(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QueryLatency (gst_harness_query_latency): get the min latency reported by any
// harnessed Element.
//
// MT safe.
//
// The function returns the following values:
//
//   - clockTime with min latency.
func (h *Harness) QueryLatency() gst.ClockTime {
	var _arg0 *C.GstHarness  // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_query_latency(_arg0)
	runtime.KeepAlive(h)

	var _clockTime gst.ClockTime // out

	_clockTime = gst.ClockTime(_cret)

	return _clockTime
}

// SetBlockingPushMode (gst_harness_set_blocking_push_mode): setting this
// will make the harness block in the chain-function, and then release when
// gst_harness_pull() or gst_harness_try_pull() is called. Can be useful when
// wanting to control a src-element that is not implementing gst_clock_id_wait()
// so it can't be controlled by the TestClock, since it otherwise would produce
// buffers as fast as possible.
//
// MT safe.
func (h *Harness) SetBlockingPushMode() {
	var _arg0 *C.GstHarness // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	C.gst_harness_set_blocking_push_mode(_arg0)
	runtime.KeepAlive(h)
}

// SetCaps (gst_harness_set_caps) sets the GstHarness srcpad and sinkpad caps.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - in to set on the harness srcpad.
//   - out to set on the harness sinkpad.
func (h *Harness) SetCaps(in *gst.Caps, out *gst.Caps) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.GstCaps    // out
	var _arg2 *C.GstCaps    // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(in)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(in)), nil)
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(out)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(out)), nil)

	C.gst_harness_set_caps(_arg0, _arg1, _arg2)
	runtime.KeepAlive(h)
	runtime.KeepAlive(in)
	runtime.KeepAlive(out)
}

// SetCapsStr (gst_harness_set_caps_str) sets the GstHarness srcpad and sinkpad
// caps using strings.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - in: gchar describing a Caps to set on the harness srcpad.
//   - out: gchar describing a Caps to set on the harness sinkpad.
func (h *Harness) SetCapsStr(in string, out string) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.gchar      // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(in)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(out)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gst_harness_set_caps_str(_arg0, _arg1, _arg2)
	runtime.KeepAlive(h)
	runtime.KeepAlive(in)
	runtime.KeepAlive(out)
}

// SetDropBuffers (gst_harness_set_drop_buffers): when set to TRUE, instead of
// placing the buffers arriving from the harnessed Element inside the sinkpads
// Queue, they are instead unreffed.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - dropBuffers specifying to drop outgoing buffers or not.
func (h *Harness) SetDropBuffers(dropBuffers bool) {
	var _arg0 *C.GstHarness // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	if dropBuffers {
		_arg1 = C.TRUE
	}

	C.gst_harness_set_drop_buffers(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(dropBuffers)
}

// SetForwarding (gst_harness_set_forwarding) as a convenience, a src-harness
// will forward GST_EVENT_STREAM_START, GST_EVENT_CAPS and GST_EVENT_SEGMENT
// to the main-harness if forwarding is enabled, and forward any sticky-events
// from the main-harness to the sink-harness. It will also forward the
// GST_QUERY_ALLOCATION.
//
// If forwarding is disabled, the user will have to either manually push these
// events from the src-harness using gst_harness_src_push_event(), or create
// and push them manually. While this will allow full control and inspection of
// these events, for the most cases having forwarding enabled will be sufficient
// when writing a test where the src-harness' main function is providing data
// for the main-harness.
//
// Forwarding is enabled by default.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - forwarding to enable/disable forwarding.
func (h *Harness) SetForwarding(forwarding bool) {
	var _arg0 *C.GstHarness // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	if forwarding {
		_arg1 = C.TRUE
	}

	C.gst_harness_set_forwarding(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(forwarding)
}

// SetLive (gst_harness_set_live) sets the liveness reported by Harness when
// receiving a latency-query. The default is TRUE.
//
// The function takes the following parameters:
//
//   - isLive: TRUE for live, FALSE for non-live.
func (h *Harness) SetLive(isLive bool) {
	var _arg0 *C.GstHarness // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	if isLive {
		_arg1 = C.TRUE
	}

	C.gst_harness_set_live(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(isLive)
}

// SetProposeAllocator (gst_harness_set_propose_allocator) sets the allocator
// and params to propose when receiving an allocation query.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - allocator (optional): Allocator.
//   - params (optional): AllocationParams.
func (h *Harness) SetProposeAllocator(allocator gst.Allocatorrer, params *gst.AllocationParams) {
	var _arg0 *C.GstHarness          // out
	var _arg1 *C.GstAllocator        // out
	var _arg2 *C.GstAllocationParams // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	if allocator != nil {
		_arg1 = (*C.GstAllocator)(unsafe.Pointer(coreglib.BaseObject(allocator).Native()))
		C.g_object_ref(C.gpointer(coreglib.BaseObject(allocator).Native()))
	}
	if params != nil {
		_arg2 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	C.gst_harness_set_propose_allocator(_arg0, _arg1, _arg2)
	runtime.KeepAlive(h)
	runtime.KeepAlive(allocator)
	runtime.KeepAlive(params)
}

// SetSinkCaps (gst_harness_set_sink_caps) sets the GstHarness sinkpad caps.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - caps to set on the harness sinkpad.
func (h *Harness) SetSinkCaps(caps *gst.Caps) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.GstCaps    // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)

	C.gst_harness_set_sink_caps(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(caps)
}

// SetSinkCapsStr (gst_harness_set_sink_caps_str) sets the GstHarness sinkpad
// caps using a string.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - str: gchar describing a Caps to set on the harness sinkpad.
func (h *Harness) SetSinkCapsStr(str string) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_harness_set_sink_caps_str(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(str)
}

// SetSrcCaps (gst_harness_set_src_caps) sets the GstHarness srcpad caps.
// This must be done before any buffers can legally be pushed from the harness
// to the element.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - caps to set on the harness srcpad.
func (h *Harness) SetSrcCaps(caps *gst.Caps) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.GstCaps    // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)

	C.gst_harness_set_src_caps(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(caps)
}

// SetSrcCapsStr (gst_harness_set_src_caps_str) sets the GstHarness srcpad caps
// using a string. This must be done before any buffers can legally be pushed
// from the harness to the element.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - str: gchar describing a Caps to set on the harness srcpad.
func (h *Harness) SetSrcCapsStr(str string) {
	var _arg0 *C.GstHarness // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_harness_set_src_caps_str(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(str)
}

// SetTime (gst_harness_set_time): advance the TestClock to a specific time.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - time to advance the clock to.
//
// The function returns the following values:
//
//   - ok: gboolean TRUE if the time could be set. FALSE if not.
func (h *Harness) SetTime(time gst.ClockTime) bool {
	var _arg0 *C.GstHarness  // out
	var _arg1 C.GstClockTime // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = C.GstClockTime(time)

	_cret = C.gst_harness_set_time(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(time)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetUpstreamLatency (gst_harness_set_upstream_latency) sets the min latency
// reported by Harness when receiving a latency-query.
//
// The function takes the following parameters:
//
//   - latency specifying the latency.
func (h *Harness) SetUpstreamLatency(latency gst.ClockTime) {
	var _arg0 *C.GstHarness  // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = C.GstClockTime(latency)

	C.gst_harness_set_upstream_latency(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(latency)
}

// SinkPushMany (gst_harness_sink_push_many): convenience that calls
// gst_harness_push_to_sink pushes number of times. Will abort the pushing if
// any one push fails.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - pushes with the number of calls to gst_harness_push_to_sink.
//
// The function returns the following values:
//
//   - flowReturn with the result of the push.
func (h *Harness) SinkPushMany(pushes int) gst.FlowReturn {
	var _arg0 *C.GstHarness   // out
	var _arg1 C.gint          // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = C.gint(pushes)

	_cret = C.gst_harness_sink_push_many(_arg0, _arg1)
	runtime.KeepAlive(h)
	runtime.KeepAlive(pushes)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// SrcCrankAndPushMany (gst_harness_src_crank_and_push_many): transfer data from
// the src-Harness to the main-Harness. Similar to gst_harness_push_from_src,
// this variant allows you to specify how many cranks and how many pushes to
// perform. This can be useful for both moving a lot of data at the same time,
// as well as cases when one crank does not equal one buffer to push and v.v.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - cranks with the number of calls to gst_harness_crank_single_clock_wait.
//   - pushes with the number of calls to gst_harness_push.
//
// The function returns the following values:
//
//   - flowReturn with the result of the push.
func (h *Harness) SrcCrankAndPushMany(cranks int, pushes int) gst.FlowReturn {
	var _arg0 *C.GstHarness   // out
	var _arg1 C.gint          // out
	var _arg2 C.gint          // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = C.gint(cranks)
	_arg2 = C.gint(pushes)

	_cret = C.gst_harness_src_crank_and_push_many(_arg0, _arg1, _arg2)
	runtime.KeepAlive(h)
	runtime.KeepAlive(cranks)
	runtime.KeepAlive(pushes)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// SrcPushEvent (gst_harness_src_push_event): similar to what
// gst_harness_src_push does with Buffers, this transfers a Event from the
// src-Harness to the main-Harness. Note that some Events are being transferred
// automagically. Look at sink_forward_pad for details.
//
// MT safe.
//
// The function returns the following values:
//
//   - ok with the result of the push.
func (h *Harness) SrcPushEvent() bool {
	var _arg0 *C.GstHarness // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_src_push_event(_arg0)
	runtime.KeepAlive(h)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TakeAllDataAsBuffer (gst_harness_take_all_data_as_buffer) pulls all pending
// data from the harness and returns it as a single buffer.
//
// The function returns the following values:
//
//   - buffer: data as a buffer. Unref with gst_buffer_unref() when no longer
//     needed.
func (h *Harness) TakeAllDataAsBuffer() *gst.Buffer {
	var _arg0 *C.GstHarness // out
	var _cret *C.GstBuffer  // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_take_all_data_as_buffer(_arg0)
	runtime.KeepAlive(h)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _buffer
}

// TakeAllData (gst_harness_take_all_data_as_bytes) pulls all pending data from
// the harness and returns it as a single #GBytes.
//
// The function returns the following values:
//
//   - bytes: pointer to the data, newly allocated. Free with g_free() when no
//     longer needed.
func (h *Harness) TakeAllData() *glib.Bytes {
	var _arg0 *C.GstHarness // out
	var _cret *C.GBytes     // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_take_all_data_as_bytes(_arg0)
	runtime.KeepAlive(h)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// Teardown (gst_harness_teardown) tears down a GstHarness, freeing all
// resources allocated using it.
//
// MT safe.
func (h *Harness) Teardown() {
	var _arg0 *C.GstHarness // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	C.gst_harness_teardown(_arg0)
	runtime.KeepAlive(h)
}

// TryPull (gst_harness_try_pull) pulls a Buffer from the Queue on the Harness
// sinkpad. Unlike gst_harness_pull this will not wait for any buffers if not
// any are present, and return NULL straight away.
//
// MT safe.
//
// The function returns the following values:
//
//   - buffer (optional) or NULL if no buffers are present in the Queue.
func (h *Harness) TryPull() *gst.Buffer {
	var _arg0 *C.GstHarness // out
	var _cret *C.GstBuffer  // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_try_pull(_arg0)
	runtime.KeepAlive(h)

	var _buffer *gst.Buffer // out

	if _cret != nil {
		_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_buffer)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _buffer
}

// TryPullEvent (gst_harness_try_pull_event) pulls an Event from the Queue on
// the Harness sinkpad. See gst_harness_try_pull for details.
//
// MT safe.
//
// The function returns the following values:
//
//   - event (optional) or NULL if no buffers are present in the Queue.
func (h *Harness) TryPullEvent() *gst.Event {
	var _arg0 *C.GstHarness // out
	var _cret *C.GstEvent   // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_try_pull_event(_arg0)
	runtime.KeepAlive(h)

	var _event *gst.Event // out

	if _cret != nil {
		_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_event)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _event
}

// TryPullUpstreamEvent (gst_harness_try_pull_upstream_event) pulls an Event
// from the Queue on the Harness srcpad. See gst_harness_try_pull for details.
//
// MT safe.
//
// The function returns the following values:
//
//   - event (optional) or NULL if no buffers are present in the Queue.
func (h *Harness) TryPullUpstreamEvent() *gst.Event {
	var _arg0 *C.GstHarness // out
	var _cret *C.GstEvent   // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_try_pull_upstream_event(_arg0)
	runtime.KeepAlive(h)

	var _event *gst.Event // out

	if _cret != nil {
		_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_event)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _event
}

// UpstreamEventsInQueue (gst_harness_upstream_events_in_queue): number of
// Events currently in the Harness srcpad Queue
//
// MT safe.
//
// The function returns the following values:
//
//   - guint number of events in the queue.
func (h *Harness) UpstreamEventsInQueue() uint {
	var _arg0 *C.GstHarness // out
	var _cret C.guint       // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_upstream_events_in_queue(_arg0)
	runtime.KeepAlive(h)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// UpstreamEventsReceived (gst_harness_upstream_events_received): total number
// of Events that has arrived on the Harness srcpad This number includes events
// handled by the harness as well as events that have already been pulled out.
//
// MT safe.
//
// The function returns the following values:
//
//   - guint number of events received.
func (h *Harness) UpstreamEventsReceived() uint {
	var _arg0 *C.GstHarness // out
	var _cret C.guint       // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	_cret = C.gst_harness_upstream_events_received(_arg0)
	runtime.KeepAlive(h)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// UseSystemclock (gst_harness_use_systemclock) sets the system Clock on the
// GstHarness Element
//
// MT safe.
func (h *Harness) UseSystemclock() {
	var _arg0 *C.GstHarness // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	C.gst_harness_use_systemclock(_arg0)
	runtime.KeepAlive(h)
}

// UseTestclock (gst_harness_use_testclock) sets the TestClock on the Harness
// Element
//
// MT safe.
func (h *Harness) UseTestclock() {
	var _arg0 *C.GstHarness // out

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))

	C.gst_harness_use_testclock(_arg0)
	runtime.KeepAlive(h)
}

// WaitForClockIDWaits (gst_harness_wait_for_clock_id_waits) waits for timeout
// seconds until waits number of ClockID waits is registered with the TestClock.
// Useful for writing deterministic tests, where you want to make sure that an
// expected number of waits have been reached.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - waits describing the numbers of ClockID registered with the TestClock.
//   - timeout describing how many seconds to wait for waits to be true.
//
// The function returns the following values:
//
//   - ok: gboolean TRUE if the waits have been registered, FALSE if not. (Could
//     be that it timed out waiting or that more waits than waits was found).
func (h *Harness) WaitForClockIDWaits(waits uint, timeout uint) bool {
	var _arg0 *C.GstHarness // out
	var _arg1 C.guint       // out
	var _arg2 C.guint       // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstHarness)(gextras.StructNative(unsafe.Pointer(h)))
	_arg1 = C.guint(waits)
	_arg2 = C.guint(timeout)

	_cret = C.gst_harness_wait_for_clock_id_waits(_arg0, _arg1, _arg2)
	runtime.KeepAlive(h)
	runtime.KeepAlive(waits)
	runtime.KeepAlive(timeout)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TestClockClass (GstTestClockClass) class of a TestClock, which has no virtual
// methods to override.
//
// An instance of this type is always passed by reference.
type TestClockClass struct {
	*testClockClass
}

// testClockClass is the struct that's finalized.
type testClockClass struct {
	native *C.GstTestClockClass
}

// ParentClass: parent class structure.
func (t *TestClockClass) ParentClass() *gst.ClockClass {
	valptr := &t.native.parent_class
	var _v *gst.ClockClass // out
	_v = (*gst.ClockClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
