// Code generated by girgen. DO NOT EDIT.

package gstallocators

import (
	"fmt"
	"runtime"
	_ "runtime/cgo"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/go-gst/go-gst/pkg/gst"
)

// #cgo pkg-config: gstreamer-allocators-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/allocators/allocators.h>
// guintptr _gotk4_gstallocators1_PhysMemoryAllocator_virtual_get_phys_addr(void* fnptr, GstPhysMemoryAllocator* arg0, GstMemory* arg1) {
//   return ((guintptr (*)(GstPhysMemoryAllocator*, GstMemory*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypePhysMemoryAllocator = coreglib.Type(C.gst_phys_memory_allocator_get_type())
	GTypeDRMDumbAllocator    = coreglib.Type(C.gst_drm_dumb_allocator_get_type())
	GTypeDmaBufAllocator     = coreglib.Type(C.gst_dmabuf_allocator_get_type())
	GTypeFdAllocator         = coreglib.Type(C.gst_fd_allocator_get_type())
	GTypeShmAllocator        = coreglib.Type(C.gst_shm_allocator_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypePhysMemoryAllocator, F: marshalPhysMemoryAllocator},
		coreglib.TypeMarshaler{T: GTypeDRMDumbAllocator, F: marshalDRMDumbAllocator},
		coreglib.TypeMarshaler{T: GTypeDmaBufAllocator, F: marshalDmaBufAllocator},
		coreglib.TypeMarshaler{T: GTypeFdAllocator, F: marshalFdAllocator},
		coreglib.TypeMarshaler{T: GTypeShmAllocator, F: marshalShmAllocator},
	})
}

const ALLOCATOR_DMABUF = "dmabuf"
const ALLOCATOR_FD = "fd"

// ALLOCATOR_SHM: name of this allocator, to be used for example with
// gst_allocator_find() and gst_memory_is_type().
const ALLOCATOR_SHM = "shm"

// CAPS_FEATURE_MEMORY_DMABUF: constant that defines the caps feature name for
// DMA buffer sharing.
//
// It has to be used for non-mappable dma-buf only, i.e. when the underlying
// memory is not mappable to user space. Or when the mapped memory contains non
// meaningful data. It can be the case for protected content or when the user
// wants explicitly avoid any software post processing.
//
// In these cases all elements between the exported and the importer has to work
// in passthrough mode. This is done by adding this caps feature.
//
// When the memory is mappable for read and write requests then it is assumes to
// be a fast path and so this caps feature should not be used. Though according
// to the dma-buf protocol, while it is mapped it prevents the exporter to
// migrate the buffer.
//
// This caps feature should not serve at all the purpose of selecting the
// GST_ALLOCATOR_DMABUF allocator during caps negotiation. When the exporter is
// the upstream element from the importer point of view, the exporter should try
// to map the dma buffer at runtime (preferably during decide_allocation phase).
// When it succeeds for T_MAP_READWRITE this caps feature should not be used.
// This allows scalers, color converts and any image processing filters to work
// directly on the dma buffer. In this case the importer element should check
// all incoming memory using gst_is_dmabuf_memory().
const CAPS_FEATURE_MEMORY_DMABUF = "memory:DMABuf"

// FdMemoryFlags various flags to control the operation of the fd backed memory.
type FdMemoryFlags C.guint

const (
	// FdMemoryFlagNone: no flag.
	FdMemoryFlagNone FdMemoryFlags = 0b0
	// FdMemoryFlagKeepMapped: once the memory is mapped, keep it mapped until
	// the memory is destroyed.
	FdMemoryFlagKeepMapped FdMemoryFlags = 0b1
	// FdMemoryFlagMapPrivate: do a private mapping instead of the default
	// shared mapping.
	FdMemoryFlagMapPrivate FdMemoryFlags = 0b10
	// FdMemoryFlagDontClose: don't close the file descriptor when the memory is
	// freed. Since: 1.10.
	FdMemoryFlagDontClose FdMemoryFlags = 0b100
)

// String returns the names in string for FdMemoryFlags.
func (f FdMemoryFlags) String() string {
	if f == 0 {
		return "FdMemoryFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(84)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FdMemoryFlagNone:
			builder.WriteString("None|")
		case FdMemoryFlagKeepMapped:
			builder.WriteString("KeepMapped|")
		case FdMemoryFlagMapPrivate:
			builder.WriteString("MapPrivate|")
		case FdMemoryFlagDontClose:
			builder.WriteString("DontClose|")
		default:
			builder.WriteString(fmt.Sprintf("FdMemoryFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FdMemoryFlags) Has(other FdMemoryFlags) bool {
	return (f & other) == other
}

// DmabufMemoryGetFd: return the file descriptor associated with mem.
//
// The function takes the following parameters:
//
//   - mem: memory to get the file descriptor.
//
// The function returns the following values:
//
//   - gint: file descriptor associated with the memory, or -1. The file
//     descriptor is still owned by the GstMemory. Use dup to take a copy if you
//     intend to use it beyond the lifetime of this GstMemory.
func DmabufMemoryGetFd(mem *gst.Memory) int {
	var _arg1 *C.GstMemory // out
	var _cret C.gint       // in

	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))

	_cret = C.gst_dmabuf_memory_get_fd(_arg1)
	runtime.KeepAlive(mem)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// DRMDumbMemoryExportDmabuf exports a DMABuf from the DRM Bumb
// buffer object. One can check if this feature is supported using
// gst_drm_dumb_allocator_has_prime_export();.
//
// The function takes the following parameters:
//
//   - mem: memory to export from.
//
// The function returns the following values:
//
//   - memory from DmaBufAllocator wrapping the exported dma-buf file
//     descriptor.
func DRMDumbMemoryExportDmabuf(mem *gst.Memory) *gst.Memory {
	var _arg1 *C.GstMemory // out
	var _cret *C.GstMemory // in

	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))

	_cret = C.gst_drm_dumb_memory_export_dmabuf(_arg1)
	runtime.KeepAlive(mem)

	var _memory *gst.Memory // out

	_memory = (*gst.Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_memory)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _memory
}

// DRMDumbMemoryGetHandle: return the DRM buffer object handle associated with
// mem.
//
// The function takes the following parameters:
//
//   - mem: memory to get the handle from.
//
// The function returns the following values:
//
//   - guint32: DRM buffer object handle associated with the memory, or 0.
//     The handle is still owned by the GstMemory and cannot be used beyond
//     the lifetime of this GstMemory unless it is being passed to DRM driver,
//     which does handle a refcount internally.
func DRMDumbMemoryGetHandle(mem *gst.Memory) uint32 {
	var _arg1 *C.GstMemory // out
	var _cret C.guint32    // in

	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))

	_cret = C.gst_drm_dumb_memory_get_handle(_arg1)
	runtime.KeepAlive(mem)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// FdMemoryGetFd: get the fd from mem. Call gst_is_fd_memory() to check if mem
// has an fd.
//
// The function takes the following parameters:
//
//   - mem: Memory.
//
// The function returns the following values:
//
//   - gint: fd of mem or -1 when there is no fd on mem.
func FdMemoryGetFd(mem *gst.Memory) int {
	var _arg1 *C.GstMemory // out
	var _cret C.gint       // in

	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))

	_cret = C.gst_fd_memory_get_fd(_arg1)
	runtime.KeepAlive(mem)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IsDmabufMemory: check if mem is dmabuf memory.
//
// The function takes the following parameters:
//
//   - mem: memory to be check.
//
// The function returns the following values:
//
//   - ok: TRUE if mem is dmabuf memory, otherwise FALSE.
func IsDmabufMemory(mem *gst.Memory) bool {
	var _arg1 *C.GstMemory // out
	var _cret C.gboolean   // in

	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))

	_cret = C.gst_is_dmabuf_memory(_arg1)
	runtime.KeepAlive(mem)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - mem: memory to be checked.
//
// The function returns the following values:
//
//   - ok: TRUE if mem is DRM Dumb memory, otherwise FALSE.
func IsDRMDumbMemory(mem *gst.Memory) bool {
	var _arg1 *C.GstMemory // out
	var _cret C.gboolean   // in

	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))

	_cret = C.gst_is_drm_dumb_memory(_arg1)
	runtime.KeepAlive(mem)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFdMemory: check if mem is memory backed by an fd.
//
// The function takes the following parameters:
//
//   - mem: Memory.
//
// The function returns the following values:
//
//   - ok: TRUE when mem has an fd that can be retrieved with
//     gst_fd_memory_get_fd().
func IsFdMemory(mem *gst.Memory) bool {
	var _arg1 *C.GstMemory // out
	var _cret C.gboolean   // in

	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))

	_cret = C.gst_is_fd_memory(_arg1)
	runtime.KeepAlive(mem)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - mem: Memory.
//
// The function returns the following values:
//
//   - ok: whether the memory at mem is backed by physical memory.
func IsPhysMemory(mem *gst.Memory) bool {
	var _arg1 *C.GstMemory // out
	var _cret C.gboolean   // in

	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))

	_cret = C.gst_is_phys_memory(_arg1)
	runtime.KeepAlive(mem)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - mem: Memory.
//
// The function returns the following values:
//
//   - guintptr: physical memory address that is backing mem, or 0 if none.
func PhysMemoryGetPhysAddr(mem *gst.Memory) uintptr {
	var _arg1 *C.GstMemory // out
	var _cret C.guintptr   // in

	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))

	_cret = C.gst_phys_memory_get_phys_addr(_arg1)
	runtime.KeepAlive(mem)

	var _guintptr uintptr // out

	_guintptr = uintptr(_cret)

	return _guintptr
}

//
// PhysMemoryAllocator wraps an interface. This means the user can get the
// underlying type by calling Cast().
type PhysMemoryAllocator struct {
	_ [0]func() // equal guard
	gst.Allocator
}

var (
	_ gst.Allocatorrer = (*PhysMemoryAllocator)(nil)
)

// PhysMemoryAllocatorrer describes PhysMemoryAllocator's interface methods.
type PhysMemoryAllocatorrer interface {
	coreglib.Objector

	basePhysMemoryAllocator() *PhysMemoryAllocator
}

var _ PhysMemoryAllocatorrer = (*PhysMemoryAllocator)(nil)

func wrapPhysMemoryAllocator(obj *coreglib.Object) *PhysMemoryAllocator {
	return &PhysMemoryAllocator{
		Allocator: gst.Allocator{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalPhysMemoryAllocator(p uintptr) (interface{}, error) {
	return wrapPhysMemoryAllocator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *PhysMemoryAllocator) basePhysMemoryAllocator() *PhysMemoryAllocator {
	return v
}

// BasePhysMemoryAllocator returns the underlying base object.
func BasePhysMemoryAllocator(obj PhysMemoryAllocatorrer) *PhysMemoryAllocator {
	return obj.basePhysMemoryAllocator()
}

// physAddr implementations shall return the physicall memory address that is
// backing the provided memory, or 0 if none.
func (allocator *PhysMemoryAllocator) physAddr(mem *gst.Memory) uintptr {
	gclass := (*C.GstPhysMemoryAllocatorInterface)(coreglib.PeekParentClass(allocator))
	fnarg := gclass.get_phys_addr

	var _arg0 *C.GstPhysMemoryAllocator // out
	var _arg1 *C.GstMemory              // out
	var _cret C.guintptr                // in

	_arg0 = (*C.GstPhysMemoryAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))

	_cret = C._gotk4_gstallocators1_PhysMemoryAllocator_virtual_get_phys_addr(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(allocator)
	runtime.KeepAlive(mem)

	var _guintptr uintptr // out

	_guintptr = uintptr(_cret)

	return _guintptr
}

// DRMDumbAllocatorOverrides contains methods that are overridable.
type DRMDumbAllocatorOverrides struct {
}

func defaultDRMDumbAllocatorOverrides(v *DRMDumbAllocator) DRMDumbAllocatorOverrides {
	return DRMDumbAllocatorOverrides{}
}

// DRMDumbAllocator: private intance object for DRMDumbAllocator.
type DRMDumbAllocator struct {
	_ [0]func() // equal guard
	gst.Allocator
}

var (
	_ gst.Allocatorrer = (*DRMDumbAllocator)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*DRMDumbAllocator, *DRMDumbAllocatorClass, DRMDumbAllocatorOverrides](
		GTypeDRMDumbAllocator,
		initDRMDumbAllocatorClass,
		wrapDRMDumbAllocator,
		defaultDRMDumbAllocatorOverrides,
	)
}

func initDRMDumbAllocatorClass(gclass unsafe.Pointer, overrides DRMDumbAllocatorOverrides, classInitFunc func(*DRMDumbAllocatorClass)) {
	if classInitFunc != nil {
		class := (*DRMDumbAllocatorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDRMDumbAllocator(obj *coreglib.Object) *DRMDumbAllocator {
	return &DRMDumbAllocator{
		Allocator: gst.Allocator{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalDRMDumbAllocator(p uintptr) (interface{}, error) {
	return wrapDRMDumbAllocator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewDRMDumbAllocatorWithDevicePath creates a new DRMDumbAllocator for the
// specific device path. This function can fail if the path does not exist,
// is not a DRM device or if the DRM device doesnot support DUMB allocation.
//
// The function takes the following parameters:
//
//   - drmDevicePath: path to the DRM device to open.
//
// The function returns the following values:
//
//   - drmDumbAllocator (optional): new DRM Dumb allocator. Use
//     gst_object_unref() to release the allocator after usage.
func NewDRMDumbAllocatorWithDevicePath(drmDevicePath string) *DRMDumbAllocator {
	var _arg1 *C.gchar        // out
	var _cret *C.GstAllocator // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(drmDevicePath)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_drm_dumb_allocator_new_with_device_path(_arg1)
	runtime.KeepAlive(drmDevicePath)

	var _drmDumbAllocator *DRMDumbAllocator // out

	if _cret != nil {
		_drmDumbAllocator = wrapDRMDumbAllocator(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _drmDumbAllocator
}

// NewDRMDumbAllocatorWithFd creates a new DRMDumbAllocator for the specific
// file desciptor. This function can fail if the file descriptor is not a DRM
// device or if the DRM device does not support DUMB allocation.
//
// The function takes the following parameters:
//
//   - drmFd: file descriptor of the DRM device.
//
// The function returns the following values:
//
//   - drmDumbAllocator (optional): new DRM Dumb allocator. Use
//     gst_object_unref() to release the allocator after usage.
func NewDRMDumbAllocatorWithFd(drmFd int) *DRMDumbAllocator {
	var _arg1 C.gint          // out
	var _cret *C.GstAllocator // in

	_arg1 = C.gint(drmFd)

	_cret = C.gst_drm_dumb_allocator_new_with_fd(_arg1)
	runtime.KeepAlive(drmFd)

	var _drmDumbAllocator *DRMDumbAllocator // out

	if _cret != nil {
		_drmDumbAllocator = wrapDRMDumbAllocator(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _drmDumbAllocator
}

// Alloc: allocated a DRM buffer object for the specific drm_fourcc, width and
// height. Note that the DRM Dumb allocation interface is agnostic to the pixel
// format. This drm_fourcc is converted into a bpp (bit-per-pixel) number and
// the height is scaled according to the sub-sampling.
//
// The function takes the following parameters:
//
//   - drmFourcc: DRM format to allocate for.
//   - width: padded width for this allocation.
//   - height: padded height for this allocation.
//
// The function returns the following values:
//
//   - outPitch: pitch as returned by the driver.
//   - memory: new DRM Dumb Memory. Use gst_memory_unref() to release the memory
//     after usage.
func (allocator *DRMDumbAllocator) Alloc(drmFourcc, width, height uint32) (uint32, *gst.Memory) {
	var _arg0 *C.GstAllocator // out
	var _arg1 C.guint32       // out
	var _arg2 C.guint32       // out
	var _arg3 C.guint32       // out
	var _arg4 C.guint32       // in
	var _cret *C.GstMemory    // in

	_arg0 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	_arg1 = C.guint32(drmFourcc)
	_arg2 = C.guint32(width)
	_arg3 = C.guint32(height)

	_cret = C.gst_drm_dumb_allocator_alloc(_arg0, _arg1, _arg2, _arg3, &_arg4)
	runtime.KeepAlive(allocator)
	runtime.KeepAlive(drmFourcc)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)

	var _outPitch uint32    // out
	var _memory *gst.Memory // out

	_outPitch = uint32(_arg4)
	_memory = (*gst.Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_memory)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _outPitch, _memory
}

// HasPrimeExport: this function allow verifying if the driver support dma-buf
// exportation.
//
// The function returns the following values:
//
//   - ok: TRUE if the allocator support exporting dma-buf.
func (allocator *DRMDumbAllocator) HasPrimeExport() bool {
	var _arg0 *C.GstAllocator // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))

	_cret = C.gst_drm_dumb_allocator_has_prime_export(_arg0)
	runtime.KeepAlive(allocator)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DmaBufAllocatorOverrides contains methods that are overridable.
type DmaBufAllocatorOverrides struct {
}

func defaultDmaBufAllocatorOverrides(v *DmaBufAllocator) DmaBufAllocatorOverrides {
	return DmaBufAllocatorOverrides{}
}

// DmaBufAllocator: base class for allocators with dmabuf-backed memory.
type DmaBufAllocator struct {
	_ [0]func() // equal guard
	FdAllocator
}

var (
	_ gst.Allocatorrer = (*DmaBufAllocator)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*DmaBufAllocator, *DmaBufAllocatorClass, DmaBufAllocatorOverrides](
		GTypeDmaBufAllocator,
		initDmaBufAllocatorClass,
		wrapDmaBufAllocator,
		defaultDmaBufAllocatorOverrides,
	)
}

func initDmaBufAllocatorClass(gclass unsafe.Pointer, overrides DmaBufAllocatorOverrides, classInitFunc func(*DmaBufAllocatorClass)) {
	if classInitFunc != nil {
		class := (*DmaBufAllocatorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDmaBufAllocator(obj *coreglib.Object) *DmaBufAllocator {
	return &DmaBufAllocator{
		FdAllocator: FdAllocator{
			Allocator: gst.Allocator{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalDmaBufAllocator(p uintptr) (interface{}, error) {
	return wrapDmaBufAllocator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewDmaBufAllocator: return a new dmabuf allocator.
//
// The function returns the following values:
//
//   - dmaBufAllocator: new dmabuf allocator. Use gst_object_unref() to release
//     the allocator after usage.
func NewDmaBufAllocator() *DmaBufAllocator {
	var _cret *C.GstAllocator // in

	_cret = C.gst_dmabuf_allocator_new()

	var _dmaBufAllocator *DmaBufAllocator // out

	_dmaBufAllocator = wrapDmaBufAllocator(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dmaBufAllocator
}

// DmaBufAllocatorAlloc: return a GstMemory that wraps a dmabuf file descriptor.
//
// The function takes the following parameters:
//
//   - allocator to be used for this memory.
//   - fd: dmabuf file descriptor.
//   - size: memory size.
//
// The function returns the following values:
//
//   - memory (optional): gstMemory based on allocator. When the buffer will be
//     released dmabuf allocator will close the fd. The memory is only mmapped
//     on gst_buffer_map() request.
func DmaBufAllocatorAlloc(allocator gst.Allocatorrer, fd int, size uint) *gst.Memory {
	var _arg1 *C.GstAllocator // out
	var _arg2 C.gint          // out
	var _arg3 C.gsize         // out
	var _cret *C.GstMemory    // in

	_arg1 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	_arg2 = C.gint(fd)
	_arg3 = C.gsize(size)

	_cret = C.gst_dmabuf_allocator_alloc(_arg1, _arg2, _arg3)
	runtime.KeepAlive(allocator)
	runtime.KeepAlive(fd)
	runtime.KeepAlive(size)

	var _memory *gst.Memory // out

	if _cret != nil {
		_memory = (*gst.Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_memory)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _memory
}

// DmaBufAllocatorAllocWithFlags: return a GstMemory that wraps a dmabuf file
// descriptor.
//
// The function takes the following parameters:
//
//   - allocator to be used for this memory.
//   - fd: dmabuf file descriptor.
//   - size: memory size.
//   - flags: extra FdMemoryFlags.
//
// The function returns the following values:
//
//   - memory (optional): gstMemory based on allocator.
//
//     When the buffer will be released the allocator will close the fd unless
//     the GST_FD_MEMORY_FLAG_DONT_CLOSE flag is specified. The memory is only
//     mmapped on gst_buffer_mmap() request.
func DmaBufAllocatorAllocWithFlags(allocator gst.Allocatorrer, fd int, size uint, flags FdMemoryFlags) *gst.Memory {
	var _arg1 *C.GstAllocator    // out
	var _arg2 C.gint             // out
	var _arg3 C.gsize            // out
	var _arg4 C.GstFdMemoryFlags // out
	var _cret *C.GstMemory       // in

	_arg1 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	_arg2 = C.gint(fd)
	_arg3 = C.gsize(size)
	_arg4 = C.GstFdMemoryFlags(flags)

	_cret = C.gst_dmabuf_allocator_alloc_with_flags(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(allocator)
	runtime.KeepAlive(fd)
	runtime.KeepAlive(size)
	runtime.KeepAlive(flags)

	var _memory *gst.Memory // out

	if _cret != nil {
		_memory = (*gst.Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_memory)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _memory
}

// FdAllocatorOverrides contains methods that are overridable.
type FdAllocatorOverrides struct {
}

func defaultFdAllocatorOverrides(v *FdAllocator) FdAllocatorOverrides {
	return FdAllocatorOverrides{}
}

// FdAllocator: base class for allocators with fd-backed memory.
type FdAllocator struct {
	_ [0]func() // equal guard
	gst.Allocator
}

var (
	_ gst.Allocatorrer = (*FdAllocator)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*FdAllocator, *FdAllocatorClass, FdAllocatorOverrides](
		GTypeFdAllocator,
		initFdAllocatorClass,
		wrapFdAllocator,
		defaultFdAllocatorOverrides,
	)
}

func initFdAllocatorClass(gclass unsafe.Pointer, overrides FdAllocatorOverrides, classInitFunc func(*FdAllocatorClass)) {
	if classInitFunc != nil {
		class := (*FdAllocatorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFdAllocator(obj *coreglib.Object) *FdAllocator {
	return &FdAllocator{
		Allocator: gst.Allocator{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalFdAllocator(p uintptr) (interface{}, error) {
	return wrapFdAllocator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewFdAllocator: return a new fd allocator.
//
// The function returns the following values:
//
//   - fdAllocator: new fd allocator. Use gst_object_unref() to release the
//     allocator after usage.
func NewFdAllocator() *FdAllocator {
	var _cret *C.GstAllocator // in

	_cret = C.gst_fd_allocator_new()

	var _fdAllocator *FdAllocator // out

	_fdAllocator = wrapFdAllocator(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fdAllocator
}

// FdAllocatorAlloc: return a GstMemory that wraps a generic file descriptor.
//
// The function takes the following parameters:
//
//   - allocator to be used for this memory.
//   - fd: file descriptor.
//   - size: memory size.
//   - flags: extra FdMemoryFlags.
//
// The function returns the following values:
//
//   - memory (optional): gstMemory based on allocator. When the buffer
//     will be released the allocator will close the fd unless the
//     GST_FD_MEMORY_FLAG_DONT_CLOSE flag is specified. The memory is only
//     mmapped on gst_buffer_map() request.
func FdAllocatorAlloc(allocator gst.Allocatorrer, fd int, size uint, flags FdMemoryFlags) *gst.Memory {
	var _arg1 *C.GstAllocator    // out
	var _arg2 C.gint             // out
	var _arg3 C.gsize            // out
	var _arg4 C.GstFdMemoryFlags // out
	var _cret *C.GstMemory       // in

	_arg1 = (*C.GstAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	_arg2 = C.gint(fd)
	_arg3 = C.gsize(size)
	_arg4 = C.GstFdMemoryFlags(flags)

	_cret = C.gst_fd_allocator_alloc(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(allocator)
	runtime.KeepAlive(fd)
	runtime.KeepAlive(size)
	runtime.KeepAlive(flags)

	var _memory *gst.Memory // out

	if _cret != nil {
		_memory = (*gst.Memory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_memory)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _memory
}

// ShmAllocatorOverrides contains methods that are overridable.
type ShmAllocatorOverrides struct {
}

func defaultShmAllocatorOverrides(v *ShmAllocator) ShmAllocatorOverrides {
	return ShmAllocatorOverrides{}
}

// ShmAllocator: this is a subclass of FdAllocator that implements the
// gst_allocator_alloc() method using memfd_create() when available, POSIX
// shm_open() otherwise. Platforms not supporting any of those (Windows) will
// always return NULL.
//
// Note that allocating new shared memories has a significant performance
// cost, it is thus recommended to keep a pool of pre-allocated Memory,
// using BufferPool. For that reason, this allocator has the
// GST_ALLOCATOR_FLAG_NO_COPY flag set.
type ShmAllocator struct {
	_ [0]func() // equal guard
	FdAllocator
}

var (
	_ gst.Allocatorrer = (*ShmAllocator)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ShmAllocator, *ShmAllocatorClass, ShmAllocatorOverrides](
		GTypeShmAllocator,
		initShmAllocatorClass,
		wrapShmAllocator,
		defaultShmAllocatorOverrides,
	)
}

func initShmAllocatorClass(gclass unsafe.Pointer, overrides ShmAllocatorOverrides, classInitFunc func(*ShmAllocatorClass)) {
	if classInitFunc != nil {
		class := (*ShmAllocatorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapShmAllocator(obj *coreglib.Object) *ShmAllocator {
	return &ShmAllocator{
		FdAllocator: FdAllocator{
			Allocator: gst.Allocator{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalShmAllocator(p uintptr) (interface{}, error) {
	return wrapShmAllocator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ShmAllocatorGet: get the ShmAllocator singleton previously registered with
// gst_shm_allocator_init_once().
//
// The function returns the following values:
//
//   - allocator (optional) or NULL if gst_shm_allocator_init_once() has not
//     been previously called.
func ShmAllocatorGet() gst.Allocatorrer {
	var _cret *C.GstAllocator // in

	_cret = C.gst_shm_allocator_get()

	var _allocator gst.Allocatorrer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gst.Allocatorrer)
				return ok
			})
			rv, ok := casted.(gst.Allocatorrer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gst.Allocatorrer")
			}
			_allocator = rv
		}
	}

	return _allocator
}

// ShmAllocatorInitOnce: register a ShmAllocator using gst_allocator_register()
// with the name GST_ALLOCATOR_SHM. This is no-op after the first call.
func ShmAllocatorInitOnce() {
	C.gst_shm_allocator_init_once()
}

// DRMDumbAllocatorClass: instance of this type is always passed by reference.
type DRMDumbAllocatorClass struct {
	*drmDumbAllocatorClass
}

// drmDumbAllocatorClass is the struct that's finalized.
type drmDumbAllocatorClass struct {
	native *C.GstDRMDumbAllocatorClass
}

// ParentClass: parent Class.
func (d *DRMDumbAllocatorClass) ParentClass() *gst.AllocatorClass {
	valptr := &d.native.parent_class
	var _v *gst.AllocatorClass // out
	_v = (*gst.AllocatorClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// DmaBufAllocatorClass: instance of this type is always passed by reference.
type DmaBufAllocatorClass struct {
	*dmaBufAllocatorClass
}

// dmaBufAllocatorClass is the struct that's finalized.
type dmaBufAllocatorClass struct {
	native *C.GstDmaBufAllocatorClass
}

func (d *DmaBufAllocatorClass) ParentClass() *FdAllocatorClass {
	valptr := &d.native.parent_class
	var _v *FdAllocatorClass // out
	_v = (*FdAllocatorClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// FdAllocatorClass: instance of this type is always passed by reference.
type FdAllocatorClass struct {
	*fdAllocatorClass
}

// fdAllocatorClass is the struct that's finalized.
type fdAllocatorClass struct {
	native *C.GstFdAllocatorClass
}

func (f *FdAllocatorClass) ParentClass() *gst.AllocatorClass {
	valptr := &f.native.parent_class
	var _v *gst.AllocatorClass // out
	_v = (*gst.AllocatorClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// PhysMemoryAllocatorInterface: marker interface for allocators with physical
// address backed memory
//
// An instance of this type is always passed by reference.
type PhysMemoryAllocatorInterface struct {
	*physMemoryAllocatorInterface
}

// physMemoryAllocatorInterface is the struct that's finalized.
type physMemoryAllocatorInterface struct {
	native *C.GstPhysMemoryAllocatorInterface
}

// ShmAllocatorClass: instance of this type is always passed by reference.
type ShmAllocatorClass struct {
	*shmAllocatorClass
}

// shmAllocatorClass is the struct that's finalized.
type shmAllocatorClass struct {
	native *C.GstShmAllocatorClass
}

// ParentClass: parent Class.
func (s *ShmAllocatorClass) ParentClass() *FdAllocatorClass {
	valptr := &s.native.parent_class
	var _v *FdAllocatorClass // out
	_v = (*FdAllocatorClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
