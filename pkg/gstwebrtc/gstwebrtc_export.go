// Code generated by girgen. DO NOT EDIT.

package gstwebrtc

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/go-gst/go-gst/pkg/gst"
)

// #define GST_USE_UNSTABLE_API // APIs in this package are unstable
// #include <stdlib.h>
// #include <gst/webrtc/webrtc.h>
import "C"

//export _gotk4_gstwebrtc1_WebRTCICEOnCandidateFunc
func _gotk4_gstwebrtc1_WebRTCICEOnCandidateFunc(arg1 *C.GstWebRTCICE, arg2 C.guint, arg3 *C.gchar, arg4 C.gpointer) {
	var fn WebRTCICEOnCandidateFunc
	{
		v := gbox.Get(uintptr(arg4))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(WebRTCICEOnCandidateFunc)
	}

	var _ice WebRTCICEer  // out
	var _streamId uint    // out
	var _candidate string // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gstwebrtc.WebRTCICEer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(WebRTCICEer)
			return ok
		})
		rv, ok := casted.(WebRTCICEer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstwebrtc.WebRTCICEer")
		}
		_ice = rv
	}
	_streamId = uint(arg2)
	_candidate = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))

	fn(_ice, _streamId, _candidate)
}

//export _gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnBufferedAmountLow
func _gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnBufferedAmountLow(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnClose
func _gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnClose(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnError
func _gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnError(arg0 C.gpointer, arg1 *C.GError, arg2 C.guintptr) {
	var f func(err error)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(err error))
	}

	var _err error // out

	_err = gerror.Take(unsafe.Pointer(arg1))

	f(_err)
}

//export _gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnMessageData
func _gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnMessageData(arg0 C.gpointer, arg1 *C.GBytes, arg2 C.guintptr) {
	var f func(data *glib.Bytes)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(data *glib.Bytes))
	}

	var _data *glib.Bytes // out

	if arg1 != nil {
		_data = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(arg1)))
		C.g_bytes_ref(arg1)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_data)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_bytes_unref((*C.GBytes)(intern.C))
			},
		)
	}

	f(_data)
}

//export _gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnMessageString
func _gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnMessageString(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(data string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(data string))
	}

	var _data string // out

	if arg1 != nil {
		_data = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	}

	f(_data)
}

//export _gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnOpen
func _gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnOpen(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gstwebrtc1_WebRTCICEClass_add_candidate
func _gotk4_gstwebrtc1_WebRTCICEClass_add_candidate(arg0 *C.GstWebRTCICE, arg1 *C.GstWebRTCICEStream, arg2 *C.gchar, arg3 *C.GstPromise) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebRTCICEOverrides](instance0)
	if overrides.AddCandidate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebRTCICEOverrides.AddCandidate, got none")
	}

	var _stream WebRTCICEStreamer // out
	var _candidate string         // out
	var _promise *gst.Promise     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gstwebrtc.WebRTCICEStreamer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(WebRTCICEStreamer)
			return ok
		})
		rv, ok := casted.(WebRTCICEStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstwebrtc.WebRTCICEStreamer")
		}
		_stream = rv
	}
	_candidate = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	if arg3 != nil {
		_promise = (*gst.Promise)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	}

	overrides.AddCandidate(_stream, _candidate, _promise)
}

//export _gotk4_gstwebrtc1_WebRTCICEClass_add_stream
func _gotk4_gstwebrtc1_WebRTCICEClass_add_stream(arg0 *C.GstWebRTCICE, arg1 C.guint) (cret *C.GstWebRTCICEStream) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebRTCICEOverrides](instance0)
	if overrides.AddStream == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebRTCICEOverrides.AddStream, got none")
	}

	var _sessionId uint // out

	_sessionId = uint(arg1)

	webRTCICEStream := overrides.AddStream(_sessionId)

	var _ WebRTCICEStreamer

	if webRTCICEStream != nil {
		cret = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.BaseObject(webRTCICEStream).Native()))
		C.g_object_ref(C.gpointer(coreglib.BaseObject(webRTCICEStream).Native()))
	}

	return cret
}

//export _gotk4_gstwebrtc1_WebRTCICEClass_add_turn_server
func _gotk4_gstwebrtc1_WebRTCICEClass_add_turn_server(arg0 *C.GstWebRTCICE, arg1 *C.gchar) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebRTCICEOverrides](instance0)
	if overrides.AddTurnServer == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebRTCICEOverrides.AddTurnServer, got none")
	}

	var _uri string // out

	_uri = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	ok := overrides.AddTurnServer(_uri)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstwebrtc1_WebRTCICEClass_find_transport
func _gotk4_gstwebrtc1_WebRTCICEClass_find_transport(arg0 *C.GstWebRTCICE, arg1 *C.GstWebRTCICEStream, arg2 C.GstWebRTCICEComponent) (cret *C.GstWebRTCICETransport) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebRTCICEOverrides](instance0)
	if overrides.FindTransport == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebRTCICEOverrides.FindTransport, got none")
	}

	var _stream WebRTCICEStreamer     // out
	var _component WebRTCICEComponent // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gstwebrtc.WebRTCICEStreamer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(WebRTCICEStreamer)
			return ok
		})
		rv, ok := casted.(WebRTCICEStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstwebrtc.WebRTCICEStreamer")
		}
		_stream = rv
	}
	_component = WebRTCICEComponent(arg2)

	webRTCICETransport := overrides.FindTransport(_stream, _component)

	var _ WebRTCICETransporter

	if webRTCICETransport != nil {
		cret = (*C.GstWebRTCICETransport)(unsafe.Pointer(coreglib.BaseObject(webRTCICETransport).Native()))
		C.g_object_ref(C.gpointer(coreglib.BaseObject(webRTCICETransport).Native()))
	}

	return cret
}

//export _gotk4_gstwebrtc1_WebRTCICEClass_gather_candidates
func _gotk4_gstwebrtc1_WebRTCICEClass_gather_candidates(arg0 *C.GstWebRTCICE, arg1 *C.GstWebRTCICEStream) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebRTCICEOverrides](instance0)
	if overrides.GatherCandidates == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebRTCICEOverrides.GatherCandidates, got none")
	}

	var _stream WebRTCICEStreamer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gstwebrtc.WebRTCICEStreamer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(WebRTCICEStreamer)
			return ok
		})
		rv, ok := casted.(WebRTCICEStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstwebrtc.WebRTCICEStreamer")
		}
		_stream = rv
	}

	ok := overrides.GatherCandidates(_stream)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstwebrtc1_WebRTCICEClass_get_http_proxy
func _gotk4_gstwebrtc1_WebRTCICEClass_get_http_proxy(arg0 *C.GstWebRTCICE) (cret *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebRTCICEOverrides](instance0)
	if overrides.HTTPProxy == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebRTCICEOverrides.HTTPProxy, got none")
	}

	utf8 := overrides.HTTPProxy()

	var _ string

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

//export _gotk4_gstwebrtc1_WebRTCICEClass_get_is_controller
func _gotk4_gstwebrtc1_WebRTCICEClass_get_is_controller(arg0 *C.GstWebRTCICE) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebRTCICEOverrides](instance0)
	if overrides.IsController == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebRTCICEOverrides.IsController, got none")
	}

	ok := overrides.IsController()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstwebrtc1_WebRTCICEClass_get_selected_pair
func _gotk4_gstwebrtc1_WebRTCICEClass_get_selected_pair(arg0 *C.GstWebRTCICE, arg1 *C.GstWebRTCICEStream, arg2 **C.GstWebRTCICECandidateStats, arg3 **C.GstWebRTCICECandidateStats) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebRTCICEOverrides](instance0)
	if overrides.SelectedPair == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebRTCICEOverrides.SelectedPair, got none")
	}

	var _stream WebRTCICEStreamer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gstwebrtc.WebRTCICEStreamer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(WebRTCICEStreamer)
			return ok
		})
		rv, ok := casted.(WebRTCICEStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstwebrtc.WebRTCICEStreamer")
		}
		_stream = rv
	}

	localStats, remoteStats, ok := overrides.SelectedPair(_stream)

	var _ *WebRTCICECandidateStats
	var _ *WebRTCICECandidateStats
	var _ bool

	*arg2 = (*C.GstWebRTCICECandidateStats)(gextras.StructNative(unsafe.Pointer(localStats)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(localStats)), nil)
	*arg3 = (*C.GstWebRTCICECandidateStats)(gextras.StructNative(unsafe.Pointer(remoteStats)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(remoteStats)), nil)
	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstwebrtc1_WebRTCICEClass_get_stun_server
func _gotk4_gstwebrtc1_WebRTCICEClass_get_stun_server(arg0 *C.GstWebRTCICE) (cret *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebRTCICEOverrides](instance0)
	if overrides.StunServer == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebRTCICEOverrides.StunServer, got none")
	}

	utf8 := overrides.StunServer()

	var _ string

	if utf8 != "" {
		cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))
	}

	return cret
}

//export _gotk4_gstwebrtc1_WebRTCICEClass_get_turn_server
func _gotk4_gstwebrtc1_WebRTCICEClass_get_turn_server(arg0 *C.GstWebRTCICE) (cret *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebRTCICEOverrides](instance0)
	if overrides.TurnServer == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebRTCICEOverrides.TurnServer, got none")
	}

	utf8 := overrides.TurnServer()

	var _ string

	if utf8 != "" {
		cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))
	}

	return cret
}

//export _gotk4_gstwebrtc1_WebRTCICEClass_set_force_relay
func _gotk4_gstwebrtc1_WebRTCICEClass_set_force_relay(arg0 *C.GstWebRTCICE, arg1 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebRTCICEOverrides](instance0)
	if overrides.SetForceRelay == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebRTCICEOverrides.SetForceRelay, got none")
	}

	var _forceRelay bool // out

	if arg1 != 0 {
		_forceRelay = true
	}

	overrides.SetForceRelay(_forceRelay)
}

//export _gotk4_gstwebrtc1_WebRTCICEClass_set_http_proxy
func _gotk4_gstwebrtc1_WebRTCICEClass_set_http_proxy(arg0 *C.GstWebRTCICE, arg1 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebRTCICEOverrides](instance0)
	if overrides.SetHTTPProxy == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebRTCICEOverrides.SetHTTPProxy, got none")
	}

	var _uri string // out

	_uri = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	overrides.SetHTTPProxy(_uri)
}

//export _gotk4_gstwebrtc1_WebRTCICEClass_set_is_controller
func _gotk4_gstwebrtc1_WebRTCICEClass_set_is_controller(arg0 *C.GstWebRTCICE, arg1 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebRTCICEOverrides](instance0)
	if overrides.SetIsController == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebRTCICEOverrides.SetIsController, got none")
	}

	var _controller bool // out

	if arg1 != 0 {
		_controller = true
	}

	overrides.SetIsController(_controller)
}

//export _gotk4_gstwebrtc1_WebRTCICEClass_set_local_credentials
func _gotk4_gstwebrtc1_WebRTCICEClass_set_local_credentials(arg0 *C.GstWebRTCICE, arg1 *C.GstWebRTCICEStream, arg2 *C.gchar, arg3 *C.gchar) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebRTCICEOverrides](instance0)
	if overrides.SetLocalCredentials == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebRTCICEOverrides.SetLocalCredentials, got none")
	}

	var _stream WebRTCICEStreamer // out
	var _ufrag string             // out
	var _pwd string               // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gstwebrtc.WebRTCICEStreamer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(WebRTCICEStreamer)
			return ok
		})
		rv, ok := casted.(WebRTCICEStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstwebrtc.WebRTCICEStreamer")
		}
		_stream = rv
	}
	_ufrag = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_pwd = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))

	ok := overrides.SetLocalCredentials(_stream, _ufrag, _pwd)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstwebrtc1_WebRTCICEClass_set_remote_credentials
func _gotk4_gstwebrtc1_WebRTCICEClass_set_remote_credentials(arg0 *C.GstWebRTCICE, arg1 *C.GstWebRTCICEStream, arg2 *C.gchar, arg3 *C.gchar) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebRTCICEOverrides](instance0)
	if overrides.SetRemoteCredentials == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebRTCICEOverrides.SetRemoteCredentials, got none")
	}

	var _stream WebRTCICEStreamer // out
	var _ufrag string             // out
	var _pwd string               // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gstwebrtc.WebRTCICEStreamer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(WebRTCICEStreamer)
			return ok
		})
		rv, ok := casted.(WebRTCICEStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstwebrtc.WebRTCICEStreamer")
		}
		_stream = rv
	}
	_ufrag = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_pwd = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))

	ok := overrides.SetRemoteCredentials(_stream, _ufrag, _pwd)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstwebrtc1_WebRTCICEClass_set_stun_server
func _gotk4_gstwebrtc1_WebRTCICEClass_set_stun_server(arg0 *C.GstWebRTCICE, arg1 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebRTCICEOverrides](instance0)
	if overrides.SetStunServer == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebRTCICEOverrides.SetStunServer, got none")
	}

	var _uri string // out

	if arg1 != nil {
		_uri = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	}

	overrides.SetStunServer(_uri)
}

//export _gotk4_gstwebrtc1_WebRTCICEClass_set_tos
func _gotk4_gstwebrtc1_WebRTCICEClass_set_tos(arg0 *C.GstWebRTCICE, arg1 *C.GstWebRTCICEStream, arg2 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebRTCICEOverrides](instance0)
	if overrides.SetTos == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebRTCICEOverrides.SetTos, got none")
	}

	var _stream WebRTCICEStreamer // out
	var _tos uint                 // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gstwebrtc.WebRTCICEStreamer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(WebRTCICEStreamer)
			return ok
		})
		rv, ok := casted.(WebRTCICEStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstwebrtc.WebRTCICEStreamer")
		}
		_stream = rv
	}
	_tos = uint(arg2)

	overrides.SetTos(_stream, _tos)
}

//export _gotk4_gstwebrtc1_WebRTCICEClass_set_turn_server
func _gotk4_gstwebrtc1_WebRTCICEClass_set_turn_server(arg0 *C.GstWebRTCICE, arg1 *C.gchar) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebRTCICEOverrides](instance0)
	if overrides.SetTurnServer == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebRTCICEOverrides.SetTurnServer, got none")
	}

	var _uri string // out

	if arg1 != nil {
		_uri = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	}

	overrides.SetTurnServer(_uri)
}

//export _gotk4_gstwebrtc1_WebRTCICEStreamClass_find_transport
func _gotk4_gstwebrtc1_WebRTCICEStreamClass_find_transport(arg0 *C.GstWebRTCICEStream, arg1 C.GstWebRTCICEComponent) (cret *C.GstWebRTCICETransport) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebRTCICEStreamOverrides](instance0)
	if overrides.FindTransport == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebRTCICEStreamOverrides.FindTransport, got none")
	}

	var _component WebRTCICEComponent // out

	_component = WebRTCICEComponent(arg1)

	webRTCICETransport := overrides.FindTransport(_component)

	var _ WebRTCICETransporter

	if webRTCICETransport != nil {
		cret = (*C.GstWebRTCICETransport)(unsafe.Pointer(coreglib.BaseObject(webRTCICETransport).Native()))
		C.g_object_ref(C.gpointer(coreglib.BaseObject(webRTCICETransport).Native()))
	}

	return cret
}

//export _gotk4_gstwebrtc1_WebRTCICEStreamClass_gather_candidates
func _gotk4_gstwebrtc1_WebRTCICEStreamClass_gather_candidates(arg0 *C.GstWebRTCICEStream) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebRTCICEStreamOverrides](instance0)
	if overrides.GatherCandidates == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebRTCICEStreamOverrides.GatherCandidates, got none")
	}

	ok := overrides.GatherCandidates()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstwebrtc1_WebRTCICETransportClass_gather_candidates
func _gotk4_gstwebrtc1_WebRTCICETransportClass_gather_candidates(arg0 *C.GstWebRTCICETransport) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WebRTCICETransportOverrides](instance0)
	if overrides.GatherCandidates == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WebRTCICETransportOverrides.GatherCandidates, got none")
	}

	ok := overrides.GatherCandidates()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstwebrtc1_WebRTCICETransport_ConnectOnNewCandidate
func _gotk4_gstwebrtc1_WebRTCICETransport_ConnectOnNewCandidate(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(object string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object string))
	}

	var _object string // out

	_object = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_object)
}

//export _gotk4_gstwebrtc1_WebRTCICETransport_ConnectOnSelectedCandidatePairChange
func _gotk4_gstwebrtc1_WebRTCICETransport_ConnectOnSelectedCandidatePairChange(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}
