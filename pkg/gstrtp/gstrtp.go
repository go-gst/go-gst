// Code generated by girgen. DO NOT EDIT.

package gstrtp

import (
	"fmt"
	"runtime"
	_ "runtime/cgo"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/go-gst/go-gst/pkg/gst"
	"github.com/go-gst/go-gst/pkg/gstbase"
)

// #cgo pkg-config: gstreamer-rtp-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/rtp/rtp.h>
// extern gssize _gotk4_gstrtp1_RTPHeaderExtensionClass_write(GstRTPHeaderExtension*, GstBuffer*, GstRTPHeaderExtensionFlags, GstBuffer*, guint8*, gsize);
// extern gsize _gotk4_gstrtp1_RTPHeaderExtensionClass_get_max_size(GstRTPHeaderExtension*, GstBuffer*);
// extern gboolean _gotk4_gstrtp1_RTPHeaderExtensionClass_update_non_rtp_src_caps(GstRTPHeaderExtension*, GstCaps*);
// extern gboolean _gotk4_gstrtp1_RTPHeaderExtensionClass_set_non_rtp_sink_caps(GstRTPHeaderExtension*, GstCaps*);
// extern gboolean _gotk4_gstrtp1_RTPHeaderExtensionClass_set_caps_from_attributes(GstRTPHeaderExtension*, GstCaps*);
// extern gboolean _gotk4_gstrtp1_RTPHeaderExtensionClass_set_attributes(GstRTPHeaderExtension*, GstRTPHeaderExtensionDirection, gchar*);
// extern gboolean _gotk4_gstrtp1_RTPHeaderExtensionClass_read(GstRTPHeaderExtension*, GstRTPHeaderExtensionFlags, guint8*, gsize, GstBuffer*);
// extern gboolean _gotk4_gstrtp1_RTPBasePayloadClass_src_event(GstRTPBasePayload*, GstEvent*);
// extern gboolean _gotk4_gstrtp1_RTPBasePayloadClass_sink_event(GstRTPBasePayload*, GstEvent*);
// extern gboolean _gotk4_gstrtp1_RTPBasePayloadClass_set_caps(GstRTPBasePayload*, GstCaps*);
// extern gboolean _gotk4_gstrtp1_RTPBasePayloadClass_query(GstRTPBasePayload*, GstPad*, GstQuery*);
// extern gboolean _gotk4_gstrtp1_RTPBaseDepayloadClass_set_caps(GstRTPBaseDepayload*, GstCaps*);
// extern gboolean _gotk4_gstrtp1_RTPBaseDepayloadClass_packet_lost(GstRTPBaseDepayload*, GstEvent*);
// extern gboolean _gotk4_gstrtp1_RTPBaseDepayloadClass_handle_event(GstRTPBaseDepayload*, GstEvent*);
// extern GstRTPHeaderExtensionFlags _gotk4_gstrtp1_RTPHeaderExtensionClass_get_supported_flags(GstRTPHeaderExtension*);
// extern GstRTPHeaderExtension* _gotk4_gstrtp1_RTPBasePayload_ConnectRequestExtension(gpointer, guint, gchar*, guintptr);
// extern GstRTPHeaderExtension* _gotk4_gstrtp1_RTPBaseDepayload_ConnectRequestExtension(gpointer, guint, gchar*, guintptr);
// extern GstFlowReturn _gotk4_gstrtp1_RTPBasePayloadClass_handle_buffer(GstRTPBasePayload*, GstBuffer*);
// extern GstCaps* _gotk4_gstrtp1_RTPBasePayloadClass_get_caps(GstRTPBasePayload*, GstPad*, GstCaps*);
// extern GstBuffer* _gotk4_gstrtp1_RTPBaseDepayloadClass_process_rtp_packet(GstRTPBaseDepayload*, GstRTPBuffer*);
// extern GstBuffer* _gotk4_gstrtp1_RTPBaseDepayloadClass_process(GstRTPBaseDepayload*, GstBuffer*);
// GstBuffer* _gotk4_gstrtp1_RTPBaseDepayload_virtual_process(void* fnptr, GstRTPBaseDepayload* arg0, GstBuffer* arg1) {
//   return ((GstBuffer* (*)(GstRTPBaseDepayload*, GstBuffer*))(fnptr))(arg0, arg1);
// };
// GstBuffer* _gotk4_gstrtp1_RTPBaseDepayload_virtual_process_rtp_packet(void* fnptr, GstRTPBaseDepayload* arg0, GstRTPBuffer* arg1) {
//   return ((GstBuffer* (*)(GstRTPBaseDepayload*, GstRTPBuffer*))(fnptr))(arg0, arg1);
// };
// GstCaps* _gotk4_gstrtp1_RTPBasePayload_virtual_get_caps(void* fnptr, GstRTPBasePayload* arg0, GstPad* arg1, GstCaps* arg2) {
//   return ((GstCaps* (*)(GstRTPBasePayload*, GstPad*, GstCaps*))(fnptr))(arg0, arg1, arg2);
// };
// GstFlowReturn _gotk4_gstrtp1_RTPBasePayload_virtual_handle_buffer(void* fnptr, GstRTPBasePayload* arg0, GstBuffer* arg1) {
//   return ((GstFlowReturn (*)(GstRTPBasePayload*, GstBuffer*))(fnptr))(arg0, arg1);
// };
// GstRTPHeaderExtensionFlags _gotk4_gstrtp1_RTPHeaderExtension_virtual_get_supported_flags(void* fnptr, GstRTPHeaderExtension* arg0) {
//   return ((GstRTPHeaderExtensionFlags (*)(GstRTPHeaderExtension*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstrtp1_RTPBaseDepayload_virtual_handle_event(void* fnptr, GstRTPBaseDepayload* arg0, GstEvent* arg1) {
//   return ((gboolean (*)(GstRTPBaseDepayload*, GstEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstrtp1_RTPBaseDepayload_virtual_packet_lost(void* fnptr, GstRTPBaseDepayload* arg0, GstEvent* arg1) {
//   return ((gboolean (*)(GstRTPBaseDepayload*, GstEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstrtp1_RTPBaseDepayload_virtual_set_caps(void* fnptr, GstRTPBaseDepayload* arg0, GstCaps* arg1) {
//   return ((gboolean (*)(GstRTPBaseDepayload*, GstCaps*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstrtp1_RTPBasePayload_virtual_query(void* fnptr, GstRTPBasePayload* arg0, GstPad* arg1, GstQuery* arg2) {
//   return ((gboolean (*)(GstRTPBasePayload*, GstPad*, GstQuery*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gstrtp1_RTPBasePayload_virtual_set_caps(void* fnptr, GstRTPBasePayload* arg0, GstCaps* arg1) {
//   return ((gboolean (*)(GstRTPBasePayload*, GstCaps*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstrtp1_RTPBasePayload_virtual_sink_event(void* fnptr, GstRTPBasePayload* arg0, GstEvent* arg1) {
//   return ((gboolean (*)(GstRTPBasePayload*, GstEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstrtp1_RTPBasePayload_virtual_src_event(void* fnptr, GstRTPBasePayload* arg0, GstEvent* arg1) {
//   return ((gboolean (*)(GstRTPBasePayload*, GstEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstrtp1_RTPHeaderExtension_virtual_read(void* fnptr, GstRTPHeaderExtension* arg0, GstRTPHeaderExtensionFlags arg1, guint8* arg2, gsize arg3, GstBuffer* arg4) {
//   return ((gboolean (*)(GstRTPHeaderExtension*, GstRTPHeaderExtensionFlags, guint8*, gsize, GstBuffer*))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// gboolean _gotk4_gstrtp1_RTPHeaderExtension_virtual_set_attributes(void* fnptr, GstRTPHeaderExtension* arg0, GstRTPHeaderExtensionDirection arg1, gchar* arg2) {
//   return ((gboolean (*)(GstRTPHeaderExtension*, GstRTPHeaderExtensionDirection, gchar*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gstrtp1_RTPHeaderExtension_virtual_set_caps_from_attributes(void* fnptr, GstRTPHeaderExtension* arg0, GstCaps* arg1) {
//   return ((gboolean (*)(GstRTPHeaderExtension*, GstCaps*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstrtp1_RTPHeaderExtension_virtual_set_non_rtp_sink_caps(void* fnptr, GstRTPHeaderExtension* arg0, GstCaps* arg1) {
//   return ((gboolean (*)(GstRTPHeaderExtension*, GstCaps*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstrtp1_RTPHeaderExtension_virtual_update_non_rtp_src_caps(void* fnptr, GstRTPHeaderExtension* arg0, GstCaps* arg1) {
//   return ((gboolean (*)(GstRTPHeaderExtension*, GstCaps*))(fnptr))(arg0, arg1);
// };
// gsize _gotk4_gstrtp1_RTPHeaderExtension_virtual_get_max_size(void* fnptr, GstRTPHeaderExtension* arg0, GstBuffer* arg1) {
//   return ((gsize (*)(GstRTPHeaderExtension*, GstBuffer*))(fnptr))(arg0, arg1);
// };
// gssize _gotk4_gstrtp1_RTPHeaderExtension_virtual_write(void* fnptr, GstRTPHeaderExtension* arg0, GstBuffer* arg1, GstRTPHeaderExtensionFlags arg2, GstBuffer* arg3, guint8* arg4, gsize arg5) {
//   return ((gssize (*)(GstRTPHeaderExtension*, GstBuffer*, GstRTPHeaderExtensionFlags, GstBuffer*, guint8*, gsize))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
import "C"

// GType values.
var (
	GTypeRTCPFBType                  = coreglib.Type(C.gst_rtcpfb_type_get_type())
	GTypeRTCPSDESType                = coreglib.Type(C.gst_rtcpsdes_type_get_type())
	GTypeRTCPType                    = coreglib.Type(C.gst_rtcp_type_get_type())
	GTypeRTCPXRType                  = coreglib.Type(C.gst_rtcpxr_type_get_type())
	GTypeRTPPayload                  = coreglib.Type(C.gst_rtp_payload_get_type())
	GTypeRTPProfile                  = coreglib.Type(C.gst_rtp_profile_get_type())
	GTypeRTPBufferFlags              = coreglib.Type(C.gst_rtp_buffer_flags_get_type())
	GTypeRTPBufferMapFlags           = coreglib.Type(C.gst_rtp_buffer_map_flags_get_type())
	GTypeRTPHeaderExtensionDirection = coreglib.Type(C.gst_rtp_header_extension_direction_get_type())
	GTypeRTPHeaderExtensionFlags     = coreglib.Type(C.gst_rtp_header_extension_flags_get_type())
	GTypeRTPBaseAudioPayload         = coreglib.Type(C.gst_rtp_base_audio_payload_get_type())
	GTypeRTPBaseDepayload            = coreglib.Type(C.gst_rtp_base_depayload_get_type())
	GTypeRTPBasePayload              = coreglib.Type(C.gst_rtp_base_payload_get_type())
	GTypeRTPHeaderExtension          = coreglib.Type(C.gst_rtp_header_extension_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeRTCPFBType, F: marshalRTCPFBType},
		coreglib.TypeMarshaler{T: GTypeRTCPSDESType, F: marshalRTCPSDESType},
		coreglib.TypeMarshaler{T: GTypeRTCPType, F: marshalRTCPType},
		coreglib.TypeMarshaler{T: GTypeRTCPXRType, F: marshalRTCPXRType},
		coreglib.TypeMarshaler{T: GTypeRTPPayload, F: marshalRTPPayload},
		coreglib.TypeMarshaler{T: GTypeRTPProfile, F: marshalRTPProfile},
		coreglib.TypeMarshaler{T: GTypeRTPBufferFlags, F: marshalRTPBufferFlags},
		coreglib.TypeMarshaler{T: GTypeRTPBufferMapFlags, F: marshalRTPBufferMapFlags},
		coreglib.TypeMarshaler{T: GTypeRTPHeaderExtensionDirection, F: marshalRTPHeaderExtensionDirection},
		coreglib.TypeMarshaler{T: GTypeRTPHeaderExtensionFlags, F: marshalRTPHeaderExtensionFlags},
		coreglib.TypeMarshaler{T: GTypeRTPBaseAudioPayload, F: marshalRTPBaseAudioPayload},
		coreglib.TypeMarshaler{T: GTypeRTPBaseDepayload, F: marshalRTPBaseDepayload},
		coreglib.TypeMarshaler{T: GTypeRTPBasePayload, F: marshalRTPBasePayload},
		coreglib.TypeMarshaler{T: GTypeRTPHeaderExtension, F: marshalRTPHeaderExtension},
	})
}

// RTCP_MAX_BYE_SSRC_COUNT (GST_RTCP_MAX_BYE_SSRC_COUNT): maximum amount of
// SSRCs in a BYE packet.
const RTCP_MAX_BYE_SSRC_COUNT = 31

// RTCP_MAX_RB_COUNT (GST_RTCP_MAX_RB_COUNT): maximum amount of Receiver report
// blocks in RR and SR messages.
const RTCP_MAX_RB_COUNT = 31

// RTCP_MAX_SDES (GST_RTCP_MAX_SDES): maximum text length for an SDES item.
const RTCP_MAX_SDES = 255

// RTCP_MAX_SDES_ITEM_COUNT (GST_RTCP_MAX_SDES_ITEM_COUNT): maximum amount of
// SDES items.
const RTCP_MAX_SDES_ITEM_COUNT = 31

// RTCP_REDUCED_SIZE_VALID_MASK (GST_RTCP_REDUCED_SIZE_VALID_MASK): mask for
// version and packet type pair allowing reduced size packets, basically it
// accepts other types than RR and SR.
const RTCP_REDUCED_SIZE_VALID_MASK = 49400

// RTCP_VALID_MASK (GST_RTCP_VALID_MASK): mask for version, padding bit and
// packet type pair.
const RTCP_VALID_MASK = 57598

// RTCP_VALID_VALUE (GST_RTCP_VALID_VALUE): valid value for the first two bytes
// of an RTCP packet after applying T_RTCP_VALID_MASK to them.
const RTCP_VALID_VALUE = 200

// RTCP_VERSION (GST_RTCP_VERSION): supported RTCP version 2.
const RTCP_VERSION = 2
const RTP_HDREXT_BASE = "urn:ietf:params:rtp-hdrext:"

// RTP_HDREXT_ELEMENT_CLASS (GST_RTP_HDREXT_ELEMENT_CLASS): constant string
// used in element classification to signal that this element is a RTP header
// extension.
const RTP_HDREXT_ELEMENT_CLASS = "Network/Extension/RTPHeader"
const RTP_HDREXT_NTP_56 = "ntp-56"
const RTP_HDREXT_NTP_56_SIZE = 7
const RTP_HDREXT_NTP_64 = "ntp-64"
const RTP_HDREXT_NTP_64_SIZE = 8
const RTP_HEADER_EXTENSION_URI_METADATA_KEY = "RTP-Header-Extension-URI"
const RTP_PAYLOAD_1016_STRING = "1"
const RTP_PAYLOAD_CELLB_STRING = "25"
const RTP_PAYLOAD_CN_STRING = "13"
const RTP_PAYLOAD_DVI4_11025_STRING = "16"
const RTP_PAYLOAD_DVI4_16000_STRING = "6"
const RTP_PAYLOAD_DVI4_22050_STRING = "17"
const RTP_PAYLOAD_DVI4_8000_STRING = "5"
const RTP_PAYLOAD_DYNAMIC_STRING = "[96, 127]"
const RTP_PAYLOAD_G721_STRING = "2"
const RTP_PAYLOAD_G722_STRING = "9"
const RTP_PAYLOAD_G723_53 = 17
const RTP_PAYLOAD_G723_53_STRING = "17"
const RTP_PAYLOAD_G723_63 = 16
const RTP_PAYLOAD_G723_63_STRING = "16"
const RTP_PAYLOAD_G723_STRING = "4"
const RTP_PAYLOAD_G728_STRING = "15"
const RTP_PAYLOAD_G729_STRING = "18"
const RTP_PAYLOAD_GSM_STRING = "3"
const RTP_PAYLOAD_H261_STRING = "31"
const RTP_PAYLOAD_H263_STRING = "34"
const RTP_PAYLOAD_JPEG_STRING = "26"
const RTP_PAYLOAD_L16_MONO_STRING = "11"
const RTP_PAYLOAD_L16_STEREO_STRING = "10"
const RTP_PAYLOAD_LPC_STRING = "7"
const RTP_PAYLOAD_MP2T_STRING = "33"
const RTP_PAYLOAD_MPA_STRING = "14"
const RTP_PAYLOAD_MPV_STRING = "32"
const RTP_PAYLOAD_NV_STRING = "28"
const RTP_PAYLOAD_PCMA_STRING = "8"
const RTP_PAYLOAD_PCMU_STRING = "0"
const RTP_PAYLOAD_QCELP_STRING = "12"
const RTP_PAYLOAD_TS41 = 19
const RTP_PAYLOAD_TS41_STRING = "19"
const RTP_PAYLOAD_TS48 = 18
const RTP_PAYLOAD_TS48_STRING = "18"
const RTP_SOURCE_META_MAX_CSRC_COUNT = 15

// RTP_VERSION (GST_RTP_VERSION): supported RTP version 2.
const RTP_VERSION = 2

// RTCPFBType (GstRTCPFBType): different types of feedback messages.
type RTCPFBType C.gint

const (
	// RtcpFbTypeInvalid (GST_RTCP_FB_TYPE_INVALID): invalid type.
	RtcpFbTypeInvalid RTCPFBType = 0
	// RtcpRtpfbTypeNack (GST_RTCP_RTPFB_TYPE_NACK): generic NACK.
	RtcpRtpfbTypeNack RTCPFBType = 1
	// RtcpRtpfbTypeTmmbr (GST_RTCP_RTPFB_TYPE_TMMBR): temporary Maximum Media
	// Stream Bit Rate Request.
	RtcpRtpfbTypeTmmbr RTCPFBType = 3
	// RtcpRtpfbTypeTmmbn (GST_RTCP_RTPFB_TYPE_TMMBN): temporary Maximum Media
	// Stream Bit Rate Notification.
	RtcpRtpfbTypeTmmbn RTCPFBType = 4
	// RtcpRtpfbTypeRtcpSrReq (GST_RTCP_RTPFB_TYPE_RTCP_SR_REQ): request an SR
	// packet for early synchronization.
	RtcpRtpfbTypeRtcpSrReq RTCPFBType = 5
	RtcpRtpfbTypeTwcc      RTCPFBType = 15
	// RtcpPsfbTypePli (GST_RTCP_PSFB_TYPE_PLI): picture Loss Indication.
	RtcpPsfbTypePli RTCPFBType = 1
	// RtcpPsfbTypeSli (GST_RTCP_PSFB_TYPE_SLI): slice Loss Indication.
	RtcpPsfbTypeSli RTCPFBType = 2
	// RtcpPsfbTypeRpsi (GST_RTCP_PSFB_TYPE_RPSI): reference Picture Selection
	// Indication.
	RtcpPsfbTypeRpsi RTCPFBType = 3
	// RtcpPsfbTypeAfb (GST_RTCP_PSFB_TYPE_AFB): application layer Feedback.
	RtcpPsfbTypeAfb RTCPFBType = 15
	// RtcpPsfbTypeFir (GST_RTCP_PSFB_TYPE_FIR): full Intra Request Command.
	RtcpPsfbTypeFir RTCPFBType = 4
	// RtcpPsfbTypeTstr (GST_RTCP_PSFB_TYPE_TSTR): temporal-Spatial Trade-off
	// Request.
	RtcpPsfbTypeTstr RTCPFBType = 5
	// RtcpPsfbTypeTstn (GST_RTCP_PSFB_TYPE_TSTN): temporal-Spatial Trade-off
	// Notification.
	RtcpPsfbTypeTstn RTCPFBType = 6
	// RtcpPsfbTypeVbcn (GST_RTCP_PSFB_TYPE_VBCN): video Back Channel Message.
	RtcpPsfbTypeVbcn RTCPFBType = 7
)

func marshalRTCPFBType(p uintptr) (interface{}, error) {
	return RTCPFBType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for RTCPFBType.
func (r RTCPFBType) String() string {
	switch r {
	case RtcpFbTypeInvalid:
		return "FbTypeInvalid"
	case RtcpRtpfbTypeNack:
		return "RtpfbTypeNack"
	case RtcpRtpfbTypeTmmbr:
		return "RtpfbTypeTmmbr"
	case RtcpRtpfbTypeTmmbn:
		return "RtpfbTypeTmmbn"
	case RtcpRtpfbTypeRtcpSrReq:
		return "RtpfbTypeRtcpSrReq"
	case RtcpRtpfbTypeTwcc:
		return "RtpfbTypeTwcc"
	case RtcpPsfbTypeSli:
		return "PsfbTypeSli"
	case RtcpPsfbTypeTstn:
		return "PsfbTypeTstn"
	case RtcpPsfbTypeVbcn:
		return "PsfbTypeVbcn"
	default:
		return fmt.Sprintf("RTCPFBType(%d)", r)
	}
}

// RTCPSDESType (GstRTCPSDESType): different types of SDES content.
type RTCPSDESType C.gint

const (
	// RtcpSdesInvalid (GST_RTCP_SDES_INVALID): invalid SDES entry.
	RtcpSdesInvalid RTCPSDESType = -1
	// RtcpSdesEnd (GST_RTCP_SDES_END): end of SDES list.
	RtcpSdesEnd RTCPSDESType = 0
	// RtcpSdesCname (GST_RTCP_SDES_CNAME): canonical name.
	RtcpSdesCname RTCPSDESType = 1
	// RtcpSdesName (GST_RTCP_SDES_NAME): user name.
	RtcpSdesName RTCPSDESType = 2
	// RtcpSdesEmail (GST_RTCP_SDES_EMAIL) user's electronic mail address.
	RtcpSdesEmail RTCPSDESType = 3
	// RtcpSdesPhone (GST_RTCP_SDES_PHONE) user's phone number.
	RtcpSdesPhone RTCPSDESType = 4
	// RtcpSdesLoc (GST_RTCP_SDES_LOC): geographic user location.
	RtcpSdesLoc RTCPSDESType = 5
	// RtcpSdesTool (GST_RTCP_SDES_TOOL): name of application or tool.
	RtcpSdesTool RTCPSDESType = 6
	// RtcpSdesNote (GST_RTCP_SDES_NOTE): notice about the source.
	RtcpSdesNote RTCPSDESType = 7
	// RtcpSdesPriv (GST_RTCP_SDES_PRIV): private extensions.
	RtcpSdesPriv RTCPSDESType = 8
	// RtcpSdesH323Caddr (GST_RTCP_SDES_H323_CADDR): h.323 callable address.
	RtcpSdesH323Caddr RTCPSDESType = 9
	// RtcpSdesApsi (GST_RTCP_SDES_APSI): application Specific Identifier
	// (RFC6776).
	RtcpSdesApsi RTCPSDESType = 10
	// RtcpSdesRgrp (GST_RTCP_SDES_RGRP): reporting Group Identifier (RFC8861).
	RtcpSdesRgrp RTCPSDESType = 11
	// RtcpSdesRtpStreamID (GST_RTCP_SDES_RTP_STREAM_ID): rtpStreamId SDES item
	// (RFC8852).
	RtcpSdesRtpStreamID RTCPSDESType = 12
	// RtcpSdesRepairedRtpStreamID (GST_RTCP_SDES_REPAIRED_RTP_STREAM_ID):
	// repairedRtpStreamId SDES item (RFC8852).
	RtcpSdesRepairedRtpStreamID RTCPSDESType = 13
	// RtcpSdesCcid (GST_RTCP_SDES_CCID): CLUE CaptId (RFC8849).
	RtcpSdesCcid RTCPSDESType = 14
	// RtcpSdesMid (GST_RTCP_SDES_MID): MID SDES item (RFC8843).
	RtcpSdesMid RTCPSDESType = 15
)

func marshalRTCPSDESType(p uintptr) (interface{}, error) {
	return RTCPSDESType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for RTCPSDESType.
func (r RTCPSDESType) String() string {
	switch r {
	case RtcpSdesInvalid:
		return "Invalid"
	case RtcpSdesEnd:
		return "End"
	case RtcpSdesCname:
		return "Cname"
	case RtcpSdesName:
		return "Name"
	case RtcpSdesEmail:
		return "Email"
	case RtcpSdesPhone:
		return "Phone"
	case RtcpSdesLoc:
		return "Loc"
	case RtcpSdesTool:
		return "Tool"
	case RtcpSdesNote:
		return "Note"
	case RtcpSdesPriv:
		return "Priv"
	case RtcpSdesH323Caddr:
		return "H323Caddr"
	case RtcpSdesApsi:
		return "Apsi"
	case RtcpSdesRgrp:
		return "Rgrp"
	case RtcpSdesRtpStreamID:
		return "RtpStreamID"
	case RtcpSdesRepairedRtpStreamID:
		return "RepairedRtpStreamID"
	case RtcpSdesCcid:
		return "Ccid"
	case RtcpSdesMid:
		return "Mid"
	default:
		return fmt.Sprintf("RTCPSDESType(%d)", r)
	}
}

// RTCPType (GstRTCPType): different RTCP packet types.
type RTCPType C.gint

const (
	// RtcpTypeInvalid (GST_RTCP_TYPE_INVALID): invalid type.
	RtcpTypeInvalid RTCPType = 0
	// RtcpTypeSr (GST_RTCP_TYPE_SR): sender report.
	RtcpTypeSr RTCPType = 200
	// RtcpTypeRr (GST_RTCP_TYPE_RR): receiver report.
	RtcpTypeRr RTCPType = 201
	// RtcpTypeSdes (GST_RTCP_TYPE_SDES): source description.
	RtcpTypeSdes RTCPType = 202
	// RtcpTypeBye (GST_RTCP_TYPE_BYE): goodbye.
	RtcpTypeBye RTCPType = 203
	// RtcpTypeApp (GST_RTCP_TYPE_APP): application defined.
	RtcpTypeApp RTCPType = 204
	// RtcpTypeRtpfb (GST_RTCP_TYPE_RTPFB): transport layer feedback.
	RtcpTypeRtpfb RTCPType = 205
	// RtcpTypePsfb (GST_RTCP_TYPE_PSFB): payload-specific feedback.
	RtcpTypePsfb RTCPType = 206
	// RtcpTypeXR (GST_RTCP_TYPE_XR): extended report.
	RtcpTypeXR RTCPType = 207
)

func marshalRTCPType(p uintptr) (interface{}, error) {
	return RTCPType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for RTCPType.
func (r RTCPType) String() string {
	switch r {
	case RtcpTypeInvalid:
		return "Invalid"
	case RtcpTypeSr:
		return "Sr"
	case RtcpTypeRr:
		return "Rr"
	case RtcpTypeSdes:
		return "Sdes"
	case RtcpTypeBye:
		return "Bye"
	case RtcpTypeApp:
		return "App"
	case RtcpTypeRtpfb:
		return "Rtpfb"
	case RtcpTypePsfb:
		return "Psfb"
	case RtcpTypeXR:
		return "XR"
	default:
		return fmt.Sprintf("RTCPType(%d)", r)
	}
}

// RTCPXRType (GstRTCPXRType) types of RTCP Extended Reports, those are
// defined in RFC 3611 and other RFCs according to the IANA registry
// (https://www.iana.org/assignments/rtcp-xr-block-types/rtcp-xr-block-types.xhtml).
type RTCPXRType C.gint

const (
	// RtcpXRTypeInvalid (GST_RTCP_XR_TYPE_INVALID): invalid XR Report Block.
	RtcpXRTypeInvalid RTCPXRType = -1
	// RtcpXRTypeLrle (GST_RTCP_XR_TYPE_LRLE) loss RLE Report Block.
	RtcpXRTypeLrle RTCPXRType = 1
	// RtcpXRTypeDrle (GST_RTCP_XR_TYPE_DRLE): duplicate RLE Report Block.
	RtcpXRTypeDrle RTCPXRType = 2
	// RtcpXRTypePrt (GST_RTCP_XR_TYPE_PRT): packet Receipt Times Report Block.
	RtcpXRTypePrt RTCPXRType = 3
	// RtcpXRTypeRrt (GST_RTCP_XR_TYPE_RRT): receiver Reference Time Report
	// Block.
	RtcpXRTypeRrt RTCPXRType = 4
	// RtcpXRTypeDlrr (GST_RTCP_XR_TYPE_DLRR): delay since the last Receiver
	// Report.
	RtcpXRTypeDlrr RTCPXRType = 5
	// RtcpXRTypeSsumm (GST_RTCP_XR_TYPE_SSUMM) statistics Summary Report Block.
	RtcpXRTypeSsumm RTCPXRType = 6
	// RtcpXRTypeVoipMetrics (GST_RTCP_XR_TYPE_VOIP_METRICS): voIP Metrics
	// Report Block.
	RtcpXRTypeVoipMetrics RTCPXRType = 7
)

func marshalRTCPXRType(p uintptr) (interface{}, error) {
	return RTCPXRType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for RTCPXRType.
func (r RTCPXRType) String() string {
	switch r {
	case RtcpXRTypeInvalid:
		return "Invalid"
	case RtcpXRTypeLrle:
		return "Lrle"
	case RtcpXRTypeDrle:
		return "Drle"
	case RtcpXRTypePrt:
		return "Prt"
	case RtcpXRTypeRrt:
		return "Rrt"
	case RtcpXRTypeDlrr:
		return "Dlrr"
	case RtcpXRTypeSsumm:
		return "Ssumm"
	case RtcpXRTypeVoipMetrics:
		return "VoipMetrics"
	default:
		return fmt.Sprintf("RTCPXRType(%d)", r)
	}
}

// RTPPayload (GstRTPPayload): standard predefined fixed payload types.
//
// The official list is at: http://www.iana.org/assignments/rtp-parameters
//
// Audio: reserved: 19 unassigned: 20-23,
//
// Video: unassigned: 24, 27, 29, 30, 35-71, 77-95 Reserved for RTCP conflict
// avoidance: 72-76.
type RTPPayload C.gint

const (
	// RtpPayloadPcmu (GST_RTP_PAYLOAD_PCMU): ITU-T G.711. mu-law audio (RFC
	// 3551).
	RtpPayloadPcmu RTPPayload = 0
	// RtpPayload1016 (GST_RTP_PAYLOAD_1016): RFC 3551 says reserved.
	RtpPayload1016 RTPPayload = 1
	// RtpPayloadG721 (GST_RTP_PAYLOAD_G721): RFC 3551 says reserved.
	RtpPayloadG721 RTPPayload = 2
	// RtpPayloadGsm (GST_RTP_PAYLOAD_GSM): GSM audio.
	RtpPayloadGsm RTPPayload = 3
	// RtpPayloadG723 (GST_RTP_PAYLOAD_G723): ITU G.723.1 audio.
	RtpPayloadG723 RTPPayload = 4
	// RtpPayloadDvi48000 (GST_RTP_PAYLOAD_DVI4_8000): IMA ADPCM wave type (RFC
	// 3551).
	RtpPayloadDvi48000 RTPPayload = 5
	// RtpPayloadDvi416000 (GST_RTP_PAYLOAD_DVI4_16000): IMA ADPCM wave type
	// (RFC 3551).
	RtpPayloadDvi416000 RTPPayload = 6
	// RtpPayloadLpc (GST_RTP_PAYLOAD_LPC): experimental linear predictive
	// encoding.
	RtpPayloadLpc RTPPayload = 7
	// RtpPayloadPcma (GST_RTP_PAYLOAD_PCMA): ITU-T G.711 A-law audio (RFC
	// 3551).
	RtpPayloadPcma RTPPayload = 8
	// RtpPayloadG722 (GST_RTP_PAYLOAD_G722): ITU-T G.722 (RFC 3551).
	RtpPayloadG722 RTPPayload = 9
	// RtpPayloadL16Stereo (GST_RTP_PAYLOAD_L16_STEREO): stereo PCM.
	RtpPayloadL16Stereo RTPPayload = 10
	// RtpPayloadL16Mono (GST_RTP_PAYLOAD_L16_MONO): mono PCM.
	RtpPayloadL16Mono RTPPayload = 11
	// RtpPayloadQcelp (GST_RTP_PAYLOAD_QCELP): EIA & TIA standard IS-733.
	RtpPayloadQcelp RTPPayload = 12
	// RtpPayloadCn (GST_RTP_PAYLOAD_CN): comfort Noise (RFC 3389).
	RtpPayloadCn RTPPayload = 13
	// RtpPayloadMpa (GST_RTP_PAYLOAD_MPA): audio MPEG 1-3.
	RtpPayloadMpa RTPPayload = 14
	// RtpPayloadG728 (GST_RTP_PAYLOAD_G728): ITU-T G.728 Speech coder (RFC
	// 3551).
	RtpPayloadG728 RTPPayload = 15
	// RtpPayloadDvi411025 (GST_RTP_PAYLOAD_DVI4_11025): IMA ADPCM wave type
	// (RFC 3551).
	RtpPayloadDvi411025 RTPPayload = 16
	// RtpPayloadDvi422050 (GST_RTP_PAYLOAD_DVI4_22050): IMA ADPCM wave type
	// (RFC 3551).
	RtpPayloadDvi422050 RTPPayload = 17
	// RtpPayloadG729 (GST_RTP_PAYLOAD_G729): ITU-T G.729 Speech coder (RFC
	// 3551).
	RtpPayloadG729 RTPPayload = 18
	// RtpPayloadCellb (GST_RTP_PAYLOAD_CELLB): see RFC 2029.
	RtpPayloadCellb RTPPayload = 25
	// RtpPayloadJPEG (GST_RTP_PAYLOAD_JPEG): ISO Standards 10918-1 and 10918-2
	// (RFC 2435).
	RtpPayloadJPEG RTPPayload = 26
	// RtpPayloadNv (GST_RTP_PAYLOAD_NV): nv encoding by Ron Frederick.
	RtpPayloadNv RTPPayload = 28
	// RtpPayloadH261 (GST_RTP_PAYLOAD_H261): ITU-T Recommendation H.261 (RFC
	// 2032).
	RtpPayloadH261 RTPPayload = 31
	// RtpPayloadMpv (GST_RTP_PAYLOAD_MPV): video MPEG 1 & 2 (RFC 2250).
	RtpPayloadMpv RTPPayload = 32
	// RtpPayloadMp2T (GST_RTP_PAYLOAD_MP2T): MPEG-2 transport stream (RFC
	// 2250).
	RtpPayloadMp2T RTPPayload = 33
	// RtpPayloadH263 (GST_RTP_PAYLOAD_H263): video H263 (RFC 2190).
	RtpPayloadH263 RTPPayload = 34
)

func marshalRTPPayload(p uintptr) (interface{}, error) {
	return RTPPayload(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for RTPPayload.
func (r RTPPayload) String() string {
	switch r {
	case RtpPayloadPcmu:
		return "Pcmu"
	case RtpPayload1016:
		return "1016"
	case RtpPayloadG721:
		return "G721"
	case RtpPayloadGsm:
		return "Gsm"
	case RtpPayloadG723:
		return "G723"
	case RtpPayloadDvi48000:
		return "Dvi48000"
	case RtpPayloadDvi416000:
		return "Dvi416000"
	case RtpPayloadLpc:
		return "Lpc"
	case RtpPayloadPcma:
		return "Pcma"
	case RtpPayloadG722:
		return "G722"
	case RtpPayloadL16Stereo:
		return "L16Stereo"
	case RtpPayloadL16Mono:
		return "L16Mono"
	case RtpPayloadQcelp:
		return "Qcelp"
	case RtpPayloadCn:
		return "Cn"
	case RtpPayloadMpa:
		return "Mpa"
	case RtpPayloadG728:
		return "G728"
	case RtpPayloadDvi411025:
		return "Dvi411025"
	case RtpPayloadDvi422050:
		return "Dvi422050"
	case RtpPayloadG729:
		return "G729"
	case RtpPayloadCellb:
		return "Cellb"
	case RtpPayloadJPEG:
		return "JPEG"
	case RtpPayloadNv:
		return "Nv"
	case RtpPayloadH261:
		return "H261"
	case RtpPayloadMpv:
		return "Mpv"
	case RtpPayloadMp2T:
		return "Mp2T"
	case RtpPayloadH263:
		return "H263"
	default:
		return fmt.Sprintf("RTPPayload(%d)", r)
	}
}

// RTPProfile (GstRTPProfile): transfer profile to use.
type RTPProfile C.gint

const (
	// RtpProfileUnknown (GST_RTP_PROFILE_UNKNOWN): invalid profile.
	RtpProfileUnknown RTPProfile = iota
	// RtpProfileAvp (GST_RTP_PROFILE_AVP): audio/Visual profile (RFC 3551).
	RtpProfileAvp
	// RtpProfileSavp (GST_RTP_PROFILE_SAVP): secure Audio/Visual profile (RFC
	// 3711).
	RtpProfileSavp
	// RtpProfileAvpf (GST_RTP_PROFILE_AVPF): audio/Visual profile with feedback
	// (RFC 4585).
	RtpProfileAvpf
	// RtpProfileSavpf (GST_RTP_PROFILE_SAVPF): secure Audio/Visual profile with
	// feedback (RFC 5124).
	RtpProfileSavpf
)

func marshalRTPProfile(p uintptr) (interface{}, error) {
	return RTPProfile(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for RTPProfile.
func (r RTPProfile) String() string {
	switch r {
	case RtpProfileUnknown:
		return "Unknown"
	case RtpProfileAvp:
		return "Avp"
	case RtpProfileSavp:
		return "Savp"
	case RtpProfileAvpf:
		return "Avpf"
	case RtpProfileSavpf:
		return "Savpf"
	default:
		return fmt.Sprintf("RTPProfile(%d)", r)
	}
}

// RTPBufferFlags (GstRTPBufferFlags): additional RTP buffer flags. These flags
// can potentially be used on any buffers carrying RTP packets.
//
// Note that these are only valid for Caps of type: application/x-rtp (x-rtcp).
// They can conflict with other extended buffer flags.
type RTPBufferFlags C.guint

const (
	// RtpBufferFlagRetransmission (GST_RTP_BUFFER_FLAG_RETRANSMISSION) was once
	// wrapped in a retransmitted packet as specified by RFC 4588.
	RtpBufferFlagRetransmission RTPBufferFlags = 0b100000000000000000000
	// RtpBufferFlagRedundant (GST_RTP_BUFFER_FLAG_REDUNDANT): packet represents
	// redundant RTP packet. The flag is used in gstrtpstorage to be able to
	// hold the packetback and use it only for recovery from packet loss. Since:
	// 1.14.
	RtpBufferFlagRedundant RTPBufferFlags = 0b1000000000000000000000
	// RtpBufferFlagLast (GST_RTP_BUFFER_FLAG_LAST): offset to define more
	// flags.
	RtpBufferFlagLast RTPBufferFlags = 0b10000000000000000000000000000
)

func marshalRTPBufferFlags(p uintptr) (interface{}, error) {
	return RTPBufferFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for RTPBufferFlags.
func (r RTPBufferFlags) String() string {
	if r == 0 {
		return "RTPBufferFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(68)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case RtpBufferFlagRetransmission:
			builder.WriteString("Retransmission|")
		case RtpBufferFlagRedundant:
			builder.WriteString("Redundant|")
		case RtpBufferFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("RTPBufferFlags(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r RTPBufferFlags) Has(other RTPBufferFlags) bool {
	return (r & other) == other
}

// RTPBufferMapFlags (GstRTPBufferMapFlags): additional mapping flags for
// gst_rtp_buffer_map().
type RTPBufferMapFlags C.guint

const (
	// RtpBufferMapFlagSkipPadding (GST_RTP_BUFFER_MAP_FLAG_SKIP_PADDING): skip
	// mapping and validation of RTP padding and RTP pad count when present.
	// Useful for buffers where the padding may be encrypted.
	RtpBufferMapFlagSkipPadding RTPBufferMapFlags = 0b10000000000000000
	// RtpBufferMapFlagLast (GST_RTP_BUFFER_MAP_FLAG_LAST): offset to define
	// more flags.
	RtpBufferMapFlagLast RTPBufferMapFlags = 0b1000000000000000000000000
)

func marshalRTPBufferMapFlags(p uintptr) (interface{}, error) {
	return RTPBufferMapFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for RTPBufferMapFlags.
func (r RTPBufferMapFlags) String() string {
	if r == 0 {
		return "RTPBufferMapFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(48)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case RtpBufferMapFlagSkipPadding:
			builder.WriteString("SkipPadding|")
		case RtpBufferMapFlagLast:
			builder.WriteString("Last|")
		default:
			builder.WriteString(fmt.Sprintf("RTPBufferMapFlags(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r RTPBufferMapFlags) Has(other RTPBufferMapFlags) bool {
	return (r & other) == other
}

// RTPHeaderExtensionDirection (GstRTPHeaderExtensionDirection): direction to
// which to apply the RTP Header Extension.
type RTPHeaderExtensionDirection C.guint

const (
	// RtpHeaderExtensionDirectionInactive
	// (GST_RTP_HEADER_EXTENSION_DIRECTION_INACTIVE): neither send nor receive
	// RTP Header Extensions.
	RtpHeaderExtensionDirectionInactive RTPHeaderExtensionDirection = 0b0
	// RtpHeaderExtensionDirectionSendonly
	// (GST_RTP_HEADER_EXTENSION_DIRECTION_SENDONLY): only send RTP Header
	// Extensions GST_RTP_HEADER_EXTENSION_DIRECTION_RECVONLY: Only receive RTP
	// Header Extensions.
	RtpHeaderExtensionDirectionSendonly RTPHeaderExtensionDirection = 0b1
	RtpHeaderExtensionDirectionRecvonly RTPHeaderExtensionDirection = 0b10
	// RtpHeaderExtensionDirectionSendrecv
	// (GST_RTP_HEADER_EXTENSION_DIRECTION_SENDRECV): send and receive RTP
	// Header Extensions ext.
	RtpHeaderExtensionDirectionSendrecv RTPHeaderExtensionDirection = 0b11
	// RtpHeaderExtensionDirectionInherited
	// (GST_RTP_HEADER_EXTENSION_DIRECTION_INHERITED): RTP header extension
	// direction is inherited from the stream.
	RtpHeaderExtensionDirectionInherited RTPHeaderExtensionDirection = 0b100
)

func marshalRTPHeaderExtensionDirection(p uintptr) (interface{}, error) {
	return RTPHeaderExtensionDirection(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for RTPHeaderExtensionDirection.
func (r RTPHeaderExtensionDirection) String() string {
	if r == 0 {
		return "RTPHeaderExtensionDirection(0)"
	}

	var builder strings.Builder
	builder.Grow(180)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case RtpHeaderExtensionDirectionInactive:
			builder.WriteString("Inactive|")
		case RtpHeaderExtensionDirectionSendonly:
			builder.WriteString("Sendonly|")
		case RtpHeaderExtensionDirectionRecvonly:
			builder.WriteString("Recvonly|")
		case RtpHeaderExtensionDirectionSendrecv:
			builder.WriteString("Sendrecv|")
		case RtpHeaderExtensionDirectionInherited:
			builder.WriteString("Inherited|")
		default:
			builder.WriteString(fmt.Sprintf("RTPHeaderExtensionDirection(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r RTPHeaderExtensionDirection) Has(other RTPHeaderExtensionDirection) bool {
	return (r & other) == other
}

// RTPHeaderExtensionFlags (GstRTPHeaderExtensionFlags) flags that apply to a
// RTP Audio/Video header extension.
type RTPHeaderExtensionFlags C.guint

const (
	// RtpHeaderExtensionOneByte (GST_RTP_HEADER_EXTENSION_ONE_BYTE): one byte
	// rtp extension header. 1-16 data bytes per extension with a maximum of 14
	// extension ids in total.
	RtpHeaderExtensionOneByte RTPHeaderExtensionFlags = 0b1
	// RtpHeaderExtensionTwoByte (GST_RTP_HEADER_EXTENSION_TWO_BYTE): two byte
	// rtp extension header. 256 data bytes per extension with a maximum of 255
	// (or 256 including appbits) extensions in total.
	RtpHeaderExtensionTwoByte RTPHeaderExtensionFlags = 0b10
)

func marshalRTPHeaderExtensionFlags(p uintptr) (interface{}, error) {
	return RTPHeaderExtensionFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for RTPHeaderExtensionFlags.
func (r RTPHeaderExtensionFlags) String() string {
	if r == 0 {
		return "RTPHeaderExtensionFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(51)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case RtpHeaderExtensionOneByte:
			builder.WriteString("OneByte|")
		case RtpHeaderExtensionTwoByte:
			builder.WriteString("TwoByte|")
		default:
			builder.WriteString(fmt.Sprintf("RTPHeaderExtensionFlags(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r RTPHeaderExtensionFlags) Has(other RTPHeaderExtensionFlags) bool {
	return (r & other) == other
}

// BufferAddRtpSourceMeta (gst_buffer_add_rtp_source_meta) attaches RTP source
// information to buffer.
//
// The function takes the following parameters:
//
//   - buffer: Buffer.
//   - ssrc (optional): pointer to the SSRC.
//   - csrc (optional): pointer to the CSRCs.
//
// The function returns the following values:
//
//   - rtpSourceMeta on buffer.
func BufferAddRtpSourceMeta(buffer *gst.Buffer, ssrc *uint32, csrc []uint32) *RTPSourceMeta {
	var _arg1 *C.GstBuffer // out
	var _arg2 *C.guint32   // out
	var _arg3 *C.guint32   // out
	var _arg4 C.guint
	var _cret *C.GstRTPSourceMeta // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	if ssrc != nil {
		_arg2 = (*C.guint32)(unsafe.Pointer(ssrc))
	}
	_arg4 = (C.guint)(len(csrc))
	if len(csrc) > 0 {
		_arg3 = (*C.guint32)(unsafe.Pointer(&csrc[0]))
	}

	_cret = C.gst_buffer_add_rtp_source_meta(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(ssrc)
	runtime.KeepAlive(csrc)

	var _rtpSourceMeta *RTPSourceMeta // out

	_rtpSourceMeta = (*RTPSourceMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rtpSourceMeta
}

// BufferGetRtpSourceMeta (gst_buffer_get_rtp_source_meta): find the
// RTPSourceMeta on buffer.
//
// The function takes the following parameters:
//
//   - buffer: Buffer.
//
// The function returns the following values:
//
//   - rtpSourceMeta (optional) or NULL when there is no such metadata on
//     buffer.
func BufferGetRtpSourceMeta(buffer *gst.Buffer) *RTPSourceMeta {
	var _arg1 *C.GstBuffer        // out
	var _cret *C.GstRTPSourceMeta // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_buffer_get_rtp_source_meta(_arg1)
	runtime.KeepAlive(buffer)

	var _rtpSourceMeta *RTPSourceMeta // out

	if _cret != nil {
		_rtpSourceMeta = (*RTPSourceMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _rtpSourceMeta
}

// RtcpNtpToUnix (gst_rtcp_ntp_to_unix) converts an NTP time to UNIX
// nanoseconds. ntptime can typically be the NTP time of an SR RTCP message
// and contains, in the upper 32 bits, the number of seconds since 1900 and,
// in the lower 32 bits, the fractional seconds. The resulting value will be the
// number of nanoseconds since 1970.
//
// The function takes the following parameters:
//
//   - ntptime: NTP timestamp.
//
// The function returns the following values:
//
//   - guint64: UNIX time for ntptime in nanoseconds.
func RtcpNtpToUnix(ntptime uint64) uint64 {
	var _arg1 C.guint64 // out
	var _cret C.guint64 // in

	_arg1 = C.guint64(ntptime)

	_cret = C.gst_rtcp_ntp_to_unix(_arg1)
	runtime.KeepAlive(ntptime)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// RtcpSdesNameToType (gst_rtcp_sdes_name_to_type): convert name into a
// GstRTCPSDESType. name is typically a key in a Structure containing SDES
// items.
//
// The function takes the following parameters:
//
//   - name: SDES name.
//
// The function returns the following values:
//
//   - rtcpsdesType for name or T_RTCP_SDES_PRIV when name is a private sdes
//     item.
func RtcpSdesNameToType(name string) RTCPSDESType {
	var _arg1 *C.gchar          // out
	var _cret C.GstRTCPSDESType // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_rtcp_sdes_name_to_type(_arg1)
	runtime.KeepAlive(name)

	var _rtcpsdesType RTCPSDESType // out

	_rtcpsdesType = RTCPSDESType(_cret)

	return _rtcpsdesType
}

// RtcpSdesTypeToName (gst_rtcp_sdes_type_to_name) converts type to the string
// equivalent. The string is typically used as a key in a Structure containing
// SDES items.
//
// The function takes the following parameters:
//
//   - typ: RTCPSDESType.
//
// The function returns the following values:
//
//   - utf8: string equivalent of type.
func RtcpSdesTypeToName(typ RTCPSDESType) string {
	var _arg1 C.GstRTCPSDESType // out
	var _cret *C.gchar          // in

	_arg1 = C.GstRTCPSDESType(typ)

	_cret = C.gst_rtcp_sdes_type_to_name(_arg1)
	runtime.KeepAlive(typ)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// RtcpUnixToNtp (gst_rtcp_unix_to_ntp) converts a UNIX timestamp in nanoseconds
// to an NTP time. The caller should pass a value with nanoseconds since 1970.
// The NTP time will, in the upper 32 bits, contain the number of seconds since
// 1900 and, in the lower 32 bits, the fractional seconds. The resulting value
// can be used as an ntptime for constructing SR RTCP packets.
//
// The function takes the following parameters:
//
//   - unixtime: UNIX timestamp in nanoseconds.
//
// The function returns the following values:
//
//   - guint64: NTP time for unixtime.
func RtcpUnixToNtp(unixtime uint64) uint64 {
	var _arg1 C.guint64 // out
	var _cret C.guint64 // in

	_arg1 = C.guint64(unixtime)

	_cret = C.gst_rtcp_unix_to_ntp(_arg1)
	runtime.KeepAlive(unixtime)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// RtpGetHeaderExtensionList (gst_rtp_get_header_extension_list): retrieve
// all the factories of the currently registered RTP header extensions.
// Call gst_element_factory_create() with each factory to create the associated
// RTPHeaderExtension.
//
// The function returns the following values:
//
//   - list of ElementFactory's. Use gst_plugin_feature_list_free() after use.
func RtpGetHeaderExtensionList() []*gst.ElementFactory {
	var _cret *C.GList // in

	_cret = C.gst_rtp_get_header_extension_list()

	var _list []*gst.ElementFactory // out

	_list = make([]*gst.ElementFactory, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstElementFactory)(v)
		var dst *gst.ElementFactory // out
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(src))
			dst = &gst.ElementFactory{
				PluginFeature: gst.PluginFeature{
					GstObject: gst.GstObject{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
					},
				},
			}
		}
		_list = append(_list, dst)
	})

	return _list
}

// RtpHdrextGetNtp56 (gst_rtp_hdrext_get_ntp_56) reads the NTP time from the
// size NTP-56 extension bytes in data and store the result in ntptime.
//
// The function takes the following parameters:
//
//   - data to read from.
//
// The function returns the following values:
//
//   - ntptime: result NTP time.
//   - ok: TRUE on success.
func RtpHdrextGetNtp56(data []byte) (uint64, bool) {
	var _arg1 C.gpointer // out
	var _arg2 C.guint
	var _arg3 C.guint64  // in
	var _cret C.gboolean // in

	_arg2 = (C.guint)(len(data))
	if len(data) > 0 {
		_arg1 = (C.gpointer)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_rtp_hdrext_get_ntp_56(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(data)

	var _ntptime uint64 // out
	var _ok bool        // out

	_ntptime = uint64(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _ntptime, _ok
}

// RtpHdrextGetNtp64 (gst_rtp_hdrext_get_ntp_64) reads the NTP time from the
// size NTP-64 extension bytes in data and store the result in ntptime.
//
// The function takes the following parameters:
//
//   - data to read from.
//
// The function returns the following values:
//
//   - ntptime: result NTP time.
//   - ok: TRUE on success.
func RtpHdrextGetNtp64(data []byte) (uint64, bool) {
	var _arg1 C.gpointer // out
	var _arg2 C.guint
	var _arg3 C.guint64  // in
	var _cret C.gboolean // in

	_arg2 = (C.guint)(len(data))
	if len(data) > 0 {
		_arg1 = (C.gpointer)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_rtp_hdrext_get_ntp_64(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(data)

	var _ntptime uint64 // out
	var _ok bool        // out

	_ntptime = uint64(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _ntptime, _ok
}

// RtpHdrextSetNtp56 (gst_rtp_hdrext_set_ntp_56) writes the NTP time in ntptime
// to the format required for the NTP-56 header extension. data must hold at
// least T_RTP_HDREXT_NTP_56_SIZE bytes.
//
// The function takes the following parameters:
//
//   - data (optional) to write to.
//   - size of data.
//   - ntptime: NTP time.
//
// The function returns the following values:
//
//   - ok: TRUE on success.
func RtpHdrextSetNtp56(data unsafe.Pointer, size uint, ntptime uint64) bool {
	var _arg1 C.gpointer // out
	var _arg2 C.guint    // out
	var _arg3 C.guint64  // out
	var _cret C.gboolean // in

	_arg1 = (C.gpointer)(unsafe.Pointer(data))
	_arg2 = C.guint(size)
	_arg3 = C.guint64(ntptime)

	_cret = C.gst_rtp_hdrext_set_ntp_56(_arg1, _arg2, _arg3)
	runtime.KeepAlive(data)
	runtime.KeepAlive(size)
	runtime.KeepAlive(ntptime)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RtpHdrextSetNtp64 (gst_rtp_hdrext_set_ntp_64) writes the NTP time in ntptime
// to the format required for the NTP-64 header extension. data must hold at
// least T_RTP_HDREXT_NTP_64_SIZE bytes.
//
// The function takes the following parameters:
//
//   - data (optional) to write to.
//   - size of data.
//   - ntptime: NTP time.
//
// The function returns the following values:
//
//   - ok: TRUE on success.
func RtpHdrextSetNtp64(data unsafe.Pointer, size uint, ntptime uint64) bool {
	var _arg1 C.gpointer // out
	var _arg2 C.guint    // out
	var _arg3 C.guint64  // out
	var _cret C.gboolean // in

	_arg1 = (C.gpointer)(unsafe.Pointer(data))
	_arg2 = C.guint(size)
	_arg3 = C.guint64(ntptime)

	_cret = C.gst_rtp_hdrext_set_ntp_64(_arg1, _arg2, _arg3)
	runtime.KeepAlive(data)
	runtime.KeepAlive(size)
	runtime.KeepAlive(ntptime)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func RtpSourceMetaApiGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.gst_rtp_source_meta_api_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// RTPBaseAudioPayloadOverrides contains methods that are overridable.
type RTPBaseAudioPayloadOverrides struct {
}

func defaultRTPBaseAudioPayloadOverrides(v *RTPBaseAudioPayload) RTPBaseAudioPayloadOverrides {
	return RTPBaseAudioPayloadOverrides{}
}

// RTPBaseAudioPayload (GstRTPBaseAudioPayload) provides a base class for audio
// RTP payloaders for frame or sample based audio codecs (constant bitrate)
//
// This class derives from GstRTPBasePayload. It can be used for payloading
// audio codecs. It will only work with constant bitrate codecs. It supports
// both frame based and sample based codecs. It takes care of packing up
// the audio data into RTP packets and filling up the headers accordingly.
// The payloading is done based on the maximum MTU (mtu) and the maximum time
// per packet (max-ptime). The general idea is to divide large data buffers into
// smaller RTP packets. The RTP packet size is the minimum of either the MTU,
// max-ptime (if set) or available data. The RTP packet size is always larger
// or equal to min-ptime (if set). If min-ptime is not set, any residual data is
// sent in a last RTP packet. In the case of frame based codecs, the resulting
// RTP packets always contain full frames.
//
// # Usage
//
// To use this base class, your child element needs to call
// either gst_rtp_base_audio_payload_set_frame_based() or
// gst_rtp_base_audio_payload_set_sample_based(). This is usually
// done in the element's _init() function. Then, the child element
// must call either gst_rtp_base_audio_payload_set_frame_options(),
// gst_rtp_base_audio_payload_set_sample_options() or
// gst_rtp_base_audio_payload_set_samplebits_options. Since
// GstRTPBaseAudioPayload derives from GstRTPBasePayload, the child element must
// set any variables or call/override any functions required by that base class.
// The child element does not need to override any other functions specific to
// GstRTPBaseAudioPayload.
type RTPBaseAudioPayload struct {
	_ [0]func() // equal guard
	RTPBasePayload
}

var (
	_ RTPBasePayloader = (*RTPBaseAudioPayload)(nil)
)

// RTPBaseAudioPayloader describes types inherited from RTPBaseAudioPayload.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type RTPBaseAudioPayloader interface {
	RTPBasePayloader

	// Flush (gst_rtp_base_audio_payload_flush): create an RTP buffer and store
	// payload_len bytes of the adapter as the payload.
	Flush(payloadLen uint, timestamp gst.ClockTime) gst.FlowReturn
	// Adapter (gst_rtp_base_audio_payload_get_adapter) gets the internal
	// adapter used by the depayloader.
	Adapter() *gstbase.Adapter
	// Push (gst_rtp_base_audio_payload_push): create an RTP buffer and store
	// payload_len bytes of data as the payload.
	Push(data []byte, timestamp gst.ClockTime) gst.FlowReturn
	// SetFrameBased (gst_rtp_base_audio_payload_set_frame_based) tells
	// RTPBaseAudioPayload that the child element is for a frame based audio
	// codec.
	SetFrameBased()
	// SetFrameOptions (gst_rtp_base_audio_payload_set_frame_options) sets the
	// options for frame based audio codecs.
	SetFrameOptions(frameDuration, frameSize int)
	// SetSampleBased (gst_rtp_base_audio_payload_set_sample_based) tells
	// RTPBaseAudioPayload that the child element is for a sample based audio
	// codec.
	SetSampleBased()
	// SetSampleOptions (gst_rtp_base_audio_payload_set_sample_options) sets the
	// options for sample based audio codecs.
	SetSampleOptions(sampleSize int)
	// SetSamplebitsOptions (gst_rtp_base_audio_payload_set_samplebits_options)
	// sets the options for sample based audio codecs.
	SetSamplebitsOptions(sampleSize int)

	baseRTPBaseAudioPayload() *RTPBaseAudioPayload
}

var _ RTPBaseAudioPayloader = (*RTPBaseAudioPayload)(nil)

func init() {
	coreglib.RegisterClassInfo[*RTPBaseAudioPayload, *RTPBaseAudioPayloadClass, RTPBaseAudioPayloadOverrides](
		GTypeRTPBaseAudioPayload,
		initRTPBaseAudioPayloadClass,
		wrapRTPBaseAudioPayload,
		defaultRTPBaseAudioPayloadOverrides,
	)
}

func initRTPBaseAudioPayloadClass(gclass unsafe.Pointer, overrides RTPBaseAudioPayloadOverrides, classInitFunc func(*RTPBaseAudioPayloadClass)) {
	if classInitFunc != nil {
		class := (*RTPBaseAudioPayloadClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapRTPBaseAudioPayload(obj *coreglib.Object) *RTPBaseAudioPayload {
	return &RTPBaseAudioPayload{
		RTPBasePayload: RTPBasePayload{
			Element: gst.Element{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalRTPBaseAudioPayload(p uintptr) (interface{}, error) {
	return wrapRTPBaseAudioPayload(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (baseaudiopayload *RTPBaseAudioPayload) baseRTPBaseAudioPayload() *RTPBaseAudioPayload {
	return baseaudiopayload
}

// BaseRTPBaseAudioPayload returns the underlying base object.
func BaseRTPBaseAudioPayload(obj RTPBaseAudioPayloader) *RTPBaseAudioPayload {
	return obj.baseRTPBaseAudioPayload()
}

// Flush (gst_rtp_base_audio_payload_flush): create an RTP buffer and store
// payload_len bytes of the adapter as the payload. Set the timestamp on the new
// buffer to timestamp before pushing the buffer downstream.
//
// If payload_len is -1, all pending bytes will be flushed. If timestamp is -1,
// the timestamp will be calculated automatically.
//
// The function takes the following parameters:
//
//   - payloadLen: length of payload.
//   - timestamp: ClockTime.
//
// The function returns the following values:
//
//   - flowReturn: FlowReturn.
func (baseaudiopayload *RTPBaseAudioPayload) Flush(payloadLen uint, timestamp gst.ClockTime) gst.FlowReturn {
	var _arg0 *C.GstRTPBaseAudioPayload // out
	var _arg1 C.guint                   // out
	var _arg2 C.GstClockTime            // out
	var _cret C.GstFlowReturn           // in

	_arg0 = (*C.GstRTPBaseAudioPayload)(unsafe.Pointer(coreglib.BaseObject(baseaudiopayload).Native()))
	_arg1 = C.guint(payloadLen)
	_arg2 = C.GstClockTime(timestamp)

	_cret = C.gst_rtp_base_audio_payload_flush(_arg0, _arg1, _arg2)
	runtime.KeepAlive(baseaudiopayload)
	runtime.KeepAlive(payloadLen)
	runtime.KeepAlive(timestamp)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// Adapter (gst_rtp_base_audio_payload_get_adapter) gets the internal adapter
// used by the depayloader.
//
// The function returns the following values:
//
//   - adapter: Adapter.
func (rtpbaseaudiopayload *RTPBaseAudioPayload) Adapter() *gstbase.Adapter {
	var _arg0 *C.GstRTPBaseAudioPayload // out
	var _cret *C.GstAdapter             // in

	_arg0 = (*C.GstRTPBaseAudioPayload)(unsafe.Pointer(coreglib.BaseObject(rtpbaseaudiopayload).Native()))

	_cret = C.gst_rtp_base_audio_payload_get_adapter(_arg0)
	runtime.KeepAlive(rtpbaseaudiopayload)

	var _adapter *gstbase.Adapter // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_adapter = &gstbase.Adapter{
			Object: obj,
		}
	}

	return _adapter
}

// Push (gst_rtp_base_audio_payload_push): create an RTP buffer and store
// payload_len bytes of data as the payload. Set the timestamp on the new buffer
// to timestamp before pushing the buffer downstream.
//
// The function takes the following parameters:
//
//   - data to set as payload.
//   - timestamp: ClockTime.
//
// The function returns the following values:
//
//   - flowReturn: FlowReturn.
func (baseaudiopayload *RTPBaseAudioPayload) Push(data []byte, timestamp gst.ClockTime) gst.FlowReturn {
	var _arg0 *C.GstRTPBaseAudioPayload // out
	var _arg1 *C.guint8                 // out
	var _arg2 C.guint
	var _arg3 C.GstClockTime  // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstRTPBaseAudioPayload)(unsafe.Pointer(coreglib.BaseObject(baseaudiopayload).Native()))
	_arg2 = (C.guint)(len(data))
	if len(data) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}
	_arg3 = C.GstClockTime(timestamp)

	_cret = C.gst_rtp_base_audio_payload_push(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(baseaudiopayload)
	runtime.KeepAlive(data)
	runtime.KeepAlive(timestamp)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// SetFrameBased (gst_rtp_base_audio_payload_set_frame_based) tells
// RTPBaseAudioPayload that the child element is for a frame based audio codec.
func (rtpbaseaudiopayload *RTPBaseAudioPayload) SetFrameBased() {
	var _arg0 *C.GstRTPBaseAudioPayload // out

	_arg0 = (*C.GstRTPBaseAudioPayload)(unsafe.Pointer(coreglib.BaseObject(rtpbaseaudiopayload).Native()))

	C.gst_rtp_base_audio_payload_set_frame_based(_arg0)
	runtime.KeepAlive(rtpbaseaudiopayload)
}

// SetFrameOptions (gst_rtp_base_audio_payload_set_frame_options) sets the
// options for frame based audio codecs.
//
// The function takes the following parameters:
//
//   - frameDuration: duraction of an audio frame in milliseconds.
//   - frameSize: size of an audio frame in bytes.
func (rtpbaseaudiopayload *RTPBaseAudioPayload) SetFrameOptions(frameDuration, frameSize int) {
	var _arg0 *C.GstRTPBaseAudioPayload // out
	var _arg1 C.gint                    // out
	var _arg2 C.gint                    // out

	_arg0 = (*C.GstRTPBaseAudioPayload)(unsafe.Pointer(coreglib.BaseObject(rtpbaseaudiopayload).Native()))
	_arg1 = C.gint(frameDuration)
	_arg2 = C.gint(frameSize)

	C.gst_rtp_base_audio_payload_set_frame_options(_arg0, _arg1, _arg2)
	runtime.KeepAlive(rtpbaseaudiopayload)
	runtime.KeepAlive(frameDuration)
	runtime.KeepAlive(frameSize)
}

// SetSampleBased (gst_rtp_base_audio_payload_set_sample_based) tells
// RTPBaseAudioPayload that the child element is for a sample based audio codec.
func (rtpbaseaudiopayload *RTPBaseAudioPayload) SetSampleBased() {
	var _arg0 *C.GstRTPBaseAudioPayload // out

	_arg0 = (*C.GstRTPBaseAudioPayload)(unsafe.Pointer(coreglib.BaseObject(rtpbaseaudiopayload).Native()))

	C.gst_rtp_base_audio_payload_set_sample_based(_arg0)
	runtime.KeepAlive(rtpbaseaudiopayload)
}

// SetSampleOptions (gst_rtp_base_audio_payload_set_sample_options) sets the
// options for sample based audio codecs.
//
// The function takes the following parameters:
//
//   - sampleSize: size per sample in bytes.
func (rtpbaseaudiopayload *RTPBaseAudioPayload) SetSampleOptions(sampleSize int) {
	var _arg0 *C.GstRTPBaseAudioPayload // out
	var _arg1 C.gint                    // out

	_arg0 = (*C.GstRTPBaseAudioPayload)(unsafe.Pointer(coreglib.BaseObject(rtpbaseaudiopayload).Native()))
	_arg1 = C.gint(sampleSize)

	C.gst_rtp_base_audio_payload_set_sample_options(_arg0, _arg1)
	runtime.KeepAlive(rtpbaseaudiopayload)
	runtime.KeepAlive(sampleSize)
}

// SetSamplebitsOptions (gst_rtp_base_audio_payload_set_samplebits_options) sets
// the options for sample based audio codecs.
//
// The function takes the following parameters:
//
//   - sampleSize: size per sample in bits.
func (rtpbaseaudiopayload *RTPBaseAudioPayload) SetSamplebitsOptions(sampleSize int) {
	var _arg0 *C.GstRTPBaseAudioPayload // out
	var _arg1 C.gint                    // out

	_arg0 = (*C.GstRTPBaseAudioPayload)(unsafe.Pointer(coreglib.BaseObject(rtpbaseaudiopayload).Native()))
	_arg1 = C.gint(sampleSize)

	C.gst_rtp_base_audio_payload_set_samplebits_options(_arg0, _arg1)
	runtime.KeepAlive(rtpbaseaudiopayload)
	runtime.KeepAlive(sampleSize)
}

// RTPBaseDepayloadOverrides contains methods that are overridable.
type RTPBaseDepayloadOverrides struct {
	// HandleEvent: custom event handling.
	HandleEvent func(event *gst.Event) bool
	// PacketLost: signal the depayloader about packet loss.
	PacketLost func(event *gst.Event) bool
	// Process process incoming rtp packets. Subclass must implement either
	// this method or process_rtp_packet to process incoming rtp packets.
	// If the child returns a buffer without a valid timestamp, the timestamp of
	// the provided buffer will be applied to the result buffer and the buffer
	// will be pushed. If this function returns NULL, nothing is pushed.
	Process func(in *gst.Buffer) *gst.Buffer
	// ProcessRtpPacket: same as the process virtual function, but slightly more
	// efficient, since it is passed the rtp buffer structure that has already
	// been mapped (with GST_MAP_READ) by the base class and thus does not
	// have to be mapped again by the subclass. Can be used by the subclass to
	// process incoming rtp packets. If the subclass returns a buffer without a
	// valid timestamp, the timestamp of the input buffer will be applied to the
	// result buffer and the output buffer will be pushed out. If this function
	// returns NULL, nothing is pushed out. Since: 1.6.
	ProcessRtpPacket func(rtpBuffer *RTPBuffer) *gst.Buffer
	// SetCaps: configure the depayloader.
	SetCaps func(caps *gst.Caps) bool
}

func defaultRTPBaseDepayloadOverrides(v *RTPBaseDepayload) RTPBaseDepayloadOverrides {
	return RTPBaseDepayloadOverrides{
		HandleEvent:      v.handleEvent,
		PacketLost:       v.packetLost,
		Process:          v.process,
		ProcessRtpPacket: v.processRtpPacket,
		SetCaps:          v.setCaps,
	}
}

// RTPBaseDepayload (GstRTPBaseDepayload) provides a base class for RTP
// depayloaders
//
// In order to handle RTP header extensions correctly if the depayloader
// aggregates multiple RTP packet payloads into one output buffer this class
// provides the function gst_rtp_base_depayload_set_aggregate_hdrext_enabled().
// If the aggregation is enabled the virtual functions
// GstRTPBaseDepayload.process or GstRTPBaseDepayload.process_rtp_packet must
// tell the base class what happens to the current RTP packet. By default the
// base class assumes that the packet payload is used with the next output
// buffer.
//
// If the RTP packet will not be used with an output buffer
// gst_rtp_base_depayload_dropped() must be called. A typical situation would be
// if we are waiting for a keyframe.
//
// If the RTP packet will be used but not with the current output buffer
// but with the next one gst_rtp_base_depayload_delayed() must be called.
// This may happen if the current RTP packet signals the start of a new output
// buffer and the currently processed output buffer will be pushed first.
// The undelay happens implicitly once the current buffer has been pushed or
// gst_rtp_base_depayload_flush() has been called.
//
// If gst_rtp_base_depayload_flush() is called all RTP packets that have not
// been dropped since the last output buffer are dropped, e.g. if an output
// buffer is discarded due to malformed data. This may or may not include the
// current RTP packet depending on the 2nd parameter keep_current.
//
// Be aware that in case gst_rtp_base_depayload_push_list() is used each buffer
// will see the same list of RTP header extensions.
type RTPBaseDepayload struct {
	_ [0]func() // equal guard
	gst.Element
}

var (
	_ gst.Elementer = (*RTPBaseDepayload)(nil)
)

// RTPBaseDepayloader describes types inherited from RTPBaseDepayload.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type RTPBaseDepayloader interface {
	gst.Elementer

	// Delayed (gst_rtp_base_depayload_delayed): called from
	// GstRTPBaseDepayload.process or GstRTPBaseDepayload.process_rtp_packet
	// when the depayloader needs to keep the current input RTP header for use
	// with the next output buffer.
	Delayed()
	// Dropped (gst_rtp_base_depayload_dropped): called from
	// GstRTPBaseDepayload.process or GstRTPBaseDepayload.process_rtp_packet if
	// the depayloader does not use the current buffer for the output buffer.
	Dropped()
	// Flush (gst_rtp_base_depayload_flush): if GstRTPBaseDepayload.process
	// or GstRTPBaseDepayload.process_rtp_packet drop an output buffer this
	// function tells the base class to flush header extension cache as well.
	Flush(keepCurrent bool)
	// IsAggregateHdrextEnabled
	// (gst_rtp_base_depayload_is_aggregate_hdrext_enabled) queries whether
	// header extensions will be aggregated per depayloaded buffers.
	IsAggregateHdrextEnabled() bool
	// IsSourceInfoEnabled (gst_rtp_base_depayload_is_source_info_enabled)
	// queries whether RTPSourceMeta will be added to depayloaded buffers.
	IsSourceInfoEnabled() bool
	// Push (gst_rtp_base_depayload_push) out_buf to the peer of filter.
	Push(outBuf *gst.Buffer) gst.FlowReturn
	// PushList (gst_rtp_base_depayload_push_list): push out_list to the peer of
	// filter.
	PushList(outList *gst.BufferList) gst.FlowReturn
	// SetAggregateHdrextEnabled
	// (gst_rtp_base_depayload_set_aggregate_hdrext_enabled): enable or disable
	// aggregating header extensions.
	SetAggregateHdrextEnabled(enable bool)
	// SetSourceInfoEnabled (gst_rtp_base_depayload_set_source_info_enabled):
	// enable or disable adding RTPSourceMeta to depayloaded buffers.
	SetSourceInfoEnabled(enable bool)

	// Request-extension: returned ext must be configured with the correct
	// ext_id and with the necessary attributes as required by the extension
	// implementation.
	ConnectRequestExtension(func(extId uint, extUri string) (rtpHeaderExtension RTPHeaderExtensioner)) coreglib.SignalHandle

	baseRTPBaseDepayload() *RTPBaseDepayload
}

var _ RTPBaseDepayloader = (*RTPBaseDepayload)(nil)

func init() {
	coreglib.RegisterClassInfo[*RTPBaseDepayload, *RTPBaseDepayloadClass, RTPBaseDepayloadOverrides](
		GTypeRTPBaseDepayload,
		initRTPBaseDepayloadClass,
		wrapRTPBaseDepayload,
		defaultRTPBaseDepayloadOverrides,
	)
}

func initRTPBaseDepayloadClass(gclass unsafe.Pointer, overrides RTPBaseDepayloadOverrides, classInitFunc func(*RTPBaseDepayloadClass)) {
	pclass := (*C.GstRTPBaseDepayloadClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeRTPBaseDepayload))))

	if overrides.HandleEvent != nil {
		pclass.handle_event = (*[0]byte)(C._gotk4_gstrtp1_RTPBaseDepayloadClass_handle_event)
	}

	if overrides.PacketLost != nil {
		pclass.packet_lost = (*[0]byte)(C._gotk4_gstrtp1_RTPBaseDepayloadClass_packet_lost)
	}

	if overrides.Process != nil {
		pclass.process = (*[0]byte)(C._gotk4_gstrtp1_RTPBaseDepayloadClass_process)
	}

	if overrides.ProcessRtpPacket != nil {
		pclass.process_rtp_packet = (*[0]byte)(C._gotk4_gstrtp1_RTPBaseDepayloadClass_process_rtp_packet)
	}

	if overrides.SetCaps != nil {
		pclass.set_caps = (*[0]byte)(C._gotk4_gstrtp1_RTPBaseDepayloadClass_set_caps)
	}

	if classInitFunc != nil {
		class := (*RTPBaseDepayloadClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapRTPBaseDepayload(obj *coreglib.Object) *RTPBaseDepayload {
	return &RTPBaseDepayload{
		Element: gst.Element{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalRTPBaseDepayload(p uintptr) (interface{}, error) {
	return wrapRTPBaseDepayload(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (depayload *RTPBaseDepayload) baseRTPBaseDepayload() *RTPBaseDepayload {
	return depayload
}

// BaseRTPBaseDepayload returns the underlying base object.
func BaseRTPBaseDepayload(obj RTPBaseDepayloader) *RTPBaseDepayload {
	return obj.baseRTPBaseDepayload()
}

// ConnectRequestExtension: returned ext must be configured with the correct
// ext_id and with the necessary attributes as required by the extension
// implementation.
func (depayload *RTPBaseDepayload) ConnectRequestExtension(f func(extId uint, extUri string) (rtpHeaderExtension RTPHeaderExtensioner)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(depayload, "request-extension", false, unsafe.Pointer(C._gotk4_gstrtp1_RTPBaseDepayload_ConnectRequestExtension), f)
}

// Delayed (gst_rtp_base_depayload_delayed): called from
// GstRTPBaseDepayload.process or GstRTPBaseDepayload.process_rtp_packet when
// the depayloader needs to keep the current input RTP header for use with the
// next output buffer.
//
// The delayed buffer will remain until the end of processing the current output
// buffer and then enqueued for processing with the next output buffer.
//
// A typical use-case is when the depayloader implementation will start a new
// output buffer for the current input RTP buffer but push the current output
// buffer first.
//
// Must be called with the stream lock held.
func (depayload *RTPBaseDepayload) Delayed() {
	var _arg0 *C.GstRTPBaseDepayload // out

	_arg0 = (*C.GstRTPBaseDepayload)(unsafe.Pointer(coreglib.BaseObject(depayload).Native()))

	C.gst_rtp_base_depayload_delayed(_arg0)
	runtime.KeepAlive(depayload)
}

// Dropped (gst_rtp_base_depayload_dropped): called from
// GstRTPBaseDepayload.process or GstRTPBaseDepayload.process_rtp_packet if the
// depayloader does not use the current buffer for the output buffer. This will
// either drop the delayed buffer or the last buffer from the header extension
// cache.
//
// A typical use-case is when the depayloader implementation is dropping an
// input RTP buffer while waiting for the first keyframe.
//
// Must be called with the stream lock held.
func (depayload *RTPBaseDepayload) Dropped() {
	var _arg0 *C.GstRTPBaseDepayload // out

	_arg0 = (*C.GstRTPBaseDepayload)(unsafe.Pointer(coreglib.BaseObject(depayload).Native()))

	C.gst_rtp_base_depayload_dropped(_arg0)
	runtime.KeepAlive(depayload)
}

// Flush (gst_rtp_base_depayload_flush): if GstRTPBaseDepayload.process or
// GstRTPBaseDepayload.process_rtp_packet drop an output buffer this function
// tells the base class to flush header extension cache as well.
//
// This will not drop an input RTP header marked as delayed from
// gst_rtp_base_depayload_delayed().
//
// If keep_current is TRUE the current input RTP header will be kept and
// enqueued after flushing the previous input RTP headers.
//
// A typical use-case for keep_current is when the depayloader implementation
// invalidates the current output buffer and starts a new one with the current
// RTP input buffer.
//
// Must be called with the stream lock held.
//
// The function takes the following parameters:
//
//   - keepCurrent: if the current RTP buffer shall be kept.
func (depayload *RTPBaseDepayload) Flush(keepCurrent bool) {
	var _arg0 *C.GstRTPBaseDepayload // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GstRTPBaseDepayload)(unsafe.Pointer(coreglib.BaseObject(depayload).Native()))
	if keepCurrent {
		_arg1 = C.TRUE
	}

	C.gst_rtp_base_depayload_flush(_arg0, _arg1)
	runtime.KeepAlive(depayload)
	runtime.KeepAlive(keepCurrent)
}

// IsAggregateHdrextEnabled (gst_rtp_base_depayload_is_aggregate_hdrext_enabled)
// queries whether header extensions will be aggregated per depayloaded buffers.
//
// The function returns the following values:
//
//   - ok: TRUE if aggregate-header-extension is enabled.
func (depayload *RTPBaseDepayload) IsAggregateHdrextEnabled() bool {
	var _arg0 *C.GstRTPBaseDepayload // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GstRTPBaseDepayload)(unsafe.Pointer(coreglib.BaseObject(depayload).Native()))

	_cret = C.gst_rtp_base_depayload_is_aggregate_hdrext_enabled(_arg0)
	runtime.KeepAlive(depayload)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSourceInfoEnabled (gst_rtp_base_depayload_is_source_info_enabled) queries
// whether RTPSourceMeta will be added to depayloaded buffers.
//
// The function returns the following values:
//
//   - ok: TRUE if source-info is enabled.
func (depayload *RTPBaseDepayload) IsSourceInfoEnabled() bool {
	var _arg0 *C.GstRTPBaseDepayload // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GstRTPBaseDepayload)(unsafe.Pointer(coreglib.BaseObject(depayload).Native()))

	_cret = C.gst_rtp_base_depayload_is_source_info_enabled(_arg0)
	runtime.KeepAlive(depayload)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Push (gst_rtp_base_depayload_push) out_buf to the peer of filter. This
// function takes ownership of out_buf.
//
// This function will by default apply the last incoming timestamp on the
// outgoing buffer when it didn't have a timestamp already.
//
// The function takes the following parameters:
//
//   - outBuf: Buffer.
//
// The function returns the following values:
//
//   - flowReturn: FlowReturn.
func (filter *RTPBaseDepayload) Push(outBuf *gst.Buffer) gst.FlowReturn {
	var _arg0 *C.GstRTPBaseDepayload // out
	var _arg1 *C.GstBuffer           // out
	var _cret C.GstFlowReturn        // in

	_arg0 = (*C.GstRTPBaseDepayload)(unsafe.Pointer(coreglib.BaseObject(filter).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(outBuf)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(outBuf)), nil)

	_cret = C.gst_rtp_base_depayload_push(_arg0, _arg1)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(outBuf)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// PushList (gst_rtp_base_depayload_push_list): push out_list to the peer of
// filter. This function takes ownership of out_list.
//
// The function takes the following parameters:
//
//   - outList: BufferList.
//
// The function returns the following values:
//
//   - flowReturn: FlowReturn.
func (filter *RTPBaseDepayload) PushList(outList *gst.BufferList) gst.FlowReturn {
	var _arg0 *C.GstRTPBaseDepayload // out
	var _arg1 *C.GstBufferList       // out
	var _cret C.GstFlowReturn        // in

	_arg0 = (*C.GstRTPBaseDepayload)(unsafe.Pointer(coreglib.BaseObject(filter).Native()))
	_arg1 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(outList)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(outList)), nil)

	_cret = C.gst_rtp_base_depayload_push_list(_arg0, _arg1)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(outList)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// SetAggregateHdrextEnabled
// (gst_rtp_base_depayload_set_aggregate_hdrext_enabled): enable or disable
// aggregating header extensions.
//
// The function takes the following parameters:
//
//   - enable: whether to aggregate header extensions per output buffer.
func (depayload *RTPBaseDepayload) SetAggregateHdrextEnabled(enable bool) {
	var _arg0 *C.GstRTPBaseDepayload // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GstRTPBaseDepayload)(unsafe.Pointer(coreglib.BaseObject(depayload).Native()))
	if enable {
		_arg1 = C.TRUE
	}

	C.gst_rtp_base_depayload_set_aggregate_hdrext_enabled(_arg0, _arg1)
	runtime.KeepAlive(depayload)
	runtime.KeepAlive(enable)
}

// SetSourceInfoEnabled (gst_rtp_base_depayload_set_source_info_enabled):
// enable or disable adding RTPSourceMeta to depayloaded buffers.
//
// The function takes the following parameters:
//
//   - enable: whether to add meta about RTP sources to buffer.
func (depayload *RTPBaseDepayload) SetSourceInfoEnabled(enable bool) {
	var _arg0 *C.GstRTPBaseDepayload // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GstRTPBaseDepayload)(unsafe.Pointer(coreglib.BaseObject(depayload).Native()))
	if enable {
		_arg1 = C.TRUE
	}

	C.gst_rtp_base_depayload_set_source_info_enabled(_arg0, _arg1)
	runtime.KeepAlive(depayload)
	runtime.KeepAlive(enable)
}

// handleEvent: custom event handling.
func (filter *RTPBaseDepayload) handleEvent(event *gst.Event) bool {
	gclass := (*C.GstRTPBaseDepayloadClass)(coreglib.PeekParentClass(filter))
	fnarg := gclass.handle_event

	var _arg0 *C.GstRTPBaseDepayload // out
	var _arg1 *C.GstEvent            // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GstRTPBaseDepayload)(unsafe.Pointer(coreglib.BaseObject(filter).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gstrtp1_RTPBaseDepayload_virtual_handle_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// packetLost: signal the depayloader about packet loss.
func (filter *RTPBaseDepayload) packetLost(event *gst.Event) bool {
	gclass := (*C.GstRTPBaseDepayloadClass)(coreglib.PeekParentClass(filter))
	fnarg := gclass.packet_lost

	var _arg0 *C.GstRTPBaseDepayload // out
	var _arg1 *C.GstEvent            // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GstRTPBaseDepayload)(unsafe.Pointer(coreglib.BaseObject(filter).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gstrtp1_RTPBaseDepayload_virtual_packet_lost(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Process incoming rtp packets. Subclass must implement either this method or
// process_rtp_packet to process incoming rtp packets. If the child returns
// a buffer without a valid timestamp, the timestamp of the provided buffer
// will be applied to the result buffer and the buffer will be pushed. If this
// function returns NULL, nothing is pushed.
func (base *RTPBaseDepayload) process(in *gst.Buffer) *gst.Buffer {
	gclass := (*C.GstRTPBaseDepayloadClass)(coreglib.PeekParentClass(base))
	fnarg := gclass.process

	var _arg0 *C.GstRTPBaseDepayload // out
	var _arg1 *C.GstBuffer           // out
	var _cret *C.GstBuffer           // in

	_arg0 = (*C.GstRTPBaseDepayload)(unsafe.Pointer(coreglib.BaseObject(base).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(in)))

	_cret = C._gotk4_gstrtp1_RTPBaseDepayload_virtual_process(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(base)
	runtime.KeepAlive(in)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _buffer
}

// processRtpPacket: same as the process virtual function, but slightly more
// efficient, since it is passed the rtp buffer structure that has already been
// mapped (with GST_MAP_READ) by the base class and thus does not have to be
// mapped again by the subclass. Can be used by the subclass to process incoming
// rtp packets. If the subclass returns a buffer without a valid timestamp,
// the timestamp of the input buffer will be applied to the result buffer and
// the output buffer will be pushed out. If this function returns NULL, nothing
// is pushed out. Since: 1.6.
func (base *RTPBaseDepayload) processRtpPacket(rtpBuffer *RTPBuffer) *gst.Buffer {
	gclass := (*C.GstRTPBaseDepayloadClass)(coreglib.PeekParentClass(base))
	fnarg := gclass.process_rtp_packet

	var _arg0 *C.GstRTPBaseDepayload // out
	var _arg1 *C.GstRTPBuffer        // out
	var _cret *C.GstBuffer           // in

	_arg0 = (*C.GstRTPBaseDepayload)(unsafe.Pointer(coreglib.BaseObject(base).Native()))
	_arg1 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtpBuffer)))

	_cret = C._gotk4_gstrtp1_RTPBaseDepayload_virtual_process_rtp_packet(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(base)
	runtime.KeepAlive(rtpBuffer)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _buffer
}

// setCaps: configure the depayloader.
func (filter *RTPBaseDepayload) setCaps(caps *gst.Caps) bool {
	gclass := (*C.GstRTPBaseDepayloadClass)(coreglib.PeekParentClass(filter))
	fnarg := gclass.set_caps

	var _arg0 *C.GstRTPBaseDepayload // out
	var _arg1 *C.GstCaps             // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GstRTPBaseDepayload)(unsafe.Pointer(coreglib.BaseObject(filter).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C._gotk4_gstrtp1_RTPBaseDepayload_virtual_set_caps(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RTPBasePayloadOverrides contains methods that are overridable.
type RTPBasePayloadOverrides struct {
	// Caps: get desired caps.
	//
	// The function takes the following parameters:
	//
	//   - pad
	//   - filter
	Caps func(pad *gst.Pad, filter *gst.Caps) *gst.Caps
	// HandleBuffer process data.
	HandleBuffer func(buffer *gst.Buffer) gst.FlowReturn
	// Query: custom query handling.
	//
	// The function takes the following parameters:
	//
	//   - pad
	//   - query
	Query func(pad *gst.Pad, query *gst.Query) bool
	// SetCaps: configure the payloader.
	SetCaps func(caps *gst.Caps) bool
	// SinkEvent: custom event handling on the sinkpad.
	SinkEvent func(event *gst.Event) bool
	// SrcEvent: custom event handling on the srcpad.
	SrcEvent func(event *gst.Event) bool
}

func defaultRTPBasePayloadOverrides(v *RTPBasePayload) RTPBasePayloadOverrides {
	return RTPBasePayloadOverrides{
		Caps:         v.caps,
		HandleBuffer: v.handleBuffer,
		Query:        v.query,
		SetCaps:      v.setCaps,
		SinkEvent:    v.sinkEvent,
		SrcEvent:     v.srcEvent,
	}
}

// RTPBasePayload (GstRTPBasePayload) provides a base class for RTP payloaders.
type RTPBasePayload struct {
	_ [0]func() // equal guard
	gst.Element
}

var (
	_ gst.Elementer = (*RTPBasePayload)(nil)
)

// RTPBasePayloader describes types inherited from RTPBasePayload.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type RTPBasePayloader interface {
	gst.Elementer

	// AllocateOutputBuffer (gst_rtp_base_payload_allocate_output_buffer):
	// allocate a new Buffer with enough data to hold an RTP packet with minimum
	// csrc_count CSRCs, a payload length of payload_len and padding of pad_len.
	AllocateOutputBuffer(payloadLen uint, padLen, csrcCount byte) *gst.Buffer
	// SourceCount (gst_rtp_base_payload_get_source_count): count the total
	// number of RTP sources found in the meta of buffer, which will be
	// automically added by gst_rtp_base_payload_allocate_output_buffer().
	SourceCount(buffer *gst.Buffer) uint
	// IsFilled (gst_rtp_base_payload_is_filled): check if the packet with size
	// and duration would exceed the configured maximum size.
	IsFilled(size uint, duration gst.ClockTime) bool
	// IsSourceInfoEnabled (gst_rtp_base_payload_is_source_info_enabled) queries
	// whether the payloader will add contributing sources (CSRCs) to the RTP
	// header from RTPSourceMeta.
	IsSourceInfoEnabled() bool
	// PushBuffer (gst_rtp_base_payload_push): push buffer to the peer element
	// of the payloader.
	PushBuffer(buffer *gst.Buffer) gst.FlowReturn
	// PushList (gst_rtp_base_payload_push_list): push list to the peer element
	// of the payloader.
	PushList(list *gst.BufferList) gst.FlowReturn
	// SetOptions (gst_rtp_base_payload_set_options): set the rtp options of the
	// payloader.
	SetOptions(media string, dynamic bool, encodingName string, clockRate uint32)
	// SetOutcapsStructure (gst_rtp_base_payload_set_outcaps_structure):
	// configure the output caps with the optional fields.
	SetOutcapsStructure(s *gst.Structure) bool
	// SetSourceInfoEnabled (gst_rtp_base_payload_set_source_info_enabled):
	// enable or disable adding contributing sources to RTP packets from
	// RTPSourceMeta.
	SetSourceInfoEnabled(enable bool)

	// Request-extension: returned ext must be configured with the correct
	// ext_id and with the necessary attributes as required by the extension
	// implementation.
	ConnectRequestExtension(func(extId uint, extUri string) (rtpHeaderExtension RTPHeaderExtensioner)) coreglib.SignalHandle

	baseRTPBasePayload() *RTPBasePayload
}

var _ RTPBasePayloader = (*RTPBasePayload)(nil)

func init() {
	coreglib.RegisterClassInfo[*RTPBasePayload, *RTPBasePayloadClass, RTPBasePayloadOverrides](
		GTypeRTPBasePayload,
		initRTPBasePayloadClass,
		wrapRTPBasePayload,
		defaultRTPBasePayloadOverrides,
	)
}

func initRTPBasePayloadClass(gclass unsafe.Pointer, overrides RTPBasePayloadOverrides, classInitFunc func(*RTPBasePayloadClass)) {
	pclass := (*C.GstRTPBasePayloadClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeRTPBasePayload))))

	if overrides.Caps != nil {
		pclass.get_caps = (*[0]byte)(C._gotk4_gstrtp1_RTPBasePayloadClass_get_caps)
	}

	if overrides.HandleBuffer != nil {
		pclass.handle_buffer = (*[0]byte)(C._gotk4_gstrtp1_RTPBasePayloadClass_handle_buffer)
	}

	if overrides.Query != nil {
		pclass.query = (*[0]byte)(C._gotk4_gstrtp1_RTPBasePayloadClass_query)
	}

	if overrides.SetCaps != nil {
		pclass.set_caps = (*[0]byte)(C._gotk4_gstrtp1_RTPBasePayloadClass_set_caps)
	}

	if overrides.SinkEvent != nil {
		pclass.sink_event = (*[0]byte)(C._gotk4_gstrtp1_RTPBasePayloadClass_sink_event)
	}

	if overrides.SrcEvent != nil {
		pclass.src_event = (*[0]byte)(C._gotk4_gstrtp1_RTPBasePayloadClass_src_event)
	}

	if classInitFunc != nil {
		class := (*RTPBasePayloadClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapRTPBasePayload(obj *coreglib.Object) *RTPBasePayload {
	return &RTPBasePayload{
		Element: gst.Element{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalRTPBasePayload(p uintptr) (interface{}, error) {
	return wrapRTPBasePayload(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (payload *RTPBasePayload) baseRTPBasePayload() *RTPBasePayload {
	return payload
}

// BaseRTPBasePayload returns the underlying base object.
func BaseRTPBasePayload(obj RTPBasePayloader) *RTPBasePayload {
	return obj.baseRTPBasePayload()
}

// ConnectRequestExtension: returned ext must be configured with the correct
// ext_id and with the necessary attributes as required by the extension
// implementation.
func (payload *RTPBasePayload) ConnectRequestExtension(f func(extId uint, extUri string) (rtpHeaderExtension RTPHeaderExtensioner)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(payload, "request-extension", false, unsafe.Pointer(C._gotk4_gstrtp1_RTPBasePayload_ConnectRequestExtension), f)
}

// AllocateOutputBuffer (gst_rtp_base_payload_allocate_output_buffer): allocate
// a new Buffer with enough data to hold an RTP packet with minimum csrc_count
// CSRCs, a payload length of payload_len and padding of pad_len. If payload has
// RTPBasePayload:source-info TRUE additional CSRCs may be allocated and filled
// with RTP source information.
//
// The function takes the following parameters:
//
//   - payloadLen: length of the payload.
//   - padLen: amount of padding.
//   - csrcCount: minimum number of CSRC entries.
//
// The function returns the following values:
//
//   - buffer: newly allocated buffer that can hold an RTP packet with given
//     parameters.
func (payload *RTPBasePayload) AllocateOutputBuffer(payloadLen uint, padLen, csrcCount byte) *gst.Buffer {
	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 C.guint              // out
	var _arg2 C.guint8             // out
	var _arg3 C.guint8             // out
	var _cret *C.GstBuffer         // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.BaseObject(payload).Native()))
	_arg1 = C.guint(payloadLen)
	_arg2 = C.guint8(padLen)
	_arg3 = C.guint8(csrcCount)

	_cret = C.gst_rtp_base_payload_allocate_output_buffer(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(payloadLen)
	runtime.KeepAlive(padLen)
	runtime.KeepAlive(csrcCount)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _buffer
}

// SourceCount (gst_rtp_base_payload_get_source_count): count the total
// number of RTP sources found in the meta of buffer, which will be
// automically added by gst_rtp_base_payload_allocate_output_buffer().
// If RTPBasePayload:source-info is FALSE the count will be 0.
//
// The function takes the following parameters:
//
//   - buffer typically the buffer to payload.
//
// The function returns the following values:
//
//   - guint: number of sources.
func (payload *RTPBasePayload) SourceCount(buffer *gst.Buffer) uint {
	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 *C.GstBuffer         // out
	var _cret C.guint              // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.BaseObject(payload).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_rtp_base_payload_get_source_count(_arg0, _arg1)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(buffer)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IsFilled (gst_rtp_base_payload_is_filled): check if the packet with size and
// duration would exceed the configured maximum size.
//
// The function takes the following parameters:
//
//   - size of the packet.
//   - duration of the packet.
//
// The function returns the following values:
//
//   - ok: TRUE if the packet of size and duration would exceed the configured
//     MTU or max_ptime.
func (payload *RTPBasePayload) IsFilled(size uint, duration gst.ClockTime) bool {
	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 C.guint              // out
	var _arg2 C.GstClockTime       // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.BaseObject(payload).Native()))
	_arg1 = C.guint(size)
	_arg2 = C.GstClockTime(duration)

	_cret = C.gst_rtp_base_payload_is_filled(_arg0, _arg1, _arg2)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(size)
	runtime.KeepAlive(duration)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSourceInfoEnabled (gst_rtp_base_payload_is_source_info_enabled) queries
// whether the payloader will add contributing sources (CSRCs) to the RTP header
// from RTPSourceMeta.
//
// The function returns the following values:
//
//   - ok: TRUE if source-info is enabled.
func (payload *RTPBasePayload) IsSourceInfoEnabled() bool {
	var _arg0 *C.GstRTPBasePayload // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.BaseObject(payload).Native()))

	_cret = C.gst_rtp_base_payload_is_source_info_enabled(_arg0)
	runtime.KeepAlive(payload)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PushBuffer (gst_rtp_base_payload_push): push buffer to the peer element of
// the payloader. The SSRC, payload type, seqnum and timestamp of the RTP buffer
// will be updated first.
//
// This function takes ownership of buffer.
//
// The function takes the following parameters:
//
//   - buffer: Buffer.
//
// The function returns the following values:
//
//   - flowReturn: FlowReturn.
func (payload *RTPBasePayload) PushBuffer(buffer *gst.Buffer) gst.FlowReturn {
	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 *C.GstBuffer         // out
	var _cret C.GstFlowReturn      // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.BaseObject(payload).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	_cret = C.gst_rtp_base_payload_push(_arg0, _arg1)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(buffer)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// PushList (gst_rtp_base_payload_push_list): push list to the peer element of
// the payloader. The SSRC, payload type, seqnum and timestamp of the RTP buffer
// will be updated first.
//
// This function takes ownership of list.
//
// The function takes the following parameters:
//
//   - list: BufferList.
//
// The function returns the following values:
//
//   - flowReturn: FlowReturn.
func (payload *RTPBasePayload) PushList(list *gst.BufferList) gst.FlowReturn {
	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 *C.GstBufferList     // out
	var _cret C.GstFlowReturn      // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.BaseObject(payload).Native()))
	_arg1 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(list)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(list)), nil)

	_cret = C.gst_rtp_base_payload_push_list(_arg0, _arg1)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(list)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// SetOptions (gst_rtp_base_payload_set_options): set the rtp options of
// the payloader. These options will be set in the caps of the payloader.
// Subclasses must call this method before calling gst_rtp_base_payload_push()
// or gst_rtp_base_payload_set_outcaps().
//
// The function takes the following parameters:
//
//   - media type (typically "audio" or "video").
//   - dynamic: if the payload type is dynamic.
//   - encodingName: encoding name.
//   - clockRate: clock rate of the media.
func (payload *RTPBasePayload) SetOptions(media string, dynamic bool, encodingName string, clockRate uint32) {
	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gboolean           // out
	var _arg3 *C.gchar             // out
	var _arg4 C.guint32            // out

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.BaseObject(payload).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(media)))
	defer C.free(unsafe.Pointer(_arg1))
	if dynamic {
		_arg2 = C.TRUE
	}
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(encodingName)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = C.guint32(clockRate)

	C.gst_rtp_base_payload_set_options(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(media)
	runtime.KeepAlive(dynamic)
	runtime.KeepAlive(encodingName)
	runtime.KeepAlive(clockRate)
}

// SetOutcapsStructure (gst_rtp_base_payload_set_outcaps_structure): configure
// the output caps with the optional fields.
//
// The function takes the following parameters:
//
//   - s (optional) with the caps fields.
//
// The function returns the following values:
//
//   - ok: TRUE if the caps could be set.
func (payload *RTPBasePayload) SetOutcapsStructure(s *gst.Structure) bool {
	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 *C.GstStructure      // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.BaseObject(payload).Native()))
	if s != nil {
		_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(s)))
	}

	_cret = C.gst_rtp_base_payload_set_outcaps_structure(_arg0, _arg1)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(s)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSourceInfoEnabled (gst_rtp_base_payload_set_source_info_enabled): enable
// or disable adding contributing sources to RTP packets from RTPSourceMeta.
//
// The function takes the following parameters:
//
//   - enable: whether to add contributing sources to RTP packets.
func (payload *RTPBasePayload) SetSourceInfoEnabled(enable bool) {
	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.BaseObject(payload).Native()))
	if enable {
		_arg1 = C.TRUE
	}

	C.gst_rtp_base_payload_set_source_info_enabled(_arg0, _arg1)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(enable)
}

// Caps: get desired caps.
//
// The function takes the following parameters:
//
//   - pad
//   - filter
func (payload *RTPBasePayload) caps(pad *gst.Pad, filter *gst.Caps) *gst.Caps {
	gclass := (*C.GstRTPBasePayloadClass)(coreglib.PeekParentClass(payload))
	fnarg := gclass.get_caps

	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 *C.GstPad            // out
	var _arg2 *C.GstCaps           // out
	var _cret *C.GstCaps           // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.BaseObject(payload).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.BaseObject(pad).Native()))
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))

	_cret = C._gotk4_gstrtp1_RTPBasePayload_virtual_get_caps(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(filter)

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _caps
}

// handleBuffer process data.
func (payload *RTPBasePayload) handleBuffer(buffer *gst.Buffer) gst.FlowReturn {
	gclass := (*C.GstRTPBasePayloadClass)(coreglib.PeekParentClass(payload))
	fnarg := gclass.handle_buffer

	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 *C.GstBuffer         // out
	var _cret C.GstFlowReturn      // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.BaseObject(payload).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C._gotk4_gstrtp1_RTPBasePayload_virtual_handle_buffer(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(buffer)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// Query: custom query handling.
//
// The function takes the following parameters:
//
//   - pad
//   - query
func (payload *RTPBasePayload) query(pad *gst.Pad, query *gst.Query) bool {
	gclass := (*C.GstRTPBasePayloadClass)(coreglib.PeekParentClass(payload))
	fnarg := gclass.query

	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 *C.GstPad            // out
	var _arg2 *C.GstQuery          // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.BaseObject(payload).Native()))
	_arg1 = (*C.GstPad)(unsafe.Pointer(coreglib.BaseObject(pad).Native()))
	_arg2 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstrtp1_RTPBasePayload_virtual_query(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(pad)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// setCaps: configure the payloader.
func (payload *RTPBasePayload) setCaps(caps *gst.Caps) bool {
	gclass := (*C.GstRTPBasePayloadClass)(coreglib.PeekParentClass(payload))
	fnarg := gclass.set_caps

	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 *C.GstCaps           // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.BaseObject(payload).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C._gotk4_gstrtp1_RTPBasePayload_virtual_set_caps(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// sinkEvent: custom event handling on the sinkpad.
func (payload *RTPBasePayload) sinkEvent(event *gst.Event) bool {
	gclass := (*C.GstRTPBasePayloadClass)(coreglib.PeekParentClass(payload))
	fnarg := gclass.sink_event

	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 *C.GstEvent          // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.BaseObject(payload).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gstrtp1_RTPBasePayload_virtual_sink_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// srcEvent: custom event handling on the srcpad.
func (payload *RTPBasePayload) srcEvent(event *gst.Event) bool {
	gclass := (*C.GstRTPBasePayloadClass)(coreglib.PeekParentClass(payload))
	fnarg := gclass.src_event

	var _arg0 *C.GstRTPBasePayload // out
	var _arg1 *C.GstEvent          // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstRTPBasePayload)(unsafe.Pointer(coreglib.BaseObject(payload).Native()))
	_arg1 = (*C.GstEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gstrtp1_RTPBasePayload_virtual_src_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(payload)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RTPHeaderExtensionOverrides contains methods that are overridable.
type RTPHeaderExtensionOverrides struct {
	// MaxSize: this is used to know how much data a certain header extension
	// will need for both allocating the resulting data, and deciding how much
	// payload data can be generated.
	//
	// Implementations should return as accurate a value as is possible using
	// the information given in the input buffer.
	//
	// The function takes the following parameters:
	//
	//   - inputMeta: Buffer.
	//
	// The function returns the following values:
	//
	//   - gsize: maximum size of the data written by this extension.
	MaxSize func(inputMeta *gst.Buffer) uint
	// SupportedFlags: retrieve the supported flags.
	//
	// The function returns the following values:
	//
	//   - rtpHeaderExtensionFlags flags supported by this instance of ext.
	SupportedFlags func() RTPHeaderExtensionFlags
	// Read the RTP header extension from data.
	//
	// The function takes the following parameters:
	//
	//   - readFlags for how the extension should be written.
	//   - data: location to read the rtp header extension from.
	//   - buffer to modify if necessary.
	//
	// The function returns the following values:
	//
	//   - ok: whether the extension could be read from data.
	Read func(readFlags RTPHeaderExtensionFlags, data []byte, buffer *gst.Buffer) bool
	// SetAttributes: set the necessary attributes that may be signaled e.g.
	// with an SDP.
	//
	// The function takes the following parameters:
	//
	//   - direction
	//   - attributes
	SetAttributes func(direction RTPHeaderExtensionDirection, attributes string) bool
	// SetCapsFromAttributes: gst_rtp_header_extension_set_id() must have been
	// called with a valid extension id that is contained in these caps.
	//
	// The only current known caps format is based on the SDP standard as
	// produced by gst_sdp_media_attributes_to_caps().
	//
	// The function takes the following parameters:
	//
	//   - caps: writable Caps to modify.
	//
	// The function returns the following values:
	//
	//   - ok: whether the configured attributes on ext can successfully be set
	//     on caps.
	SetCapsFromAttributes func(caps *gst.Caps) bool
	// SetNonRtpSinkCaps passes RTP payloader's sink (i.e. not payloaded) caps
	// to the header extension.
	//
	// The function takes the following parameters:
	//
	//   - caps: sink Caps.
	//
	// The function returns the following values:
	//
	//   - ok: whether caps could be read successfully.
	SetNonRtpSinkCaps func(caps *gst.Caps) bool
	// UpdateNonRtpSrcCaps updates depayloader src caps based on the information
	// received in RTP header. caps must be writable as this function may modify
	// them.
	//
	// The function takes the following parameters:
	//
	//   - caps: src Caps to modify.
	//
	// The function returns the following values:
	//
	//   - ok: whether caps were modified successfully.
	UpdateNonRtpSrcCaps func(caps *gst.Caps) bool
	// Write writes the RTP header extension to data using information available
	// from the input_meta. data will be sized to be at least the value returned
	// from gst_rtp_header_extension_get_max_size().
	//
	// The function takes the following parameters:
	//
	//   - inputMeta: input Buffer to read information from if necessary.
	//   - writeFlags for how the extension should be written.
	//   - output RTP Buffer.
	//   - data: location to write the rtp header extension into.
	//
	// The function returns the following values:
	//
	//   - gssize: size of the data written, < 0 on failure.
	Write func(inputMeta *gst.Buffer, writeFlags RTPHeaderExtensionFlags, output *gst.Buffer, data []byte) int
}

func defaultRTPHeaderExtensionOverrides(v *RTPHeaderExtension) RTPHeaderExtensionOverrides {
	return RTPHeaderExtensionOverrides{
		MaxSize:               v.maxSize,
		SupportedFlags:        v.supportedFlags,
		Read:                  v.read,
		SetAttributes:         v.setAttributes,
		SetCapsFromAttributes: v.setCapsFromAttributes,
		SetNonRtpSinkCaps:     v.setNonRtpSinkCaps,
		UpdateNonRtpSrcCaps:   v.updateNonRtpSrcCaps,
		Write:                 v.write,
	}
}

// RTPHeaderExtension (GstRTPHeaderExtension): instance struct for a RTP
// Audio/Video header extension.
type RTPHeaderExtension struct {
	_ [0]func() // equal guard
	gst.Element
}

var (
	_ gst.Elementer = (*RTPHeaderExtension)(nil)
)

// RTPHeaderExtensioner describes types inherited from RTPHeaderExtension.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type RTPHeaderExtensioner interface {
	gst.Elementer

	// Direction (gst_rtp_header_extension_get_direction): retrieve the
	// direction.
	Direction() RTPHeaderExtensionDirection
	ID() uint
	// MaxSize (gst_rtp_header_extension_get_max_size): this is used to know how
	// much data a certain header extension will need for both allocating the
	// resulting data, and deciding how much payload data can be generated.
	MaxSize(inputMeta *gst.Buffer) uint
	SdpCapsFieldName() string
	SupportedFlags() RTPHeaderExtensionFlags
	URI() string
	// Read (gst_rtp_header_extension_read) the RTP header extension from data.
	Read(readFlags RTPHeaderExtensionFlags, data []byte, buffer *gst.Buffer) bool
	// SetAttributesFromCaps
	// (gst_rtp_header_extension_set_attributes_from_caps):
	// gst_rtp_header_extension_set_id() must have been called with a valid
	// extension id that is contained in these caps.
	SetAttributesFromCaps(caps *gst.Caps) bool
	// SetCapsFromAttributes
	// (gst_rtp_header_extension_set_caps_from_attributes):
	// gst_rtp_header_extension_set_id() must have been called with a valid
	// extension id that is contained in these caps.
	SetCapsFromAttributes(caps *gst.Caps) bool
	// SetCapsFromAttributesHelper
	// (gst_rtp_header_extension_set_caps_from_attributes_helper): helper
	// implementation for GstRTPExtensionClass::set_caps_from_attributes that
	// sets the ext uri on caps with the specified extension id as required for
	// sdp Caps.
	SetCapsFromAttributesHelper(caps *gst.Caps, attributes string) bool
	// SetDirection (gst_rtp_header_extension_set_direction): set the direction
	// that this header extension should be used in.
	SetDirection(direction RTPHeaderExtensionDirection)
	// SetID (gst_rtp_header_extension_set_id) sets the RTP extension id on ext.
	SetID(extId uint)
	// SetNonRtpSinkCaps (gst_rtp_header_extension_set_non_rtp_sink_caps) passes
	// RTP payloader's sink (i.e.
	SetNonRtpSinkCaps(caps *gst.Caps) bool
	// SetWantsUpdateNonRtpSrcCaps
	// (gst_rtp_header_extension_set_wants_update_non_rtp_src_caps): call this
	// function in a subclass from RTPHeaderExtensionClass::read to tell the
	// depayloader whether the data just parsed from RTP packet require updating
	// its src (non-RTP) caps.
	SetWantsUpdateNonRtpSrcCaps(state bool)
	// UpdateNonRtpSrcCaps (gst_rtp_header_extension_update_non_rtp_src_caps)
	// updates depayloader src caps based on the information received in RTP
	// header.
	UpdateNonRtpSrcCaps(caps *gst.Caps) bool
	// WantsUpdateNonRtpSrcCaps
	// (gst_rtp_header_extension_wants_update_non_rtp_src_caps): call this
	// function after gst_rtp_header_extension_read() to check if the
	// depayloader's src caps need updating with data received in the last RTP
	// packet.
	WantsUpdateNonRtpSrcCaps() bool
	// Write (gst_rtp_header_extension_write) writes the RTP header extension to
	// data using information available from the input_meta.
	Write(inputMeta *gst.Buffer, writeFlags RTPHeaderExtensionFlags, output *gst.Buffer, data []byte) int

	baseRTPHeaderExtension() *RTPHeaderExtension
}

var _ RTPHeaderExtensioner = (*RTPHeaderExtension)(nil)

func init() {
	coreglib.RegisterClassInfo[*RTPHeaderExtension, *RTPHeaderExtensionClass, RTPHeaderExtensionOverrides](
		GTypeRTPHeaderExtension,
		initRTPHeaderExtensionClass,
		wrapRTPHeaderExtension,
		defaultRTPHeaderExtensionOverrides,
	)
}

func initRTPHeaderExtensionClass(gclass unsafe.Pointer, overrides RTPHeaderExtensionOverrides, classInitFunc func(*RTPHeaderExtensionClass)) {
	pclass := (*C.GstRTPHeaderExtensionClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeRTPHeaderExtension))))

	if overrides.MaxSize != nil {
		pclass.get_max_size = (*[0]byte)(C._gotk4_gstrtp1_RTPHeaderExtensionClass_get_max_size)
	}

	if overrides.SupportedFlags != nil {
		pclass.get_supported_flags = (*[0]byte)(C._gotk4_gstrtp1_RTPHeaderExtensionClass_get_supported_flags)
	}

	if overrides.Read != nil {
		pclass.read = (*[0]byte)(C._gotk4_gstrtp1_RTPHeaderExtensionClass_read)
	}

	if overrides.SetAttributes != nil {
		pclass.set_attributes = (*[0]byte)(C._gotk4_gstrtp1_RTPHeaderExtensionClass_set_attributes)
	}

	if overrides.SetCapsFromAttributes != nil {
		pclass.set_caps_from_attributes = (*[0]byte)(C._gotk4_gstrtp1_RTPHeaderExtensionClass_set_caps_from_attributes)
	}

	if overrides.SetNonRtpSinkCaps != nil {
		pclass.set_non_rtp_sink_caps = (*[0]byte)(C._gotk4_gstrtp1_RTPHeaderExtensionClass_set_non_rtp_sink_caps)
	}

	if overrides.UpdateNonRtpSrcCaps != nil {
		pclass.update_non_rtp_src_caps = (*[0]byte)(C._gotk4_gstrtp1_RTPHeaderExtensionClass_update_non_rtp_src_caps)
	}

	if overrides.Write != nil {
		pclass.write = (*[0]byte)(C._gotk4_gstrtp1_RTPHeaderExtensionClass_write)
	}

	if classInitFunc != nil {
		class := (*RTPHeaderExtensionClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapRTPHeaderExtension(obj *coreglib.Object) *RTPHeaderExtension {
	return &RTPHeaderExtension{
		Element: gst.Element{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalRTPHeaderExtension(p uintptr) (interface{}, error) {
	return wrapRTPHeaderExtension(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (ext *RTPHeaderExtension) baseRTPHeaderExtension() *RTPHeaderExtension {
	return ext
}

// BaseRTPHeaderExtension returns the underlying base object.
func BaseRTPHeaderExtension(obj RTPHeaderExtensioner) *RTPHeaderExtension {
	return obj.baseRTPHeaderExtension()
}

// Direction (gst_rtp_header_extension_get_direction): retrieve the direction.
//
// The function returns the following values:
//
//   - rtpHeaderExtensionDirection: direction.
func (ext *RTPHeaderExtension) Direction() RTPHeaderExtensionDirection {
	var _arg0 *C.GstRTPHeaderExtension         // out
	var _cret C.GstRTPHeaderExtensionDirection // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))

	_cret = C.gst_rtp_header_extension_get_direction(_arg0)
	runtime.KeepAlive(ext)

	var _rtpHeaderExtensionDirection RTPHeaderExtensionDirection // out

	_rtpHeaderExtensionDirection = RTPHeaderExtensionDirection(_cret)

	return _rtpHeaderExtensionDirection
}

// The function returns the following values:
//
//   - guint: RTP extension id configured on ext.
func (ext *RTPHeaderExtension) ID() uint {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _cret C.guint                  // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))

	_cret = C.gst_rtp_header_extension_get_id(_arg0)
	runtime.KeepAlive(ext)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// MaxSize (gst_rtp_header_extension_get_max_size): this is used to know how
// much data a certain header extension will need for both allocating the
// resulting data, and deciding how much payload data can be generated.
//
// Implementations should return as accurate a value as is possible using the
// information given in the input buffer.
//
// The function takes the following parameters:
//
//   - inputMeta: Buffer.
//
// The function returns the following values:
//
//   - gsize: maximum size of the data written by this extension.
func (ext *RTPHeaderExtension) MaxSize(inputMeta *gst.Buffer) uint {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 *C.GstBuffer             // out
	var _cret C.gsize                  // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(inputMeta)))

	_cret = C.gst_rtp_header_extension_get_max_size(_arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(inputMeta)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// The function returns the following values:
//
//   - utf8 field name used in SDP-like Caps for this ext configuration.
func (ext *RTPHeaderExtension) SdpCapsFieldName() string {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))

	_cret = C.gst_rtp_header_extension_get_sdp_caps_field_name(_arg0)
	runtime.KeepAlive(ext)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// The function returns the following values:
//
//   - rtpHeaderExtensionFlags flags supported by this instance of ext.
func (ext *RTPHeaderExtension) SupportedFlags() RTPHeaderExtensionFlags {
	var _arg0 *C.GstRTPHeaderExtension     // out
	var _cret C.GstRTPHeaderExtensionFlags // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))

	_cret = C.gst_rtp_header_extension_get_supported_flags(_arg0)
	runtime.KeepAlive(ext)

	var _rtpHeaderExtensionFlags RTPHeaderExtensionFlags // out

	_rtpHeaderExtensionFlags = RTPHeaderExtensionFlags(_cret)

	return _rtpHeaderExtensionFlags
}

// The function returns the following values:
//
//   - utf8 (optional): RTP extension URI for this object.
func (ext *RTPHeaderExtension) URI() string {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _cret *C.gchar                 // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))

	_cret = C.gst_rtp_header_extension_get_uri(_arg0)
	runtime.KeepAlive(ext)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Read (gst_rtp_header_extension_read) the RTP header extension from data.
//
// The function takes the following parameters:
//
//   - readFlags for how the extension should be written.
//   - data: location to read the rtp header extension from.
//   - buffer to modify if necessary.
//
// The function returns the following values:
//
//   - ok: whether the extension could be read from data.
func (ext *RTPHeaderExtension) Read(readFlags RTPHeaderExtensionFlags, data []byte, buffer *gst.Buffer) bool {
	var _arg0 *C.GstRTPHeaderExtension     // out
	var _arg1 C.GstRTPHeaderExtensionFlags // out
	var _arg2 *C.guint8                    // out
	var _arg3 C.gsize
	var _arg4 *C.GstBuffer // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))
	_arg1 = C.GstRTPHeaderExtensionFlags(readFlags)
	_arg3 = (C.gsize)(len(data))
	if len(data) > 0 {
		_arg2 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}
	_arg4 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_rtp_header_extension_read(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(readFlags)
	runtime.KeepAlive(data)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAttributesFromCaps (gst_rtp_header_extension_set_attributes_from_caps):
// gst_rtp_header_extension_set_id() must have been called with a valid
// extension id that is contained in these caps.
//
// The only current known caps format is based on the SDP standard as produced
// by gst_sdp_media_attributes_to_caps().
//
// The function takes the following parameters:
//
//   - caps to configure this extension with.
//
// The function returns the following values:
//
//   - ok: whether the caps could be successfully set on ext.
func (ext *RTPHeaderExtension) SetAttributesFromCaps(caps *gst.Caps) bool {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 *C.GstCaps               // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_rtp_header_extension_set_attributes_from_caps(_arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetCapsFromAttributes (gst_rtp_header_extension_set_caps_from_attributes):
// gst_rtp_header_extension_set_id() must have been called with a valid
// extension id that is contained in these caps.
//
// The only current known caps format is based on the SDP standard as produced
// by gst_sdp_media_attributes_to_caps().
//
// The function takes the following parameters:
//
//   - caps: writable Caps to modify.
//
// The function returns the following values:
//
//   - ok: whether the configured attributes on ext can successfully be set on
//     caps.
func (ext *RTPHeaderExtension) SetCapsFromAttributes(caps *gst.Caps) bool {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 *C.GstCaps               // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_rtp_header_extension_set_caps_from_attributes(_arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetCapsFromAttributesHelper
// (gst_rtp_header_extension_set_caps_from_attributes_helper): helper
// implementation for GstRTPExtensionClass::set_caps_from_attributes that sets
// the ext uri on caps with the specified extension id as required for sdp Caps.
//
// Requires that the extension does not have any attributes or direction
// advertised in caps.
//
// The function takes the following parameters:
//
//   - caps to write fields into.
//   - attributes
//
// The function returns the following values:
//
//   - ok: whether the ext attributes could be set on caps.
func (ext *RTPHeaderExtension) SetCapsFromAttributesHelper(caps *gst.Caps, attributes string) bool {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 *C.GstCaps               // out
	var _arg2 *C.gchar                 // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_rtp_header_extension_set_caps_from_attributes_helper(_arg0, _arg1, _arg2)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(attributes)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetDirection (gst_rtp_header_extension_set_direction):
// set the direction that this header extension should be used in. If
// T_RTP_HEADER_EXTENSION_DIRECTION_INHERITED is included, the direction will
// not be included in the caps (as it shouldn't be in the extmap line in the
// SDP).
//
// The function takes the following parameters:
//
//   - direction: direction.
func (ext *RTPHeaderExtension) SetDirection(direction RTPHeaderExtensionDirection) {
	var _arg0 *C.GstRTPHeaderExtension         // out
	var _arg1 C.GstRTPHeaderExtensionDirection // out

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))
	_arg1 = C.GstRTPHeaderExtensionDirection(direction)

	C.gst_rtp_header_extension_set_direction(_arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(direction)
}

// SetID (gst_rtp_header_extension_set_id) sets the RTP extension id on ext.
//
// The function takes the following parameters:
//
//   - extId: id of this extension.
func (ext *RTPHeaderExtension) SetID(extId uint) {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 C.guint                  // out

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))
	_arg1 = C.guint(extId)

	C.gst_rtp_header_extension_set_id(_arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(extId)
}

// SetNonRtpSinkCaps (gst_rtp_header_extension_set_non_rtp_sink_caps) passes RTP
// payloader's sink (i.e. not payloaded) caps to the header extension.
//
// The function takes the following parameters:
//
//   - caps: sink Caps.
//
// The function returns the following values:
//
//   - ok: whether caps could be read successfully.
func (ext *RTPHeaderExtension) SetNonRtpSinkCaps(caps *gst.Caps) bool {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 *C.GstCaps               // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_rtp_header_extension_set_non_rtp_sink_caps(_arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetWantsUpdateNonRtpSrcCaps
// (gst_rtp_header_extension_set_wants_update_non_rtp_src_caps): call this
// function in a subclass from RTPHeaderExtensionClass::read to tell the
// depayloader whether the data just parsed from RTP packet require updating its
// src (non-RTP) caps. If state is TRUE, RTPBaseDepayload will eventually invoke
// gst_rtp_header_extension_update_non_rtp_src_caps() to have the caps update
// applied. Applying the update also flips the internal "wants update" flag back
// to FALSE.
//
// The function takes the following parameters:
//
//   - state: TRUE if caps update is needed.
func (ext *RTPHeaderExtension) SetWantsUpdateNonRtpSrcCaps(state bool) {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 C.gboolean               // out

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))
	if state {
		_arg1 = C.TRUE
	}

	C.gst_rtp_header_extension_set_wants_update_non_rtp_src_caps(_arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(state)
}

// UpdateNonRtpSrcCaps (gst_rtp_header_extension_update_non_rtp_src_caps)
// updates depayloader src caps based on the information received in RTP header.
// caps must be writable as this function may modify them.
//
// The function takes the following parameters:
//
//   - caps: src Caps to modify.
//
// The function returns the following values:
//
//   - ok: whether caps were modified successfully.
func (ext *RTPHeaderExtension) UpdateNonRtpSrcCaps(caps *gst.Caps) bool {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 *C.GstCaps               // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_rtp_header_extension_update_non_rtp_src_caps(_arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WantsUpdateNonRtpSrcCaps
// (gst_rtp_header_extension_wants_update_non_rtp_src_caps): call this function
// after gst_rtp_header_extension_read() to check if the depayloader's src caps
// need updating with data received in the last RTP packet.
//
// The function returns the following values:
//
//   - ok: whether ext wants to update depayloader's src caps.
func (ext *RTPHeaderExtension) WantsUpdateNonRtpSrcCaps() bool {
	var _arg0 *C.GstRTPHeaderExtension // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))

	_cret = C.gst_rtp_header_extension_wants_update_non_rtp_src_caps(_arg0)
	runtime.KeepAlive(ext)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Write (gst_rtp_header_extension_write) writes the RTP header extension to
// data using information available from the input_meta. data will be sized to
// be at least the value returned from gst_rtp_header_extension_get_max_size().
//
// The function takes the following parameters:
//
//   - inputMeta: input Buffer to read information from if necessary.
//   - writeFlags for how the extension should be written.
//   - output RTP Buffer.
//   - data: location to write the rtp header extension into.
//
// The function returns the following values:
//
//   - gssize: size of the data written, < 0 on failure.
func (ext *RTPHeaderExtension) Write(inputMeta *gst.Buffer, writeFlags RTPHeaderExtensionFlags, output *gst.Buffer, data []byte) int {
	var _arg0 *C.GstRTPHeaderExtension     // out
	var _arg1 *C.GstBuffer                 // out
	var _arg2 C.GstRTPHeaderExtensionFlags // out
	var _arg3 *C.GstBuffer                 // out
	var _arg4 *C.guint8                    // out
	var _arg5 C.gsize
	var _cret C.gssize // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(inputMeta)))
	_arg2 = C.GstRTPHeaderExtensionFlags(writeFlags)
	_arg3 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(output)))
	_arg5 = (C.gsize)(len(data))
	if len(data) > 0 {
		_arg4 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_rtp_header_extension_write(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(inputMeta)
	runtime.KeepAlive(writeFlags)
	runtime.KeepAlive(output)
	runtime.KeepAlive(data)

	var _gssize int // out

	_gssize = int(_cret)

	return _gssize
}

// maxSize: this is used to know how much data a certain header extension will
// need for both allocating the resulting data, and deciding how much payload
// data can be generated.
//
// Implementations should return as accurate a value as is possible using the
// information given in the input buffer.
//
// The function takes the following parameters:
//
//   - inputMeta: Buffer.
//
// The function returns the following values:
//
//   - gsize: maximum size of the data written by this extension.
func (ext *RTPHeaderExtension) maxSize(inputMeta *gst.Buffer) uint {
	gclass := (*C.GstRTPHeaderExtensionClass)(coreglib.PeekParentClass(ext))
	fnarg := gclass.get_max_size

	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 *C.GstBuffer             // out
	var _cret C.gsize                  // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(inputMeta)))

	_cret = C._gotk4_gstrtp1_RTPHeaderExtension_virtual_get_max_size(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(inputMeta)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// supportedFlags: retrieve the supported flags.
//
// The function returns the following values:
//
//   - rtpHeaderExtensionFlags flags supported by this instance of ext.
func (ext *RTPHeaderExtension) supportedFlags() RTPHeaderExtensionFlags {
	gclass := (*C.GstRTPHeaderExtensionClass)(coreglib.PeekParentClass(ext))
	fnarg := gclass.get_supported_flags

	var _arg0 *C.GstRTPHeaderExtension     // out
	var _cret C.GstRTPHeaderExtensionFlags // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))

	_cret = C._gotk4_gstrtp1_RTPHeaderExtension_virtual_get_supported_flags(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(ext)

	var _rtpHeaderExtensionFlags RTPHeaderExtensionFlags // out

	_rtpHeaderExtensionFlags = RTPHeaderExtensionFlags(_cret)

	return _rtpHeaderExtensionFlags
}

// Read: read the RTP header extension from data.
//
// The function takes the following parameters:
//
//   - readFlags for how the extension should be written.
//   - data: location to read the rtp header extension from.
//   - buffer to modify if necessary.
//
// The function returns the following values:
//
//   - ok: whether the extension could be read from data.
func (ext *RTPHeaderExtension) read(readFlags RTPHeaderExtensionFlags, data []byte, buffer *gst.Buffer) bool {
	gclass := (*C.GstRTPHeaderExtensionClass)(coreglib.PeekParentClass(ext))
	fnarg := gclass.read

	var _arg0 *C.GstRTPHeaderExtension     // out
	var _arg1 C.GstRTPHeaderExtensionFlags // out
	var _arg2 *C.guint8                    // out
	var _arg3 C.gsize
	var _arg4 *C.GstBuffer // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))
	_arg1 = C.GstRTPHeaderExtensionFlags(readFlags)
	_arg3 = (C.gsize)(len(data))
	if len(data) > 0 {
		_arg2 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}
	_arg4 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C._gotk4_gstrtp1_RTPHeaderExtension_virtual_read(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(readFlags)
	runtime.KeepAlive(data)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// setAttributes: set the necessary attributes that may be signaled e.g.
// with an SDP.
//
// The function takes the following parameters:
//
//   - direction
//   - attributes
func (ext *RTPHeaderExtension) setAttributes(direction RTPHeaderExtensionDirection, attributes string) bool {
	gclass := (*C.GstRTPHeaderExtensionClass)(coreglib.PeekParentClass(ext))
	fnarg := gclass.set_attributes

	var _arg0 *C.GstRTPHeaderExtension         // out
	var _arg1 C.GstRTPHeaderExtensionDirection // out
	var _arg2 *C.gchar                         // out
	var _cret C.gboolean                       // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))
	_arg1 = C.GstRTPHeaderExtensionDirection(direction)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C._gotk4_gstrtp1_RTPHeaderExtension_virtual_set_attributes(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(attributes)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// setCapsFromAttributes: gst_rtp_header_extension_set_id() must have been
// called with a valid extension id that is contained in these caps.
//
// The only current known caps format is based on the SDP standard as produced
// by gst_sdp_media_attributes_to_caps().
//
// The function takes the following parameters:
//
//   - caps: writable Caps to modify.
//
// The function returns the following values:
//
//   - ok: whether the configured attributes on ext can successfully be set on
//     caps.
func (ext *RTPHeaderExtension) setCapsFromAttributes(caps *gst.Caps) bool {
	gclass := (*C.GstRTPHeaderExtensionClass)(coreglib.PeekParentClass(ext))
	fnarg := gclass.set_caps_from_attributes

	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 *C.GstCaps               // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C._gotk4_gstrtp1_RTPHeaderExtension_virtual_set_caps_from_attributes(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// setNonRtpSinkCaps passes RTP payloader's sink (i.e. not payloaded) caps to
// the header extension.
//
// The function takes the following parameters:
//
//   - caps: sink Caps.
//
// The function returns the following values:
//
//   - ok: whether caps could be read successfully.
func (ext *RTPHeaderExtension) setNonRtpSinkCaps(caps *gst.Caps) bool {
	gclass := (*C.GstRTPHeaderExtensionClass)(coreglib.PeekParentClass(ext))
	fnarg := gclass.set_non_rtp_sink_caps

	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 *C.GstCaps               // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C._gotk4_gstrtp1_RTPHeaderExtension_virtual_set_non_rtp_sink_caps(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// updateNonRtpSrcCaps updates depayloader src caps based on the information
// received in RTP header. caps must be writable as this function may modify
// them.
//
// The function takes the following parameters:
//
//   - caps: src Caps to modify.
//
// The function returns the following values:
//
//   - ok: whether caps were modified successfully.
func (ext *RTPHeaderExtension) updateNonRtpSrcCaps(caps *gst.Caps) bool {
	gclass := (*C.GstRTPHeaderExtensionClass)(coreglib.PeekParentClass(ext))
	fnarg := gclass.update_non_rtp_src_caps

	var _arg0 *C.GstRTPHeaderExtension // out
	var _arg1 *C.GstCaps               // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C._gotk4_gstrtp1_RTPHeaderExtension_virtual_update_non_rtp_src_caps(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Write writes the RTP header extension to data using information available
// from the input_meta. data will be sized to be at least the value returned
// from gst_rtp_header_extension_get_max_size().
//
// The function takes the following parameters:
//
//   - inputMeta: input Buffer to read information from if necessary.
//   - writeFlags for how the extension should be written.
//   - output RTP Buffer.
//   - data: location to write the rtp header extension into.
//
// The function returns the following values:
//
//   - gssize: size of the data written, < 0 on failure.
func (ext *RTPHeaderExtension) write(inputMeta *gst.Buffer, writeFlags RTPHeaderExtensionFlags, output *gst.Buffer, data []byte) int {
	gclass := (*C.GstRTPHeaderExtensionClass)(coreglib.PeekParentClass(ext))
	fnarg := gclass.write

	var _arg0 *C.GstRTPHeaderExtension     // out
	var _arg1 *C.GstBuffer                 // out
	var _arg2 C.GstRTPHeaderExtensionFlags // out
	var _arg3 *C.GstBuffer                 // out
	var _arg4 *C.guint8                    // out
	var _arg5 C.gsize
	var _cret C.gssize // in

	_arg0 = (*C.GstRTPHeaderExtension)(unsafe.Pointer(coreglib.BaseObject(ext).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(inputMeta)))
	_arg2 = C.GstRTPHeaderExtensionFlags(writeFlags)
	_arg3 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(output)))
	_arg5 = (C.gsize)(len(data))
	if len(data) > 0 {
		_arg4 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}

	_cret = C._gotk4_gstrtp1_RTPHeaderExtension_virtual_write(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(ext)
	runtime.KeepAlive(inputMeta)
	runtime.KeepAlive(writeFlags)
	runtime.KeepAlive(output)
	runtime.KeepAlive(data)

	var _gssize int // out

	_gssize = int(_cret)

	return _gssize
}

// The function takes the following parameters:
//
//   - uri: rtp header extension URI to search for.
//
// The function returns the following values:
//
//   - rtpHeaderExtension (optional) for uri or NULL.
func RTPHeaderExtensionCreateFromURI(uri string) RTPHeaderExtensioner {
	var _arg1 *C.gchar                 // out
	var _cret *C.GstRTPHeaderExtension // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_rtp_header_extension_create_from_uri(_arg1)
	runtime.KeepAlive(uri)

	var _rtpHeaderExtension RTPHeaderExtensioner // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(RTPHeaderExtensioner)
				return ok
			})
			rv, ok := casted.(RTPHeaderExtensioner)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstrtp.RTPHeaderExtensioner")
			}
			_rtpHeaderExtension = rv
		}
	}

	return _rtpHeaderExtension
}

// RTCPBuffer (GstRTCPBuffer): note: The API in this module is not yet declared
// stable.
//
// The GstRTPCBuffer helper functions makes it easy to parse and create
// regular Buffer objects that contain compound RTCP packets. These buffers are
// typically of 'application/x-rtcp' Caps.
//
// An RTCP buffer consists of 1 or more RTCPPacket structures that you can
// retrieve with gst_rtcp_buffer_get_first_packet(). RTCPPacket acts as
// a pointer into the RTCP buffer; you can move to the next packet with
// gst_rtcp_packet_move_to_next().
//
// An instance of this type is always passed by reference.
type RTCPBuffer struct {
	*rtcpBuffer
}

// rtcpBuffer is the struct that's finalized.
type rtcpBuffer struct {
	native *C.GstRTCPBuffer
}

func (r *RTCPBuffer) Buffer() *gst.Buffer {
	valptr := &r.native.buffer
	var _v *gst.Buffer // out
	_v = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_v)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})
	return _v
}

func (r *RTCPBuffer) Map() *gst.MapInfo {
	valptr := &r.native._map
	var _v *gst.MapInfo // out
	_v = (*gst.MapInfo)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// AddPacket (gst_rtcp_buffer_add_packet): add a new packet of type to rtcp.
// packet will point to the newly created packet.
//
// The function takes the following parameters:
//
//   - typ of the new packet.
//   - packet: pointer to new packet.
//
// The function returns the following values:
//
//   - ok: TRUE if the packet could be created. This function returns FALSE if
//     the max mtu is exceeded for the buffer.
func (rtcp *RTCPBuffer) AddPacket(typ RTCPType, packet *RTCPPacket) bool {
	var _arg0 *C.GstRTCPBuffer // out
	var _arg1 C.GstRTCPType    // out
	var _arg2 *C.GstRTCPPacket // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPBuffer)(gextras.StructNative(unsafe.Pointer(rtcp)))
	_arg1 = C.GstRTCPType(typ)
	_arg2 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_buffer_add_packet(_arg0, _arg1, _arg2)
	runtime.KeepAlive(rtcp)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(packet)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FirstPacket (gst_rtcp_buffer_get_first_packet): initialize a new RTCPPacket
// pointer that points to the first packet in rtcp.
//
// The function takes the following parameters:
//
//   - packet: RTCPPacket.
//
// The function returns the following values:
//
//   - ok: TRUE if the packet existed in rtcp.
func (rtcp *RTCPBuffer) FirstPacket(packet *RTCPPacket) bool {
	var _arg0 *C.GstRTCPBuffer // out
	var _arg1 *C.GstRTCPPacket // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPBuffer)(gextras.StructNative(unsafe.Pointer(rtcp)))
	_arg1 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_buffer_get_first_packet(_arg0, _arg1)
	runtime.KeepAlive(rtcp)
	runtime.KeepAlive(packet)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PacketCount (gst_rtcp_buffer_get_packet_count): get the number of RTCP
// packets in rtcp.
//
// The function returns the following values:
//
//   - guint: number of RTCP packets in rtcp.
func (rtcp *RTCPBuffer) PacketCount() uint {
	var _arg0 *C.GstRTCPBuffer // out
	var _cret C.guint          // in

	_arg0 = (*C.GstRTCPBuffer)(gextras.StructNative(unsafe.Pointer(rtcp)))

	_cret = C.gst_rtcp_buffer_get_packet_count(_arg0)
	runtime.KeepAlive(rtcp)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Unmap (gst_rtcp_buffer_unmap): finish rtcp after being constructed. This
// function is usually called after gst_rtcp_buffer_map() and after adding the
// RTCP items to the new buffer.
//
// The function adjusts the size of rtcp with the total length of all the added
// packets.
func (rtcp *RTCPBuffer) Unmap() bool {
	var _arg0 *C.GstRTCPBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPBuffer)(gextras.StructNative(unsafe.Pointer(rtcp)))

	_cret = C.gst_rtcp_buffer_unmap(_arg0)
	runtime.KeepAlive(rtcp)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RTCPBufferMap (gst_rtcp_buffer_map): open buffer for reading or writing,
// depending on flags. The resulting RTCP buffer state is stored in rtcp.
//
// The function takes the following parameters:
//
//   - buffer with an RTCP packet.
//   - flags for the mapping.
//   - rtcp: resulting RTCPBuffer.
func RTCPBufferMap(buffer *gst.Buffer, flags gst.MapFlags, rtcp *RTCPBuffer) bool {
	var _arg1 *C.GstBuffer     // out
	var _arg2 C.GstMapFlags    // out
	var _arg3 *C.GstRTCPBuffer // out
	var _cret C.gboolean       // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = C.GstMapFlags(flags)
	_arg3 = (*C.GstRTCPBuffer)(gextras.StructNative(unsafe.Pointer(rtcp)))

	_cret = C.gst_rtcp_buffer_map(_arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(rtcp)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NewRTCPBuffer (gst_rtcp_buffer_new): create a new buffer for constructing
// RTCP packets. The packet will have a maximum size of mtu.
//
// The function takes the following parameters:
//
//   - mtu: maximum mtu size.
//
// The function returns the following values:
//
//   - buffer: newly allocated buffer.
func NewRTCPBuffer(mtu uint) *gst.Buffer {
	var _arg1 C.guint      // out
	var _cret *C.GstBuffer // in

	_arg1 = C.guint(mtu)

	_cret = C.gst_rtcp_buffer_new(_arg1)
	runtime.KeepAlive(mtu)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _buffer
}

// NewRTCPBufferCopyData (gst_rtcp_buffer_new_copy_data): create a new buffer
// and set the data to a copy of len bytes of data and the size to len. The data
// will be freed when the buffer is freed.
//
// The function takes the following parameters:
//
//   - data for the new buffer.
//
// The function returns the following values:
//
//   - buffer: newly allocated buffer with a copy of data and of size len.
func NewRTCPBufferCopyData(data []byte) *gst.Buffer {
	var _arg1 C.gconstpointer // out
	var _arg2 C.guint
	var _cret *C.GstBuffer // in

	_arg2 = (C.guint)(len(data))
	if len(data) > 0 {
		_arg1 = (C.gconstpointer)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_rtcp_buffer_new_copy_data(_arg1, _arg2)
	runtime.KeepAlive(data)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _buffer
}

// NewRTCPBufferTakeData (gst_rtcp_buffer_new_take_data): create a new buffer
// and set the data and size of the buffer to data and len respectively.
// data will be freed when the buffer is unreffed, so this function transfers
// ownership of data to the new buffer.
//
// The function takes the following parameters:
//
//   - data for the new buffer.
//
// The function returns the following values:
//
//   - buffer: newly allocated buffer with data and of size len.
func NewRTCPBufferTakeData(data []byte) *gst.Buffer {
	var _arg1 C.gpointer // out
	var _arg2 C.guint
	var _cret *C.GstBuffer // in

	_arg2 = (C.guint)(len(data))
	if len(data) > 0 {
		_arg1 = (C.gpointer)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_rtcp_buffer_new_take_data(_arg1, _arg2)
	runtime.KeepAlive(data)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _buffer
}

// RTCPBufferValidate (gst_rtcp_buffer_validate): check if the data pointed to
// by buffer is a valid RTCP packet using gst_rtcp_buffer_validate_data().
//
// The function takes the following parameters:
//
//   - buffer to validate.
//
// The function returns the following values:
//
//   - ok: TRUE if buffer is a valid RTCP packet.
func RTCPBufferValidate(buffer *gst.Buffer) bool {
	var _arg1 *C.GstBuffer // out
	var _cret C.gboolean   // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_rtcp_buffer_validate(_arg1)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RTCPBufferValidateData (gst_rtcp_buffer_validate_data): check if the data and
// size point to the data of a valid compound, non-reduced size RTCP packet.
// Use this function to validate a packet before using the other functions in
// this module.
//
// The function takes the following parameters:
//
//   - data to validate.
//
// The function returns the following values:
//
//   - ok: TRUE if the data points to a valid RTCP packet.
func RTCPBufferValidateData(data []byte) bool {
	var _arg1 *C.guint8 // out
	var _arg2 C.guint
	var _cret C.gboolean // in

	_arg2 = (C.guint)(len(data))
	if len(data) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_rtcp_buffer_validate_data(_arg1, _arg2)
	runtime.KeepAlive(data)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RTCPBufferValidateDataReduced (gst_rtcp_buffer_validate_data_reduced):
// check if the data and size point to the data of a valid RTCP packet.
// Use this function to validate a packet before using the other functions in
// this module.
//
// This function is updated to support reduced size rtcp packets according to
// RFC 5506 and will validate full compound RTCP packets as well as reduced size
// RTCP packets.
//
// The function takes the following parameters:
//
//   - data to validate.
//
// The function returns the following values:
//
//   - ok: TRUE if the data points to a valid RTCP packet.
func RTCPBufferValidateDataReduced(data []byte) bool {
	var _arg1 *C.guint8 // out
	var _arg2 C.guint
	var _cret C.gboolean // in

	_arg2 = (C.guint)(len(data))
	if len(data) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_rtcp_buffer_validate_data_reduced(_arg1, _arg2)
	runtime.KeepAlive(data)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RTCPBufferValidateReduced (gst_rtcp_buffer_validate_reduced):
// check if the data pointed to by buffer is a valid RTCP packet using
// gst_rtcp_buffer_validate_reduced().
//
// The function takes the following parameters:
//
//   - buffer to validate.
//
// The function returns the following values:
//
//   - ok: TRUE if buffer is a valid RTCP packet.
func RTCPBufferValidateReduced(buffer *gst.Buffer) bool {
	var _arg1 *C.GstBuffer // out
	var _cret C.gboolean   // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_rtcp_buffer_validate_reduced(_arg1)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RTCPPacket (GstRTCPPacket): data structure that points to a packet at
// offset in buffer. The size of the structure is made public to allow stack
// allocations.
//
// An instance of this type is always passed by reference.
type RTCPPacket struct {
	*rtcpPacket
}

// rtcpPacket is the struct that's finalized.
type rtcpPacket struct {
	native *C.GstRTCPPacket
}

// Rtcp: pointer to RTCP buffer.
func (r *RTCPPacket) Rtcp() *RTCPBuffer {
	valptr := &r.native.rtcp
	var _v *RTCPBuffer // out
	_v = (*RTCPBuffer)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// Offset: offset of packet in buffer data.
func (r *RTCPPacket) Offset() uint {
	valptr := &r.native.offset
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Offset: offset of packet in buffer data.
func (r *RTCPPacket) SetOffset(offset uint) {
	valptr := &r.native.offset
	*valptr = C.guint(offset)
}

// AddProfileSpecificExt (gst_rtcp_packet_add_profile_specific_ext):
// add profile-specific extension data to packet. If packet already contains
// profile-specific extension data will be appended to the existing extension.
//
// The function takes the following parameters:
//
//   - data: profile-specific data.
//
// The function returns the following values:
//
//   - ok: TRUE if the profile specific extension data was added.
func (packet *RTCPPacket) AddProfileSpecificExt(data []byte) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint8        // out
	var _arg2 C.guint
	var _cret C.gboolean // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg2 = (C.guint)(len(data))
	if len(data) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_rtcp_packet_add_profile_specific_ext(_arg0, _arg1, _arg2)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(data)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AddRb (gst_rtcp_packet_add_rb): add a new report block to packet with the
// given values.
//
// The function takes the following parameters:
//
//   - ssrc: data source being reported.
//   - fractionlost: fraction lost since last SR/RR.
//   - packetslost: cumululative number of packets lost.
//   - exthighestseq: extended last sequence number received.
//   - jitter: interarrival jitter.
//   - lsr: last SR packet from this source.
//   - dlsr: delay since last SR packet.
//
// The function returns the following values:
//
//   - ok: TRUE if the packet was created. This function can return FALSE if
//     the max MTU is exceeded or the number of report blocks is greater than
//     T_RTCP_MAX_RB_COUNT.
func (packet *RTCPPacket) AddRb(ssrc uint32, fractionlost byte, packetslost int32, exthighestseq uint32, jitter uint32, lsr uint32, dlsr uint32) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint32        // out
	var _arg2 C.guint8         // out
	var _arg3 C.gint32         // out
	var _arg4 C.guint32        // out
	var _arg5 C.guint32        // out
	var _arg6 C.guint32        // out
	var _arg7 C.guint32        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint32(ssrc)
	_arg2 = C.guint8(fractionlost)
	_arg3 = C.gint32(packetslost)
	_arg4 = C.guint32(exthighestseq)
	_arg5 = C.guint32(jitter)
	_arg6 = C.guint32(lsr)
	_arg7 = C.guint32(dlsr)

	_cret = C.gst_rtcp_packet_add_rb(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)
	runtime.KeepAlive(fractionlost)
	runtime.KeepAlive(packetslost)
	runtime.KeepAlive(exthighestseq)
	runtime.KeepAlive(jitter)
	runtime.KeepAlive(lsr)
	runtime.KeepAlive(dlsr)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AppGetData (gst_rtcp_packet_app_get_data): get the application-dependent data
// attached to a RTPFB or PSFB packet.
//
// The function returns the following values:
//
//   - guint8: pointer to the data.
func (packet *RTCPPacket) AppGetData() *byte {
	var _arg0 *C.GstRTCPPacket // out
	var _cret *C.guint8        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_app_get_data(_arg0)
	runtime.KeepAlive(packet)

	var _guint8 *byte // out

	_guint8 = (*byte)(unsafe.Pointer(_cret))

	return _guint8
}

// AppGetDataLength (gst_rtcp_packet_app_get_data_length): get the length of the
// application-dependent data attached to an APP packet.
//
// The function returns the following values:
//
//   - guint16: length of data in 32-bit words.
func (packet *RTCPPacket) AppGetDataLength() uint16 {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint16        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_app_get_data_length(_arg0)
	runtime.KeepAlive(packet)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// AppGetName (gst_rtcp_packet_app_get_name): get the name field of the APP
// packet.
//
// The function returns the following values:
//
//   - utf8: 4-byte name field, not zero-terminated.
func (packet *RTCPPacket) AppGetName() string {
	var _arg0 *C.GstRTCPPacket // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_app_get_name(_arg0)
	runtime.KeepAlive(packet)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// AppGetSsrc (gst_rtcp_packet_app_get_ssrc): get the SSRC/CSRC field of the APP
// packet.
//
// The function returns the following values:
//
//   - guint32: SSRC/CSRC.
func (packet *RTCPPacket) AppGetSsrc() uint32 {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint32        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_app_get_ssrc(_arg0)
	runtime.KeepAlive(packet)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// AppGetSubtype (gst_rtcp_packet_app_get_subtype): get the subtype field of the
// APP packet.
//
// The function returns the following values:
//
//   - guint8: subtype.
func (packet *RTCPPacket) AppGetSubtype() byte {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint8         // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_app_get_subtype(_arg0)
	runtime.KeepAlive(packet)

	var _guint8 byte // out

	_guint8 = byte(_cret)

	return _guint8
}

// AppSetDataLength (gst_rtcp_packet_app_set_data_length): set the length of the
// application-dependent data attached to an APP packet.
//
// The function takes the following parameters:
//
//   - wordlen: length of the data in 32-bit words.
//
// The function returns the following values:
//
//   - ok: TRUE if there was enough space in the packet to add this much data.
func (packet *RTCPPacket) AppSetDataLength(wordlen uint16) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint16        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint16(wordlen)

	_cret = C.gst_rtcp_packet_app_set_data_length(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(wordlen)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AppSetName (gst_rtcp_packet_app_set_name): set the name field of the APP
// packet.
//
// The function takes the following parameters:
//
//   - name: 4-byte ASCII name.
func (packet *RTCPPacket) AppSetName(name string) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_rtcp_packet_app_set_name(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(name)
}

// AppSetSsrc (gst_rtcp_packet_app_set_ssrc): set the SSRC/CSRC field of the APP
// packet.
//
// The function takes the following parameters:
//
//   - ssrc: SSRC/CSRC of the packet.
func (packet *RTCPPacket) AppSetSsrc(ssrc uint32) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint32        // out

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint32(ssrc)

	C.gst_rtcp_packet_app_set_ssrc(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)
}

// AppSetSubtype (gst_rtcp_packet_app_set_subtype): set the subtype field of the
// APP packet.
//
// The function takes the following parameters:
//
//   - subtype of the packet.
func (packet *RTCPPacket) AppSetSubtype(subtype byte) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint8         // out

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint8(subtype)

	C.gst_rtcp_packet_app_set_subtype(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(subtype)
}

// ByeAddSsrc (gst_rtcp_packet_bye_add_ssrc): add ssrc to the BYE packet.
//
// The function takes the following parameters:
//
//   - ssrc: SSRC to add.
//
// The function returns the following values:
//
//   - ok: TRUE if the ssrc was added. This function can return FALSE if the
//     max MTU is exceeded or the number of sources blocks is greater than
//     T_RTCP_MAX_BYE_SSRC_COUNT.
func (packet *RTCPPacket) ByeAddSsrc(ssrc uint32) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint32        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint32(ssrc)

	_cret = C.gst_rtcp_packet_bye_add_ssrc(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ByeAddSsrcs (gst_rtcp_packet_bye_add_ssrcs) adds len SSRCs in ssrc to BYE
// packet.
//
// The function takes the following parameters:
//
//   - ssrc: array of SSRCs to add.
//
// The function returns the following values:
//
//   - ok: TRUE if the all the SSRCs were added. This function can return FALSE
//     if the max MTU is exceeded or the number of sources blocks is greater
//     than T_RTCP_MAX_BYE_SSRC_COUNT.
func (packet *RTCPPacket) ByeAddSsrcs(ssrc []uint32) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint32       // out
	var _arg2 C.guint
	var _cret C.gboolean // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg2 = (C.guint)(len(ssrc))
	if len(ssrc) > 0 {
		_arg1 = (*C.guint32)(unsafe.Pointer(&ssrc[0]))
	}

	_cret = C.gst_rtcp_packet_bye_add_ssrcs(_arg0, _arg1, _arg2)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ByeGetNthSsrc (gst_rtcp_packet_bye_get_nth_ssrc): get the nth SSRC of the BYE
// packet.
//
// The function takes the following parameters:
//
//   - nth SSRC to get.
//
// The function returns the following values:
//
//   - guint32: nth SSRC of packet.
func (packet *RTCPPacket) ByeGetNthSsrc(nth uint) uint32 {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint          // out
	var _cret C.guint32        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint(nth)

	_cret = C.gst_rtcp_packet_bye_get_nth_ssrc(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(nth)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// ByeGetReason (gst_rtcp_packet_bye_get_reason): get the reason in packet.
//
// The function returns the following values:
//
//   - utf8 (optional): reason for the BYE packet or NULL if the packet did not
//     contain a reason string. The string must be freed with g_free() after
//     usage.
func (packet *RTCPPacket) ByeGetReason() string {
	var _arg0 *C.GstRTCPPacket // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_bye_get_reason(_arg0)
	runtime.KeepAlive(packet)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// ByeGetReasonLen (gst_rtcp_packet_bye_get_reason_len): get the length of the
// reason string.
//
// The function returns the following values:
//
//   - guint8: length of the reason string or 0 when there is no reason string
//     present.
func (packet *RTCPPacket) ByeGetReasonLen() byte {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint8         // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_bye_get_reason_len(_arg0)
	runtime.KeepAlive(packet)

	var _guint8 byte // out

	_guint8 = byte(_cret)

	return _guint8
}

// ByeGetSsrcCount (gst_rtcp_packet_bye_get_ssrc_count): get the number of SSRC
// fields in packet.
//
// The function returns the following values:
//
//   - guint: number of SSRC fields in packet.
func (packet *RTCPPacket) ByeGetSsrcCount() uint {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint          // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_bye_get_ssrc_count(_arg0)
	runtime.KeepAlive(packet)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ByeSetReason (gst_rtcp_packet_bye_set_reason): set the reason string to
// reason in packet.
//
// The function takes the following parameters:
//
//   - reason string.
//
// The function returns the following values:
//
//   - ok: TRUE if the string could be set.
func (packet *RTCPPacket) ByeSetReason(reason string) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.gchar         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(reason)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_rtcp_packet_bye_set_reason(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(reason)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CopyProfileSpecificExt (gst_rtcp_packet_copy_profile_specific_ext):
// profile-specific extension data is copied into a new allocated memory area
// data. This must be freed with g_free() after usage.
//
// The function returns the following values:
//
//   - data: result profile-specific data.
//   - ok: TRUE if there was valid data.
func (packet *RTCPPacket) CopyProfileSpecificExt() ([]byte, bool) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint8        // in
	var _arg2 C.guint          // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_copy_profile_specific_ext(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(packet)

	var _data []byte // out
	var _ok bool     // out

	defer C.free(unsafe.Pointer(_arg1))
	_data = make([]byte, _arg2)
	copy(_data, unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), _arg2))
	if _cret != 0 {
		_ok = true
	}

	return _data, _ok
}

// FbGetFci (gst_rtcp_packet_fb_get_fci): get the Feedback Control Information
// attached to a RTPFB or PSFB packet.
//
// The function returns the following values:
//
//   - guint8: pointer to the FCI.
func (packet *RTCPPacket) FbGetFci() *byte {
	var _arg0 *C.GstRTCPPacket // out
	var _cret *C.guint8        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_fb_get_fci(_arg0)
	runtime.KeepAlive(packet)

	var _guint8 *byte // out

	_guint8 = (*byte)(unsafe.Pointer(_cret))

	return _guint8
}

// FbGetFciLength (gst_rtcp_packet_fb_get_fci_length): get the length of the
// Feedback Control Information attached to a RTPFB or PSFB packet.
//
// The function returns the following values:
//
//   - guint16: length of the FCI in 32-bit words.
func (packet *RTCPPacket) FbGetFciLength() uint16 {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint16        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_fb_get_fci_length(_arg0)
	runtime.KeepAlive(packet)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// FbGetMediaSsrc (gst_rtcp_packet_fb_get_media_ssrc): get the media SSRC field
// of the RTPFB or PSFB packet.
//
// The function returns the following values:
//
//   - guint32: media SSRC.
func (packet *RTCPPacket) FbGetMediaSsrc() uint32 {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint32        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_fb_get_media_ssrc(_arg0)
	runtime.KeepAlive(packet)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// FbGetSenderSsrc (gst_rtcp_packet_fb_get_sender_ssrc): get the sender SSRC
// field of the RTPFB or PSFB packet.
//
// The function returns the following values:
//
//   - guint32: sender SSRC.
func (packet *RTCPPacket) FbGetSenderSsrc() uint32 {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint32        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_fb_get_sender_ssrc(_arg0)
	runtime.KeepAlive(packet)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// FbGetType (gst_rtcp_packet_fb_get_type): get the feedback message type of the
// FB packet.
//
// The function returns the following values:
//
//   - rtcpfbType: feedback message type.
func (packet *RTCPPacket) FbGetType() RTCPFBType {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.GstRTCPFBType  // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_fb_get_type(_arg0)
	runtime.KeepAlive(packet)

	var _rtcpfbType RTCPFBType // out

	_rtcpfbType = RTCPFBType(_cret)

	return _rtcpfbType
}

// FbSetFciLength (gst_rtcp_packet_fb_set_fci_length): set the length of the
// Feedback Control Information attached to a RTPFB or PSFB packet.
//
// The function takes the following parameters:
//
//   - wordlen: length of the FCI in 32-bit words.
//
// The function returns the following values:
//
//   - ok: TRUE if there was enough space in the packet to add this much FCI.
func (packet *RTCPPacket) FbSetFciLength(wordlen uint16) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint16        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint16(wordlen)

	_cret = C.gst_rtcp_packet_fb_set_fci_length(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(wordlen)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FbSetMediaSsrc (gst_rtcp_packet_fb_set_media_ssrc): set the media SSRC field
// of the RTPFB or PSFB packet.
//
// The function takes the following parameters:
//
//   - ssrc: media SSRC.
func (packet *RTCPPacket) FbSetMediaSsrc(ssrc uint32) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint32        // out

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint32(ssrc)

	C.gst_rtcp_packet_fb_set_media_ssrc(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)
}

// FbSetSenderSsrc (gst_rtcp_packet_fb_set_sender_ssrc): set the sender SSRC
// field of the RTPFB or PSFB packet.
//
// The function takes the following parameters:
//
//   - ssrc: sender SSRC.
func (packet *RTCPPacket) FbSetSenderSsrc(ssrc uint32) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint32        // out

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint32(ssrc)

	C.gst_rtcp_packet_fb_set_sender_ssrc(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)
}

// FbSetType (gst_rtcp_packet_fb_set_type): set the feedback message type of the
// FB packet.
//
// The function takes the following parameters:
//
//   - typ to set.
func (packet *RTCPPacket) FbSetType(typ RTCPFBType) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.GstRTCPFBType  // out

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.GstRTCPFBType(typ)

	C.gst_rtcp_packet_fb_set_type(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(typ)
}

// Count (gst_rtcp_packet_get_count): get the count field in packet.
//
// The function returns the following values:
//
//   - guint8: count field in packet or -1 if packet does not point to a valid
//     packet.
func (packet *RTCPPacket) Count() byte {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint8         // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_get_count(_arg0)
	runtime.KeepAlive(packet)

	var _guint8 byte // out

	_guint8 = byte(_cret)

	return _guint8
}

// Length (gst_rtcp_packet_get_length): get the length field of packet. This is
// the length of the packet in 32-bit words minus one.
//
// The function returns the following values:
//
//   - guint16: length field of packet.
func (packet *RTCPPacket) Length() uint16 {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint16        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_get_length(_arg0)
	runtime.KeepAlive(packet)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// Padding (gst_rtcp_packet_get_padding): get the packet padding of the packet
// pointed to by packet.
//
// The function returns the following values:
//
//   - ok: if the packet has the padding bit set.
func (packet *RTCPPacket) Padding() bool {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_get_padding(_arg0)
	runtime.KeepAlive(packet)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - data: result profile-specific data.
//   - ok: TRUE if there was valid data.
func (packet *RTCPPacket) ProfileSpecificExt() ([]byte, bool) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint8        // in
	var _arg2 C.guint          // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_get_profile_specific_ext(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(packet)

	var _data []byte // out
	var _ok bool     // out

	_data = make([]byte, _arg2)
	copy(_data, unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), _arg2))
	if _cret != 0 {
		_ok = true
	}

	return _data, _ok
}

// The function returns the following values:
//
//   - guint16: number of 32-bit words containing profile-specific extension
//     data from packet.
func (packet *RTCPPacket) ProfileSpecificExtLength() uint16 {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint16        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_get_profile_specific_ext_length(_arg0)
	runtime.KeepAlive(packet)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// Rb (gst_rtcp_packet_get_rb): parse the values of the nth report block in
// packet and store the result in the values.
//
// The function takes the following parameters:
//
//   - nth report block in packet.
//
// The function returns the following values:
//
//   - ssrc: result for data source being reported.
//   - fractionlost: result for fraction lost since last SR/RR.
//   - packetslost: result for the cumululative number of packets lost.
//   - exthighestseq: result for the extended last sequence number received.
//   - jitter: result for the interarrival jitter.
//   - lsr: result for the last SR packet from this source.
//   - dlsr: result for the delay since last SR packet.
func (packet *RTCPPacket) Rb(nth uint) (ssrc uint32, fractionlost byte, packetslost int32, exthighestseq uint32, jitter uint32, lsr uint32, dlsr uint32) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint          // out
	var _arg2 C.guint32        // in
	var _arg3 C.guint8         // in
	var _arg4 C.gint32         // in
	var _arg5 C.guint32        // in
	var _arg6 C.guint32        // in
	var _arg7 C.guint32        // in
	var _arg8 C.guint32        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint(nth)

	C.gst_rtcp_packet_get_rb(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5, &_arg6, &_arg7, &_arg8)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(nth)

	var _ssrc uint32          // out
	var _fractionlost byte    // out
	var _packetslost int32    // out
	var _exthighestseq uint32 // out
	var _jitter uint32        // out
	var _lsr uint32           // out
	var _dlsr uint32          // out

	_ssrc = uint32(_arg2)
	_fractionlost = byte(_arg3)
	_packetslost = int32(_arg4)
	_exthighestseq = uint32(_arg5)
	_jitter = uint32(_arg6)
	_lsr = uint32(_arg7)
	_dlsr = uint32(_arg8)

	return _ssrc, _fractionlost, _packetslost, _exthighestseq, _jitter, _lsr, _dlsr
}

// RbCount (gst_rtcp_packet_get_rb_count): get the number of report blocks in
// packet.
//
// The function returns the following values:
//
//   - guint: number of report blocks in packet.
func (packet *RTCPPacket) RbCount() uint {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint          // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_get_rb_count(_arg0)
	runtime.KeepAlive(packet)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Type (gst_rtcp_packet_get_type): get the packet type of the packet pointed to
// by packet.
//
// The function returns the following values:
//
//   - rtcpType: packet type or GST_RTCP_TYPE_INVALID when packet is not
//     pointing to a valid packet.
func (packet *RTCPPacket) Type() RTCPType {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.GstRTCPType    // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_get_type(_arg0)
	runtime.KeepAlive(packet)

	var _rtcpType RTCPType // out

	_rtcpType = RTCPType(_cret)

	return _rtcpType
}

// MoveToNext (gst_rtcp_packet_move_to_next): move the packet pointer packet
// to the next packet in the payload. Use gst_rtcp_buffer_get_first_packet() to
// initialize packet.
//
// The function returns the following values:
//
//   - ok: TRUE if packet is pointing to a valid packet after calling this
//     function.
func (packet *RTCPPacket) MoveToNext() bool {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_move_to_next(_arg0)
	runtime.KeepAlive(packet)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Remove (gst_rtcp_packet_remove) removes the packet pointed to by packet and
// moves pointer to the next one.
//
// The function returns the following values:
//
//   - ok: TRUE if packet is pointing to a valid packet after calling this
//     function.
func (packet *RTCPPacket) Remove() bool {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_remove(_arg0)
	runtime.KeepAlive(packet)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RrGetSsrc (gst_rtcp_packet_rr_get_ssrc): get the ssrc field of the RR packet.
//
// The function returns the following values:
//
//   - guint32: ssrc.
func (packet *RTCPPacket) RrGetSsrc() uint32 {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint32        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_rr_get_ssrc(_arg0)
	runtime.KeepAlive(packet)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// RrSetSsrc (gst_rtcp_packet_rr_set_ssrc): set the ssrc field of the RR packet.
//
// The function takes the following parameters:
//
//   - ssrc: SSRC to set.
func (packet *RTCPPacket) RrSetSsrc(ssrc uint32) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint32        // out

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint32(ssrc)

	C.gst_rtcp_packet_rr_set_ssrc(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)
}

// SdesAddEntry (gst_rtcp_packet_sdes_add_entry): add a new SDES entry to the
// current item in packet.
//
// The function takes the following parameters:
//
//   - typ of the SDES entry.
//   - data: data.
//
// The function returns the following values:
//
//   - ok: TRUE if the item could be added, FALSE if the MTU has been reached.
func (packet *RTCPPacket) SdesAddEntry(typ RTCPSDESType, data []byte) bool {
	var _arg0 *C.GstRTCPPacket  // out
	var _arg1 C.GstRTCPSDESType // out
	var _arg3 *C.guint8         // out
	var _arg2 C.guint8
	var _cret C.gboolean // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.GstRTCPSDESType(typ)
	_arg2 = (C.guint8)(len(data))
	if len(data) > 0 {
		_arg3 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_rtcp_packet_sdes_add_entry(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(data)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SdesAddItem (gst_rtcp_packet_sdes_add_item): add a new SDES item for ssrc to
// packet.
//
// The function takes the following parameters:
//
//   - ssrc: SSRC of the new item to add.
//
// The function returns the following values:
//
//   - ok: TRUE if the item could be added, FALSE if the maximum amount of items
//     has been exceeded for the SDES packet or the MTU has been reached.
func (packet *RTCPPacket) SdesAddItem(ssrc uint32) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint32        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint32(ssrc)

	_cret = C.gst_rtcp_packet_sdes_add_item(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SdesCopyEntry (gst_rtcp_packet_sdes_copy_entry): this function is like
// gst_rtcp_packet_sdes_get_entry() but it returns a null-terminated copy of the
// data instead. use g_free() after usage.
//
// The function takes the following parameters:
//
//   - typ: result of the entry type.
//
// The function returns the following values:
//
//   - data: result entry data.
//   - ok: TRUE if there was valid data.
func (packet *RTCPPacket) SdesCopyEntry(typ *RTCPSDESType) ([]byte, bool) {
	var _arg0 *C.GstRTCPPacket   // out
	var _arg1 *C.GstRTCPSDESType // out
	var _arg3 *C.guint8          // in
	var _arg2 C.guint8           // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.GstRTCPSDESType)(unsafe.Pointer(typ))

	_cret = C.gst_rtcp_packet_sdes_copy_entry(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(typ)

	var _data []byte // out
	var _ok bool     // out

	defer C.free(unsafe.Pointer(_arg3))
	_data = make([]byte, _arg2)
	copy(_data, unsafe.Slice((*byte)(unsafe.Pointer(_arg3)), _arg2))
	if _cret != 0 {
		_ok = true
	}

	return _data, _ok
}

// SdesFirstEntry (gst_rtcp_packet_sdes_first_entry): move to the first SDES
// entry in the current item.
//
// The function returns the following values:
//
//   - ok: TRUE if there was a first entry.
func (packet *RTCPPacket) SdesFirstEntry() bool {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_sdes_first_entry(_arg0)
	runtime.KeepAlive(packet)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SdesFirstItem (gst_rtcp_packet_sdes_first_item): move to the first SDES item
// in packet.
//
// The function returns the following values:
//
//   - ok: TRUE if there was a first item.
func (packet *RTCPPacket) SdesFirstItem() bool {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_sdes_first_item(_arg0)
	runtime.KeepAlive(packet)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SdesGetEntry (gst_rtcp_packet_sdes_get_entry): get the data of the current
// SDES item entry. type (when not NULL) will contain the type of the entry.
// data (when not NULL) will point to len bytes.
//
// When type refers to a text item, data will point to a UTF8
// string. Note that this UTF8 string is NOT null-terminated. Use
// gst_rtcp_packet_sdes_copy_entry() to get a null-terminated copy of the entry.
//
// The function takes the following parameters:
//
//   - typ: result of the entry type.
//
// The function returns the following values:
//
//   - data: result entry data.
//   - ok: TRUE if there was valid data.
func (packet *RTCPPacket) SdesGetEntry(typ *RTCPSDESType) ([]byte, bool) {
	var _arg0 *C.GstRTCPPacket   // out
	var _arg1 *C.GstRTCPSDESType // out
	var _arg3 *C.guint8          // in
	var _arg2 C.guint8           // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.GstRTCPSDESType)(unsafe.Pointer(typ))

	_cret = C.gst_rtcp_packet_sdes_get_entry(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(typ)

	var _data []byte // out
	var _ok bool     // out

	_data = make([]byte, _arg2)
	copy(_data, unsafe.Slice((*byte)(unsafe.Pointer(_arg3)), _arg2))
	if _cret != 0 {
		_ok = true
	}

	return _data, _ok
}

// SdesGetItemCount (gst_rtcp_packet_sdes_get_item_count): get the number of
// items in the SDES packet packet.
//
// The function returns the following values:
//
//   - guint: number of items in packet.
func (packet *RTCPPacket) SdesGetItemCount() uint {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint          // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_sdes_get_item_count(_arg0)
	runtime.KeepAlive(packet)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SdesGetSsrc (gst_rtcp_packet_sdes_get_ssrc): get the SSRC of the current SDES
// item.
//
// The function returns the following values:
//
//   - guint32: SSRC of the current item.
func (packet *RTCPPacket) SdesGetSsrc() uint32 {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint32        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_sdes_get_ssrc(_arg0)
	runtime.KeepAlive(packet)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// SdesNextEntry (gst_rtcp_packet_sdes_next_entry): move to the next SDES entry
// in the current item.
//
// The function returns the following values:
//
//   - ok: TRUE if there was a next entry.
func (packet *RTCPPacket) SdesNextEntry() bool {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_sdes_next_entry(_arg0)
	runtime.KeepAlive(packet)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SdesNextItem (gst_rtcp_packet_sdes_next_item): move to the next SDES item in
// packet.
//
// The function returns the following values:
//
//   - ok: TRUE if there was a next item.
func (packet *RTCPPacket) SdesNextItem() bool {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_sdes_next_item(_arg0)
	runtime.KeepAlive(packet)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetRb (gst_rtcp_packet_set_rb): set the nth new report block in packet with
// the given values.
//
// Note: Not implemented.
//
// The function takes the following parameters:
//
//   - nth report block to set.
//   - ssrc: data source being reported.
//   - fractionlost: fraction lost since last SR/RR.
//   - packetslost: cumululative number of packets lost.
//   - exthighestseq: extended last sequence number received.
//   - jitter: interarrival jitter.
//   - lsr: last SR packet from this source.
//   - dlsr: delay since last SR packet.
func (packet *RTCPPacket) SetRb(nth uint, ssrc uint32, fractionlost byte, packetslost int32, exthighestseq uint32, jitter uint32, lsr uint32, dlsr uint32) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint          // out
	var _arg2 C.guint32        // out
	var _arg3 C.guint8         // out
	var _arg4 C.gint32         // out
	var _arg5 C.guint32        // out
	var _arg6 C.guint32        // out
	var _arg7 C.guint32        // out
	var _arg8 C.guint32        // out

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint(nth)
	_arg2 = C.guint32(ssrc)
	_arg3 = C.guint8(fractionlost)
	_arg4 = C.gint32(packetslost)
	_arg5 = C.guint32(exthighestseq)
	_arg6 = C.guint32(jitter)
	_arg7 = C.guint32(lsr)
	_arg8 = C.guint32(dlsr)

	C.gst_rtcp_packet_set_rb(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(nth)
	runtime.KeepAlive(ssrc)
	runtime.KeepAlive(fractionlost)
	runtime.KeepAlive(packetslost)
	runtime.KeepAlive(exthighestseq)
	runtime.KeepAlive(jitter)
	runtime.KeepAlive(lsr)
	runtime.KeepAlive(dlsr)
}

// SrGetSenderInfo (gst_rtcp_packet_sr_get_sender_info): parse the SR sender
// info and store the values.
//
// The function returns the following values:
//
//   - ssrc: result SSRC.
//   - ntptime: result NTP time.
//   - rtptime: result RTP time.
//   - packetCount: result packet count.
//   - octetCount: result octet count.
func (packet *RTCPPacket) SrGetSenderInfo() (ssrc uint32, ntptime uint64, rtptime uint32, packetCount uint32, octetCount uint32) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint32        // in
	var _arg2 C.guint64        // in
	var _arg3 C.guint32        // in
	var _arg4 C.guint32        // in
	var _arg5 C.guint32        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	C.gst_rtcp_packet_sr_get_sender_info(_arg0, &_arg1, &_arg2, &_arg3, &_arg4, &_arg5)
	runtime.KeepAlive(packet)

	var _ssrc uint32        // out
	var _ntptime uint64     // out
	var _rtptime uint32     // out
	var _packetCount uint32 // out
	var _octetCount uint32  // out

	_ssrc = uint32(_arg1)
	_ntptime = uint64(_arg2)
	_rtptime = uint32(_arg3)
	_packetCount = uint32(_arg4)
	_octetCount = uint32(_arg5)

	return _ssrc, _ntptime, _rtptime, _packetCount, _octetCount
}

// SrSetSenderInfo (gst_rtcp_packet_sr_set_sender_info): set the given values in
// the SR packet packet.
//
// The function takes the following parameters:
//
//   - ssrc: SSRC.
//   - ntptime: NTP time.
//   - rtptime: RTP time.
//   - packetCount: packet count.
//   - octetCount: octet count.
func (packet *RTCPPacket) SrSetSenderInfo(ssrc uint32, ntptime uint64, rtptime uint32, packetCount uint32, octetCount uint32) {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint32        // out
	var _arg2 C.guint64        // out
	var _arg3 C.guint32        // out
	var _arg4 C.guint32        // out
	var _arg5 C.guint32        // out

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint32(ssrc)
	_arg2 = C.guint64(ntptime)
	_arg3 = C.guint32(rtptime)
	_arg4 = C.guint32(packetCount)
	_arg5 = C.guint32(octetCount)

	C.gst_rtcp_packet_sr_set_sender_info(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)
	runtime.KeepAlive(ntptime)
	runtime.KeepAlive(rtptime)
	runtime.KeepAlive(packetCount)
	runtime.KeepAlive(octetCount)
}

// XRFirstRb (gst_rtcp_packet_xr_first_rb): move to the first extended report
// block in XR packet.
//
// The function returns the following values:
//
//   - ok: TRUE if there was a first extended report block.
func (packet *RTCPPacket) XRFirstRb() bool {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_xr_first_rb(_arg0)
	runtime.KeepAlive(packet)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - guint16: number of 32-bit words containing type-specific block data from
//     packet.
func (packet *RTCPPacket) XRGetBlockLength() uint16 {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint16        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_xr_get_block_length(_arg0)
	runtime.KeepAlive(packet)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// XRGetBlockType (gst_rtcp_packet_xr_get_block_type): get the extended report
// block type of the XR packet.
//
// The function returns the following values:
//
//   - rtcpxrType: extended report block type.
func (packet *RTCPPacket) XRGetBlockType() RTCPXRType {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.GstRTCPXRType  // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_xr_get_block_type(_arg0)
	runtime.KeepAlive(packet)

	var _rtcpxrType RTCPXRType // out

	_rtcpxrType = RTCPXRType(_cret)

	return _rtcpxrType
}

// XRGetDlrrBlock (gst_rtcp_packet_xr_get_dlrr_block): parse the extended report
// block for DLRR report block type.
//
// The function takes the following parameters:
//
//   - nth: index of sub-block to retrieve.
//   - ssrc: SSRC of the receiver.
//   - lastRr: last receiver reference timestamp of ssrc.
//   - delay since last_rr.
//
// The function returns the following values:
//
//   - ok: TRUE if the report block is correctly parsed.
func (packet *RTCPPacket) XRGetDlrrBlock(nth uint, ssrc *uint32, lastRr *uint32, delay *uint32) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint          // out
	var _arg2 *C.guint32       // out
	var _arg3 *C.guint32       // out
	var _arg4 *C.guint32       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint(nth)
	_arg2 = (*C.guint32)(unsafe.Pointer(ssrc))
	_arg3 = (*C.guint32)(unsafe.Pointer(lastRr))
	_arg4 = (*C.guint32)(unsafe.Pointer(delay))

	_cret = C.gst_rtcp_packet_xr_get_dlrr_block(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(nth)
	runtime.KeepAlive(ssrc)
	runtime.KeepAlive(lastRr)
	runtime.KeepAlive(delay)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// XRGetPrtBySeq (gst_rtcp_packet_xr_get_prt_by_seq): retrieve the packet
// receipt time of seq which ranges in [begin_seq, end_seq).
//
// The function takes the following parameters:
//
//   - seq: sequence to retrieve the time.
//   - receiptTime: packet receipt time of seq.
//
// The function returns the following values:
//
//   - ok: TRUE if the report block returns the receipt time correctly.
func (packet *RTCPPacket) XRGetPrtBySeq(seq uint16, receiptTime *uint32) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint16        // out
	var _arg2 *C.guint32       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint16(seq)
	_arg2 = (*C.guint32)(unsafe.Pointer(receiptTime))

	_cret = C.gst_rtcp_packet_xr_get_prt_by_seq(_arg0, _arg1, _arg2)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(seq)
	runtime.KeepAlive(receiptTime)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// XRGetPrtInfo (gst_rtcp_packet_xr_get_prt_info): parse the Packet Recept Times
// Report Block from a XR packet.
//
// The function takes the following parameters:
//
//   - ssrc: SSRC of the RTP data packet source being reported upon by this
//     report block.
//   - thinning: amount of thinning performed on the sequence number space.
//   - beginSeq: first sequence number that this block reports on.
//   - endSeq: last sequence number that this block reports on plus one.
//
// The function returns the following values:
//
//   - ok: TRUE if the report block is correctly parsed.
func (packet *RTCPPacket) XRGetPrtInfo(ssrc *uint32, thinning *byte, beginSeq *uint16, endSeq *uint16) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint32       // out
	var _arg2 *C.guint8        // out
	var _arg3 *C.guint16       // out
	var _arg4 *C.guint16       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint32)(unsafe.Pointer(ssrc))
	_arg2 = (*C.guint8)(unsafe.Pointer(thinning))
	_arg3 = (*C.guint16)(unsafe.Pointer(beginSeq))
	_arg4 = (*C.guint16)(unsafe.Pointer(endSeq))

	_cret = C.gst_rtcp_packet_xr_get_prt_info(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)
	runtime.KeepAlive(thinning)
	runtime.KeepAlive(beginSeq)
	runtime.KeepAlive(endSeq)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// XRGetRLEInfo (gst_rtcp_packet_xr_get_rle_info): parse the extended report
// block for Loss RLE and Duplicated LRE block type.
//
// The function takes the following parameters:
//
//   - ssrc: SSRC of the RTP data packet source being reported upon by this
//     report block.
//   - thinning: amount of thinning performed on the sequence number space.
//   - beginSeq: first sequence number that this block reports on.
//   - endSeq: last sequence number that this block reports on plus one.
//   - chunkCount: number of chunks calculated by block length.
//
// The function returns the following values:
//
//   - ok: TRUE if the report block is correctly parsed.
func (packet *RTCPPacket) XRGetRLEInfo(ssrc *uint32, thinning *byte, beginSeq *uint16, endSeq *uint16, chunkCount *uint32) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint32       // out
	var _arg2 *C.guint8        // out
	var _arg3 *C.guint16       // out
	var _arg4 *C.guint16       // out
	var _arg5 *C.guint32       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint32)(unsafe.Pointer(ssrc))
	_arg2 = (*C.guint8)(unsafe.Pointer(thinning))
	_arg3 = (*C.guint16)(unsafe.Pointer(beginSeq))
	_arg4 = (*C.guint16)(unsafe.Pointer(endSeq))
	_arg5 = (*C.guint32)(unsafe.Pointer(chunkCount))

	_cret = C.gst_rtcp_packet_xr_get_rle_info(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)
	runtime.KeepAlive(thinning)
	runtime.KeepAlive(beginSeq)
	runtime.KeepAlive(endSeq)
	runtime.KeepAlive(chunkCount)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// XRGetRLENthChunk (gst_rtcp_packet_xr_get_rle_nth_chunk): retrieve actual
// chunk data.
//
// The function takes the following parameters:
//
//   - nth: index of chunk to retrieve.
//   - chunk: nth chunk.
//
// The function returns the following values:
//
//   - ok: TRUE if the report block returns chunk correctly.
func (packet *RTCPPacket) XRGetRLENthChunk(nth uint, chunk *uint16) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 C.guint          // out
	var _arg2 *C.guint16       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = C.guint(nth)
	_arg2 = (*C.guint16)(unsafe.Pointer(chunk))

	_cret = C.gst_rtcp_packet_xr_get_rle_nth_chunk(_arg0, _arg1, _arg2)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(nth)
	runtime.KeepAlive(chunk)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - timestamp: NTP timestamp.
//
// The function returns the following values:
//
//   - ok: TRUE if the report block returns the reference time correctly.
func (packet *RTCPPacket) XRGetRrt(timestamp *uint64) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint64       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint64)(unsafe.Pointer(timestamp))

	_cret = C.gst_rtcp_packet_xr_get_rrt(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(timestamp)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// XRGetSsrc (gst_rtcp_packet_xr_get_ssrc): get the ssrc field of the XR packet.
//
// The function returns the following values:
//
//   - guint32: ssrc.
func (packet *RTCPPacket) XRGetSsrc() uint32 {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.guint32        // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_xr_get_ssrc(_arg0)
	runtime.KeepAlive(packet)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// XRGetSummaryInfo (gst_rtcp_packet_xr_get_summary_info): extract a basic
// information from static summary report block of XR packet.
//
// The function takes the following parameters:
//
//   - ssrc: SSRC of the source.
//   - beginSeq: first sequence number that this block reports on.
//   - endSeq: last sequence number that this block reports on plus one.
//
// The function returns the following values:
//
//   - ok: TRUE if the report block is correctly parsed.
func (packet *RTCPPacket) XRGetSummaryInfo(ssrc *uint32, beginSeq *uint16, endSeq *uint16) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint32       // out
	var _arg2 *C.guint16       // out
	var _arg3 *C.guint16       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint32)(unsafe.Pointer(ssrc))
	_arg2 = (*C.guint16)(unsafe.Pointer(beginSeq))
	_arg3 = (*C.guint16)(unsafe.Pointer(endSeq))

	_cret = C.gst_rtcp_packet_xr_get_summary_info(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)
	runtime.KeepAlive(beginSeq)
	runtime.KeepAlive(endSeq)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// XRGetSummaryJitter (gst_rtcp_packet_xr_get_summary_jitter): extract jitter
// information from the statistics summary. If the jitter flag in a block header
// is set as zero, all of jitters will be zero.
//
// The function takes the following parameters:
//
//   - minJitter: minimum relative transit time between two sequences.
//   - maxJitter: maximum relative transit time between two sequences.
//   - meanJitter: mean relative transit time between two sequences.
//   - devJitter: standard deviation of the relative transit time between two
//     sequences.
//
// The function returns the following values:
//
//   - ok: TRUE if the report block is correctly parsed.
func (packet *RTCPPacket) XRGetSummaryJitter(minJitter *uint32, maxJitter *uint32, meanJitter *uint32, devJitter *uint32) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint32       // out
	var _arg2 *C.guint32       // out
	var _arg3 *C.guint32       // out
	var _arg4 *C.guint32       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint32)(unsafe.Pointer(minJitter))
	_arg2 = (*C.guint32)(unsafe.Pointer(maxJitter))
	_arg3 = (*C.guint32)(unsafe.Pointer(meanJitter))
	_arg4 = (*C.guint32)(unsafe.Pointer(devJitter))

	_cret = C.gst_rtcp_packet_xr_get_summary_jitter(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(minJitter)
	runtime.KeepAlive(maxJitter)
	runtime.KeepAlive(meanJitter)
	runtime.KeepAlive(devJitter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// XRGetSummaryPkt (gst_rtcp_packet_xr_get_summary_pkt): get the number of
// lost or duplicate packets. If the flag in a block header is set as zero,
// lost_packets or dup_packets will be zero.
//
// The function takes the following parameters:
//
//   - lostPackets: number of lost packets between begin_seq and end_seq.
//   - dupPackets: number of duplicate packets between begin_seq and end_seq.
//
// The function returns the following values:
//
//   - ok: TRUE if the report block is correctly parsed.
func (packet *RTCPPacket) XRGetSummaryPkt(lostPackets *uint32, dupPackets *uint32) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint32       // out
	var _arg2 *C.guint32       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint32)(unsafe.Pointer(lostPackets))
	_arg2 = (*C.guint32)(unsafe.Pointer(dupPackets))

	_cret = C.gst_rtcp_packet_xr_get_summary_pkt(_arg0, _arg1, _arg2)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(lostPackets)
	runtime.KeepAlive(dupPackets)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - burstDensity: fraction of RTP data packets within burst periods.
//   - gapDensity: fraction of RTP data packets within inter-burst gaps.
//   - burstDuration: mean duration(ms) of the burst periods.
//   - gapDuration: mean duration(ms) of the gap periods.
//
// The function returns the following values:
//
//   - ok: TRUE if the report block is correctly parsed.
func (packet *RTCPPacket) XRGetVoipBurstMetrics(burstDensity *byte, gapDensity *byte, burstDuration *uint16, gapDuration *uint16) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint8        // out
	var _arg2 *C.guint8        // out
	var _arg3 *C.guint16       // out
	var _arg4 *C.guint16       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint8)(unsafe.Pointer(burstDensity))
	_arg2 = (*C.guint8)(unsafe.Pointer(gapDensity))
	_arg3 = (*C.guint16)(unsafe.Pointer(burstDuration))
	_arg4 = (*C.guint16)(unsafe.Pointer(gapDuration))

	_cret = C.gst_rtcp_packet_xr_get_voip_burst_metrics(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(burstDensity)
	runtime.KeepAlive(gapDensity)
	runtime.KeepAlive(burstDuration)
	runtime.KeepAlive(gapDuration)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - gmin: gap threshold.
//   - rxConfig: receiver configuration byte.
//
// The function returns the following values:
//
//   - ok: TRUE if the report block is correctly parsed.
func (packet *RTCPPacket) XRGetVoipConfigurationParams(gmin *byte, rxConfig *byte) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint8        // out
	var _arg2 *C.guint8        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint8)(unsafe.Pointer(gmin))
	_arg2 = (*C.guint8)(unsafe.Pointer(rxConfig))

	_cret = C.gst_rtcp_packet_xr_get_voip_configuration_params(_arg0, _arg1, _arg2)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(gmin)
	runtime.KeepAlive(rxConfig)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - roundtripDelay: most recently calculated round trip time between RTP
//     interfaces(ms).
//   - endSystemDelay: most recently estimated end system delay(ms).
//
// The function returns the following values:
//
//   - ok: TRUE if the report block is correctly parsed.
func (packet *RTCPPacket) XRGetVoipDelayMetrics(roundtripDelay *uint16, endSystemDelay *uint16) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint16       // out
	var _arg2 *C.guint16       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint16)(unsafe.Pointer(roundtripDelay))
	_arg2 = (*C.guint16)(unsafe.Pointer(endSystemDelay))

	_cret = C.gst_rtcp_packet_xr_get_voip_delay_metrics(_arg0, _arg1, _arg2)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(roundtripDelay)
	runtime.KeepAlive(endSystemDelay)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - jbNominal: current nominal jitter buffer delay(ms).
//   - jbMaximum: current maximum jitter buffer delay(ms).
//   - jbAbsMax: absolute maximum delay(ms).
//
// The function returns the following values:
//
//   - ok: TRUE if the report block is correctly parsed.
func (packet *RTCPPacket) XRGetVoipJitterBufferParams(jbNominal *uint16, jbMaximum *uint16, jbAbsMax *uint16) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint16       // out
	var _arg2 *C.guint16       // out
	var _arg3 *C.guint16       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint16)(unsafe.Pointer(jbNominal))
	_arg2 = (*C.guint16)(unsafe.Pointer(jbMaximum))
	_arg3 = (*C.guint16)(unsafe.Pointer(jbAbsMax))

	_cret = C.gst_rtcp_packet_xr_get_voip_jitter_buffer_params(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(jbNominal)
	runtime.KeepAlive(jbMaximum)
	runtime.KeepAlive(jbAbsMax)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - ssrc: SSRC of source.
//
// The function returns the following values:
//
//   - ok: TRUE if the report block is correctly parsed.
func (packet *RTCPPacket) XRGetVoipMetricsSsrc(ssrc *uint32) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint32       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint32)(unsafe.Pointer(ssrc))

	_cret = C.gst_rtcp_packet_xr_get_voip_metrics_ssrc(_arg0, _arg1)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(ssrc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - lossRate: fraction of RTP data packets from the source lost.
//   - discardRate: fraction of RTP data packets from the source that have been
//     discarded.
//
// The function returns the following values:
//
//   - ok: TRUE if the report block is correctly parsed.
func (packet *RTCPPacket) XRGetVoipPacketMetrics(lossRate *byte, discardRate *byte) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint8        // out
	var _arg2 *C.guint8        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint8)(unsafe.Pointer(lossRate))
	_arg2 = (*C.guint8)(unsafe.Pointer(discardRate))

	_cret = C.gst_rtcp_packet_xr_get_voip_packet_metrics(_arg0, _arg1, _arg2)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(lossRate)
	runtime.KeepAlive(discardRate)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - rFactor: r factor is a voice quality metric describing the segment of the
//     call.
//   - extRFactor: external R factor is a voice quality metric.
//   - mosLq: estimated mean opinion score for listening quality.
//   - mosCq: estimated mean opinion score for conversational quality.
//
// The function returns the following values:
//
//   - ok: TRUE if the report block is correctly parsed.
func (packet *RTCPPacket) XRGetVoipQualityMetrics(rFactor *byte, extRFactor *byte, mosLq *byte, mosCq *byte) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint8        // out
	var _arg2 *C.guint8        // out
	var _arg3 *C.guint8        // out
	var _arg4 *C.guint8        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint8)(unsafe.Pointer(rFactor))
	_arg2 = (*C.guint8)(unsafe.Pointer(extRFactor))
	_arg3 = (*C.guint8)(unsafe.Pointer(mosLq))
	_arg4 = (*C.guint8)(unsafe.Pointer(mosCq))

	_cret = C.gst_rtcp_packet_xr_get_voip_quality_metrics(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(rFactor)
	runtime.KeepAlive(extRFactor)
	runtime.KeepAlive(mosLq)
	runtime.KeepAlive(mosCq)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - signalLevel: ratio of the signal level to a 0 dBm reference.
//   - noiseLevel: ratio of the silent period background noise level to a 0 dBm
//     reference.
//   - rerl: residual echo return loss value.
//   - gmin: gap threshold.
//
// The function returns the following values:
//
//   - ok: TRUE if the report block is correctly parsed.
func (packet *RTCPPacket) XRGetVoipSignalMetrics(signalLevel *byte, noiseLevel *byte, rerl *byte, gmin *byte) bool {
	var _arg0 *C.GstRTCPPacket // out
	var _arg1 *C.guint8        // out
	var _arg2 *C.guint8        // out
	var _arg3 *C.guint8        // out
	var _arg4 *C.guint8        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.guint8)(unsafe.Pointer(signalLevel))
	_arg2 = (*C.guint8)(unsafe.Pointer(noiseLevel))
	_arg3 = (*C.guint8)(unsafe.Pointer(rerl))
	_arg4 = (*C.guint8)(unsafe.Pointer(gmin))

	_cret = C.gst_rtcp_packet_xr_get_voip_signal_metrics(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(signalLevel)
	runtime.KeepAlive(noiseLevel)
	runtime.KeepAlive(rerl)
	runtime.KeepAlive(gmin)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// XRNextRb (gst_rtcp_packet_xr_next_rb): move to the next extended report block
// in XR packet.
//
// The function returns the following values:
//
//   - ok: TRUE if there was a next extended report block.
func (packet *RTCPPacket) XRNextRb() bool {
	var _arg0 *C.GstRTCPPacket // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstRTCPPacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_rtcp_packet_xr_next_rb(_arg0)
	runtime.KeepAlive(packet)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RTPBaseAudioPayloadClass (GstRTPBaseAudioPayloadClass): base class for audio
// RTP payloader.
//
// An instance of this type is always passed by reference.
type RTPBaseAudioPayloadClass struct {
	*rtpBaseAudioPayloadClass
}

// rtpBaseAudioPayloadClass is the struct that's finalized.
type rtpBaseAudioPayloadClass struct {
	native *C.GstRTPBaseAudioPayloadClass
}

// ParentClass: parent class.
func (r *RTPBaseAudioPayloadClass) ParentClass() *RTPBasePayloadClass {
	valptr := &r.native.parent_class
	var _v *RTPBasePayloadClass // out
	_v = (*RTPBasePayloadClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// RTPBaseDepayloadClass (GstRTPBaseDepayloadClass): base class for RTP
// depayloaders.
//
// An instance of this type is always passed by reference.
type RTPBaseDepayloadClass struct {
	*rtpBaseDepayloadClass
}

// rtpBaseDepayloadClass is the struct that's finalized.
type rtpBaseDepayloadClass struct {
	native *C.GstRTPBaseDepayloadClass
}

// ParentClass: parent class.
func (r *RTPBaseDepayloadClass) ParentClass() *gst.ElementClass {
	valptr := &r.native.parent_class
	var _v *gst.ElementClass // out
	_v = (*gst.ElementClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// RTPBasePayloadClass (GstRTPBasePayloadClass): base class for audio RTP
// payloader.
//
// An instance of this type is always passed by reference.
type RTPBasePayloadClass struct {
	*rtpBasePayloadClass
}

// rtpBasePayloadClass is the struct that's finalized.
type rtpBasePayloadClass struct {
	native *C.GstRTPBasePayloadClass
}

// ParentClass: parent class.
func (r *RTPBasePayloadClass) ParentClass() *gst.ElementClass {
	valptr := &r.native.parent_class
	var _v *gst.ElementClass // out
	_v = (*gst.ElementClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// RTPBuffer (GstRTPBuffer) helper functions makes it easy to parse and create
// regular Buffer objects that contain RTP payloads. These buffers are typically
// of 'application/x-rtp' Caps.
//
// An instance of this type is always passed by reference.
type RTPBuffer struct {
	*rtpBuffer
}

// rtpBuffer is the struct that's finalized.
type rtpBuffer struct {
	native *C.GstRTPBuffer
}

// Buffer: pointer to RTP buffer.
func (r *RTPBuffer) Buffer() *gst.Buffer {
	valptr := &r.native.buffer
	var _v *gst.Buffer // out
	_v = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_v)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})
	return _v
}

// State: internal state.
func (r *RTPBuffer) State() uint {
	valptr := &r.native.state
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Data: array of data.
func (r *RTPBuffer) Data() [4]unsafe.Pointer {
	valptr := &r.native.data
	var _v [4]unsafe.Pointer // out
	{
		src := &*valptr
		for i := 0; i < 4; i++ {
			_v[i] = (unsafe.Pointer)(unsafe.Pointer(src[i]))
		}
	}
	return _v
}

// Size: array of size.
func (r *RTPBuffer) Size() [4]uint {
	valptr := &r.native.size
	var _v [4]uint // out
	_v = *(*[4]uint)(unsafe.Pointer(&*valptr))
	return _v
}

// Map: array of MapInfo.
func (r *RTPBuffer) Map() [4]gst.MapInfo {
	valptr := &r.native._map
	var _v [4]gst.MapInfo // out
	{
		src := &*valptr
		for i := 0; i < 4; i++ {
			_v[i] = *(*gst.MapInfo)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
		}
	}
	return _v
}

// State: internal state.
func (r *RTPBuffer) SetState(state uint) {
	valptr := &r.native.state
	*valptr = C.guint(state)
}

// AddExtensionOnebyteHeader (gst_rtp_buffer_add_extension_onebyte_header)
// adds a RFC 5285 header extension with a one byte header to the end
// of the RTP header. If there is already a RFC 5285 header extension
// with a one byte header, the new extension will be appended. It will
// not work if there is already a header extension that does not follow
// the mechanism described in RFC 5285 or if there is a header extension
// with a two bytes header as described in RFC 5285. In that case, use
// gst_rtp_buffer_add_extension_twobytes_header().
//
// The function takes the following parameters:
//
//   - id: ID of the header extension (between 1 and 14).
//   - data: location for data.
//
// The function returns the following values:
//
//   - ok: TRUE if header extension could be added.
func (rtp *RTPBuffer) AddExtensionOnebyteHeader(id byte, data []byte) bool {
	var _arg0 *C.GstRTPBuffer // out
	var _arg1 C.guint8        // out
	var _arg2 C.gconstpointer // out
	var _arg3 C.guint
	var _cret C.gboolean // in

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))
	_arg1 = C.guint8(id)
	_arg3 = (C.guint)(len(data))
	if len(data) > 0 {
		_arg2 = (C.gconstpointer)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_rtp_buffer_add_extension_onebyte_header(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(rtp)
	runtime.KeepAlive(id)
	runtime.KeepAlive(data)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AddExtensionTwobytesHeader (gst_rtp_buffer_add_extension_twobytes_header)
// adds a RFC 5285 header extension with a two bytes header to the end
// of the RTP header. If there is already a RFC 5285 header extension
// with a two bytes header, the new extension will be appended. It will
// not work if there is already a header extension that does not follow
// the mechanism described in RFC 5285 or if there is a header extension
// with a one byte header as described in RFC 5285. In that case, use
// gst_rtp_buffer_add_extension_onebyte_header().
//
// The function takes the following parameters:
//
//   - appbits: application specific bits.
//   - id: ID of the header extension.
//   - data: location for data.
//
// The function returns the following values:
//
//   - ok: TRUE if header extension could be added.
func (rtp *RTPBuffer) AddExtensionTwobytesHeader(appbits byte, id byte, data []byte) bool {
	var _arg0 *C.GstRTPBuffer // out
	var _arg1 C.guint8        // out
	var _arg2 C.guint8        // out
	var _arg3 C.gconstpointer // out
	var _arg4 C.guint
	var _cret C.gboolean // in

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))
	_arg1 = C.guint8(appbits)
	_arg2 = C.guint8(id)
	_arg4 = (C.guint)(len(data))
	if len(data) > 0 {
		_arg3 = (C.gconstpointer)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_rtp_buffer_add_extension_twobytes_header(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(rtp)
	runtime.KeepAlive(appbits)
	runtime.KeepAlive(id)
	runtime.KeepAlive(data)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Csrc (gst_rtp_buffer_get_csrc): get the CSRC at index idx in buffer.
//
// The function takes the following parameters:
//
//   - idx: index of the CSRC to get.
//
// The function returns the following values:
//
//   - guint32: CSRC at index idx in host order.
func (rtp *RTPBuffer) Csrc(idx byte) uint32 {
	var _arg0 *C.GstRTPBuffer // out
	var _arg1 C.guint8        // out
	var _cret C.guint32       // in

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))
	_arg1 = C.guint8(idx)

	_cret = C.gst_rtp_buffer_get_csrc(_arg0, _arg1)
	runtime.KeepAlive(rtp)
	runtime.KeepAlive(idx)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// CsrcCount (gst_rtp_buffer_get_csrc_count): get the CSRC count of the RTP
// packet in buffer.
//
// The function returns the following values:
//
//   - guint8: CSRC count of buffer.
func (rtp *RTPBuffer) CsrcCount() byte {
	var _arg0 *C.GstRTPBuffer // out
	var _cret C.guint8        // in

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))

	_cret = C.gst_rtp_buffer_get_csrc_count(_arg0)
	runtime.KeepAlive(rtp)

	var _guint8 byte // out

	_guint8 = byte(_cret)

	return _guint8
}

// Extension (gst_rtp_buffer_get_extension): check if the extension bit is set
// on the RTP packet in buffer.
//
// The function returns the following values:
//
//   - ok: TRUE if buffer has the extension bit set.
func (rtp *RTPBuffer) Extension() bool {
	var _arg0 *C.GstRTPBuffer // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))

	_cret = C.gst_rtp_buffer_get_extension(_arg0)
	runtime.KeepAlive(rtp)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ExtensionData (gst_rtp_buffer_get_extension_bytes): similar to
// gst_rtp_buffer_get_extension_data, but more suitable for language bindings
// usage. bits will contain the extension 16 bits of custom data and the
// extension data (not including the extension header) is placed in a new
// #GBytes structure.
//
// If rtp did not contain an extension, this function will return NULL, with
// bits unchanged. If there is an extension header but no extension data then an
// empty #GBytes will be returned.
//
// The function returns the following values:
//
//   - bits: location for header bits.
//   - bytes (optional): new #GBytes if an extension header was present and NULL
//     otherwise.
func (rtp *RTPBuffer) ExtensionData() (uint16, *glib.Bytes) {
	var _arg0 *C.GstRTPBuffer // out
	var _arg1 C.guint16       // in
	var _cret *C.GBytes       // in

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))

	_cret = C.gst_rtp_buffer_get_extension_bytes(_arg0, &_arg1)
	runtime.KeepAlive(rtp)

	var _bits uint16       // out
	var _bytes *glib.Bytes // out

	_bits = uint16(_arg1)
	if _cret != nil {
		_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_bytes)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_bytes_unref((*C.GBytes)(intern.C))
			},
		)
	}

	return _bits, _bytes
}

// ExtensionOnebyteHeader (gst_rtp_buffer_get_extension_onebyte_header) parses
// RFC 5285 style header extensions with a one byte header. It will return the
// nth extension with the requested id.
//
// The function takes the following parameters:
//
//   - id: ID of the header extension to be read (between 1 and 14).
//   - nth: read the nth extension packet with the requested ID.
//
// The function returns the following values:
//
//   - data (optional): location for data.
//   - ok: TRUE if buffer had the requested header extension.
func (rtp *RTPBuffer) ExtensionOnebyteHeader(id byte, nth uint) ([]byte, bool) {
	var _arg0 *C.GstRTPBuffer // out
	var _arg1 C.guint8        // out
	var _arg2 C.guint         // out
	var _arg3 C.gpointer      // in
	var _arg4 C.guint         // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))
	_arg1 = C.guint8(id)
	_arg2 = C.guint(nth)

	_cret = C.gst_rtp_buffer_get_extension_onebyte_header(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(rtp)
	runtime.KeepAlive(id)
	runtime.KeepAlive(nth)

	var _data []byte // out
	var _ok bool     // out

	_data = make([]byte, _arg4)
	copy(_data, unsafe.Slice((*byte)(unsafe.Pointer(_arg3)), _arg4))
	if _cret != 0 {
		_ok = true
	}

	return _data, _ok
}

// ExtensionTwobytesHeader (gst_rtp_buffer_get_extension_twobytes_header) parses
// RFC 5285 style header extensions with a two bytes header. It will return the
// nth extension with the requested id.
//
// The function takes the following parameters:
//
//   - id: ID of the header extension to be read (between 1 and 14).
//   - nth: read the nth extension packet with the requested ID.
//
// The function returns the following values:
//
//   - appbits (optional): application specific bits.
//   - data (optional): location for data.
//   - ok: TRUE if buffer had the requested header extension.
func (rtp *RTPBuffer) ExtensionTwobytesHeader(id byte, nth uint) (byte, []byte, bool) {
	var _arg0 *C.GstRTPBuffer // out
	var _arg1 C.guint8        // in
	var _arg2 C.guint8        // out
	var _arg3 C.guint         // out
	var _arg4 C.gpointer      // in
	var _arg5 C.guint         // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))
	_arg2 = C.guint8(id)
	_arg3 = C.guint(nth)

	_cret = C.gst_rtp_buffer_get_extension_twobytes_header(_arg0, &_arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(rtp)
	runtime.KeepAlive(id)
	runtime.KeepAlive(nth)

	var _appbits byte // out
	var _data []byte  // out
	var _ok bool      // out

	_appbits = byte(_arg1)
	_data = make([]byte, _arg5)
	copy(_data, unsafe.Slice((*byte)(unsafe.Pointer(_arg4)), _arg5))
	if _cret != 0 {
		_ok = true
	}

	return _appbits, _data, _ok
}

// HeaderLen (gst_rtp_buffer_get_header_len): return the total length of the
// header in buffer. This include the length of the fixed header, the CSRC list
// and the extension header.
//
// The function returns the following values:
//
//   - guint: total length of the header in buffer.
func (rtp *RTPBuffer) HeaderLen() uint {
	var _arg0 *C.GstRTPBuffer // out
	var _cret C.guint         // in

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))

	_cret = C.gst_rtp_buffer_get_header_len(_arg0)
	runtime.KeepAlive(rtp)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Marker (gst_rtp_buffer_get_marker): check if the marker bit is set on the RTP
// packet in buffer.
//
// The function returns the following values:
//
//   - ok: TRUE if buffer has the marker bit set.
func (rtp *RTPBuffer) Marker() bool {
	var _arg0 *C.GstRTPBuffer // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))

	_cret = C.gst_rtp_buffer_get_marker(_arg0)
	runtime.KeepAlive(rtp)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PacketLen (gst_rtp_buffer_get_packet_len): return the total length of the
// packet in buffer.
//
// The function returns the following values:
//
//   - guint: total length of the packet in buffer.
func (rtp *RTPBuffer) PacketLen() uint {
	var _arg0 *C.GstRTPBuffer // out
	var _cret C.guint         // in

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))

	_cret = C.gst_rtp_buffer_get_packet_len(_arg0)
	runtime.KeepAlive(rtp)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Padding (gst_rtp_buffer_get_padding): check if the padding bit is set on the
// RTP packet in buffer.
//
// The function returns the following values:
//
//   - ok: TRUE if buffer has the padding bit set.
func (rtp *RTPBuffer) Padding() bool {
	var _arg0 *C.GstRTPBuffer // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))

	_cret = C.gst_rtp_buffer_get_padding(_arg0)
	runtime.KeepAlive(rtp)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PayloadBuffer (gst_rtp_buffer_get_payload_buffer): create a buffer of the
// payload of the RTP packet in buffer. This function will internally create a
// subbuffer of buffer so that a memcpy can be avoided.
//
// The function returns the following values:
//
//   - buffer: new buffer with the data of the payload.
func (rtp *RTPBuffer) PayloadBuffer() *gst.Buffer {
	var _arg0 *C.GstRTPBuffer // out
	var _cret *C.GstBuffer    // in

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))

	_cret = C.gst_rtp_buffer_get_payload_buffer(_arg0)
	runtime.KeepAlive(rtp)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _buffer
}

// Payload (gst_rtp_buffer_get_payload_bytes): similar to
// gst_rtp_buffer_get_payload, but more suitable for language bindings usage.
// The return value is a pointer to a #GBytes structure containing the payload
// data in rtp.
//
// The function returns the following values:
//
//   - bytes (optional): new #GBytes containing the payload data in rtp.
func (rtp *RTPBuffer) Payload() *glib.Bytes {
	var _arg0 *C.GstRTPBuffer // out
	var _cret *C.GBytes       // in

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))

	_cret = C.gst_rtp_buffer_get_payload_bytes(_arg0)
	runtime.KeepAlive(rtp)

	var _bytes *glib.Bytes // out

	if _cret != nil {
		_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_bytes)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_bytes_unref((*C.GBytes)(intern.C))
			},
		)
	}

	return _bytes
}

// PayloadLen (gst_rtp_buffer_get_payload_len): get the length of the payload of
// the RTP packet in buffer.
//
// The function returns the following values:
//
//   - guint: length of the payload in buffer.
func (rtp *RTPBuffer) PayloadLen() uint {
	var _arg0 *C.GstRTPBuffer // out
	var _cret C.guint         // in

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))

	_cret = C.gst_rtp_buffer_get_payload_len(_arg0)
	runtime.KeepAlive(rtp)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// PayloadSubbuffer (gst_rtp_buffer_get_payload_subbuffer): create a subbuffer
// of the payload of the RTP packet in buffer. offset bytes are skipped in the
// payload and the subbuffer will be of size len. If len is -1 the total payload
// starting from offset is subbuffered.
//
// The function takes the following parameters:
//
//   - offset in the payload.
//   - len: length in the payload.
//
// The function returns the following values:
//
//   - buffer: new buffer with the specified data of the payload.
func (rtp *RTPBuffer) PayloadSubbuffer(offset uint, len uint) *gst.Buffer {
	var _arg0 *C.GstRTPBuffer // out
	var _arg1 C.guint         // out
	var _arg2 C.guint         // out
	var _cret *C.GstBuffer    // in

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))
	_arg1 = C.guint(offset)
	_arg2 = C.guint(len)

	_cret = C.gst_rtp_buffer_get_payload_subbuffer(_arg0, _arg1, _arg2)
	runtime.KeepAlive(rtp)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(len)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _buffer
}

// PayloadType (gst_rtp_buffer_get_payload_type): get the payload type of the
// RTP packet in buffer.
//
// The function returns the following values:
//
//   - guint8: payload type.
func (rtp *RTPBuffer) PayloadType() byte {
	var _arg0 *C.GstRTPBuffer // out
	var _cret C.guint8        // in

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))

	_cret = C.gst_rtp_buffer_get_payload_type(_arg0)
	runtime.KeepAlive(rtp)

	var _guint8 byte // out

	_guint8 = byte(_cret)

	return _guint8
}

// Seq (gst_rtp_buffer_get_seq): get the sequence number of the RTP packet in
// buffer.
//
// The function returns the following values:
//
//   - guint16: sequence number in host order.
func (rtp *RTPBuffer) Seq() uint16 {
	var _arg0 *C.GstRTPBuffer // out
	var _cret C.guint16       // in

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))

	_cret = C.gst_rtp_buffer_get_seq(_arg0)
	runtime.KeepAlive(rtp)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// Ssrc (gst_rtp_buffer_get_ssrc): get the SSRC of the RTP packet in buffer.
//
// The function returns the following values:
//
//   - guint32: SSRC of buffer in host order.
func (rtp *RTPBuffer) Ssrc() uint32 {
	var _arg0 *C.GstRTPBuffer // out
	var _cret C.guint32       // in

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))

	_cret = C.gst_rtp_buffer_get_ssrc(_arg0)
	runtime.KeepAlive(rtp)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// Timestamp (gst_rtp_buffer_get_timestamp): get the timestamp of the RTP packet
// in buffer.
//
// The function returns the following values:
//
//   - guint32: timestamp in host order.
func (rtp *RTPBuffer) Timestamp() uint32 {
	var _arg0 *C.GstRTPBuffer // out
	var _cret C.guint32       // in

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))

	_cret = C.gst_rtp_buffer_get_timestamp(_arg0)
	runtime.KeepAlive(rtp)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// Version (gst_rtp_buffer_get_version): get the version number of the RTP
// packet in buffer.
//
// The function returns the following values:
//
//   - guint8: version of buffer.
func (rtp *RTPBuffer) Version() byte {
	var _arg0 *C.GstRTPBuffer // out
	var _cret C.guint8        // in

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))

	_cret = C.gst_rtp_buffer_get_version(_arg0)
	runtime.KeepAlive(rtp)

	var _guint8 byte // out

	_guint8 = byte(_cret)

	return _guint8
}

// PadTo (gst_rtp_buffer_pad_to): set the amount of padding in the RTP packet in
// buffer to len. If len is 0, the padding is removed.
//
// NOTE: This function does not work correctly.
//
// The function takes the following parameters:
//
//   - len: new amount of padding.
func (rtp *RTPBuffer) PadTo(len uint) {
	var _arg0 *C.GstRTPBuffer // out
	var _arg1 C.guint         // out

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))
	_arg1 = C.guint(len)

	C.gst_rtp_buffer_pad_to(_arg0, _arg1)
	runtime.KeepAlive(rtp)
	runtime.KeepAlive(len)
}

// RemoveExtensionData (gst_rtp_buffer_remove_extension_data) unsets the
// extension bit of the RTP buffer and removes the extension header and data.
//
// If the RTP buffer has no header extension data, the action has no effect. The
// RTP buffer must be mapped READWRITE only once and the underlying GstBuffer
// must be writable.
func (rtp *RTPBuffer) RemoveExtensionData() {
	var _arg0 *C.GstRTPBuffer // out

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))

	C.gst_rtp_buffer_remove_extension_data(_arg0)
	runtime.KeepAlive(rtp)
}

// SetCsrc (gst_rtp_buffer_set_csrc): modify the CSRC at index idx in buffer to
// csrc.
//
// The function takes the following parameters:
//
//   - idx: CSRC index to set.
//   - csrc: CSRC in host order to set at idx.
func (rtp *RTPBuffer) SetCsrc(idx byte, csrc uint32) {
	var _arg0 *C.GstRTPBuffer // out
	var _arg1 C.guint8        // out
	var _arg2 C.guint32       // out

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))
	_arg1 = C.guint8(idx)
	_arg2 = C.guint32(csrc)

	C.gst_rtp_buffer_set_csrc(_arg0, _arg1, _arg2)
	runtime.KeepAlive(rtp)
	runtime.KeepAlive(idx)
	runtime.KeepAlive(csrc)
}

// SetExtension (gst_rtp_buffer_set_extension): set the extension bit on the RTP
// packet in buffer to extension.
//
// The function takes the following parameters:
//
//   - extension: new extension.
func (rtp *RTPBuffer) SetExtension(extension bool) {
	var _arg0 *C.GstRTPBuffer // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))
	if extension {
		_arg1 = C.TRUE
	}

	C.gst_rtp_buffer_set_extension(_arg0, _arg1)
	runtime.KeepAlive(rtp)
	runtime.KeepAlive(extension)
}

// SetExtensionData (gst_rtp_buffer_set_extension_data): set the extension bit
// of the rtp buffer and fill in the bits and length of the extension header.
// If the existing extension data is not large enough, it will be made larger.
//
// Will also shorten the extension data from 1.20.
//
// The function takes the following parameters:
//
//   - bits specific for the extension.
//   - length that counts the number of 32-bit words in the extension, excluding
//     the extension header ( therefore zero is a valid length).
//
// The function returns the following values:
//
//   - ok: true if done.
func (rtp *RTPBuffer) SetExtensionData(bits uint16, length uint16) bool {
	var _arg0 *C.GstRTPBuffer // out
	var _arg1 C.guint16       // out
	var _arg2 C.guint16       // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))
	_arg1 = C.guint16(bits)
	_arg2 = C.guint16(length)

	_cret = C.gst_rtp_buffer_set_extension_data(_arg0, _arg1, _arg2)
	runtime.KeepAlive(rtp)
	runtime.KeepAlive(bits)
	runtime.KeepAlive(length)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetMarker (gst_rtp_buffer_set_marker): set the marker bit on the RTP packet
// in buffer to marker.
//
// The function takes the following parameters:
//
//   - marker: new marker.
func (rtp *RTPBuffer) SetMarker(marker bool) {
	var _arg0 *C.GstRTPBuffer // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))
	if marker {
		_arg1 = C.TRUE
	}

	C.gst_rtp_buffer_set_marker(_arg0, _arg1)
	runtime.KeepAlive(rtp)
	runtime.KeepAlive(marker)
}

// SetPacketLen (gst_rtp_buffer_set_packet_len): set the total rtp size to len.
// The data in the buffer will be made larger if needed. Any padding will be
// removed from the packet.
//
// The function takes the following parameters:
//
//   - len: new packet length.
func (rtp *RTPBuffer) SetPacketLen(len uint) {
	var _arg0 *C.GstRTPBuffer // out
	var _arg1 C.guint         // out

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))
	_arg1 = C.guint(len)

	C.gst_rtp_buffer_set_packet_len(_arg0, _arg1)
	runtime.KeepAlive(rtp)
	runtime.KeepAlive(len)
}

// SetPadding (gst_rtp_buffer_set_padding): set the padding bit on the RTP
// packet in buffer to padding.
//
// The function takes the following parameters:
//
//   - padding: new padding.
func (rtp *RTPBuffer) SetPadding(padding bool) {
	var _arg0 *C.GstRTPBuffer // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))
	if padding {
		_arg1 = C.TRUE
	}

	C.gst_rtp_buffer_set_padding(_arg0, _arg1)
	runtime.KeepAlive(rtp)
	runtime.KeepAlive(padding)
}

// SetPayloadType (gst_rtp_buffer_set_payload_type): set the payload type of the
// RTP packet in buffer to payload_type.
//
// The function takes the following parameters:
//
//   - payloadType: new type.
func (rtp *RTPBuffer) SetPayloadType(payloadType byte) {
	var _arg0 *C.GstRTPBuffer // out
	var _arg1 C.guint8        // out

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))
	_arg1 = C.guint8(payloadType)

	C.gst_rtp_buffer_set_payload_type(_arg0, _arg1)
	runtime.KeepAlive(rtp)
	runtime.KeepAlive(payloadType)
}

// SetSeq (gst_rtp_buffer_set_seq): set the sequence number of the RTP packet in
// buffer to seq.
//
// The function takes the following parameters:
//
//   - seq: new sequence number.
func (rtp *RTPBuffer) SetSeq(seq uint16) {
	var _arg0 *C.GstRTPBuffer // out
	var _arg1 C.guint16       // out

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))
	_arg1 = C.guint16(seq)

	C.gst_rtp_buffer_set_seq(_arg0, _arg1)
	runtime.KeepAlive(rtp)
	runtime.KeepAlive(seq)
}

// SetSsrc (gst_rtp_buffer_set_ssrc): set the SSRC on the RTP packet in buffer
// to ssrc.
//
// The function takes the following parameters:
//
//   - ssrc: new SSRC.
func (rtp *RTPBuffer) SetSsrc(ssrc uint32) {
	var _arg0 *C.GstRTPBuffer // out
	var _arg1 C.guint32       // out

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))
	_arg1 = C.guint32(ssrc)

	C.gst_rtp_buffer_set_ssrc(_arg0, _arg1)
	runtime.KeepAlive(rtp)
	runtime.KeepAlive(ssrc)
}

// SetTimestamp (gst_rtp_buffer_set_timestamp): set the timestamp of the RTP
// packet in buffer to timestamp.
//
// The function takes the following parameters:
//
//   - timestamp: new timestamp.
func (rtp *RTPBuffer) SetTimestamp(timestamp uint32) {
	var _arg0 *C.GstRTPBuffer // out
	var _arg1 C.guint32       // out

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))
	_arg1 = C.guint32(timestamp)

	C.gst_rtp_buffer_set_timestamp(_arg0, _arg1)
	runtime.KeepAlive(rtp)
	runtime.KeepAlive(timestamp)
}

// SetVersion (gst_rtp_buffer_set_version): set the version of the RTP packet in
// buffer to version.
//
// The function takes the following parameters:
//
//   - version: new version.
func (rtp *RTPBuffer) SetVersion(version byte) {
	var _arg0 *C.GstRTPBuffer // out
	var _arg1 C.guint8        // out

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))
	_arg1 = C.guint8(version)

	C.gst_rtp_buffer_set_version(_arg0, _arg1)
	runtime.KeepAlive(rtp)
	runtime.KeepAlive(version)
}

// Unmap (gst_rtp_buffer_unmap) rtp previously mapped with gst_rtp_buffer_map().
func (rtp *RTPBuffer) Unmap() {
	var _arg0 *C.GstRTPBuffer // out

	_arg0 = (*C.GstRTPBuffer)(gextras.StructNative(unsafe.Pointer(rtp)))

	C.gst_rtp_buffer_unmap(_arg0)
	runtime.KeepAlive(rtp)
}

// RTPBufferAllocateData (gst_rtp_buffer_allocate_data): allocate enough data
// in buffer to hold an RTP packet with csrc_count CSRCs, a payload length of
// payload_len and padding of pad_len. buffer must be writable and all previous
// memory in buffer will be freed. If pad_len is >0, the padding bit will be
// set. All other RTP header fields will be set to 0/FALSE.
//
// The function takes the following parameters:
//
//   - buffer: Buffer.
//   - payloadLen: length of the payload.
//   - padLen: amount of padding.
//   - csrcCount: number of CSRC entries.
func RTPBufferAllocateData(buffer *gst.Buffer, payloadLen uint, padLen, csrcCount byte) {
	var _arg1 *C.GstBuffer // out
	var _arg2 C.guint      // out
	var _arg3 C.guint8     // out
	var _arg4 C.guint8     // out

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = C.guint(payloadLen)
	_arg3 = C.guint8(padLen)
	_arg4 = C.guint8(csrcCount)

	C.gst_rtp_buffer_allocate_data(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(payloadLen)
	runtime.KeepAlive(padLen)
	runtime.KeepAlive(csrcCount)
}

// RTPBufferCalcHeaderLen (gst_rtp_buffer_calc_header_len): calculate the header
// length of an RTP packet with csrc_count CSRC entries. An RTP packet can have
// at most 15 CSRC entries.
//
// The function takes the following parameters:
//
//   - csrcCount: number of CSRC entries.
//
// The function returns the following values:
//
//   - guint: length of an RTP header with csrc_count CSRC entries.
func RTPBufferCalcHeaderLen(csrcCount byte) uint {
	var _arg1 C.guint8 // out
	var _cret C.guint  // in

	_arg1 = C.guint8(csrcCount)

	_cret = C.gst_rtp_buffer_calc_header_len(_arg1)
	runtime.KeepAlive(csrcCount)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// RTPBufferCalcPacketLen (gst_rtp_buffer_calc_packet_len): calculate the total
// length of an RTP packet with a payload size of payload_len, a padding of
// pad_len and a csrc_count CSRC entries.
//
// The function takes the following parameters:
//
//   - payloadLen: length of the payload.
//   - padLen: amount of padding.
//   - csrcCount: number of CSRC entries.
//
// The function returns the following values:
//
//   - guint: total length of an RTP header with given parameters.
func RTPBufferCalcPacketLen(payloadLen uint, padLen, csrcCount byte) uint {
	var _arg1 C.guint  // out
	var _arg2 C.guint8 // out
	var _arg3 C.guint8 // out
	var _cret C.guint  // in

	_arg1 = C.guint(payloadLen)
	_arg2 = C.guint8(padLen)
	_arg3 = C.guint8(csrcCount)

	_cret = C.gst_rtp_buffer_calc_packet_len(_arg1, _arg2, _arg3)
	runtime.KeepAlive(payloadLen)
	runtime.KeepAlive(padLen)
	runtime.KeepAlive(csrcCount)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// RTPBufferCalcPayloadLen (gst_rtp_buffer_calc_payload_len): calculate the
// length of the payload of an RTP packet with size packet_len, a padding of
// pad_len and a csrc_count CSRC entries.
//
// The function takes the following parameters:
//
//   - packetLen: length of the total RTP packet.
//   - padLen: amount of padding.
//   - csrcCount: number of CSRC entries.
//
// The function returns the following values:
//
//   - guint: length of the payload of an RTP packet with given parameters.
func RTPBufferCalcPayloadLen(packetLen uint, padLen, csrcCount byte) uint {
	var _arg1 C.guint  // out
	var _arg2 C.guint8 // out
	var _arg3 C.guint8 // out
	var _cret C.guint  // in

	_arg1 = C.guint(packetLen)
	_arg2 = C.guint8(padLen)
	_arg3 = C.guint8(csrcCount)

	_cret = C.gst_rtp_buffer_calc_payload_len(_arg1, _arg2, _arg3)
	runtime.KeepAlive(packetLen)
	runtime.KeepAlive(padLen)
	runtime.KeepAlive(csrcCount)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// RTPBufferCompareSeqnum (gst_rtp_buffer_compare_seqnum): compare two sequence
// numbers, taking care of wraparounds. This function returns the difference
// between seqnum1 and seqnum2.
//
// The function takes the following parameters:
//
//   - seqnum1: sequence number.
//   - seqnum2: sequence number.
//
// The function returns the following values:
//
//   - gint: negative value if seqnum1 is bigger than seqnum2, 0 if they are
//     equal or a positive value if seqnum1 is smaller than segnum2.
func RTPBufferCompareSeqnum(seqnum1, seqnum2 uint16) int {
	var _arg1 C.guint16 // out
	var _arg2 C.guint16 // out
	var _cret C.gint    // in

	_arg1 = C.guint16(seqnum1)
	_arg2 = C.guint16(seqnum2)

	_cret = C.gst_rtp_buffer_compare_seqnum(_arg1, _arg2)
	runtime.KeepAlive(seqnum1)
	runtime.KeepAlive(seqnum2)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// RTPBufferDefaultClockRate (gst_rtp_buffer_default_clock_rate): get the
// default clock-rate for the static payload type payload_type.
//
// The function takes the following parameters:
//
//   - payloadType: static payload type.
//
// The function returns the following values:
//
//   - guint32: default clock rate or -1 if the payload type is not static or
//     the clock-rate is undefined.
func RTPBufferDefaultClockRate(payloadType byte) uint32 {
	var _arg1 C.guint8  // out
	var _cret C.guint32 // in

	_arg1 = C.guint8(payloadType)

	_cret = C.gst_rtp_buffer_default_clock_rate(_arg1)
	runtime.KeepAlive(payloadType)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// RTPBufferGetExtensionOnebyteHeaderFromBytes
// (gst_rtp_buffer_get_extension_onebyte_header_from_bytes): similar to
// gst_rtp_buffer_get_extension_onebyte_header, but working on the #GBytes you
// get from gst_rtp_buffer_get_extension_bytes. Parses RFC 5285 style header
// extensions with a one byte header. It will return the nth extension with the
// requested id.
//
// The function takes the following parameters:
//
//   - bytes: #GBytes.
//   - bitPattern: bit-pattern. Anything but 0xBEDE is rejected.
//   - id: ID of the header extension to be read (between 1 and 14).
//   - nth: read the nth extension packet with the requested ID.
//
// The function returns the following values:
//
//   - data: location for data.
//   - ok: TRUE if bytes had the requested header extension.
func RTPBufferGetExtensionOnebyteHeaderFromBytes(bytes *glib.Bytes, bitPattern uint16, id byte, nth uint) ([]byte, bool) {
	var _arg1 *C.GBytes  // out
	var _arg2 C.guint16  // out
	var _arg3 C.guint8   // out
	var _arg4 C.guint    // out
	var _arg5 C.gpointer // in
	var _arg6 C.guint    // in
	var _cret C.gboolean // in

	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))
	_arg2 = C.guint16(bitPattern)
	_arg3 = C.guint8(id)
	_arg4 = C.guint(nth)

	_cret = C.gst_rtp_buffer_get_extension_onebyte_header_from_bytes(_arg1, _arg2, _arg3, _arg4, &_arg5, &_arg6)
	runtime.KeepAlive(bytes)
	runtime.KeepAlive(bitPattern)
	runtime.KeepAlive(id)
	runtime.KeepAlive(nth)

	var _data []byte // out
	var _ok bool     // out

	_data = make([]byte, _arg6)
	copy(_data, unsafe.Slice((*byte)(unsafe.Pointer(_arg5)), _arg6))
	if _cret != 0 {
		_ok = true
	}

	return _data, _ok
}

// RTPBufferMap (gst_rtp_buffer_map): map the contents of buffer into rtp.
//
// The function takes the following parameters:
//
//   - buffer: Buffer.
//   - flags: MapFlags.
//
// The function returns the following values:
//
//   - rtp: RTPBuffer.
//   - ok: TRUE if buffer could be mapped.
func RTPBufferMap(buffer *gst.Buffer, flags gst.MapFlags) (*RTPBuffer, bool) {
	var _arg1 *C.GstBuffer   // out
	var _arg2 C.GstMapFlags  // out
	var _arg3 C.GstRTPBuffer // in
	var _cret C.gboolean     // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = C.GstMapFlags(flags)

	_cret = C.gst_rtp_buffer_map(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(flags)

	var _rtp *RTPBuffer // out
	var _ok bool        // out

	_rtp = (*RTPBuffer)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))
	if _cret != 0 {
		_ok = true
	}

	return _rtp, _ok
}

// NewRTPBufferAllocate (gst_rtp_buffer_new_allocate): allocate a new Buffer
// with enough data to hold an RTP packet with csrc_count CSRCs, a payload
// length of payload_len and padding of pad_len. All other RTP header fields
// will be set to 0/FALSE.
//
// The function takes the following parameters:
//
//   - payloadLen: length of the payload.
//   - padLen: amount of padding.
//   - csrcCount: number of CSRC entries.
//
// The function returns the following values:
//
//   - buffer: newly allocated buffer that can hold an RTP packet with given
//     parameters.
func NewRTPBufferAllocate(payloadLen uint, padLen, csrcCount byte) *gst.Buffer {
	var _arg1 C.guint      // out
	var _arg2 C.guint8     // out
	var _arg3 C.guint8     // out
	var _cret *C.GstBuffer // in

	_arg1 = C.guint(payloadLen)
	_arg2 = C.guint8(padLen)
	_arg3 = C.guint8(csrcCount)

	_cret = C.gst_rtp_buffer_new_allocate(_arg1, _arg2, _arg3)
	runtime.KeepAlive(payloadLen)
	runtime.KeepAlive(padLen)
	runtime.KeepAlive(csrcCount)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _buffer
}

// NewRTPBufferAllocateLen (gst_rtp_buffer_new_allocate_len): create a new
// Buffer that can hold an RTP packet that is exactly packet_len long. The
// length of the payload depends on pad_len and csrc_count and can be calculated
// with gst_rtp_buffer_calc_payload_len(). All RTP header fields will be set to
// 0/FALSE.
//
// The function takes the following parameters:
//
//   - packetLen: total length of the packet.
//   - padLen: amount of padding.
//   - csrcCount: number of CSRC entries.
//
// The function returns the following values:
//
//   - buffer: newly allocated buffer that can hold an RTP packet of packet_len.
func NewRTPBufferAllocateLen(packetLen uint, padLen, csrcCount byte) *gst.Buffer {
	var _arg1 C.guint      // out
	var _arg2 C.guint8     // out
	var _arg3 C.guint8     // out
	var _cret *C.GstBuffer // in

	_arg1 = C.guint(packetLen)
	_arg2 = C.guint8(padLen)
	_arg3 = C.guint8(csrcCount)

	_cret = C.gst_rtp_buffer_new_allocate_len(_arg1, _arg2, _arg3)
	runtime.KeepAlive(packetLen)
	runtime.KeepAlive(padLen)
	runtime.KeepAlive(csrcCount)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _buffer
}

// NewRTPBufferCopyData (gst_rtp_buffer_new_copy_data): create a new buffer and
// set the data to a copy of len bytes of data and the size to len. The data
// will be freed when the buffer is freed.
//
// The function takes the following parameters:
//
//   - data for the new buffer.
//
// The function returns the following values:
//
//   - buffer: newly allocated buffer with a copy of data and of size len.
func NewRTPBufferCopyData(data []byte) *gst.Buffer {
	var _arg1 C.gconstpointer // out
	var _arg2 C.gsize
	var _cret *C.GstBuffer // in

	_arg2 = (C.gsize)(len(data))
	if len(data) > 0 {
		_arg1 = (C.gconstpointer)(unsafe.Pointer(&data[0]))
	}

	_cret = C.gst_rtp_buffer_new_copy_data(_arg1, _arg2)
	runtime.KeepAlive(data)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _buffer
}

// NewRTPBufferTakeData (gst_rtp_buffer_new_take_data): create a new buffer and
// set the data and size of the buffer to data and len respectively. data will
// be freed when the buffer is unreffed, so this function transfers ownership of
// data to the new buffer.
//
// The function takes the following parameters:
//
//   - data: data for the new buffer.
//
// The function returns the following values:
//
//   - buffer: newly allocated buffer with data and of size len.
func NewRTPBufferTakeData(data []byte) *gst.Buffer {
	var _arg1 C.gpointer // out
	var _arg2 C.gsize
	var _cret *C.GstBuffer // in

	_arg2 = (C.gsize)(len(data))
	_arg1 = (C.gpointer)(C.calloc(C.size_t(len(data)), C.size_t(C.sizeof_guint8)))
	copy(unsafe.Slice((*byte)(_arg1), len(data)), data)

	_cret = C.gst_rtp_buffer_new_take_data(_arg1, _arg2)
	runtime.KeepAlive(data)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _buffer
}

// RTPHeaderExtensionClass (GstRTPHeaderExtensionClass): base class for RTP
// Header extensions.
//
// An instance of this type is always passed by reference.
type RTPHeaderExtensionClass struct {
	*rtpHeaderExtensionClass
}

// rtpHeaderExtensionClass is the struct that's finalized.
type rtpHeaderExtensionClass struct {
	native *C.GstRTPHeaderExtensionClass
}

// ParentClass: parent class.
func (r *RTPHeaderExtensionClass) ParentClass() *gst.ElementClass {
	valptr := &r.native.parent_class
	var _v *gst.ElementClass // out
	_v = (*gst.ElementClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// SetURI (gst_rtp_header_extension_class_set_uri): set the URI for this RTP
// header extension implementation.
//
// The function takes the following parameters:
//
//   - uri: RTP Header extension uri for klass.
func (klass *RTPHeaderExtensionClass) SetURI(uri string) {
	var _arg0 *C.GstRTPHeaderExtensionClass // out
	var _arg1 *C.gchar                      // out

	_arg0 = (*C.GstRTPHeaderExtensionClass)(gextras.StructNative(unsafe.Pointer(klass)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_rtp_header_extension_class_set_uri(_arg0, _arg1)
	runtime.KeepAlive(klass)
	runtime.KeepAlive(uri)
}

// RTPPayloadInfo (GstRTPPayloadInfo): structure holding default payload type
// information.
//
// An instance of this type is always passed by reference.
type RTPPayloadInfo struct {
	*rtpPayloadInfo
}

// rtpPayloadInfo is the struct that's finalized.
type rtpPayloadInfo struct {
	native *C.GstRTPPayloadInfo
}

// PayloadType: payload type, -1 means dynamic.
func (r *RTPPayloadInfo) PayloadType() byte {
	valptr := &r.native.payload_type
	var _v byte // out
	_v = byte(*valptr)
	return _v
}

// Media: media type(s), usually "audio", "video", "application", "text",
// "message".
func (r *RTPPayloadInfo) Media() string {
	valptr := &r.native.media
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// EncodingName: encoding name of pt.
func (r *RTPPayloadInfo) EncodingName() string {
	valptr := &r.native.encoding_name
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// ClockRate: default clock rate, 0 = unknown/variable.
func (r *RTPPayloadInfo) ClockRate() uint {
	valptr := &r.native.clock_rate
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// EncodingParameters: encoding parameters. For audio this is the number of
// channels. NULL = not applicable.
func (r *RTPPayloadInfo) EncodingParameters() string {
	valptr := &r.native.encoding_parameters
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Bitrate: bitrate of the media. 0 = unknown/variable.
func (r *RTPPayloadInfo) Bitrate() uint {
	valptr := &r.native.bitrate
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// PayloadType: payload type, -1 means dynamic.
func (r *RTPPayloadInfo) SetPayloadType(payloadType byte) {
	valptr := &r.native.payload_type
	*valptr = C.guint8(payloadType)
}

// ClockRate: default clock rate, 0 = unknown/variable.
func (r *RTPPayloadInfo) SetClockRate(clockRate uint) {
	valptr := &r.native.clock_rate
	*valptr = C.guint(clockRate)
}

// Bitrate: bitrate of the media. 0 = unknown/variable.
func (r *RTPPayloadInfo) SetBitrate(bitrate uint) {
	valptr := &r.native.bitrate
	*valptr = C.guint(bitrate)
}

// RTPPayloadInfoForName (gst_rtp_payload_info_for_name): get the RTPPayloadInfo
// for media and encoding_name. This function is mostly used to get the default
// clock-rate and bandwidth for dynamic payload types specified with media and
// encoding name.
//
// The search for encoding_name will be performed in a case insensitive way.
//
// The function takes the following parameters:
//
//   - media to find.
//   - encodingName: encoding name to find.
//
// The function returns the following values:
//
//   - rtpPayloadInfo (optional) or NULL when no info could be found.
func RTPPayloadInfoForName(media, encodingName string) *RTPPayloadInfo {
	var _arg1 *C.gchar             // out
	var _arg2 *C.gchar             // out
	var _cret *C.GstRTPPayloadInfo // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(media)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(encodingName)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_rtp_payload_info_for_name(_arg1, _arg2)
	runtime.KeepAlive(media)
	runtime.KeepAlive(encodingName)

	var _rtpPayloadInfo *RTPPayloadInfo // out

	if _cret != nil {
		_rtpPayloadInfo = (*RTPPayloadInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _rtpPayloadInfo
}

// RTPPayloadInfoForPt (gst_rtp_payload_info_for_pt): get the RTPPayloadInfo for
// payload_type. This function is mostly used to get the default clock-rate and
// bandwidth for static payload types specified with payload_type.
//
// The function takes the following parameters:
//
//   - payloadType: payload_type to find.
//
// The function returns the following values:
//
//   - rtpPayloadInfo (optional) or NULL when no info could be found.
func RTPPayloadInfoForPt(payloadType byte) *RTPPayloadInfo {
	var _arg1 C.guint8             // out
	var _cret *C.GstRTPPayloadInfo // in

	_arg1 = C.guint8(payloadType)

	_cret = C.gst_rtp_payload_info_for_pt(_arg1)
	runtime.KeepAlive(payloadType)

	var _rtpPayloadInfo *RTPPayloadInfo // out

	if _cret != nil {
		_rtpPayloadInfo = (*RTPPayloadInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _rtpPayloadInfo
}

// RTPSourceMeta (GstRTPSourceMeta): meta describing the source(s) of the
// buffer.
//
// An instance of this type is always passed by reference.
type RTPSourceMeta struct {
	*rtpSourceMeta
}

// rtpSourceMeta is the struct that's finalized.
type rtpSourceMeta struct {
	native *C.GstRTPSourceMeta
}

// Meta: parent Meta.
func (r *RTPSourceMeta) Meta() *gst.Meta {
	valptr := &r.native.meta
	var _v *gst.Meta // out
	_v = (*gst.Meta)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Ssrc: SSRC.
func (r *RTPSourceMeta) Ssrc() uint32 {
	valptr := &r.native.ssrc
	var _v uint32 // out
	_v = uint32(*valptr)
	return _v
}

// SsrcValid: whether ssrc is set and valid.
func (r *RTPSourceMeta) SsrcValid() bool {
	valptr := &r.native.ssrc_valid
	var _v bool // out
	if *valptr != 0 {
		_v = true
	}
	return _v
}

// Csrc: pointer to the CSRCs.
func (r *RTPSourceMeta) Csrc() [15]uint32 {
	valptr := &r.native.csrc
	var _v [15]uint32 // out
	_v = *(*[15]uint32)(unsafe.Pointer(&*valptr))
	return _v
}

// CsrcCount: number of elements in csrc.
func (r *RTPSourceMeta) CsrcCount() uint {
	valptr := &r.native.csrc_count
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// SsrcValid: whether ssrc is set and valid.
func (r *RTPSourceMeta) SetSsrcValid(ssrcValid bool) {
	valptr := &r.native.ssrc_valid
	if ssrcValid {
		*valptr = C.TRUE
	}
}

// CsrcCount: number of elements in csrc.
func (r *RTPSourceMeta) SetCsrcCount(csrcCount uint) {
	valptr := &r.native.csrc_count
	*valptr = C.guint(csrcCount)
}

// AppendCsrc (gst_rtp_source_meta_append_csrc) appends csrc to the list of
// contributing sources in meta.
//
// The function takes the following parameters:
//
//   - csrc csrcs to append.
//
// The function returns the following values:
//
//   - ok: TRUE if all elements in csrc was added, FALSE otherwise.
func (meta *RTPSourceMeta) AppendCsrc(csrc []uint32) bool {
	var _arg0 *C.GstRTPSourceMeta // out
	var _arg1 *C.guint32          // out
	var _arg2 C.guint
	var _cret C.gboolean // in

	_arg0 = (*C.GstRTPSourceMeta)(gextras.StructNative(unsafe.Pointer(meta)))
	_arg2 = (C.guint)(len(csrc))
	if len(csrc) > 0 {
		_arg1 = (*C.guint32)(unsafe.Pointer(&csrc[0]))
	}

	_cret = C.gst_rtp_source_meta_append_csrc(_arg0, _arg1, _arg2)
	runtime.KeepAlive(meta)
	runtime.KeepAlive(csrc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SourceCount (gst_rtp_source_meta_get_source_count): count the total number of
// RTP sources found in meta, both SSRC and CSRC.
//
// The function returns the following values:
//
//   - guint: number of RTP sources.
func (meta *RTPSourceMeta) SourceCount() uint {
	var _arg0 *C.GstRTPSourceMeta // out
	var _cret C.guint             // in

	_arg0 = (*C.GstRTPSourceMeta)(gextras.StructNative(unsafe.Pointer(meta)))

	_cret = C.gst_rtp_source_meta_get_source_count(_arg0)
	runtime.KeepAlive(meta)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SetSsrc (gst_rtp_source_meta_set_ssrc) sets ssrc in meta. If ssrc is NULL the
// ssrc of meta will be unset.
//
// The function takes the following parameters:
//
//   - ssrc (optional): pointer to the SSRC.
//
// The function returns the following values:
//
//   - ok: TRUE on success, FALSE otherwise.
func (meta *RTPSourceMeta) SetSsrc(ssrc *uint32) bool {
	var _arg0 *C.GstRTPSourceMeta // out
	var _arg1 *C.guint32          // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstRTPSourceMeta)(gextras.StructNative(unsafe.Pointer(meta)))
	if ssrc != nil {
		_arg1 = (*C.guint32)(unsafe.Pointer(ssrc))
	}

	_cret = C.gst_rtp_source_meta_set_ssrc(_arg0, _arg1)
	runtime.KeepAlive(meta)
	runtime.KeepAlive(ssrc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func RTPSourceMetaGetInfo() *gst.MetaInfo {
	var _cret *C.GstMetaInfo // in

	_cret = C.gst_rtp_source_meta_get_info()

	var _metaInfo *gst.MetaInfo // out

	_metaInfo = (*gst.MetaInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _metaInfo
}
