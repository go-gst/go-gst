// Code generated by girgen. DO NOT EDIT.

package gsttag

import (
	"fmt"
	"runtime"
	_ "runtime/cgo"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/go-gst/go-gst/pkg/gst"
)

// #cgo pkg-config: gstreamer-tag-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/tag/tag.h>
// extern gboolean _gotk4_gsttag1_TagDemuxClass_identify_tag(GstTagDemux*, GstBuffer*, gboolean, guint*);
// extern GstTagList* _gotk4_gsttag1_TagDemuxClass_merge_tags(GstTagDemux*, GstTagList*, GstTagList*);
// extern GstBuffer* _gotk4_gsttag1_TagMuxClass_render_start_tag(GstTagMux*, GstTagList*);
// extern GstBuffer* _gotk4_gsttag1_TagMuxClass_render_end_tag(GstTagMux*, GstTagList*);
// GstBuffer* _gotk4_gsttag1_TagMux_virtual_render_end_tag(void* fnptr, GstTagMux* arg0, GstTagList* arg1) {
//   return ((GstBuffer* (*)(GstTagMux*, GstTagList*))(fnptr))(arg0, arg1);
// };
// GstBuffer* _gotk4_gsttag1_TagMux_virtual_render_start_tag(void* fnptr, GstTagMux* arg0, GstTagList* arg1) {
//   return ((GstBuffer* (*)(GstTagMux*, GstTagList*))(fnptr))(arg0, arg1);
// };
// GstTagList* _gotk4_gsttag1_TagDemux_virtual_merge_tags(void* fnptr, GstTagDemux* arg0, GstTagList* arg1, GstTagList* arg2) {
//   return ((GstTagList* (*)(GstTagDemux*, GstTagList*, GstTagList*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gsttag1_TagDemux_virtual_identify_tag(void* fnptr, GstTagDemux* arg0, GstBuffer* arg1, gboolean arg2, guint* arg3) {
//   return ((gboolean (*)(GstTagDemux*, GstBuffer*, gboolean, guint*))(fnptr))(arg0, arg1, arg2, arg3);
// };
import "C"

// GType values.
var (
	GTypeTagDemuxResult  = coreglib.Type(C.gst_tag_demux_result_get_type())
	GTypeTagImageType    = coreglib.Type(C.gst_tag_image_type_get_type())
	GTypeTagLicenseFlags = coreglib.Type(C.gst_tag_license_flags_get_type())
	GTypeTagXmpWriter    = coreglib.Type(C.gst_tag_xmp_writer_get_type())
	GTypeTagDemux        = coreglib.Type(C.gst_tag_demux_get_type())
	GTypeTagMux          = coreglib.Type(C.gst_tag_mux_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTagDemuxResult, F: marshalTagDemuxResult},
		coreglib.TypeMarshaler{T: GTypeTagImageType, F: marshalTagImageType},
		coreglib.TypeMarshaler{T: GTypeTagLicenseFlags, F: marshalTagLicenseFlags},
		coreglib.TypeMarshaler{T: GTypeTagXmpWriter, F: marshalTagXmpWriter},
		coreglib.TypeMarshaler{T: GTypeTagDemux, F: marshalTagDemux},
		coreglib.TypeMarshaler{T: GTypeTagMux, F: marshalTagMux},
	})
}

// TAG_ACOUSTID_FINGERPRINT: acoustID Fingerprint (Chromaprint).
const TAG_ACOUSTID_FINGERPRINT = "chromaprint-fingerprint"

// TAG_ACOUSTID_ID: acoustID Identifier.
const TAG_ACOUSTID_ID = "acoustid-id"

// TAG_CAPTURING_CONTRAST: direction of contrast processing applied when
// capturing an image. (string)
//
// The allowed values are: "normal" "soft" "hard".
const TAG_CAPTURING_CONTRAST = "capturing-contrast"

// TAG_CAPTURING_DIGITAL_ZOOM_RATIO: digital zoom ratio used when capturing an
// image. (double).
const TAG_CAPTURING_DIGITAL_ZOOM_RATIO = "capturing-digital-zoom-ratio"

// TAG_CAPTURING_EXPOSURE_COMPENSATION: exposure compensation using when
// capturing an image in EV. (double).
const TAG_CAPTURING_EXPOSURE_COMPENSATION = "capturing-exposure-compensation"

// TAG_CAPTURING_EXPOSURE_MODE: exposure mode used when capturing an image.
// (string)
//
// The allowed values are: "auto-exposure" "manual-exposure" "auto-bracket".
const TAG_CAPTURING_EXPOSURE_MODE = "capturing-exposure-mode"

// TAG_CAPTURING_EXPOSURE_PROGRAM: type of exposure control used when capturing
// an image. (string)
//
// The allowed values are: "undefined" "manual" "normal" - automatically
// controlled "aperture-priority" - user selects aperture value
// "shutter-priority" - user selects shutter speed "creative" - biased towards
// depth of field "action" - biased towards fast shutter speed "portrait" -
// closeup, leaving background out of focus "landscape" - landscape photos,
// background in focus.
const TAG_CAPTURING_EXPOSURE_PROGRAM = "capturing-exposure-program"

// TAG_CAPTURING_FLASH_FIRED: if flash was fired during the capture of an image.
// (boolean)
//
// Note that if this tag isn't present, it should not be assumed that the flash
// did not fire. It should be treated as unknown.
const TAG_CAPTURING_FLASH_FIRED = "capturing-flash-fired"

// TAG_CAPTURING_FLASH_MODE: flash mode selected during the capture of an image.
// (string)
//
// The allowed values are: "auto" "always" "never".
const TAG_CAPTURING_FLASH_MODE = "capturing-flash-mode"

// TAG_CAPTURING_FOCAL_LENGTH: focal length used when capturing an image, in mm.
// (double).
const TAG_CAPTURING_FOCAL_LENGTH = "capturing-focal-length"

// TAG_CAPTURING_FOCAL_LENGTH_35_MM: 35 mm equivalent focal length used when
// capturing an image, in mm. (double).
const TAG_CAPTURING_FOCAL_LENGTH_35_MM = "capturing-focal-length-35mm"

// TAG_CAPTURING_FOCAL_RATIO: focal ratio (f-number) used when capturing an
// image. (double)
//
// The value stored is the denominator of the focal ratio (f-number). For
// example, if this tag value is 2, the focal ratio is f/2.
const TAG_CAPTURING_FOCAL_RATIO = "capturing-focal-ratio"

// TAG_CAPTURING_GAIN_ADJUSTMENT: gain adjustment applied to an image. (string)
//
// The allowed values are: "none" "low-gain-up" "high-gain-up" "low-gain-down"
// "high-gain-down".
const TAG_CAPTURING_GAIN_ADJUSTMENT = "capturing-gain-adjustment"

// TAG_CAPTURING_ISO_SPEED: ISO speed used when capturing an image. (integer).
const TAG_CAPTURING_ISO_SPEED = "capturing-iso-speed"

// TAG_CAPTURING_METERING_MODE defines the way a camera determines the exposure.
// (string)
//
// The allowed values are: "unknown" "average" "center-weighted-average" "spot"
// "multi-spot" "pattern" "partial" "other".
const TAG_CAPTURING_METERING_MODE = "capturing-metering-mode"

// TAG_CAPTURING_SATURATION: direction of saturation processing applied when
// capturing an image. (string)
//
// The allowed values are: "normal" "low-saturation" "high-saturation".
const TAG_CAPTURING_SATURATION = "capturing-saturation"

// TAG_CAPTURING_SCENE_CAPTURE_TYPE: scene mode used when capturing an image.
// (string)
//
// The allowed values are: "standard" "landscape" "portrait" "night-scene".
const TAG_CAPTURING_SCENE_CAPTURE_TYPE = "capturing-scene-capture-type"

// TAG_CAPTURING_SHARPNESS: direction of sharpness processing applied when
// capturing an image. (string)
//
// The allowed values are: "normal" "soft" "hard".
const TAG_CAPTURING_SHARPNESS = "capturing-sharpness"

// TAG_CAPTURING_SHUTTER_SPEED: shutter speed used when capturing an image,
// in seconds. (fraction).
const TAG_CAPTURING_SHUTTER_SPEED = "capturing-shutter-speed"

// TAG_CAPTURING_SOURCE indicates the source of capture. The device/medium used
// to do the capture. (string)
//
// Allowed values are: "dsc" (= digital still camera) "transparent-scanner"
// "reflex-scanner" "other".
const TAG_CAPTURING_SOURCE = "capturing-source"

// TAG_CAPTURING_WHITE_BALANCE: white balance mode used when capturing an image.
// (string)
//
// The allowed values are: "auto" "manual" "daylight" "cloudy" "tungsten"
// "fluorescent" "fluorescent h" (newer daylight-calibrated fluorescents)
// "flash".
const TAG_CAPTURING_WHITE_BALANCE = "capturing-white-balance"

// TAG_CDDA_CDDB_DISCID: CDDB disc id in its short form (e.g. 'aa063d0f').
const TAG_CDDA_CDDB_DISCID = "discid"

// TAG_CDDA_CDDB_DISCID_FULL: CDDB disc id including all details.
const TAG_CDDA_CDDB_DISCID_FULL = "discid-full"

// TAG_CDDA_MUSICBRAINZ_DISCID: musicbrainz disc id (e.g.
// 'ahg7JUcfR3vCYBphSDIogOOWrr0-').
const TAG_CDDA_MUSICBRAINZ_DISCID = "musicbrainz-discid"

// TAG_CDDA_MUSICBRAINZ_DISCID_FULL: musicbrainz disc id details.
const TAG_CDDA_MUSICBRAINZ_DISCID_FULL = "musicbrainz-discid-full"

// TAG_CMML_CLIP: annodex CMML clip element tag.
const TAG_CMML_CLIP = "cmml-clip"

// TAG_CMML_HEAD: annodex CMML head element tag.
const TAG_CMML_HEAD = "cmml-head"

// TAG_CMML_STREAM: annodex CMML stream element tag.
const TAG_CMML_STREAM = "cmml-stream"

// TAG_ID3V2_HEADER_SIZE: ID3V2 header size considered minimum input
// for some functions such as gst_tag_list_from_id3v2_tag() and
// gst_tag_get_id3v2_tag_size() for example.
const TAG_ID3V2_HEADER_SIZE = 10

// TAG_IMAGE_HORIZONTAL_PPI: media (image/video) intended horizontal pixel
// density in ppi. (double).
const TAG_IMAGE_HORIZONTAL_PPI = "image-horizontal-ppi"

// TAG_IMAGE_VERTICAL_PPI: media (image/video) intended vertical pixel density
// in ppi. (double).
const TAG_IMAGE_VERTICAL_PPI = "image-vertical-ppi"

// TAG_MUSICAL_KEY: musical key in which the sound starts. It is represented
// as a string with a maximum length of three characters. The ground keys are
// represented with "A","B","C","D","E", "F" and "G" and halfkeys represented
// with "b" and "#". Minor is represented as "m" (e.g. "Dbm"). Off key is
// represented with an "o" only. This notation might be extended in the future
// to support non-minor/major keys.
const TAG_MUSICAL_KEY = "musical-key"

// TAG_MUSICBRAINZ_ALBUMARTISTID: musicBrainz album artist ID.
const TAG_MUSICBRAINZ_ALBUMARTISTID = "musicbrainz-albumartistid"

// TAG_MUSICBRAINZ_ALBUMID: musicBrainz album ID.
const TAG_MUSICBRAINZ_ALBUMID = "musicbrainz-albumid"

// TAG_MUSICBRAINZ_ARTISTID: musicBrainz artist ID.
const TAG_MUSICBRAINZ_ARTISTID = "musicbrainz-artistid"

// TAG_MUSICBRAINZ_RELEASEGROUPID: musicBrainz Release Group ID.
const TAG_MUSICBRAINZ_RELEASEGROUPID = "musicbrainz-releasegroupid"

// TAG_MUSICBRAINZ_RELEASETRACKID: musicBrainz Release Track ID.
const TAG_MUSICBRAINZ_RELEASETRACKID = "musicbrainz-releasetrackid"

// TAG_MUSICBRAINZ_TRACKID: musicBrainz track ID.
const TAG_MUSICBRAINZ_TRACKID = "musicbrainz-trackid"

// TAG_MUSICBRAINZ_TRMID: musicBrainz track TRM ID.
const TAG_MUSICBRAINZ_TRMID = "musicbrainz-trmid"

// TagDemuxResult: result values from the parse_tag virtual function.
type TagDemuxResult C.gint

const (
	// TagDemuxResultBrokenTag: cannot parse tag, just skip it.
	TagDemuxResultBrokenTag TagDemuxResult = iota
	// TagDemuxResultAgain: call again with less or more data.
	TagDemuxResultAgain
	// TagDemuxResultOK: parsed tag successfully.
	TagDemuxResultOK
)

func marshalTagDemuxResult(p uintptr) (interface{}, error) {
	return TagDemuxResult(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TagDemuxResult.
func (t TagDemuxResult) String() string {
	switch t {
	case TagDemuxResultBrokenTag:
		return "BrokenTag"
	case TagDemuxResultAgain:
		return "Again"
	case TagDemuxResultOK:
		return "OK"
	default:
		return fmt.Sprintf("TagDemuxResult(%d)", t)
	}
}

// TagImageType: type of image contained in an image tag (specified as
// "image-type" field in the info structure in the image's Sample).
type TagImageType C.gint

const (
	// TagImageTypeNone: no image type. Can be used to tell functions such as
	// gst_tag_image_data_to_image_sample() that no image type should be set.
	TagImageTypeNone TagImageType = -1
	// TagImageTypeUndefined: undefined/other image type.
	TagImageTypeUndefined TagImageType = 0
	// TagImageTypeFrontCover: cover (front).
	TagImageTypeFrontCover TagImageType = 1
	// TagImageTypeBackCover: cover (back).
	TagImageTypeBackCover TagImageType = 2
	// TagImageTypeLeafletPage: leaflet page.
	TagImageTypeLeafletPage TagImageType = 3
	// TagImageTypeMedium: medium (e.g. label side of CD).
	TagImageTypeMedium TagImageType = 4
	// TagImageTypeLeadArtist: lead artist/lead performer/soloist.
	TagImageTypeLeadArtist TagImageType = 5
	// TagImageTypeArtist: artist/performer.
	TagImageTypeArtist TagImageType = 6
	// TagImageTypeConductor: conductor.
	TagImageTypeConductor TagImageType = 7
	// TagImageTypeBandOrchestra: band/orchestra.
	TagImageTypeBandOrchestra TagImageType = 8
	// TagImageTypeComposer: composer.
	TagImageTypeComposer TagImageType = 9
	// TagImageTypeLyricist: lyricist/text writer.
	TagImageTypeLyricist TagImageType = 10
	// TagImageTypeRecordingLocation: recording location.
	TagImageTypeRecordingLocation TagImageType = 11
	// TagImageTypeDuringRecording: during recording.
	TagImageTypeDuringRecording TagImageType = 12
	// TagImageTypeDuringPerformance: during performance.
	TagImageTypeDuringPerformance TagImageType = 13
	// TagImageTypeVideoCapture: movie/video screen capture.
	TagImageTypeVideoCapture TagImageType = 14
	// TagImageTypeFish: fish as funny as the ID3v2 spec.
	TagImageTypeFish TagImageType = 15
	// TagImageTypeIllustration: illustration.
	TagImageTypeIllustration TagImageType = 16
	// TagImageTypeBandArtistLogo: band/artist logotype.
	TagImageTypeBandArtistLogo TagImageType = 17
	// TagImageTypePublisherStudioLogo: publisher/studio logotype.
	TagImageTypePublisherStudioLogo TagImageType = 18
)

func marshalTagImageType(p uintptr) (interface{}, error) {
	return TagImageType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TagImageType.
func (t TagImageType) String() string {
	switch t {
	case TagImageTypeNone:
		return "None"
	case TagImageTypeUndefined:
		return "Undefined"
	case TagImageTypeFrontCover:
		return "FrontCover"
	case TagImageTypeBackCover:
		return "BackCover"
	case TagImageTypeLeafletPage:
		return "LeafletPage"
	case TagImageTypeMedium:
		return "Medium"
	case TagImageTypeLeadArtist:
		return "LeadArtist"
	case TagImageTypeArtist:
		return "Artist"
	case TagImageTypeConductor:
		return "Conductor"
	case TagImageTypeBandOrchestra:
		return "BandOrchestra"
	case TagImageTypeComposer:
		return "Composer"
	case TagImageTypeLyricist:
		return "Lyricist"
	case TagImageTypeRecordingLocation:
		return "RecordingLocation"
	case TagImageTypeDuringRecording:
		return "DuringRecording"
	case TagImageTypeDuringPerformance:
		return "DuringPerformance"
	case TagImageTypeVideoCapture:
		return "VideoCapture"
	case TagImageTypeFish:
		return "Fish"
	case TagImageTypeIllustration:
		return "Illustration"
	case TagImageTypeBandArtistLogo:
		return "BandArtistLogo"
	case TagImageTypePublisherStudioLogo:
		return "PublisherStudioLogo"
	default:
		return fmt.Sprintf("TagImageType(%d)", t)
	}
}

// TagLicenseFlags: see http://creativecommons.org/ns for more information.
type TagLicenseFlags C.guint

const (
	// TagLicensePermitsReproduction: making multiple copies is allowed.
	TagLicensePermitsReproduction TagLicenseFlags = 0b1
	// TagLicensePermitsDistribution: distribution, public display and public
	// performance are allowed.
	TagLicensePermitsDistribution TagLicenseFlags = 0b10
	// TagLicensePermitsDerivativeWorks: distribution of derivative works is
	// allowed.
	TagLicensePermitsDerivativeWorks TagLicenseFlags = 0b100
	// TagLicensePermitsSharing: commercial derivatives are allowed, but only
	// non-commercial distribution is allowed.
	TagLicensePermitsSharing TagLicenseFlags = 0b1000
	// TagLicenseRequiresNotice: copyright and license notices must be kept
	// intact.
	TagLicenseRequiresNotice TagLicenseFlags = 0b100000000
	// TagLicenseRequiresAttribution: credit must be given to copyright holder
	// and/or author.
	TagLicenseRequiresAttribution TagLicenseFlags = 0b1000000000
	// TagLicenseRequiresShareAlike: derivative works must be licensed under the
	// same terms or compatible terms as the original work.
	TagLicenseRequiresShareAlike TagLicenseFlags = 0b10000000000
	// TagLicenseRequiresSourceCode: source code (the preferred form for making
	// modifications) must be provided when exercising some rights granted by
	// the license.
	TagLicenseRequiresSourceCode TagLicenseFlags = 0b100000000000
	// TagLicenseRequiresCopyleft: derivative and combined works must be
	// licensed under specified terms, similar to those of the original work.
	TagLicenseRequiresCopyleft TagLicenseFlags = 0b1000000000000
	// TagLicenseRequiresLesserCopyleft: derivative works must be licensed under
	// specified terms, with at least the same conditions as the original work;
	// combinations with the work may be licensed under different terms.
	TagLicenseRequiresLesserCopyleft TagLicenseFlags = 0b10000000000000
	// TagLicenseProhibitsCommercialUse: exercising rights for commercial
	// purposes is prohibited.
	TagLicenseProhibitsCommercialUse TagLicenseFlags = 0b10000000000000000
	// TagLicenseProhibitsHighIncomeNationUse: use in a non-developing country
	// is prohibited.
	TagLicenseProhibitsHighIncomeNationUse TagLicenseFlags = 0b100000000000000000
	// TagLicenseCreativeCommonsLicense: license was created by the Creative
	// Commons project.
	TagLicenseCreativeCommonsLicense TagLicenseFlags = 0b1000000000000000000000000
	// TagLicenseFreeSoftwareFoundationLicense: license was created by the Free
	// Software Foundation (FSF).
	TagLicenseFreeSoftwareFoundationLicense TagLicenseFlags = 0b10000000000000000000000000
)

func marshalTagLicenseFlags(p uintptr) (interface{}, error) {
	return TagLicenseFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TagLicenseFlags.
func (t TagLicenseFlags) String() string {
	if t == 0 {
		return "TagLicenseFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TagLicensePermitsReproduction:
			builder.WriteString("PermitsReproduction|")
		case TagLicensePermitsDistribution:
			builder.WriteString("PermitsDistribution|")
		case TagLicensePermitsDerivativeWorks:
			builder.WriteString("PermitsDerivativeWorks|")
		case TagLicensePermitsSharing:
			builder.WriteString("PermitsSharing|")
		case TagLicenseRequiresNotice:
			builder.WriteString("RequiresNotice|")
		case TagLicenseRequiresAttribution:
			builder.WriteString("RequiresAttribution|")
		case TagLicenseRequiresShareAlike:
			builder.WriteString("RequiresShareAlike|")
		case TagLicenseRequiresSourceCode:
			builder.WriteString("RequiresSourceCode|")
		case TagLicenseRequiresCopyleft:
			builder.WriteString("RequiresCopyleft|")
		case TagLicenseRequiresLesserCopyleft:
			builder.WriteString("RequiresLesserCopyleft|")
		case TagLicenseProhibitsCommercialUse:
			builder.WriteString("ProhibitsCommercialUse|")
		case TagLicenseProhibitsHighIncomeNationUse:
			builder.WriteString("ProhibitsHighIncomeNationUse|")
		case TagLicenseCreativeCommonsLicense:
			builder.WriteString("CreativeCommonsLicense|")
		case TagLicenseFreeSoftwareFoundationLicense:
			builder.WriteString("FreeSoftwareFoundationLicense|")
		default:
			builder.WriteString(fmt.Sprintf("TagLicenseFlags(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TagLicenseFlags) Has(other TagLicenseFlags) bool {
	return (t & other) == other
}

// TagCheckLanguageCode: check if a given string contains a known ISO 639
// language code.
//
// This is useful in situations where it's not clear whether a given string
// is a language code (which should be put into a T_TAG_LANGUAGE_CODE tag)
// or a free-form language name descriptor (which should be put into a
// T_TAG_LANGUAGE_NAME tag instead).
//
// The function takes the following parameters:
//
//   - langCode: ISO-639 language code (e.g. "deu" or "ger" or "de").
//
// The function returns the following values:
//
//   - ok: TRUE if the two- or three-letter language code in lang_code is a
//     valid ISO-639 language code.
func TagCheckLanguageCode(langCode string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(langCode)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_check_language_code(_arg1)
	runtime.KeepAlive(langCode)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TagFreeformStringToUTF8: convenience function to read a string with unknown
// character encoding. If the string is already in UTF-8 encoding, it will be
// returned right away. If not it tries to detect byte-order-mark for UTF-16/32
// cases and use that. Otherwise, the environment will be searched for a number
// of environment variables (whose names are specified in the NULL-terminated
// string array env_vars) containing a list of character encodings to try/use.
// If none are specified, the current locale will be tried. If that also doesn't
// work, WINDOWS-1252/ISO-8859-1 is assumed (which will almost always succeed).
//
// The function takes the following parameters:
//
//   - data: string data.
//   - envVars: a NULL-terminated string array of environment variable names,
//     or NULL.
//
// The function returns the following values:
//
//   - utf8 (optional): newly-allocated string in UTF-8 encoding, or NULL.
func TagFreeformStringToUTF8(data string, envVars []string) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gint
	var _arg3 **C.gchar // out
	var _cret *C.gchar  // in

	_arg2 = (C.gint)(len(data))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(data) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(data)), data)
	defer C.free(unsafe.Pointer(_arg1))
	{
		_arg3 = (**C.gchar)(C.calloc(C.size_t((len(envVars) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg3))
		{
			out := unsafe.Slice(_arg3, len(envVars)+1)
			var zero *C.gchar
			out[len(envVars)] = zero
			for i := range envVars {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(envVars[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.gst_tag_freeform_string_to_utf8(_arg1, _arg2, _arg3)
	runtime.KeepAlive(data)
	runtime.KeepAlive(envVars)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// TagFromID3Tag looks up the GStreamer tag for a ID3v2 tag.
//
// The function takes the following parameters:
//
//   - id3Tag: ID3v2 tag to convert to GStreamer tag.
//
// The function returns the following values:
//
//   - utf8 (optional): corresponding GStreamer tag or NULL if none exists.
func TagFromID3Tag(id3Tag string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(id3Tag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_from_id3_tag(_arg1)
	runtime.KeepAlive(id3Tag)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TagFromID3UserTag looks up the GStreamer tag for an ID3v2 user tag (e.g.
// description in TXXX frame or owner in UFID frame).
//
// The function takes the following parameters:
//
//   - typ: type of ID3v2 user tag (e.g. "TXXX" or "UDIF").
//   - id3UserTag: ID3v2 user tag to convert to GStreamer tag.
//
// The function returns the following values:
//
//   - utf8 (optional): corresponding GStreamer tag or NULL if none exists.
func TagFromID3UserTag(typ, id3UserTag string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(id3UserTag)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_tag_from_id3_user_tag(_arg1, _arg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(id3UserTag)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TagFromVorbisTag looks up the GStreamer tag for a vorbiscomment tag.
//
// The function takes the following parameters:
//
//   - vorbisTag: vorbiscomment tag to convert to GStreamer tag.
//
// The function returns the following values:
//
//   - utf8 (optional): corresponding GStreamer tag or NULL if none exists.
func TagFromVorbisTag(vorbisTag string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(vorbisTag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_from_vorbis_tag(_arg1)
	runtime.KeepAlive(vorbisTag)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TagGetID3V2TagSize determines size of an ID3v2 tag on buffer containing at
// least ID3v2 header, i.e. at least T_TAG_ID3V2_HEADER_SIZE (10) bytes;.
//
// The function takes the following parameters:
//
//   - buffer holding ID3v2 tag (or at least the start of one).
//
// The function returns the following values:
//
//   - guint: size of tag, or 0 if header is invalid or too small.
func TagGetID3V2TagSize(buffer *gst.Buffer) uint {
	var _arg1 *C.GstBuffer // out
	var _cret C.guint      // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_tag_get_id3v2_tag_size(_arg1)
	runtime.KeepAlive(buffer)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// TagGetLanguageCodeISO6391 returns two-letter ISO-639-1 language code given
// a three-letter ISO-639-2 language code or two-letter ISO-639-1 language code
// (both are accepted for convenience).
//
// Language codes are case-sensitive and expected to be lower case.
//
// The function takes the following parameters:
//
//   - langCode: ISO-639 language code (e.g. "deu" or "ger" or "de").
//
// The function returns the following values:
//
//   - utf8 (optional): two-letter ISO-639-1 language code string that maps to
//     lang_code, or NULL if no mapping is known. The returned string must not
//     be modified or freed.
func TagGetLanguageCodeISO6391(langCode string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(langCode)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_language_code_iso_639_1(_arg1)
	runtime.KeepAlive(langCode)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TagGetLanguageCodeISO6392B returns three-letter ISO-639-2 "bibliographic"
// language code given a two-letter ISO-639-1 language code or a three-letter
// ISO-639-2 language code (both are accepted for convenience).
//
// The "bibliographic" code is derived from the English name of the language
// (e.g. "ger" for German instead of "de" or "deu"). In most scenarios,
// the "terminological" codes are preferred.
//
// Language codes are case-sensitive and expected to be lower case.
//
// The function takes the following parameters:
//
//   - langCode: ISO-639 language code (e.g. "deu" or "ger" or "de").
//
// The function returns the following values:
//
//   - utf8 (optional): three-letter ISO-639-2 language code string that maps to
//     lang_code, or NULL if no mapping is known. The returned string must not
//     be modified or freed.
func TagGetLanguageCodeISO6392B(langCode string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(langCode)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_language_code_iso_639_2B(_arg1)
	runtime.KeepAlive(langCode)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TagGetLanguageCodeISO6392T returns three-letter ISO-639-2 "terminological"
// language code given a two-letter ISO-639-1 language code or a three-letter
// ISO-639-2 language code (both are accepted for convenience).
//
// The "terminological" code is derived from the local name of the language
// (e.g. "deu" for German instead of "ger"). In most scenarios, the
// "terminological" codes are preferred over the "bibliographic" ones.
//
// Language codes are case-sensitive and expected to be lower case.
//
// The function takes the following parameters:
//
//   - langCode: ISO-639 language code (e.g. "deu" or "ger" or "de").
//
// The function returns the following values:
//
//   - utf8 (optional): three-letter ISO-639-2 language code string that maps to
//     lang_code, or NULL if no mapping is known. The returned string must not
//     be modified or freed.
func TagGetLanguageCodeISO6392T(langCode string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(langCode)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_language_code_iso_639_2T(_arg1)
	runtime.KeepAlive(langCode)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TagGetLanguageCodes returns a list of known language codes (in form of
// two-letter ISO-639-1 codes). This is useful for UIs to build a list of
// available languages for tagging purposes (e.g. to tag an audio track
// appropriately in a video or audio editor).
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated string array with two-letter language codes.
//     Free with g_strfreev() when no longer needed.
func TagGetLanguageCodes() []string {
	var _cret **C.gchar // in

	_cret = C.gst_tag_get_language_codes()

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// TagGetLanguageName returns the name of the language given an ISO-639 language
// code as found in a GST_TAG_LANGUAGE_CODE tag. The name will be translated
// according to the current locale (if the library was built against the
// iso-codes package, otherwise the English name will be returned).
//
// Language codes are case-sensitive and expected to be lower case.
//
// The function takes the following parameters:
//
//   - languageCode: two or three-letter ISO-639 language code.
//
// The function returns the following values:
//
//   - utf8 (optional): language name in UTF-8 format, or NULL if language_code
//     could not be mapped to a language name. The returned string must not
//     be modified and does not need to freed; it will stay valid until the
//     application is terminated.
func TagGetLanguageName(languageCode string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(languageCode)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_language_name(_arg1)
	runtime.KeepAlive(languageCode)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TagGetLicenseDescription: get the description of a license, which is a
// translated description of the license's main features.
//
// The function takes the following parameters:
//
//   - licenseRef: license reference string in form of a URI, e.g.
//     "http://creativecommons.org/licenses/by-nc-nd/2.0/".
//
// The function returns the following values:
//
//   - utf8 (optional): description of the license, or NULL if the license is
//     unknown or a description is not available.
func TagGetLicenseDescription(licenseRef string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(licenseRef)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_license_description(_arg1)
	runtime.KeepAlive(licenseRef)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TagGetLicenseFlags: get the flags of a license, which describe most of the
// features of a license in their most general form.
//
// The function takes the following parameters:
//
//   - licenseRef: license reference string in form of a URI, e.g.
//     "http://creativecommons.org/licenses/by-nc-nd/2.0/".
//
// The function returns the following values:
//
//   - tagLicenseFlags flags of the license, or 0 if the license is unknown.
func TagGetLicenseFlags(licenseRef string) TagLicenseFlags {
	var _arg1 *C.gchar             // out
	var _cret C.GstTagLicenseFlags // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(licenseRef)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_license_flags(_arg1)
	runtime.KeepAlive(licenseRef)

	var _tagLicenseFlags TagLicenseFlags // out

	_tagLicenseFlags = TagLicenseFlags(_cret)

	return _tagLicenseFlags
}

// TagGetLicenseJurisdiction: get the jurisdiction code of a license. This is
// usually a two-letter ISO 3166-1 alpha-2 code, but there is also the special
// case of Scotland, for which no code exists and which is thus represented as
// "scotland".
//
// Known jurisdictions: ar, at, au, be, bg, br, ca, ch, cl, cn, co, de, dk, es,
// fi, fr, hr, hu, il, in, it, jp, kr, mk, mt, mx, my, nl, pe, pl, pt, scotland,
// se, si, tw, uk, us, za.
//
// The function takes the following parameters:
//
//   - licenseRef: license reference string in form of a URI, e.g.
//     "http://creativecommons.org/licenses/by-nc-nd/2.0/".
//
// The function returns the following values:
//
//   - utf8 (optional): jurisdiction code of the license, or NULL if the license
//     is unknown or is not specific to a particular jurisdiction.
func TagGetLicenseJurisdiction(licenseRef string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(licenseRef)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_license_jurisdiction(_arg1)
	runtime.KeepAlive(licenseRef)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TagGetLicenseNick: get the nick name of a license, which is a short
// (untranslated) string such as e.g. "CC BY-NC-ND 2.0 UK".
//
// The function takes the following parameters:
//
//   - licenseRef: license reference string in form of a URI, e.g.
//     "http://creativecommons.org/licenses/by-nc-nd/2.0/".
//
// The function returns the following values:
//
//   - utf8 (optional): nick name of the license, or NULL if the license is
//     unknown.
func TagGetLicenseNick(licenseRef string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(licenseRef)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_license_nick(_arg1)
	runtime.KeepAlive(licenseRef)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TagGetLicenseTitle: get the title of a license, which is a short translated
// description of the license's features (generally not very pretty though).
//
// The function takes the following parameters:
//
//   - licenseRef: license reference string in form of a URI, e.g.
//     "http://creativecommons.org/licenses/by-nc-nd/2.0/".
//
// The function returns the following values:
//
//   - utf8 (optional): title of the license, or NULL if the license is unknown
//     or no title is available.
func TagGetLicenseTitle(licenseRef string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(licenseRef)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_license_title(_arg1)
	runtime.KeepAlive(licenseRef)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TagGetLicenseVersion: get the version of a license.
//
// The function takes the following parameters:
//
//   - licenseRef: license reference string in form of a URI, e.g.
//     "http://creativecommons.org/licenses/by-nc-nd/2.0/".
//
// The function returns the following values:
//
//   - utf8 (optional): version of the license, or NULL if the license is not
//     known or has no version.
func TagGetLicenseVersion(licenseRef string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(licenseRef)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_get_license_version(_arg1)
	runtime.KeepAlive(licenseRef)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TagGetLicenses returns a list of known license references (in form of URIs).
// This is useful for UIs to build a list of available licenses for tagging
// purposes (e.g. to tag an audio track appropriately in a video or audio
// editor, or an image in a camera application).
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of license strings. Free with g_strfreev()
//     when no longer needed.
func TagGetLicenses() []string {
	var _cret **C.gchar // in

	_cret = C.gst_tag_get_licenses()

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// TagID3GenreCount gets the number of ID3v1 genres that can be identified.
// Winamp genres are included.
//
// The function returns the following values:
//
//   - guint: number of ID3v1 genres that can be identified.
func TagID3GenreCount() uint {
	var _cret C.guint // in

	_cret = C.gst_tag_id3_genre_count()

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// TagID3GenreGet gets the ID3v1 genre name for a given ID.
//
// The function takes the following parameters:
//
//   - id: ID of genre to query.
//
// The function returns the following values:
//
//   - utf8 (optional): genre or NULL if no genre is associated with that ID.
func TagID3GenreGet(id uint) string {
	var _arg1 C.guint  // out
	var _cret *C.gchar // in

	_arg1 = C.guint(id)

	_cret = C.gst_tag_id3_genre_get(_arg1)
	runtime.KeepAlive(id)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TagImageDataToImageSample: helper function for tag-reading plugins to create
// a Sample suitable to add to a TagList as an image tag (such as T_TAG_IMAGE
// or T_TAG_PREVIEW_IMAGE) from the encoded image data and an (optional) image
// type.
//
// Background: cover art and other images in tags are usually stored as a blob
// of binary image data, often accompanied by a MIME type or some other content
// type string (e.g. 'png', 'jpeg', 'jpg'). Sometimes there is also an 'image
// type' to indicate what kind of image this is (e.g. front cover, back cover,
// artist, etc.). The image data may also be an URI to the image rather than the
// image itself.
//
// In GStreamer, image tags are Sample<!-- -->s containing the raw image data,
// with the sample caps describing the content type of the image (e.g.
// image/jpeg, image/png, text/uri-list). The sample info may contain an
// additional 'image-type' field of TagImageType to describe the type of image
// (front cover, back cover etc.). T_TAG_PREVIEW_IMAGE tags should not carry an
// image type, their type is already indicated via the special tag name.
//
// This function will do various checks and typefind the encoded image data (we
// can't trust the declared mime type).
//
// The function takes the following parameters:
//
//   - imageData: (encoded) image.
//   - imageType: type of the image, or T_TAG_IMAGE_TYPE_UNDEFINED.
//     Pass T_TAG_IMAGE_TYPE_NONE if no image type should be set at all (e.g.
//     for preview images).
//
// The function returns the following values:
//
//   - sample (optional): newly-allocated image sample for use in tag lists,
//     or NULL.
func TagImageDataToImageSample(imageData []byte, imageType TagImageType) *gst.Sample {
	var _arg1 *C.guint8 // out
	var _arg2 C.guint
	var _arg3 C.GstTagImageType // out
	var _cret *C.GstSample      // in

	_arg2 = (C.guint)(len(imageData))
	if len(imageData) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&imageData[0]))
	}
	_arg3 = C.GstTagImageType(imageType)

	_cret = C.gst_tag_image_data_to_image_sample(_arg1, _arg2, _arg3)
	runtime.KeepAlive(imageData)
	runtime.KeepAlive(imageType)

	var _sample *gst.Sample // out

	if _cret != nil {
		_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_sample)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _sample
}

// TagListAddID3Image adds an image from an ID3 APIC frame (or
// similar, such as used in FLAC) to the given tag list. Also see
// gst_tag_image_data_to_image_sample() for more information on image tags in
// GStreamer.
//
// The function takes the following parameters:
//
//   - tagList: tag list.
//   - imageData: (encoded) image.
//   - id3PictureType: picture type as per the ID3 (v2.4.0) specification for
//     the APIC frame (0 = unknown/other).
//
// The function returns the following values:
//
//   - ok: TRUE if the image was processed, otherwise FALSE.
func TagListAddID3Image(tagList *gst.TagList, imageData []byte, id3PictureType uint) bool {
	var _arg1 *C.GstTagList // out
	var _arg2 *C.guint8     // out
	var _arg3 C.guint
	var _arg4 C.guint    // out
	var _cret C.gboolean // in

	_arg1 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(tagList)))
	_arg3 = (C.guint)(len(imageData))
	if len(imageData) > 0 {
		_arg2 = (*C.guint8)(unsafe.Pointer(&imageData[0]))
	}
	_arg4 = C.guint(id3PictureType)

	_cret = C.gst_tag_list_add_id3_image(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(tagList)
	runtime.KeepAlive(imageData)
	runtime.KeepAlive(id3PictureType)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TagListFromExifBuffer parses the IFD and IFD tags data contained in the
// buffer and puts it on a taglist. The base_offset is used to subtract from
// the offset in the tag entries and be able to get the offset relative to the
// buffer start.
//
// The function takes the following parameters:
//
//   - buffer: exif buffer.
//   - byteOrder: byte order of the data.
//   - baseOffset: offset from the tiff header to this buffer.
//
// The function returns the following values:
//
//   - tagList: parsed taglist.
func TagListFromExifBuffer(buffer *gst.Buffer, byteOrder int, baseOffset uint32) *gst.TagList {
	var _arg1 *C.GstBuffer  // out
	var _arg2 C.gint        // out
	var _arg3 C.guint32     // out
	var _cret *C.GstTagList // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = C.gint(byteOrder)
	_arg3 = C.guint32(baseOffset)

	_cret = C.gst_tag_list_from_exif_buffer(_arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(byteOrder)
	runtime.KeepAlive(baseOffset)

	var _tagList *gst.TagList // out

	_tagList = (*gst.TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_tagList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _tagList
}

// TagListFromExifBufferWithTIFFHeader parses the exif tags starting with a tiff
// header structure.
//
// The function takes the following parameters:
//
//   - buffer: exif buffer.
//
// The function returns the following values:
//
//   - tagList: taglist.
func TagListFromExifBufferWithTIFFHeader(buffer *gst.Buffer) *gst.TagList {
	var _arg1 *C.GstBuffer  // out
	var _cret *C.GstTagList // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_tag_list_from_exif_buffer_with_tiff_header(_arg1)
	runtime.KeepAlive(buffer)

	var _tagList *gst.TagList // out

	_tagList = (*gst.TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_tagList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _tagList
}

// TagListFromID3V2Tag creates a new tag list that contains the information
// parsed out of a ID3 tag.
//
// The function takes the following parameters:
//
//   - buffer to convert.
//
// The function returns the following values:
//
//   - tagList (optional): new TagList with all tags that could be extracted
//     from the given vorbiscomment buffer or NULL on error.
func TagListFromID3V2Tag(buffer *gst.Buffer) *gst.TagList {
	var _arg1 *C.GstBuffer  // out
	var _cret *C.GstTagList // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_tag_list_from_id3v2_tag(_arg1)
	runtime.KeepAlive(buffer)

	var _tagList *gst.TagList // out

	if _cret != nil {
		_tagList = (*gst.TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_tagList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _tagList
}

// TagListFromVorbiscomment creates a new tag list that contains the information
// parsed out of a vorbiscomment packet.
//
// The function takes the following parameters:
//
//   - data to convert.
//   - idData: identification data at start of stream.
//
// The function returns the following values:
//
//   - vendorString (optional): pointer to a string that should take the vendor
//     string of this vorbis comment or NULL if you don't need it.
//   - tagList (optional): new TagList with all tags that could be extracted
//     from the given vorbiscomment buffer or NULL on error.
func TagListFromVorbiscomment(data, idData []byte) (string, *gst.TagList) {
	var _arg1 *C.guint8 // out
	var _arg2 C.gsize
	var _arg3 *C.guint8 // out
	var _arg4 C.guint
	var _arg5 *C.gchar      // in
	var _cret *C.GstTagList // in

	_arg2 = (C.gsize)(len(data))
	if len(data) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}
	_arg4 = (C.guint)(len(idData))
	if len(idData) > 0 {
		_arg3 = (*C.guint8)(unsafe.Pointer(&idData[0]))
	}

	_cret = C.gst_tag_list_from_vorbiscomment(_arg1, _arg2, _arg3, _arg4, &_arg5)
	runtime.KeepAlive(data)
	runtime.KeepAlive(idData)

	var _vendorString string  // out
	var _tagList *gst.TagList // out

	if _arg5 != nil {
		_vendorString = C.GoString((*C.gchar)(unsafe.Pointer(_arg5)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	if _cret != nil {
		_tagList = (*gst.TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_tagList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _vendorString, _tagList
}

// TagListFromVorbiscommentBuffer creates a new tag list that contains the
// information parsed out of a vorbiscomment packet.
//
// The function takes the following parameters:
//
//   - buffer to convert.
//   - idData: identification data at start of stream.
//
// The function returns the following values:
//
//   - vendorString (optional): pointer to a string that should take the vendor
//     string of this vorbis comment or NULL if you don't need it.
//   - tagList (optional): new TagList with all tags that could be extracted
//     from the given vorbiscomment buffer or NULL on error.
func TagListFromVorbiscommentBuffer(buffer *gst.Buffer, idData []byte) (string, *gst.TagList) {
	var _arg1 *C.GstBuffer // out
	var _arg2 *C.guint8    // out
	var _arg3 C.guint
	var _arg4 *C.gchar      // in
	var _cret *C.GstTagList // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg3 = (C.guint)(len(idData))
	if len(idData) > 0 {
		_arg2 = (*C.guint8)(unsafe.Pointer(&idData[0]))
	}

	_cret = C.gst_tag_list_from_vorbiscomment_buffer(_arg1, _arg2, _arg3, &_arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(idData)

	var _vendorString string  // out
	var _tagList *gst.TagList // out

	if _arg4 != nil {
		_vendorString = C.GoString((*C.gchar)(unsafe.Pointer(_arg4)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if _cret != nil {
		_tagList = (*gst.TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_tagList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _vendorString, _tagList
}

// TagListFromXmpBuffer: parse a xmp packet into a taglist.
//
// The function takes the following parameters:
//
//   - buffer: buffer.
//
// The function returns the following values:
//
//   - tagList (optional): new taglist or NULL, free the list when done.
func TagListFromXmpBuffer(buffer *gst.Buffer) *gst.TagList {
	var _arg1 *C.GstBuffer  // out
	var _cret *C.GstTagList // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_tag_list_from_xmp_buffer(_arg1)
	runtime.KeepAlive(buffer)

	var _tagList *gst.TagList // out

	if _cret != nil {
		_tagList = (*gst.TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_tagList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _tagList
}

// TagListNewFromID3V1 parses the data containing an ID3v1 tag and returns a
// TagList from the parsed data.
//
// The function takes the following parameters:
//
//   - data: 128 bytes of data containing the ID3v1 tag.
//
// The function returns the following values:
//
//   - tagList (optional): new tag list or NULL if the data was not an ID3v1
//     tag.
func TagListNewFromID3V1(data [128]byte) *gst.TagList {
	var _arg1 *C.guint8     // out
	var _cret *C.GstTagList // in

	_arg1 = (*C.guint8)(unsafe.Pointer(&data))

	_cret = C.gst_tag_list_new_from_id3v1(_arg1)
	runtime.KeepAlive(data)

	var _tagList *gst.TagList // out

	if _cret != nil {
		_tagList = (*gst.TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_tagList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _tagList
}

// TagListToExifBuffer formats the tags in taglist on exif format. The resulting
// buffer contains the tags IFD and is followed by the data pointed by the tag
// entries.
//
// The function takes the following parameters:
//
//   - taglist: taglist.
//   - byteOrder: byte order used in writing (G_LITTLE_ENDIAN or G_BIG_ENDIAN).
//   - baseOffset: offset from the tiff header first byte.
//
// The function returns the following values:
//
//   - buffer: gstBuffer containing the tag entries followed by the tag data.
func TagListToExifBuffer(taglist *gst.TagList, byteOrder int, baseOffset uint32) *gst.Buffer {
	var _arg1 *C.GstTagList // out
	var _arg2 C.gint        // out
	var _arg3 C.guint32     // out
	var _cret *C.GstBuffer  // in

	_arg1 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(taglist)))
	_arg2 = C.gint(byteOrder)
	_arg3 = C.guint32(baseOffset)

	_cret = C.gst_tag_list_to_exif_buffer(_arg1, _arg2, _arg3)
	runtime.KeepAlive(taglist)
	runtime.KeepAlive(byteOrder)
	runtime.KeepAlive(baseOffset)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _buffer
}

// TagListToExifBufferWithTIFFHeader formats the tags in taglist into exif
// structure, a tiff header is put in the beginning of the buffer.
//
// The function takes the following parameters:
//
//   - taglist: taglist.
//
// The function returns the following values:
//
//   - buffer: gstBuffer containing the data.
func TagListToExifBufferWithTIFFHeader(taglist *gst.TagList) *gst.Buffer {
	var _arg1 *C.GstTagList // out
	var _cret *C.GstBuffer  // in

	_arg1 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(taglist)))

	_cret = C.gst_tag_list_to_exif_buffer_with_tiff_header(_arg1)
	runtime.KeepAlive(taglist)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _buffer
}

// TagListToVorbiscommentBuffer creates a new vorbiscomment buffer from a tag
// list.
//
// The function takes the following parameters:
//
//   - list: tag list to convert.
//   - idData: identification data at start of stream.
//   - vendorString (optional): string that describes the vendor string or NULL.
//
// The function returns the following values:
//
//   - buffer: new Buffer containing a vorbiscomment buffer with all tags that
//     could be converted from the given tag list.
func TagListToVorbiscommentBuffer(list *gst.TagList, idData []byte, vendorString string) *gst.Buffer {
	var _arg1 *C.GstTagList // out
	var _arg2 *C.guint8     // out
	var _arg3 C.guint
	var _arg4 *C.gchar     // out
	var _cret *C.GstBuffer // in

	_arg1 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg3 = (C.guint)(len(idData))
	if len(idData) > 0 {
		_arg2 = (*C.guint8)(unsafe.Pointer(&idData[0]))
	}
	if vendorString != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(vendorString)))
		defer C.free(unsafe.Pointer(_arg4))
	}

	_cret = C.gst_tag_list_to_vorbiscomment_buffer(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(list)
	runtime.KeepAlive(idData)
	runtime.KeepAlive(vendorString)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _buffer
}

// TagListToXmpBuffer formats a taglist as a xmp packet using only the selected
// schemas. An empty list (NULL) means that all schemas should be used.
//
// The function takes the following parameters:
//
//   - list: tags.
//   - readOnly does the container forbid inplace editing.
//   - schemas: NULL terminated array of schemas to be used on serialization.
//
// The function returns the following values:
//
//   - buffer (optional): new buffer or NULL, unref the buffer when done.
func TagListToXmpBuffer(list *gst.TagList, readOnly bool, schemas []string) *gst.Buffer {
	var _arg1 *C.GstTagList // out
	var _arg2 C.gboolean    // out
	var _arg3 **C.gchar     // out
	var _cret *C.GstBuffer  // in

	_arg1 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	if readOnly {
		_arg2 = C.TRUE
	}
	{
		_arg3 = (**C.gchar)(C.calloc(C.size_t((len(schemas) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg3))
		{
			out := unsafe.Slice(_arg3, len(schemas)+1)
			var zero *C.gchar
			out[len(schemas)] = zero
			for i := range schemas {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(schemas[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.gst_tag_list_to_xmp_buffer(_arg1, _arg2, _arg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(readOnly)
	runtime.KeepAlive(schemas)

	var _buffer *gst.Buffer // out

	if _cret != nil {
		_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_buffer)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _buffer
}

// TagParseExtendedComment: convenience function to parse a
// GST_TAG_EXTENDED_COMMENT string and separate it into its components.
//
// If successful, key, lang and/or value will be set to newly allocated strings
// that you need to free with g_free() when done. key and lang may also be
// set to NULL by this function if there is no key or no language code in the
// extended comment string.
//
// The function takes the following parameters:
//
//   - extComment: extended comment string, see T_TAG_EXTENDED_COMMENT.
//   - failIfNoKey: whether to fail if strings are not in key=value form.
//
// The function returns the following values:
//
//   - key (optional): return location for the comment description key, or NULL.
//   - lang (optional): return location for the comment ISO-639 language code,
//     or NULL.
//   - value: return location for the actual comment string, or NULL.
//   - ok: TRUE if the string could be parsed, otherwise FALSE.
func TagParseExtendedComment(extComment string, failIfNoKey bool) (key, lang, value string, ok bool) {
	var _arg1 *C.gchar   // out
	var _arg2 *C.gchar   // in
	var _arg3 *C.gchar   // in
	var _arg4 *C.gchar   // in
	var _arg5 C.gboolean // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(extComment)))
	defer C.free(unsafe.Pointer(_arg1))
	if failIfNoKey {
		_arg5 = C.TRUE
	}

	_cret = C.gst_tag_parse_extended_comment(_arg1, &_arg2, &_arg3, &_arg4, _arg5)
	runtime.KeepAlive(extComment)
	runtime.KeepAlive(failIfNoKey)

	var _key string   // out
	var _lang string  // out
	var _value string // out
	var _ok bool      // out

	if _arg2 != nil {
		_key = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if _arg3 != nil {
		_lang = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	_value = C.GoString((*C.gchar)(unsafe.Pointer(_arg4)))
	defer C.free(unsafe.Pointer(_arg4))
	if _cret != 0 {
		_ok = true
	}

	return _key, _lang, _value, _ok
}

// TagRegisterMusicbrainzTags registers additional musicbrainz-specific tags
// with the GStreamer tag system. Plugins and applications that use these tags
// should call this function before using them. Can be called multiple times.
func TagRegisterMusicbrainzTags() {
	C.gst_tag_register_musicbrainz_tags()
}

// TagToID3Tag looks up the ID3v2 tag for a GStreamer tag.
//
// The function takes the following parameters:
//
//   - gstTag: GStreamer tag to convert to vorbiscomment tag.
//
// The function returns the following values:
//
//   - utf8 (optional): corresponding ID3v2 tag or NULL if none exists.
func TagToID3Tag(gstTag string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(gstTag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_to_id3_tag(_arg1)
	runtime.KeepAlive(gstTag)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TagToVorbisComments creates a new tag list that contains the information
// parsed out of a vorbiscomment packet.
//
// The function takes the following parameters:
//
//   - list: TagList.
//   - tag: GStreamer tag identifier, such as T_TAG_ARTIST.
//
// The function returns the following values:
//
//   - ret of newly-allocated key=value strings. Free with g_list_foreach (list,
//     (GFunc) g_free, NULL) plus g_list_free (list).
func TagToVorbisComments(list *gst.TagList, tag string) []string {
	var _arg1 *C.GstTagList // out
	var _arg2 *C.gchar      // out
	var _cret *C.GList      // in

	_arg1 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_tag_to_vorbis_comments(_arg1, _arg2)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)

	var _ret []string // out

	_ret = make([]string, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.gchar)(v)
		var dst string // out
		dst = C.GoString((*C.gchar)(unsafe.Pointer(src)))
		defer C.free(unsafe.Pointer(src))
		_ret = append(_ret, dst)
	})

	return _ret
}

// TagToVorbisTag looks up the vorbiscomment tag for a GStreamer tag.
//
// The function takes the following parameters:
//
//   - gstTag: GStreamer tag to convert to vorbiscomment tag.
//
// The function returns the following values:
//
//   - utf8 (optional): corresponding vorbiscomment tag or NULL if none exists.
func TagToVorbisTag(gstTag string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(gstTag)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_to_vorbis_tag(_arg1)
	runtime.KeepAlive(gstTag)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TagXmpListSchemas gets the list of supported schemas in the xmp lib.
//
// The function returns the following values:
//
//   - utf8s: NULL terminated array of strings with the schema names.
func TagXmpListSchemas() []string {
	var _cret **C.gchar // in

	_cret = C.gst_tag_xmp_list_schemas()

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// VorbisTagAdd: convenience function using gst_tag_from_vorbis_tag(), parsing a
// vorbis comment string into the right type and adding it to the given taglist
// list.
//
// Unknown vorbiscomment tags will be added to the tag list in form of a
// T_TAG_EXTENDED_COMMENT.
//
// The function takes the following parameters:
//
//   - list: TagList.
//   - tag: vorbiscomment tag string (key in key=value), must be valid UTF-8.
//   - value: vorbiscomment value string (value in key=value), must be valid
//     UTF-8.
func VorbisTagAdd(list *gst.TagList, tag, value string) {
	var _arg1 *C.GstTagList // out
	var _arg2 *C.gchar      // out
	var _arg3 *C.gchar      // out

	_arg1 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(list)))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(tag)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg3))

	C.gst_vorbis_tag_add(_arg1, _arg2, _arg3)
	runtime.KeepAlive(list)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(value)
}

// TagXmpWriterOverrider contains methods that are overridable.
type TagXmpWriterOverrider interface {
}

// TagXmpWriter: this interface is implemented by elements that are able to do
// XMP serialization. Examples for such elements are #jifmux and #qtmux.
//
// Applications can use this interface to configure which XMP schemas
// should be used when serializing tags into XMP. Schemas are represented
// by their names, a full list of the supported schemas can be obtained from
// gst_tag_xmp_list_schemas(). By default, all schemas are used.
//
// TagXmpWriter wraps an interface. This means the user can get the
// underlying type by calling Cast().
type TagXmpWriter struct {
	_ [0]func() // equal guard
	gst.Element
}

var (
	_ gst.Elementer = (*TagXmpWriter)(nil)
)

// TagXmpWriterer describes TagXmpWriter's interface methods.
type TagXmpWriterer interface {
	coreglib.Objector

	// AddAllSchemas adds all available XMP schemas to the configuration.
	AddAllSchemas()
	// AddSchema adds schema to the list schemas.
	AddSchema(schema string)
	// HasSchema checks if schema is going to be used.
	HasSchema(schema string) bool
	// RemoveAllSchemas removes all schemas from the list of schemas to use.
	RemoveAllSchemas()
	// RemoveSchema removes a schema from the list of schemas to use.
	RemoveSchema(schema string)
	TagListToXmpBuffer(taglist *gst.TagList, readOnly bool) *gst.Buffer
}

var _ TagXmpWriterer = (*TagXmpWriter)(nil)

func ifaceInitTagXmpWriterer(gifacePtr, data C.gpointer) {
}

func wrapTagXmpWriter(obj *coreglib.Object) *TagXmpWriter {
	return &TagXmpWriter{
		Element: gst.Element{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalTagXmpWriter(p uintptr) (interface{}, error) {
	return wrapTagXmpWriter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// AddAllSchemas adds all available XMP schemas to the configuration. Meaning
// that all will be used.
func (config *TagXmpWriter) AddAllSchemas() {
	var _arg0 *C.GstTagXmpWriter // out

	_arg0 = (*C.GstTagXmpWriter)(unsafe.Pointer(coreglib.InternObject(config).Native()))

	C.gst_tag_xmp_writer_add_all_schemas(_arg0)
	runtime.KeepAlive(config)
}

// AddSchema adds schema to the list schemas.
//
// The function takes the following parameters:
//
//   - schema to be added.
func (config *TagXmpWriter) AddSchema(schema string) {
	var _arg0 *C.GstTagXmpWriter // out
	var _arg1 *C.gchar           // out

	_arg0 = (*C.GstTagXmpWriter)(unsafe.Pointer(coreglib.InternObject(config).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(schema)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_tag_xmp_writer_add_schema(_arg0, _arg1)
	runtime.KeepAlive(config)
	runtime.KeepAlive(schema)
}

// HasSchema checks if schema is going to be used.
//
// The function takes the following parameters:
//
//   - schema to test.
//
// The function returns the following values:
//
//   - ok: TRUE if it is going to be used.
func (config *TagXmpWriter) HasSchema(schema string) bool {
	var _arg0 *C.GstTagXmpWriter // out
	var _arg1 *C.gchar           // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstTagXmpWriter)(unsafe.Pointer(coreglib.InternObject(config).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(schema)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_tag_xmp_writer_has_schema(_arg0, _arg1)
	runtime.KeepAlive(config)
	runtime.KeepAlive(schema)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveAllSchemas removes all schemas from the list of schemas to use. Meaning
// that no XMP will be generated.
func (config *TagXmpWriter) RemoveAllSchemas() {
	var _arg0 *C.GstTagXmpWriter // out

	_arg0 = (*C.GstTagXmpWriter)(unsafe.Pointer(coreglib.InternObject(config).Native()))

	C.gst_tag_xmp_writer_remove_all_schemas(_arg0)
	runtime.KeepAlive(config)
}

// RemoveSchema removes a schema from the list of schemas to use. Nothing is
// done if the schema wasn't in the list.
//
// The function takes the following parameters:
//
//   - schema to remove.
func (config *TagXmpWriter) RemoveSchema(schema string) {
	var _arg0 *C.GstTagXmpWriter // out
	var _arg1 *C.gchar           // out

	_arg0 = (*C.GstTagXmpWriter)(unsafe.Pointer(coreglib.InternObject(config).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(schema)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_tag_xmp_writer_remove_schema(_arg0, _arg1)
	runtime.KeepAlive(config)
	runtime.KeepAlive(schema)
}

// The function takes the following parameters:
//
//   - taglist
//   - readOnly
func (config *TagXmpWriter) TagListToXmpBuffer(taglist *gst.TagList, readOnly bool) *gst.Buffer {
	var _arg0 *C.GstTagXmpWriter // out
	var _arg1 *C.GstTagList      // out
	var _arg2 C.gboolean         // out
	var _cret *C.GstBuffer       // in

	_arg0 = (*C.GstTagXmpWriter)(unsafe.Pointer(coreglib.InternObject(config).Native()))
	_arg1 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(taglist)))
	if readOnly {
		_arg2 = C.TRUE
	}

	_cret = C.gst_tag_xmp_writer_tag_list_to_xmp_buffer(_arg0, _arg1, _arg2)
	runtime.KeepAlive(config)
	runtime.KeepAlive(taglist)
	runtime.KeepAlive(readOnly)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _buffer
}

// TagDemuxOverrides contains methods that are overridable.
type TagDemuxOverrides struct {
	// IdentifyTag: identify tag and determine the size required to parse the
	// tag. Buffer may be larger than the specified minimum size. Subclassed
	// MUST override this vfunc in their class_init function.
	//
	// The function takes the following parameters:
	//
	//   - buffer
	//   - startTag
	//   - tagSize
	IdentifyTag func(buffer *gst.Buffer, startTag bool, tagSize *uint) bool
	// MergeTags: merge start and end tags. Subclasses may want to override
	// this vfunc to allow prioritising of start or end tag according to
	// user preference. Note that both start_tags and end_tags may be NULL.
	// By default start tags are preferred over end tags.
	//
	// The function takes the following parameters:
	//
	//   - startTags
	//   - endTags
	MergeTags func(startTags, endTags *gst.TagList) *gst.TagList
}

func defaultTagDemuxOverrides(v *TagDemux) TagDemuxOverrides {
	return TagDemuxOverrides{
		IdentifyTag: v.identifyTag,
		MergeTags:   v.mergeTags,
	}
}

// TagDemux provides a base class for demuxing tags at the beginning or end of a
// stream and handles things like typefinding, querying, seeking, and different
// modes of operation (chain-based, pull_range-based, and providing downstream
// elements with random access if upstream supports that). The tag is stripped
// from the output, and all offsets are adjusted for the tag sizes, so that to
// the downstream element the stream will appear as if there was no tag at all.
// Also, once the tag has been parsed, GstTagDemux will try to determine the
// media type of the resulting stream and add a source pad with the appropriate
// caps in order to facilitate auto-plugging.
//
// # Deriving from GstTagDemux
//
// Subclasses have to do four things:
//
//   - In their base init function, they must add a pad template for the sink
//     pad to the element class, describing the media type they can parse in the
//     caps of the pad template.
//   - In their class init function, they must override
//     GST_TAG_DEMUX_CLASS(demux_klass)->identify_tag with their own identify
//     function.
//   - In their class init function, they must override
//     GST_TAG_DEMUX_CLASS(demux_klass)->parse_tag with their own parse
//     function.
//   - In their class init function, they must also set
//     GST_TAG_DEMUX_CLASS(demux_klass)->min_start_size and/or
//     GST_TAG_DEMUX_CLASS(demux_klass)->min_end_size to the minimum size
//     required for the identify function to decide whether the stream has a
//     supported tag or not. A class parsing ID3v1 tags, for example, would set
//     min_end_size to 128 bytes.
type TagDemux struct {
	_ [0]func() // equal guard
	gst.Element
}

var (
	_ gst.Elementer = (*TagDemux)(nil)
)

// TagDemuxer describes types inherited from class TagDemux.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type TagDemuxer interface {
	coreglib.Objector
	baseTagDemux() *TagDemux
}

var _ TagDemuxer = (*TagDemux)(nil)

func init() {
	coreglib.RegisterClassInfo[*TagDemux, *TagDemuxClass, TagDemuxOverrides](
		GTypeTagDemux,
		initTagDemuxClass,
		wrapTagDemux,
		defaultTagDemuxOverrides,
	)
}

func initTagDemuxClass(gclass unsafe.Pointer, overrides TagDemuxOverrides, classInitFunc func(*TagDemuxClass)) {
	pclass := (*C.GstTagDemuxClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeTagDemux))))

	if overrides.IdentifyTag != nil {
		pclass.identify_tag = (*[0]byte)(C._gotk4_gsttag1_TagDemuxClass_identify_tag)
	}

	if overrides.MergeTags != nil {
		pclass.merge_tags = (*[0]byte)(C._gotk4_gsttag1_TagDemuxClass_merge_tags)
	}

	if classInitFunc != nil {
		class := (*TagDemuxClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTagDemux(obj *coreglib.Object) *TagDemux {
	return &TagDemux{
		Element: gst.Element{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalTagDemux(p uintptr) (interface{}, error) {
	return wrapTagDemux(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *TagDemux) baseTagDemux() *TagDemux {
	return v
}

// BaseTagDemux returns the underlying base object.
func BaseTagDemux(obj TagDemuxer) *TagDemux {
	return obj.baseTagDemux()
}

// identifyTag: identify tag and determine the size required to parse the tag.
// Buffer may be larger than the specified minimum size. Subclassed MUST
// override this vfunc in their class_init function.
//
// The function takes the following parameters:
//
//   - buffer
//   - startTag
//   - tagSize
func (demux *TagDemux) identifyTag(buffer *gst.Buffer, startTag bool, tagSize *uint) bool {
	gclass := (*C.GstTagDemuxClass)(coreglib.PeekParentClass(demux))
	fnarg := gclass.identify_tag

	var _arg0 *C.GstTagDemux // out
	var _arg1 *C.GstBuffer   // out
	var _arg2 C.gboolean     // out
	var _arg3 *C.guint       // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstTagDemux)(unsafe.Pointer(coreglib.InternObject(demux).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	if startTag {
		_arg2 = C.TRUE
	}
	_arg3 = (*C.guint)(unsafe.Pointer(tagSize))

	_cret = C._gotk4_gsttag1_TagDemux_virtual_identify_tag(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(demux)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(startTag)
	runtime.KeepAlive(tagSize)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// mergeTags: merge start and end tags. Subclasses may want to override this
// vfunc to allow prioritising of start or end tag according to user preference.
// Note that both start_tags and end_tags may be NULL. By default start tags are
// preferred over end tags.
//
// The function takes the following parameters:
//
//   - startTags
//   - endTags
func (demux *TagDemux) mergeTags(startTags, endTags *gst.TagList) *gst.TagList {
	gclass := (*C.GstTagDemuxClass)(coreglib.PeekParentClass(demux))
	fnarg := gclass.merge_tags

	var _arg0 *C.GstTagDemux // out
	var _arg1 *C.GstTagList  // out
	var _arg2 *C.GstTagList  // out
	var _cret *C.GstTagList  // in

	_arg0 = (*C.GstTagDemux)(unsafe.Pointer(coreglib.InternObject(demux).Native()))
	_arg1 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(startTags)))
	_arg2 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(endTags)))

	_cret = C._gotk4_gsttag1_TagDemux_virtual_merge_tags(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(demux)
	runtime.KeepAlive(startTags)
	runtime.KeepAlive(endTags)

	var _tagList *gst.TagList // out

	_tagList = (*gst.TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_tagList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _tagList
}

// TagMuxOverrides contains methods that are overridable.
type TagMuxOverrides struct {
	// RenderEndTag: create a tag buffer to add to the end of the input stream
	// given a tag list, or NULL.
	RenderEndTag func(tagList *gst.TagList) *gst.Buffer
	// RenderStartTag: create a tag buffer to add to the beginning of the input
	// stream given a tag list, or NULL.
	RenderStartTag func(tagList *gst.TagList) *gst.Buffer
}

func defaultTagMuxOverrides(v *TagMux) TagMuxOverrides {
	return TagMuxOverrides{
		RenderEndTag:   v.renderEndTag,
		RenderStartTag: v.renderStartTag,
	}
}

// TagMux provides a base class for adding tags at the beginning or end of a
// stream.
//
// # Deriving from GstTagMux
//
// Subclasses have to do the following things:
//
//   - In their base init function, they must add pad templates for the sink pad
//     and the source pad to the element class, describing the media type they
//     accept and output in the caps of the pad template.
//   - In their class init function, they must override the
//     GST_TAG_MUX_CLASS(mux_klass)->render_start_tag and/or
//     GST_TAG_MUX_CLASS(mux_klass)->render_end_tag vfuncs and set up a render
//     function.
type TagMux struct {
	_ [0]func() // equal guard
	gst.Element

	gst.TagSetter
}

var (
	_ gst.Elementer = (*TagMux)(nil)
)

// TagMuxer describes types inherited from class TagMux.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type TagMuxer interface {
	coreglib.Objector
	baseTagMux() *TagMux
}

var _ TagMuxer = (*TagMux)(nil)

func init() {
	coreglib.RegisterClassInfo[*TagMux, *TagMuxClass, TagMuxOverrides](
		GTypeTagMux,
		initTagMuxClass,
		wrapTagMux,
		defaultTagMuxOverrides,
	)
}

func initTagMuxClass(gclass unsafe.Pointer, overrides TagMuxOverrides, classInitFunc func(*TagMuxClass)) {
	pclass := (*C.GstTagMuxClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeTagMux))))

	if overrides.RenderEndTag != nil {
		pclass.render_end_tag = (*[0]byte)(C._gotk4_gsttag1_TagMuxClass_render_end_tag)
	}

	if overrides.RenderStartTag != nil {
		pclass.render_start_tag = (*[0]byte)(C._gotk4_gsttag1_TagMuxClass_render_start_tag)
	}

	if classInitFunc != nil {
		class := (*TagMuxClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTagMux(obj *coreglib.Object) *TagMux {
	return &TagMux{
		Element: gst.Element{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
		TagSetter: gst.TagSetter{
			Element: gst.Element{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalTagMux(p uintptr) (interface{}, error) {
	return wrapTagMux(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *TagMux) baseTagMux() *TagMux {
	return v
}

// BaseTagMux returns the underlying base object.
func BaseTagMux(obj TagMuxer) *TagMux {
	return obj.baseTagMux()
}

// renderEndTag: create a tag buffer to add to the end of the input stream given
// a tag list, or NULL.
func (mux *TagMux) renderEndTag(tagList *gst.TagList) *gst.Buffer {
	gclass := (*C.GstTagMuxClass)(coreglib.PeekParentClass(mux))
	fnarg := gclass.render_end_tag

	var _arg0 *C.GstTagMux  // out
	var _arg1 *C.GstTagList // out
	var _cret *C.GstBuffer  // in

	_arg0 = (*C.GstTagMux)(unsafe.Pointer(coreglib.InternObject(mux).Native()))
	_arg1 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(tagList)))

	_cret = C._gotk4_gsttag1_TagMux_virtual_render_end_tag(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(mux)
	runtime.KeepAlive(tagList)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _buffer
}

// renderStartTag: create a tag buffer to add to the beginning of the input
// stream given a tag list, or NULL.
func (mux *TagMux) renderStartTag(tagList *gst.TagList) *gst.Buffer {
	gclass := (*C.GstTagMuxClass)(coreglib.PeekParentClass(mux))
	fnarg := gclass.render_start_tag

	var _arg0 *C.GstTagMux  // out
	var _arg1 *C.GstTagList // out
	var _cret *C.GstBuffer  // in

	_arg0 = (*C.GstTagMux)(unsafe.Pointer(coreglib.InternObject(mux).Native()))
	_arg1 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(tagList)))

	_cret = C._gotk4_gsttag1_TagMux_virtual_render_start_tag(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(mux)
	runtime.KeepAlive(tagList)

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _buffer
}

// TagDemuxClass structure. See documentation at beginning of section for
// details about what subclasses need to override and do.
//
// An instance of this type is always passed by reference.
type TagDemuxClass struct {
	*tagDemuxClass
}

// tagDemuxClass is the struct that's finalized.
type tagDemuxClass struct {
	native *C.GstTagDemuxClass
}

// ParentClass: parent class.
func (t *TagDemuxClass) ParentClass() *gst.ElementClass {
	valptr := &t.native.parent_class
	var _v *gst.ElementClass // out
	_v = (*gst.ElementClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// MinStartSize: minimum size required to identify a tag at the start and
// determine its total size. Set to 0 if not interested in start tags.
// Subclasses should set this in their class_init function.
func (t *TagDemuxClass) MinStartSize() uint {
	valptr := &t.native.min_start_size
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// MinEndSize: minimum size required to identify a tag at the end and determine
// its total size. Set to 0 if not interested in end tags. Subclasses should set
// this in their class_init function.
func (t *TagDemuxClass) MinEndSize() uint {
	valptr := &t.native.min_end_size
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// TagMuxClass structure. Subclasses need to override at least one of the two
// render vfuncs.
//
// An instance of this type is always passed by reference.
type TagMuxClass struct {
	*tagMuxClass
}

// tagMuxClass is the struct that's finalized.
type tagMuxClass struct {
	native *C.GstTagMuxClass
}

// ParentClass: parent class.
func (t *TagMuxClass) ParentClass() *gst.ElementClass {
	valptr := &t.native.parent_class
	var _v *gst.ElementClass // out
	_v = (*gst.ElementClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// TagXmpWriterInterface: instance of this type is always passed by reference.
type TagXmpWriterInterface struct {
	*tagXmpWriterInterface
}

// tagXmpWriterInterface is the struct that's finalized.
type tagXmpWriterInterface struct {
	native *C.GstTagXmpWriterInterface
}
