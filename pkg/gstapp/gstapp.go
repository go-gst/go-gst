// Code generated by girgen. DO NOT EDIT.

package gstapp

import (
	"fmt"
	"runtime"
	_ "runtime/cgo"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/go-gst/go-gst/pkg/gst"
	"github.com/go-gst/go-gst/pkg/gstbase"
)

// #cgo pkg-config: gstreamer-app-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/app/app.h>
// extern void _gotk4_gstapp1_AppSrc_ConnectNeedData(gpointer, guint, guintptr);
// extern void _gotk4_gstapp1_AppSrc_ConnectEnoughData(gpointer, guintptr);
// extern void _gotk4_gstapp1_AppSrcClass_need_data(GstAppSrc*, guint);
// extern void _gotk4_gstapp1_AppSrcClass_enough_data(GstAppSrc*);
// extern void _gotk4_gstapp1_AppSink_ConnectEos(gpointer, guintptr);
// extern void _gotk4_gstapp1_AppSinkClass_eos(GstAppSink*);
// extern gboolean _gotk4_gstapp1_AppSrc_ConnectSeekData(gpointer, guint64, guintptr);
// extern gboolean _gotk4_gstapp1_AppSrcClass_seek_data(GstAppSrc*, guint64);
// extern gboolean _gotk4_gstapp1_AppSink_ConnectProposeAllocation(gpointer, GstQuery*, guintptr);
// extern gboolean _gotk4_gstapp1_AppSink_ConnectNewSerializedEvent(gpointer, guintptr);
// extern GstSample* _gotk4_gstapp1_AppSinkClass_try_pull_sample(GstAppSink*, GstClockTime);
// extern GstSample* _gotk4_gstapp1_AppSinkClass_try_pull_preroll(GstAppSink*, GstClockTime);
// extern GstSample* _gotk4_gstapp1_AppSinkClass_pull_sample(GstAppSink*);
// extern GstSample* _gotk4_gstapp1_AppSinkClass_pull_preroll(GstAppSink*);
// extern GstFlowReturn _gotk4_gstapp1_AppSrcClass_push_sample(GstAppSrc*, GstSample*);
// extern GstFlowReturn _gotk4_gstapp1_AppSrcClass_push_buffer_list(GstAppSrc*, GstBufferList*);
// extern GstFlowReturn _gotk4_gstapp1_AppSrcClass_push_buffer(GstAppSrc*, GstBuffer*);
// extern GstFlowReturn _gotk4_gstapp1_AppSrcClass_end_of_stream(GstAppSrc*);
// extern GstFlowReturn _gotk4_gstapp1_AppSink_ConnectNewSample(gpointer, guintptr);
// extern GstFlowReturn _gotk4_gstapp1_AppSink_ConnectNewPreroll(gpointer, guintptr);
// extern GstFlowReturn _gotk4_gstapp1_AppSinkClass_new_sample(GstAppSink*);
// extern GstFlowReturn _gotk4_gstapp1_AppSinkClass_new_preroll(GstAppSink*);
// GstFlowReturn _gotk4_gstapp1_AppSink_virtual_new_preroll(void* fnptr, GstAppSink* arg0) {
//   return ((GstFlowReturn (*)(GstAppSink*))(fnptr))(arg0);
// };
// GstFlowReturn _gotk4_gstapp1_AppSink_virtual_new_sample(void* fnptr, GstAppSink* arg0) {
//   return ((GstFlowReturn (*)(GstAppSink*))(fnptr))(arg0);
// };
// GstFlowReturn _gotk4_gstapp1_AppSrc_virtual_end_of_stream(void* fnptr, GstAppSrc* arg0) {
//   return ((GstFlowReturn (*)(GstAppSrc*))(fnptr))(arg0);
// };
// GstFlowReturn _gotk4_gstapp1_AppSrc_virtual_push_buffer(void* fnptr, GstAppSrc* arg0, GstBuffer* arg1) {
//   return ((GstFlowReturn (*)(GstAppSrc*, GstBuffer*))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gstapp1_AppSrc_virtual_push_buffer_list(void* fnptr, GstAppSrc* arg0, GstBufferList* arg1) {
//   return ((GstFlowReturn (*)(GstAppSrc*, GstBufferList*))(fnptr))(arg0, arg1);
// };
// GstFlowReturn _gotk4_gstapp1_AppSrc_virtual_push_sample(void* fnptr, GstAppSrc* arg0, GstSample* arg1) {
//   return ((GstFlowReturn (*)(GstAppSrc*, GstSample*))(fnptr))(arg0, arg1);
// };
// GstSample* _gotk4_gstapp1_AppSink_virtual_pull_preroll(void* fnptr, GstAppSink* arg0) {
//   return ((GstSample* (*)(GstAppSink*))(fnptr))(arg0);
// };
// GstSample* _gotk4_gstapp1_AppSink_virtual_pull_sample(void* fnptr, GstAppSink* arg0) {
//   return ((GstSample* (*)(GstAppSink*))(fnptr))(arg0);
// };
// GstSample* _gotk4_gstapp1_AppSink_virtual_try_pull_preroll(void* fnptr, GstAppSink* arg0, GstClockTime arg1) {
//   return ((GstSample* (*)(GstAppSink*, GstClockTime))(fnptr))(arg0, arg1);
// };
// GstSample* _gotk4_gstapp1_AppSink_virtual_try_pull_sample(void* fnptr, GstAppSink* arg0, GstClockTime arg1) {
//   return ((GstSample* (*)(GstAppSink*, GstClockTime))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstapp1_AppSrc_virtual_seek_data(void* fnptr, GstAppSrc* arg0, guint64 arg1) {
//   return ((gboolean (*)(GstAppSrc*, guint64))(fnptr))(arg0, arg1);
// };
// void _gotk4_gstapp1_AppSink_virtual_eos(void* fnptr, GstAppSink* arg0) {
//   ((void (*)(GstAppSink*))(fnptr))(arg0);
// };
// void _gotk4_gstapp1_AppSrc_virtual_enough_data(void* fnptr, GstAppSrc* arg0) {
//   ((void (*)(GstAppSrc*))(fnptr))(arg0);
// };
// void _gotk4_gstapp1_AppSrc_virtual_need_data(void* fnptr, GstAppSrc* arg0, guint arg1) {
//   ((void (*)(GstAppSrc*, guint))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeAppLeakyType  = coreglib.Type(C.gst_app_leaky_type_get_type())
	GTypeAppStreamType = coreglib.Type(C.gst_app_stream_type_get_type())
	GTypeAppSink       = coreglib.Type(C.gst_app_sink_get_type())
	GTypeAppSrc        = coreglib.Type(C.gst_app_src_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAppLeakyType, F: marshalAppLeakyType},
		coreglib.TypeMarshaler{T: GTypeAppStreamType, F: marshalAppStreamType},
		coreglib.TypeMarshaler{T: GTypeAppSink, F: marshalAppSink},
		coreglib.TypeMarshaler{T: GTypeAppSrc, F: marshalAppSrc},
	})
}

// AppLeakyType: buffer dropping scheme to avoid the element's internal queue to
// block when full.
type AppLeakyType C.gint

const (
	// AppLeakyTypeNone: not Leaky.
	AppLeakyTypeNone AppLeakyType = iota
	// AppLeakyTypeUpstream: leaky on upstream (new buffers).
	AppLeakyTypeUpstream
	// AppLeakyTypeDownstream: leaky on downstream (old buffers).
	AppLeakyTypeDownstream
)

func marshalAppLeakyType(p uintptr) (interface{}, error) {
	return AppLeakyType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AppLeakyType.
func (a AppLeakyType) String() string {
	switch a {
	case AppLeakyTypeNone:
		return "None"
	case AppLeakyTypeUpstream:
		return "Upstream"
	case AppLeakyTypeDownstream:
		return "Downstream"
	default:
		return fmt.Sprintf("AppLeakyType(%d)", a)
	}
}

// AppStreamType: stream type.
type AppStreamType C.gint

const (
	// AppStreamTypeStream: no seeking is supported in the stream, such as a
	// live stream.
	AppStreamTypeStream AppStreamType = iota
	// AppStreamTypeSeekable: stream is seekable but seeking might not be very
	// fast, such as data from a webserver.
	AppStreamTypeSeekable
	// AppStreamTypeRandomAccess: stream is seekable and seeking is fast,
	// such as in a local file.
	AppStreamTypeRandomAccess
)

func marshalAppStreamType(p uintptr) (interface{}, error) {
	return AppStreamType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AppStreamType.
func (a AppStreamType) String() string {
	switch a {
	case AppStreamTypeStream:
		return "Stream"
	case AppStreamTypeSeekable:
		return "Seekable"
	case AppStreamTypeRandomAccess:
		return "RandomAccess"
	default:
		return fmt.Sprintf("AppStreamType(%d)", a)
	}
}

// AppSinkOverrides contains methods that are overridable.
type AppSinkOverrides struct {
	Eos        func()
	NewPreroll func() gst.FlowReturn
	NewSample  func() gst.FlowReturn
	// PullPreroll: get the last preroll sample in appsink. This was the sample
	// that caused the appsink to preroll in the PAUSED state.
	//
	// This function is typically used when dealing with a pipeline in the
	// PAUSED state. Calling this function after doing a seek will give the
	// sample right after the seek position.
	//
	// Calling this function will clear the internal reference to the preroll
	// buffer.
	//
	// Note that the preroll sample will also be returned as the first sample
	// when calling gst_app_sink_pull_sample().
	//
	// If an EOS event was received before any buffers, this function returns
	// NULL. Use gst_app_sink_is_eos () to check for the EOS condition.
	//
	// This function blocks until a preroll sample or EOS is received or the
	// appsink element is set to the READY/NULL state.
	//
	// The function returns the following values:
	//
	//   - sample (optional) or NULL when the appsink is stopped or EOS.
	//     Call gst_sample_unref() after usage.
	PullPreroll func() *gst.Sample
	// PullSample: this function blocks until a sample or EOS becomes available
	// or the appsink element is set to the READY/NULL state.
	//
	// This function will only return samples when the appsink is in the
	// PLAYING state. All rendered buffers will be put in a queue so that
	// the application can pull samples at its own rate. Note that when the
	// application does not pull samples fast enough, the queued buffers could
	// consume a lot of memory, especially when dealing with raw video frames.
	//
	// If an EOS event was received before any buffers, this function returns
	// NULL. Use gst_app_sink_is_eos () to check for the EOS condition.
	//
	// The function returns the following values:
	//
	//   - sample (optional) or NULL when the appsink is stopped or EOS.
	//     Call gst_sample_unref() after usage.
	PullSample func() *gst.Sample
	// TryPullPreroll: get the last preroll sample in appsink. This was the
	// sample that caused the appsink to preroll in the PAUSED state.
	//
	// This function is typically used when dealing with a pipeline in the
	// PAUSED state. Calling this function after doing a seek will give the
	// sample right after the seek position.
	//
	// Calling this function will clear the internal reference to the preroll
	// buffer.
	//
	// Note that the preroll sample will also be returned as the first sample
	// when calling gst_app_sink_pull_sample().
	//
	// If an EOS event was received before any buffers or the timeout expires,
	// this function returns NULL. Use gst_app_sink_is_eos () to check for the
	// EOS condition.
	//
	// This function blocks until a preroll sample or EOS is received, the
	// appsink element is set to the READY/NULL state, or the timeout expires.
	//
	// The function takes the following parameters:
	//
	//   - timeout: maximum amount of time to wait for the preroll sample.
	//
	// The function returns the following values:
	//
	//   - sample (optional) or NULL when the appsink is stopped or EOS or the
	//     timeout expires. Call gst_sample_unref() after usage.
	TryPullPreroll func(timeout gst.ClockTime) *gst.Sample
	// TryPullSample: this function blocks until a sample or EOS becomes
	// available or the appsink element is set to the READY/NULL state or the
	// timeout expires.
	//
	// This function will only return samples when the appsink is in the
	// PLAYING state. All rendered buffers will be put in a queue so that
	// the application can pull samples at its own rate. Note that when the
	// application does not pull samples fast enough, the queued buffers could
	// consume a lot of memory, especially when dealing with raw video frames.
	//
	// If an EOS event was received before any buffers or the timeout expires,
	// this function returns NULL. Use gst_app_sink_is_eos () to check for the
	// EOS condition.
	//
	// The function takes the following parameters:
	//
	//   - timeout: maximum amount of time to wait for a sample.
	//
	// The function returns the following values:
	//
	//   - sample (optional) or NULL when the appsink is stopped or EOS or the
	//     timeout expires. Call gst_sample_unref() after usage.
	TryPullSample func(timeout gst.ClockTime) *gst.Sample
}

func defaultAppSinkOverrides(v *AppSink) AppSinkOverrides {
	return AppSinkOverrides{
		Eos:            v.eos,
		NewPreroll:     v.newPreroll,
		NewSample:      v.newSample,
		PullPreroll:    v.pullPreroll,
		PullSample:     v.pullSample,
		TryPullPreroll: v.tryPullPreroll,
		TryPullSample:  v.tryPullSample,
	}
}

// AppSink: appsink is a sink plugin that supports many different methods for
// making the application get a handle on the GStreamer data in a pipeline.
// Unlike most GStreamer elements, Appsink provides external API functions.
//
// appsink can be used by linking to the gstappsink.h header file to access the
// methods or by using the appsink action signals and properties.
//
// The normal way of retrieving samples from appsink is by using the
// gst_app_sink_pull_sample() and gst_app_sink_pull_preroll() methods. These
// methods block until a sample becomes available in the sink or when the sink
// is shut down or reaches EOS. There are also timed variants of these methods,
// gst_app_sink_try_pull_sample() and gst_app_sink_try_pull_preroll(), which
// accept a timeout parameter to limit the amount of time to wait.
//
// Appsink will internally use a queue to collect buffers from the streaming
// thread. If the application is not pulling samples fast enough, this queue
// will consume a lot of memory over time. The "max-buffers", "max-time" and
// "max-bytes" properties can be used to limit the queue size. The "drop"
// property controls whether the streaming thread blocks or if older buffers
// are dropped when the maximum queue size is reached. Note that blocking the
// streaming thread can negatively affect real-time performance and should be
// avoided.
//
// If a blocking behaviour is not desirable, setting the "emit-signals" property
// to TRUE will make appsink emit the "new-sample" and "new-preroll" signals
// when a sample can be pulled without blocking.
//
// The "caps" property on appsink can be used to control the formats that
// appsink can receive. This property can contain non-fixed caps, the format of
// the pulled samples can be obtained by getting the sample caps.
//
// If one of the pull-preroll or pull-sample methods return NULL, the appsink is
// stopped or in the EOS state. You can check for the EOS state with the "eos"
// property or with the gst_app_sink_is_eos() method.
//
// The eos signal can also be used to be informed when the EOS state is reached
// to avoid polling.
type AppSink struct {
	_ [0]func() // equal guard
	gstbase.BaseSink

	gst.URIHandler
}

var (
	_ gstbase.BaseSinker = (*AppSink)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*AppSink, *AppSinkClass, AppSinkOverrides](
		GTypeAppSink,
		initAppSinkClass,
		wrapAppSink,
		defaultAppSinkOverrides,
	)
}

func initAppSinkClass(gclass unsafe.Pointer, overrides AppSinkOverrides, classInitFunc func(*AppSinkClass)) {
	pclass := (*C.GstAppSinkClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAppSink))))

	if overrides.Eos != nil {
		pclass.eos = (*[0]byte)(C._gotk4_gstapp1_AppSinkClass_eos)
	}

	if overrides.NewPreroll != nil {
		pclass.new_preroll = (*[0]byte)(C._gotk4_gstapp1_AppSinkClass_new_preroll)
	}

	if overrides.NewSample != nil {
		pclass.new_sample = (*[0]byte)(C._gotk4_gstapp1_AppSinkClass_new_sample)
	}

	if overrides.PullPreroll != nil {
		pclass.pull_preroll = (*[0]byte)(C._gotk4_gstapp1_AppSinkClass_pull_preroll)
	}

	if overrides.PullSample != nil {
		pclass.pull_sample = (*[0]byte)(C._gotk4_gstapp1_AppSinkClass_pull_sample)
	}

	if overrides.TryPullPreroll != nil {
		pclass.try_pull_preroll = (*[0]byte)(C._gotk4_gstapp1_AppSinkClass_try_pull_preroll)
	}

	if overrides.TryPullSample != nil {
		pclass.try_pull_sample = (*[0]byte)(C._gotk4_gstapp1_AppSinkClass_try_pull_sample)
	}

	if classInitFunc != nil {
		class := (*AppSinkClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAppSink(obj *coreglib.Object) *AppSink {
	return &AppSink{
		BaseSink: gstbase.BaseSink{
			Element: gst.Element{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
		URIHandler: gst.URIHandler{
			Object: obj,
		},
	}
}

func marshalAppSink(p uintptr) (interface{}, error) {
	return wrapAppSink(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectEos: signal that the end-of-stream has been reached. This signal is
// emitted from the streaming thread.
func (appsink *AppSink) ConnectEos(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsink, "eos", false, unsafe.Pointer(C._gotk4_gstapp1_AppSink_ConnectEos), f)
}

// ConnectNewPreroll: signal that a new preroll sample is available.
//
// This signal is emitted from the streaming thread and only when the
// "emit-signals" property is TRUE.
//
// The new preroll sample can be retrieved with the "pull-preroll" action signal
// or gst_app_sink_pull_preroll() either from this signal callback or from any
// other thread.
//
// Note that this signal is only emitted when the "emit-signals" property is set
// to TRUE, which it is not by default for performance reasons.
func (appsink *AppSink) ConnectNewPreroll(f func() (flowReturn gst.FlowReturn)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsink, "new-preroll", false, unsafe.Pointer(C._gotk4_gstapp1_AppSink_ConnectNewPreroll), f)
}

// ConnectNewSample: signal that a new sample is available.
//
// This signal is emitted from the streaming thread and only when the
// "emit-signals" property is TRUE.
//
// The new sample can be retrieved with the "pull-sample" action signal or
// gst_app_sink_pull_sample() either from this signal callback or from any other
// thread.
//
// Note that this signal is only emitted when the "emit-signals" property is set
// to TRUE, which it is not by default for performance reasons.
func (appsink *AppSink) ConnectNewSample(f func() (flowReturn gst.FlowReturn)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsink, "new-sample", false, unsafe.Pointer(C._gotk4_gstapp1_AppSink_ConnectNewSample), f)
}

// ConnectNewSerializedEvent: signal that a new downstream serialized event is
// available.
//
// This signal is emitted from the streaming thread and only when the
// "emit-signals" property is TRUE.
//
// The new event can be retrieved with the "try-pull-object" action signal or
// gst_app_sink_pull_object() either from this signal callback or from any other
// thread.
//
// EOS will not be notified using this signal, use AppSink::eos instead.
// EOS cannot be pulled either, use gst_app_sink_is_eos() to check for it.
//
// Note that this signal is only emitted when the "emit-signals" property is set
// to TRUE, which it is not by default for performance reasons.
//
// The callback should return TRUE if the event has been handled, which will
// skip basesink handling of the event, FALSE otherwise.
func (appsink *AppSink) ConnectNewSerializedEvent(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsink, "new-serialized-event", false, unsafe.Pointer(C._gotk4_gstapp1_AppSink_ConnectNewSerializedEvent), f)
}

// ConnectProposeAllocation: signal that a new propose_allocation query is
// available.
//
// This signal is emitted from the streaming thread and only when the
// "emit-signals" property is TRUE.
func (appsink *AppSink) ConnectProposeAllocation(f func(query *gst.Query) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsink, "propose-allocation", false, unsafe.Pointer(C._gotk4_gstapp1_AppSink_ConnectProposeAllocation), f)
}

// BufferListSupport: check if appsink supports buffer lists.
//
// The function returns the following values:
//
//   - ok: TRUE if appsink supports buffer lists.
func (appsink *AppSink) BufferListSupport() bool {
	var _arg0 *C.GstAppSink // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C.gst_app_sink_get_buffer_list_support(_arg0)
	runtime.KeepAlive(appsink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Caps: get the configured caps on appsink.
//
// The function returns the following values:
//
//   - caps (optional) accepted by the sink. gst_caps_unref() after usage.
func (appsink *AppSink) Caps() *gst.Caps {
	var _arg0 *C.GstAppSink // out
	var _cret *C.GstCaps    // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C.gst_app_sink_get_caps(_arg0)
	runtime.KeepAlive(appsink)

	var _caps *gst.Caps // out

	if _cret != nil {
		_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_caps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _caps
}

// Drop: check if appsink will drop old buffers when the maximum amount of
// queued data is reached (meaning max buffers, time or bytes limit, whichever
// is hit first).
//
// The function returns the following values:
//
//   - ok: TRUE if appsink is dropping old buffers when the queue is filled.
func (appsink *AppSink) Drop() bool {
	var _arg0 *C.GstAppSink // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C.gst_app_sink_get_drop(_arg0)
	runtime.KeepAlive(appsink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EmitSignals: check if appsink will emit the "new-preroll" and "new-sample"
// signals.
//
// The function returns the following values:
//
//   - ok: TRUE if appsink is emitting the "new-preroll" and "new-sample"
//     signals.
func (appsink *AppSink) EmitSignals() bool {
	var _arg0 *C.GstAppSink // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C.gst_app_sink_get_emit_signals(_arg0)
	runtime.KeepAlive(appsink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MaxBuffers: get the maximum amount of buffers that can be queued in appsink.
//
// The function returns the following values:
//
//   - guint: maximum amount of buffers that can be queued.
func (appsink *AppSink) MaxBuffers() uint {
	var _arg0 *C.GstAppSink // out
	var _cret C.guint       // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C.gst_app_sink_get_max_buffers(_arg0)
	runtime.KeepAlive(appsink)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// MaxBytes: get the maximum total size, in bytes, that can be queued in
// appsink.
//
// The function returns the following values:
//
//   - guint64: maximum amount of bytes that can be queued.
func (appsink *AppSink) MaxBytes() uint64 {
	var _arg0 *C.GstAppSink // out
	var _cret C.guint64     // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C.gst_app_sink_get_max_bytes(_arg0)
	runtime.KeepAlive(appsink)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// MaxTime: get the maximum total duration that can be queued in appsink.
//
// The function returns the following values:
//
//   - clockTime: maximum total duration that can be queued.
func (appsink *AppSink) MaxTime() gst.ClockTime {
	var _arg0 *C.GstAppSink  // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C.gst_app_sink_get_max_time(_arg0)
	runtime.KeepAlive(appsink)

	var _clockTime gst.ClockTime // out

	_clockTime = gst.ClockTime(_cret)

	return _clockTime
}

// WaitOnEos: check if appsink will wait for all buffers to be consumed when an
// EOS is received.
//
// The function returns the following values:
//
//   - ok: TRUE if appsink will wait for all buffers to be consumed when an EOS
//     is received.
func (appsink *AppSink) WaitOnEos() bool {
	var _arg0 *C.GstAppSink // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C.gst_app_sink_get_wait_on_eos(_arg0)
	runtime.KeepAlive(appsink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEos: check if appsink is EOS, which is when no more samples can be pulled
// because an EOS event was received.
//
// This function also returns TRUE when the appsink is not in the PAUSED or
// PLAYING state.
//
// The function returns the following values:
//
//   - ok: TRUE if no more samples can be pulled and the appsink is EOS.
func (appsink *AppSink) IsEos() bool {
	var _arg0 *C.GstAppSink // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C.gst_app_sink_is_eos(_arg0)
	runtime.KeepAlive(appsink)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PullPreroll: get the last preroll sample in appsink. This was the sample that
// caused the appsink to preroll in the PAUSED state.
//
// This function is typically used when dealing with a pipeline in the PAUSED
// state. Calling this function after doing a seek will give the sample right
// after the seek position.
//
// Calling this function will clear the internal reference to the preroll
// buffer.
//
// Note that the preroll sample will also be returned as the first sample when
// calling gst_app_sink_pull_sample().
//
// If an EOS event was received before any buffers, this function returns NULL.
// Use gst_app_sink_is_eos () to check for the EOS condition.
//
// This function blocks until a preroll sample or EOS is received or the appsink
// element is set to the READY/NULL state.
//
// The function returns the following values:
//
//   - sample (optional) or NULL when the appsink is stopped or EOS. Call
//     gst_sample_unref() after usage.
func (appsink *AppSink) PullPreroll() *gst.Sample {
	var _arg0 *C.GstAppSink // out
	var _cret *C.GstSample  // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C.gst_app_sink_pull_preroll(_arg0)
	runtime.KeepAlive(appsink)

	var _sample *gst.Sample // out

	if _cret != nil {
		_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_sample)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _sample
}

// PullSample: this function blocks until a sample or EOS becomes available or
// the appsink element is set to the READY/NULL state.
//
// This function will only return samples when the appsink is in the PLAYING
// state. All rendered buffers will be put in a queue so that the application
// can pull samples at its own rate. Note that when the application does not
// pull samples fast enough, the queued buffers could consume a lot of memory,
// especially when dealing with raw video frames.
//
// If an EOS event was received before any buffers, this function returns NULL.
// Use gst_app_sink_is_eos () to check for the EOS condition.
//
// The function returns the following values:
//
//   - sample (optional) or NULL when the appsink is stopped or EOS. Call
//     gst_sample_unref() after usage.
func (appsink *AppSink) PullSample() *gst.Sample {
	var _arg0 *C.GstAppSink // out
	var _cret *C.GstSample  // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C.gst_app_sink_pull_sample(_arg0)
	runtime.KeepAlive(appsink)

	var _sample *gst.Sample // out

	if _cret != nil {
		_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_sample)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _sample
}

// SetBufferListSupport: instruct appsink to enable or disable buffer list
// support.
//
// For backwards-compatibility reasons applications need to opt in to indicate
// that they will be able to handle buffer lists.
//
// The function takes the following parameters:
//
//   - enableLists: enable or disable buffer list support.
func (appsink *AppSink) SetBufferListSupport(enableLists bool) {
	var _arg0 *C.GstAppSink // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))
	if enableLists {
		_arg1 = C.TRUE
	}

	C.gst_app_sink_set_buffer_list_support(_arg0, _arg1)
	runtime.KeepAlive(appsink)
	runtime.KeepAlive(enableLists)
}

// SetCaps: set the capabilities on the appsink element. This function takes
// a copy of the caps structure. After calling this method, the sink will only
// accept caps that match caps. If caps is non-fixed, or incomplete, you must
// check the caps on the samples to get the actual used caps.
//
// The function takes the following parameters:
//
//   - caps (optional) to set.
func (appsink *AppSink) SetCaps(caps *gst.Caps) {
	var _arg0 *C.GstAppSink // out
	var _arg1 *C.GstCaps    // out

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))
	if caps != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}

	C.gst_app_sink_set_caps(_arg0, _arg1)
	runtime.KeepAlive(appsink)
	runtime.KeepAlive(caps)
}

// SetDrop: instruct appsink to drop old buffers when the maximum amount
// of queued data is reached, that is, when any configured limit is hit
// (max-buffers, max-time or max-bytes).
//
// The function takes the following parameters:
//
//   - drop: new state.
func (appsink *AppSink) SetDrop(drop bool) {
	var _arg0 *C.GstAppSink // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))
	if drop {
		_arg1 = C.TRUE
	}

	C.gst_app_sink_set_drop(_arg0, _arg1)
	runtime.KeepAlive(appsink)
	runtime.KeepAlive(drop)
}

// SetEmitSignals: make appsink emit the "new-preroll" and "new-sample" signals.
// This option is by default disabled because signal emission is expensive and
// unneeded when the application prefers to operate in pull mode.
//
// The function takes the following parameters:
//
//   - emit: new state.
func (appsink *AppSink) SetEmitSignals(emit bool) {
	var _arg0 *C.GstAppSink // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))
	if emit {
		_arg1 = C.TRUE
	}

	C.gst_app_sink_set_emit_signals(_arg0, _arg1)
	runtime.KeepAlive(appsink)
	runtime.KeepAlive(emit)
}

// SetMaxBuffers: set the maximum amount of buffers that can be queued in
// appsink. After this amount of buffers are queued in appsink, any more
// buffers will block upstream elements until a sample is pulled from appsink,
// unless 'drop' is set, in which case new buffers will be discarded.
//
// The function takes the following parameters:
//
//   - max: maximum number of buffers to queue.
func (appsink *AppSink) SetMaxBuffers(max uint) {
	var _arg0 *C.GstAppSink // out
	var _arg1 C.guint       // out

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))
	_arg1 = C.guint(max)

	C.gst_app_sink_set_max_buffers(_arg0, _arg1)
	runtime.KeepAlive(appsink)
	runtime.KeepAlive(max)
}

// SetMaxBytes: set the maximum total size that can be queued in appsink.
// After this amount of buffers are queued in appsink, any more buffers will
// block upstream elements until a sample is pulled from appsink, unless 'drop'
// is set, in which case new buffers will be discarded.
//
// The function takes the following parameters:
//
//   - max: maximum total size of buffers to queue, in bytes.
func (appsink *AppSink) SetMaxBytes(max uint64) {
	var _arg0 *C.GstAppSink // out
	var _arg1 C.guint64     // out

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))
	_arg1 = C.guint64(max)

	C.gst_app_sink_set_max_bytes(_arg0, _arg1)
	runtime.KeepAlive(appsink)
	runtime.KeepAlive(max)
}

// SetMaxTime: set the maximum total duration that can be queued in appsink.
// After this amount of buffers are queued in appsink, any more buffers will
// block upstream elements until a sample is pulled from appsink, unless 'drop'
// is set, in which case new buffers will be discarded.
//
// The function takes the following parameters:
//
//   - max: maximum total duration to queue.
func (appsink *AppSink) SetMaxTime(max gst.ClockTime) {
	var _arg0 *C.GstAppSink  // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))
	_arg1 = C.GstClockTime(max)

	C.gst_app_sink_set_max_time(_arg0, _arg1)
	runtime.KeepAlive(appsink)
	runtime.KeepAlive(max)
}

// SetWaitOnEos: instruct appsink to wait for all buffers to be consumed when an
// EOS is received.
//
// The function takes the following parameters:
//
//   - wait: new state.
func (appsink *AppSink) SetWaitOnEos(wait bool) {
	var _arg0 *C.GstAppSink // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))
	if wait {
		_arg1 = C.TRUE
	}

	C.gst_app_sink_set_wait_on_eos(_arg0, _arg1)
	runtime.KeepAlive(appsink)
	runtime.KeepAlive(wait)
}

// TryPullPreroll: get the last preroll sample in appsink. This was the sample
// that caused the appsink to preroll in the PAUSED state.
//
// This function is typically used when dealing with a pipeline in the PAUSED
// state. Calling this function after doing a seek will give the sample right
// after the seek position.
//
// Calling this function will clear the internal reference to the preroll
// buffer.
//
// Note that the preroll sample will also be returned as the first sample when
// calling gst_app_sink_pull_sample().
//
// If an EOS event was received before any buffers or the timeout expires,
// this function returns NULL. Use gst_app_sink_is_eos () to check for the EOS
// condition.
//
// This function blocks until a preroll sample or EOS is received, the appsink
// element is set to the READY/NULL state, or the timeout expires.
//
// The function takes the following parameters:
//
//   - timeout: maximum amount of time to wait for the preroll sample.
//
// The function returns the following values:
//
//   - sample (optional) or NULL when the appsink is stopped or EOS or the
//     timeout expires. Call gst_sample_unref() after usage.
func (appsink *AppSink) TryPullPreroll(timeout gst.ClockTime) *gst.Sample {
	var _arg0 *C.GstAppSink  // out
	var _arg1 C.GstClockTime // out
	var _cret *C.GstSample   // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))
	_arg1 = C.GstClockTime(timeout)

	_cret = C.gst_app_sink_try_pull_preroll(_arg0, _arg1)
	runtime.KeepAlive(appsink)
	runtime.KeepAlive(timeout)

	var _sample *gst.Sample // out

	if _cret != nil {
		_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_sample)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _sample
}

// TryPullSample: this function blocks until a sample or EOS becomes available
// or the appsink element is set to the READY/NULL state or the timeout expires.
//
// This function will only return samples when the appsink is in the PLAYING
// state. All rendered buffers will be put in a queue so that the application
// can pull samples at its own rate. Note that when the application does not
// pull samples fast enough, the queued buffers could consume a lot of memory,
// especially when dealing with raw video frames.
//
// If an EOS event was received before any buffers or the timeout expires,
// this function returns NULL. Use gst_app_sink_is_eos () to check for the EOS
// condition.
//
// The function takes the following parameters:
//
//   - timeout: maximum amount of time to wait for a sample.
//
// The function returns the following values:
//
//   - sample (optional) or NULL when the appsink is stopped or EOS or the
//     timeout expires. Call gst_sample_unref() after usage.
func (appsink *AppSink) TryPullSample(timeout gst.ClockTime) *gst.Sample {
	var _arg0 *C.GstAppSink  // out
	var _arg1 C.GstClockTime // out
	var _cret *C.GstSample   // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))
	_arg1 = C.GstClockTime(timeout)

	_cret = C.gst_app_sink_try_pull_sample(_arg0, _arg1)
	runtime.KeepAlive(appsink)
	runtime.KeepAlive(timeout)

	var _sample *gst.Sample // out

	if _cret != nil {
		_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_sample)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _sample
}

func (appsink *AppSink) eos() {
	gclass := (*C.GstAppSinkClass)(coreglib.PeekParentClass(appsink))
	fnarg := gclass.eos

	var _arg0 *C.GstAppSink // out

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	C._gotk4_gstapp1_AppSink_virtual_eos(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appsink)
}

func (appsink *AppSink) newPreroll() gst.FlowReturn {
	gclass := (*C.GstAppSinkClass)(coreglib.PeekParentClass(appsink))
	fnarg := gclass.new_preroll

	var _arg0 *C.GstAppSink   // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C._gotk4_gstapp1_AppSink_virtual_new_preroll(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appsink)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

func (appsink *AppSink) newSample() gst.FlowReturn {
	gclass := (*C.GstAppSinkClass)(coreglib.PeekParentClass(appsink))
	fnarg := gclass.new_sample

	var _arg0 *C.GstAppSink   // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C._gotk4_gstapp1_AppSink_virtual_new_sample(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appsink)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// pullPreroll: get the last preroll sample in appsink. This was the sample that
// caused the appsink to preroll in the PAUSED state.
//
// This function is typically used when dealing with a pipeline in the PAUSED
// state. Calling this function after doing a seek will give the sample right
// after the seek position.
//
// Calling this function will clear the internal reference to the preroll
// buffer.
//
// Note that the preroll sample will also be returned as the first sample when
// calling gst_app_sink_pull_sample().
//
// If an EOS event was received before any buffers, this function returns NULL.
// Use gst_app_sink_is_eos () to check for the EOS condition.
//
// This function blocks until a preroll sample or EOS is received or the appsink
// element is set to the READY/NULL state.
//
// The function returns the following values:
//
//   - sample (optional) or NULL when the appsink is stopped or EOS. Call
//     gst_sample_unref() after usage.
func (appsink *AppSink) pullPreroll() *gst.Sample {
	gclass := (*C.GstAppSinkClass)(coreglib.PeekParentClass(appsink))
	fnarg := gclass.pull_preroll

	var _arg0 *C.GstAppSink // out
	var _cret *C.GstSample  // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C._gotk4_gstapp1_AppSink_virtual_pull_preroll(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appsink)

	var _sample *gst.Sample // out

	if _cret != nil {
		_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_sample)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _sample
}

// pullSample: this function blocks until a sample or EOS becomes available or
// the appsink element is set to the READY/NULL state.
//
// This function will only return samples when the appsink is in the PLAYING
// state. All rendered buffers will be put in a queue so that the application
// can pull samples at its own rate. Note that when the application does not
// pull samples fast enough, the queued buffers could consume a lot of memory,
// especially when dealing with raw video frames.
//
// If an EOS event was received before any buffers, this function returns NULL.
// Use gst_app_sink_is_eos () to check for the EOS condition.
//
// The function returns the following values:
//
//   - sample (optional) or NULL when the appsink is stopped or EOS. Call
//     gst_sample_unref() after usage.
func (appsink *AppSink) pullSample() *gst.Sample {
	gclass := (*C.GstAppSinkClass)(coreglib.PeekParentClass(appsink))
	fnarg := gclass.pull_sample

	var _arg0 *C.GstAppSink // out
	var _cret *C.GstSample  // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))

	_cret = C._gotk4_gstapp1_AppSink_virtual_pull_sample(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appsink)

	var _sample *gst.Sample // out

	if _cret != nil {
		_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_sample)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _sample
}

// tryPullPreroll: get the last preroll sample in appsink. This was the sample
// that caused the appsink to preroll in the PAUSED state.
//
// This function is typically used when dealing with a pipeline in the PAUSED
// state. Calling this function after doing a seek will give the sample right
// after the seek position.
//
// Calling this function will clear the internal reference to the preroll
// buffer.
//
// Note that the preroll sample will also be returned as the first sample when
// calling gst_app_sink_pull_sample().
//
// If an EOS event was received before any buffers or the timeout expires,
// this function returns NULL. Use gst_app_sink_is_eos () to check for the EOS
// condition.
//
// This function blocks until a preroll sample or EOS is received, the appsink
// element is set to the READY/NULL state, or the timeout expires.
//
// The function takes the following parameters:
//
//   - timeout: maximum amount of time to wait for the preroll sample.
//
// The function returns the following values:
//
//   - sample (optional) or NULL when the appsink is stopped or EOS or the
//     timeout expires. Call gst_sample_unref() after usage.
func (appsink *AppSink) tryPullPreroll(timeout gst.ClockTime) *gst.Sample {
	gclass := (*C.GstAppSinkClass)(coreglib.PeekParentClass(appsink))
	fnarg := gclass.try_pull_preroll

	var _arg0 *C.GstAppSink  // out
	var _arg1 C.GstClockTime // out
	var _cret *C.GstSample   // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))
	_arg1 = C.GstClockTime(timeout)

	_cret = C._gotk4_gstapp1_AppSink_virtual_try_pull_preroll(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(appsink)
	runtime.KeepAlive(timeout)

	var _sample *gst.Sample // out

	if _cret != nil {
		_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_sample)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _sample
}

// tryPullSample: this function blocks until a sample or EOS becomes available
// or the appsink element is set to the READY/NULL state or the timeout expires.
//
// This function will only return samples when the appsink is in the PLAYING
// state. All rendered buffers will be put in a queue so that the application
// can pull samples at its own rate. Note that when the application does not
// pull samples fast enough, the queued buffers could consume a lot of memory,
// especially when dealing with raw video frames.
//
// If an EOS event was received before any buffers or the timeout expires,
// this function returns NULL. Use gst_app_sink_is_eos () to check for the EOS
// condition.
//
// The function takes the following parameters:
//
//   - timeout: maximum amount of time to wait for a sample.
//
// The function returns the following values:
//
//   - sample (optional) or NULL when the appsink is stopped or EOS or the
//     timeout expires. Call gst_sample_unref() after usage.
func (appsink *AppSink) tryPullSample(timeout gst.ClockTime) *gst.Sample {
	gclass := (*C.GstAppSinkClass)(coreglib.PeekParentClass(appsink))
	fnarg := gclass.try_pull_sample

	var _arg0 *C.GstAppSink  // out
	var _arg1 C.GstClockTime // out
	var _cret *C.GstSample   // in

	_arg0 = (*C.GstAppSink)(unsafe.Pointer(coreglib.InternObject(appsink).Native()))
	_arg1 = C.GstClockTime(timeout)

	_cret = C._gotk4_gstapp1_AppSink_virtual_try_pull_sample(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(appsink)
	runtime.KeepAlive(timeout)

	var _sample *gst.Sample // out

	if _cret != nil {
		_sample = (*gst.Sample)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_sample)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _sample
}

// AppSrcOverrides contains methods that are overridable.
type AppSrcOverrides struct {
	// EndOfStream indicates to the appsrc element that the last buffer queued
	// in the element is the last buffer of the stream.
	//
	// The function returns the following values:
	//
	//   - flowReturn when the EOS was successfully queued. T_FLOW_FLUSHING when
	//     appsrc is not PAUSED or PLAYING.
	EndOfStream func() gst.FlowReturn
	EnoughData  func()
	NeedData    func(length uint)
	// PushBuffer adds a buffer to the queue of buffers that the appsrc element
	// will push to its source pad. This function takes ownership of the buffer.
	//
	// When the block property is TRUE, this function can block until free space
	// becomes available in the queue.
	//
	// The function takes the following parameters:
	//
	//   - buffer to push.
	//
	// The function returns the following values:
	//
	//   - flowReturn when the buffer was successfully queued. T_FLOW_FLUSHING
	//     when appsrc is not PAUSED or PLAYING. T_FLOW_EOS when EOS occurred.
	PushBuffer func(buffer *gst.Buffer) gst.FlowReturn
	// PushBufferList adds a buffer list to the queue of buffers and buffer
	// lists that the appsrc element will push to its source pad. This function
	// takes ownership of buffer_list.
	//
	// When the block property is TRUE, this function can block until free space
	// becomes available in the queue.
	//
	// The function takes the following parameters:
	//
	//   - bufferList to push.
	//
	// The function returns the following values:
	//
	//   - flowReturn when the buffer list was successfully queued.
	//     T_FLOW_FLUSHING when appsrc is not PAUSED or PLAYING. T_FLOW_EOS when
	//     EOS occurred.
	PushBufferList func(bufferList *gst.BufferList) gst.FlowReturn
	// PushSample: extract a buffer from the provided sample and adds it to the
	// queue of buffers that the appsrc element will push to its source pad.
	// Any previous caps that were set on appsrc will be replaced by the caps
	// associated with the sample if not equal.
	//
	// This function does not take ownership of the sample so the sample needs
	// to be unreffed after calling this function.
	//
	// When the block property is TRUE, this function can block until free space
	// becomes available in the queue.
	//
	// The function takes the following parameters:
	//
	//   - sample from which buffer and caps may be extracted.
	//
	// The function returns the following values:
	//
	//   - flowReturn when the buffer was successfully queued. T_FLOW_FLUSHING
	//     when appsrc is not PAUSED or PLAYING. T_FLOW_EOS when EOS occurred.
	PushSample func(sample *gst.Sample) gst.FlowReturn
	SeekData   func(offset uint64) bool
}

func defaultAppSrcOverrides(v *AppSrc) AppSrcOverrides {
	return AppSrcOverrides{
		EndOfStream:    v.endOfStream,
		EnoughData:     v.enoughData,
		NeedData:       v.needData,
		PushBuffer:     v.pushBuffer,
		PushBufferList: v.pushBufferList,
		PushSample:     v.pushSample,
		SeekData:       v.seekData,
	}
}

// AppSrc: appsrc element can be used by applications to insert data into a
// GStreamer pipeline. Unlike most GStreamer elements, appsrc provides external
// API functions.
//
// appsrc can be used by linking with the libgstapp library to access the
// methods directly or by using the appsrc action signals.
//
// Before operating appsrc, the caps property must be set to fixed caps
// describing the format of the data that will be pushed with appsrc.
// An exception to this is when pushing buffers with unknown caps, in which case
// no caps should be set. This is typically true of file-like sources that push
// raw byte buffers. If you don't want to explicitly set the caps, you can use
// gst_app_src_push_sample. This method gets the caps associated with the sample
// and sets them on the appsrc replacing any previously set caps (if different
// from sample's caps).
//
// The main way of handing data to the appsrc element is by calling the
// gst_app_src_push_buffer() method or by emitting the push-buffer action
// signal. This will put the buffer onto a queue from which appsrc will read
// from in its streaming thread. It is important to note that data transport
// will not happen from the thread that performed the push-buffer call.
//
// The "max-bytes", "max-buffers" and "max-time" properties control how much
// data can be queued in appsrc before appsrc considers the queue full.
// A filled internal queue will always signal the "enough-data" signal,
// which signals the application that it should stop pushing data into appsrc.
// The "block" property will cause appsrc to block the push-buffer method until
// free data becomes available again.
//
// When the internal queue is running out of data, the "need-data" signal is
// emitted, which signals the application that it should start pushing more data
// into appsrc.
//
// In addition to the "need-data" and "enough-data" signals, appsrc can emit the
// "seek-data" signal when the "stream-mode" property is set to "seekable" or
// "random-access". The signal argument will contain the new desired position
// in the stream expressed in the unit set with the "format" property. After
// receiving the seek-data signal, the application should push-buffers from the
// new position.
//
// These signals allow the application to operate the appsrc in two different
// ways:
//
// The push mode, in which the application repeatedly calls the
// push-buffer/push-sample method with a new buffer/sample. Optionally, the
// queue size in the appsrc can be controlled with the enough-data and need-data
// signals by respectively stopping/starting the push-buffer/push-sample calls.
// This is a typical mode of operation for the stream-type "stream" and
// "seekable". Use this mode when implementing various network protocols or
// hardware devices.
//
// The pull mode, in which the need-data signal triggers the next push-buffer
// call. This mode is typically used in the "random-access" stream-type. Use
// this mode for file access or other randomly accessible sources. In this mode,
// a buffer of exactly the amount of bytes given by the need-data signal should
// be pushed into appsrc.
//
// In all modes, the size property on appsrc should contain the total stream
// size in bytes. Setting this property is mandatory in the random-access mode.
// For the stream and seekable modes, setting this property is optional but
// recommended.
//
// When the application has finished pushing data into appsrc, it should
// call gst_app_src_end_of_stream() or emit the end-of-stream action signal.
// After this call, no more buffers can be pushed into appsrc until a flushing
// seek occurs or the state of the appsrc has gone through READY.
type AppSrc struct {
	_ [0]func() // equal guard
	gstbase.BaseSrc

	gst.URIHandler
}

var (
	_ gstbase.BaseSrcer = (*AppSrc)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*AppSrc, *AppSrcClass, AppSrcOverrides](
		GTypeAppSrc,
		initAppSrcClass,
		wrapAppSrc,
		defaultAppSrcOverrides,
	)
}

func initAppSrcClass(gclass unsafe.Pointer, overrides AppSrcOverrides, classInitFunc func(*AppSrcClass)) {
	pclass := (*C.GstAppSrcClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAppSrc))))

	if overrides.EndOfStream != nil {
		pclass.end_of_stream = (*[0]byte)(C._gotk4_gstapp1_AppSrcClass_end_of_stream)
	}

	if overrides.EnoughData != nil {
		pclass.enough_data = (*[0]byte)(C._gotk4_gstapp1_AppSrcClass_enough_data)
	}

	if overrides.NeedData != nil {
		pclass.need_data = (*[0]byte)(C._gotk4_gstapp1_AppSrcClass_need_data)
	}

	if overrides.PushBuffer != nil {
		pclass.push_buffer = (*[0]byte)(C._gotk4_gstapp1_AppSrcClass_push_buffer)
	}

	if overrides.PushBufferList != nil {
		pclass.push_buffer_list = (*[0]byte)(C._gotk4_gstapp1_AppSrcClass_push_buffer_list)
	}

	if overrides.PushSample != nil {
		pclass.push_sample = (*[0]byte)(C._gotk4_gstapp1_AppSrcClass_push_sample)
	}

	if overrides.SeekData != nil {
		pclass.seek_data = (*[0]byte)(C._gotk4_gstapp1_AppSrcClass_seek_data)
	}

	if classInitFunc != nil {
		class := (*AppSrcClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAppSrc(obj *coreglib.Object) *AppSrc {
	return &AppSrc{
		BaseSrc: gstbase.BaseSrc{
			Element: gst.Element{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
		URIHandler: gst.URIHandler{
			Object: obj,
		},
	}
}

func marshalAppSrc(p uintptr) (interface{}, error) {
	return wrapAppSrc(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectEnoughData: signal that the source has enough data. It is recommended
// that the application stops calling push-buffer until the need-data signal is
// emitted again to avoid excessive buffer queueing.
func (appsrc *AppSrc) ConnectEnoughData(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsrc, "enough-data", false, unsafe.Pointer(C._gotk4_gstapp1_AppSrc_ConnectEnoughData), f)
}

// ConnectNeedData: signal that the source needs more data. In the callback or
// from another thread you should call push-buffer or end-of-stream.
//
// length is just a hint and when it is set to -1, any number of bytes can be
// pushed into appsrc.
//
// You can call push-buffer multiple times until the enough-data signal is
// fired.
func (appsrc *AppSrc) ConnectNeedData(f func(length uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsrc, "need-data", false, unsafe.Pointer(C._gotk4_gstapp1_AppSrc_ConnectNeedData), f)
}

// ConnectSeekData: seek to the given offset. The next push-buffer should
// produce buffers from the new offset. This callback is only called for
// seekable stream types.
func (appsrc *AppSrc) ConnectSeekData(f func(offset uint64) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(appsrc, "seek-data", false, unsafe.Pointer(C._gotk4_gstapp1_AppSrc_ConnectSeekData), f)
}

// EndOfStream indicates to the appsrc element that the last buffer queued in
// the element is the last buffer of the stream.
//
// The function returns the following values:
//
//   - flowReturn when the EOS was successfully queued. T_FLOW_FLUSHING when
//     appsrc is not PAUSED or PLAYING.
func (appsrc *AppSrc) EndOfStream() gst.FlowReturn {
	var _arg0 *C.GstAppSrc    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_end_of_stream(_arg0)
	runtime.KeepAlive(appsrc)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// Caps: get the configured caps on appsrc.
//
// The function returns the following values:
//
//   - caps (optional) produced by the source. gst_caps_unref() after usage.
func (appsrc *AppSrc) Caps() *gst.Caps {
	var _arg0 *C.GstAppSrc // out
	var _cret *C.GstCaps   // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_caps(_arg0)
	runtime.KeepAlive(appsrc)

	var _caps *gst.Caps // out

	if _cret != nil {
		_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_caps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _caps
}

// CurrentLevelBuffers: get the number of currently queued buffers inside
// appsrc.
//
// The function returns the following values:
//
//   - guint64: number of currently queued buffers.
func (appsrc *AppSrc) CurrentLevelBuffers() uint64 {
	var _arg0 *C.GstAppSrc // out
	var _cret C.guint64    // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_current_level_buffers(_arg0)
	runtime.KeepAlive(appsrc)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// CurrentLevelBytes: get the number of currently queued bytes inside appsrc.
//
// The function returns the following values:
//
//   - guint64: number of currently queued bytes.
func (appsrc *AppSrc) CurrentLevelBytes() uint64 {
	var _arg0 *C.GstAppSrc // out
	var _cret C.guint64    // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_current_level_bytes(_arg0)
	runtime.KeepAlive(appsrc)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// CurrentLevelTime: get the amount of currently queued time inside appsrc.
//
// The function returns the following values:
//
//   - clockTime: amount of currently queued time.
func (appsrc *AppSrc) CurrentLevelTime() gst.ClockTime {
	var _arg0 *C.GstAppSrc   // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_current_level_time(_arg0)
	runtime.KeepAlive(appsrc)

	var _clockTime gst.ClockTime // out

	_clockTime = gst.ClockTime(_cret)

	return _clockTime
}

// Duration: get the duration of the stream in nanoseconds. A value of
// GST_CLOCK_TIME_NONE means that the duration is not known.
//
// The function returns the following values:
//
//   - clockTime: duration of the stream previously set with
//     gst_app_src_set_duration();.
func (appsrc *AppSrc) Duration() gst.ClockTime {
	var _arg0 *C.GstAppSrc   // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_duration(_arg0)
	runtime.KeepAlive(appsrc)

	var _clockTime gst.ClockTime // out

	_clockTime = gst.ClockTime(_cret)

	return _clockTime
}

// EmitSignals: check if appsrc will emit the "new-preroll" and "new-buffer"
// signals.
//
// The function returns the following values:
//
//   - ok: TRUE if appsrc is emitting the "new-preroll" and "new-buffer"
//     signals.
func (appsrc *AppSrc) EmitSignals() bool {
	var _arg0 *C.GstAppSrc // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_emit_signals(_arg0)
	runtime.KeepAlive(appsrc)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Latency: retrieve the min and max latencies in min and max respectively.
//
// The function returns the following values:
//
//   - min latency.
//   - max latency.
func (appsrc *AppSrc) Latency() (min, max uint64) {
	var _arg0 *C.GstAppSrc // out
	var _arg1 C.guint64    // in
	var _arg2 C.guint64    // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	C.gst_app_src_get_latency(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(appsrc)

	var _min uint64 // out
	var _max uint64 // out

	_min = uint64(_arg1)
	_max = uint64(_arg2)

	return _min, _max
}

// LeakyType returns the currently set AppLeakyType. See
// gst_app_src_set_leaky_type() for more details.
//
// The function returns the following values:
//
//   - appLeakyType: currently set AppLeakyType.
func (appsrc *AppSrc) LeakyType() AppLeakyType {
	var _arg0 *C.GstAppSrc      // out
	var _cret C.GstAppLeakyType // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_leaky_type(_arg0)
	runtime.KeepAlive(appsrc)

	var _appLeakyType AppLeakyType // out

	_appLeakyType = AppLeakyType(_cret)

	return _appLeakyType
}

// MaxBuffers: get the maximum amount of buffers that can be queued in appsrc.
//
// The function returns the following values:
//
//   - guint64: maximum amount of buffers that can be queued.
func (appsrc *AppSrc) MaxBuffers() uint64 {
	var _arg0 *C.GstAppSrc // out
	var _cret C.guint64    // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_max_buffers(_arg0)
	runtime.KeepAlive(appsrc)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// MaxBytes: get the maximum amount of bytes that can be queued in appsrc.
//
// The function returns the following values:
//
//   - guint64: maximum amount of bytes that can be queued.
func (appsrc *AppSrc) MaxBytes() uint64 {
	var _arg0 *C.GstAppSrc // out
	var _cret C.guint64    // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_max_bytes(_arg0)
	runtime.KeepAlive(appsrc)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// MaxTime: get the maximum amount of time that can be queued in appsrc.
//
// The function returns the following values:
//
//   - clockTime: maximum amount of time that can be queued.
func (appsrc *AppSrc) MaxTime() gst.ClockTime {
	var _arg0 *C.GstAppSrc   // out
	var _cret C.GstClockTime // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_max_time(_arg0)
	runtime.KeepAlive(appsrc)

	var _clockTime gst.ClockTime // out

	_clockTime = gst.ClockTime(_cret)

	return _clockTime
}

// Size: get the size of the stream in bytes. A value of -1 means that the size
// is not known.
//
// The function returns the following values:
//
//   - gint64: size of the stream previously set with gst_app_src_set_size();.
func (appsrc *AppSrc) Size() int64 {
	var _arg0 *C.GstAppSrc // out
	var _cret C.gint64     // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_size(_arg0)
	runtime.KeepAlive(appsrc)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// StreamType: get the stream type. Control the stream type of appsrc with
// gst_app_src_set_stream_type().
//
// The function returns the following values:
//
//   - appStreamType: stream type.
func (appsrc *AppSrc) StreamType() AppStreamType {
	var _arg0 *C.GstAppSrc       // out
	var _cret C.GstAppStreamType // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C.gst_app_src_get_stream_type(_arg0)
	runtime.KeepAlive(appsrc)

	var _appStreamType AppStreamType // out

	_appStreamType = AppStreamType(_cret)

	return _appStreamType
}

// PushBuffer adds a buffer to the queue of buffers that the appsrc element will
// push to its source pad. This function takes ownership of the buffer.
//
// When the block property is TRUE, this function can block until free space
// becomes available in the queue.
//
// The function takes the following parameters:
//
//   - buffer to push.
//
// The function returns the following values:
//
//   - flowReturn when the buffer was successfully queued. T_FLOW_FLUSHING when
//     appsrc is not PAUSED or PLAYING. T_FLOW_EOS when EOS occurred.
func (appsrc *AppSrc) PushBuffer(buffer *gst.Buffer) gst.FlowReturn {
	var _arg0 *C.GstAppSrc    // out
	var _arg1 *C.GstBuffer    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	_cret = C.gst_app_src_push_buffer(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(buffer)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// PushBufferList adds a buffer list to the queue of buffers and buffer lists
// that the appsrc element will push to its source pad. This function takes
// ownership of buffer_list.
//
// When the block property is TRUE, this function can block until free space
// becomes available in the queue.
//
// The function takes the following parameters:
//
//   - bufferList to push.
//
// The function returns the following values:
//
//   - flowReturn when the buffer list was successfully queued. T_FLOW_FLUSHING
//     when appsrc is not PAUSED or PLAYING. T_FLOW_EOS when EOS occurred.
func (appsrc *AppSrc) PushBufferList(bufferList *gst.BufferList) gst.FlowReturn {
	var _arg0 *C.GstAppSrc     // out
	var _arg1 *C.GstBufferList // out
	var _cret C.GstFlowReturn  // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(bufferList)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(bufferList)), nil)

	_cret = C.gst_app_src_push_buffer_list(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(bufferList)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// PushSample: extract a buffer from the provided sample and adds it to the
// queue of buffers that the appsrc element will push to its source pad. Any
// previous caps that were set on appsrc will be replaced by the caps associated
// with the sample if not equal.
//
// This function does not take ownership of the sample so the sample needs to be
// unreffed after calling this function.
//
// When the block property is TRUE, this function can block until free space
// becomes available in the queue.
//
// The function takes the following parameters:
//
//   - sample from which buffer and caps may be extracted.
//
// The function returns the following values:
//
//   - flowReturn when the buffer was successfully queued. T_FLOW_FLUSHING when
//     appsrc is not PAUSED or PLAYING. T_FLOW_EOS when EOS occurred.
func (appsrc *AppSrc) PushSample(sample *gst.Sample) gst.FlowReturn {
	var _arg0 *C.GstAppSrc    // out
	var _arg1 *C.GstSample    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = (*C.GstSample)(gextras.StructNative(unsafe.Pointer(sample)))

	_cret = C.gst_app_src_push_sample(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(sample)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// SetCaps: set the capabilities on the appsrc element. This function takes a
// copy of the caps structure. After calling this method, the source will only
// produce caps that match caps. caps must be fixed and the caps on the buffers
// must match the caps or left NULL.
//
// The function takes the following parameters:
//
//   - caps (optional) to set.
func (appsrc *AppSrc) SetCaps(caps *gst.Caps) {
	var _arg0 *C.GstAppSrc // out
	var _arg1 *C.GstCaps   // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	if caps != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	}

	C.gst_app_src_set_caps(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(caps)
}

// SetDuration: set the duration of the stream in nanoseconds. A value of
// GST_CLOCK_TIME_NONE means that the duration is not known.
//
// The function takes the following parameters:
//
//   - duration to set.
func (appsrc *AppSrc) SetDuration(duration gst.ClockTime) {
	var _arg0 *C.GstAppSrc   // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = C.GstClockTime(duration)

	C.gst_app_src_set_duration(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(duration)
}

// SetEmitSignals: make appsrc emit the "new-preroll" and "new-buffer" signals.
// This option is by default disabled because signal emission is expensive and
// unneeded when the application prefers to operate in pull mode.
//
// The function takes the following parameters:
//
//   - emit: new state.
func (appsrc *AppSrc) SetEmitSignals(emit bool) {
	var _arg0 *C.GstAppSrc // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	if emit {
		_arg1 = C.TRUE
	}

	C.gst_app_src_set_emit_signals(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(emit)
}

// SetLatency: configure the min and max latency in src. If min is set to -1,
// the default latency calculations for pseudo-live sources will be used.
//
// The function takes the following parameters:
//
//   - min latency.
//   - max latency.
func (appsrc *AppSrc) SetLatency(min, max uint64) {
	var _arg0 *C.GstAppSrc // out
	var _arg1 C.guint64    // out
	var _arg2 C.guint64    // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = C.guint64(min)
	_arg2 = C.guint64(max)

	C.gst_app_src_set_latency(_arg0, _arg1, _arg2)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(min)
	runtime.KeepAlive(max)
}

// SetLeakyType: when set to any other value than GST_APP_LEAKY_TYPE_NONE then
// the appsrc will drop any buffers that are pushed into it once its internal
// queue is full. The selected type defines whether to drop the oldest or new
// buffers.
//
// The function takes the following parameters:
//
//   - leaky: AppLeakyType.
func (appsrc *AppSrc) SetLeakyType(leaky AppLeakyType) {
	var _arg0 *C.GstAppSrc      // out
	var _arg1 C.GstAppLeakyType // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = C.GstAppLeakyType(leaky)

	C.gst_app_src_set_leaky_type(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(leaky)
}

// SetMaxBuffers: set the maximum amount of buffers that can be queued in
// appsrc. After the maximum amount of buffers are queued, appsrc will emit the
// "enough-data" signal.
//
// The function takes the following parameters:
//
//   - max: maximum number of buffers to queue.
func (appsrc *AppSrc) SetMaxBuffers(max uint64) {
	var _arg0 *C.GstAppSrc // out
	var _arg1 C.guint64    // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = C.guint64(max)

	C.gst_app_src_set_max_buffers(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(max)
}

// SetMaxBytes: set the maximum amount of bytes that can be queued in appsrc.
// After the maximum amount of bytes are queued, appsrc will emit the
// "enough-data" signal.
//
// The function takes the following parameters:
//
//   - max: maximum number of bytes to queue.
func (appsrc *AppSrc) SetMaxBytes(max uint64) {
	var _arg0 *C.GstAppSrc // out
	var _arg1 C.guint64    // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = C.guint64(max)

	C.gst_app_src_set_max_bytes(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(max)
}

// SetMaxTime: set the maximum amount of time that can be queued in appsrc.
// After the maximum amount of time are queued, appsrc will emit the
// "enough-data" signal.
//
// The function takes the following parameters:
//
//   - max: maximum amonut of time to queue.
func (appsrc *AppSrc) SetMaxTime(max gst.ClockTime) {
	var _arg0 *C.GstAppSrc   // out
	var _arg1 C.GstClockTime // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = C.GstClockTime(max)

	C.gst_app_src_set_max_time(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(max)
}

// SetSize: set the size of the stream in bytes. A value of -1 means that the
// size is not known.
//
// The function takes the following parameters:
//
//   - size to set.
func (appsrc *AppSrc) SetSize(size int64) {
	var _arg0 *C.GstAppSrc // out
	var _arg1 C.gint64     // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = C.gint64(size)

	C.gst_app_src_set_size(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(size)
}

// SetStreamType: set the stream type on appsrc. For seekable streams, the
// "seek" signal must be connected to.
//
// A stream_type stream.
//
// The function takes the following parameters:
//
//   - typ: new state.
func (appsrc *AppSrc) SetStreamType(typ AppStreamType) {
	var _arg0 *C.GstAppSrc       // out
	var _arg1 C.GstAppStreamType // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = C.GstAppStreamType(typ)

	C.gst_app_src_set_stream_type(_arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(typ)
}

// endOfStream indicates to the appsrc element that the last buffer queued in
// the element is the last buffer of the stream.
//
// The function returns the following values:
//
//   - flowReturn when the EOS was successfully queued. T_FLOW_FLUSHING when
//     appsrc is not PAUSED or PLAYING.
func (appsrc *AppSrc) endOfStream() gst.FlowReturn {
	gclass := (*C.GstAppSrcClass)(coreglib.PeekParentClass(appsrc))
	fnarg := gclass.end_of_stream

	var _arg0 *C.GstAppSrc    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	_cret = C._gotk4_gstapp1_AppSrc_virtual_end_of_stream(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appsrc)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

func (appsrc *AppSrc) enoughData() {
	gclass := (*C.GstAppSrcClass)(coreglib.PeekParentClass(appsrc))
	fnarg := gclass.enough_data

	var _arg0 *C.GstAppSrc // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))

	C._gotk4_gstapp1_AppSrc_virtual_enough_data(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appsrc)
}

func (appsrc *AppSrc) needData(length uint) {
	gclass := (*C.GstAppSrcClass)(coreglib.PeekParentClass(appsrc))
	fnarg := gclass.need_data

	var _arg0 *C.GstAppSrc // out
	var _arg1 C.guint      // out

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = C.guint(length)

	C._gotk4_gstapp1_AppSrc_virtual_need_data(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(length)
}

// pushBuffer adds a buffer to the queue of buffers that the appsrc element will
// push to its source pad. This function takes ownership of the buffer.
//
// When the block property is TRUE, this function can block until free space
// becomes available in the queue.
//
// The function takes the following parameters:
//
//   - buffer to push.
//
// The function returns the following values:
//
//   - flowReturn when the buffer was successfully queued. T_FLOW_FLUSHING when
//     appsrc is not PAUSED or PLAYING. T_FLOW_EOS when EOS occurred.
func (appsrc *AppSrc) pushBuffer(buffer *gst.Buffer) gst.FlowReturn {
	gclass := (*C.GstAppSrcClass)(coreglib.PeekParentClass(appsrc))
	fnarg := gclass.push_buffer

	var _arg0 *C.GstAppSrc    // out
	var _arg1 *C.GstBuffer    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	_cret = C._gotk4_gstapp1_AppSrc_virtual_push_buffer(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(buffer)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// pushBufferList adds a buffer list to the queue of buffers and buffer lists
// that the appsrc element will push to its source pad. This function takes
// ownership of buffer_list.
//
// When the block property is TRUE, this function can block until free space
// becomes available in the queue.
//
// The function takes the following parameters:
//
//   - bufferList to push.
//
// The function returns the following values:
//
//   - flowReturn when the buffer list was successfully queued. T_FLOW_FLUSHING
//     when appsrc is not PAUSED or PLAYING. T_FLOW_EOS when EOS occurred.
func (appsrc *AppSrc) pushBufferList(bufferList *gst.BufferList) gst.FlowReturn {
	gclass := (*C.GstAppSrcClass)(coreglib.PeekParentClass(appsrc))
	fnarg := gclass.push_buffer_list

	var _arg0 *C.GstAppSrc     // out
	var _arg1 *C.GstBufferList // out
	var _cret C.GstFlowReturn  // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = (*C.GstBufferList)(gextras.StructNative(unsafe.Pointer(bufferList)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(bufferList)), nil)

	_cret = C._gotk4_gstapp1_AppSrc_virtual_push_buffer_list(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(bufferList)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// pushSample: extract a buffer from the provided sample and adds it to the
// queue of buffers that the appsrc element will push to its source pad. Any
// previous caps that were set on appsrc will be replaced by the caps associated
// with the sample if not equal.
//
// This function does not take ownership of the sample so the sample needs to be
// unreffed after calling this function.
//
// When the block property is TRUE, this function can block until free space
// becomes available in the queue.
//
// The function takes the following parameters:
//
//   - sample from which buffer and caps may be extracted.
//
// The function returns the following values:
//
//   - flowReturn when the buffer was successfully queued. T_FLOW_FLUSHING when
//     appsrc is not PAUSED or PLAYING. T_FLOW_EOS when EOS occurred.
func (appsrc *AppSrc) pushSample(sample *gst.Sample) gst.FlowReturn {
	gclass := (*C.GstAppSrcClass)(coreglib.PeekParentClass(appsrc))
	fnarg := gclass.push_sample

	var _arg0 *C.GstAppSrc    // out
	var _arg1 *C.GstSample    // out
	var _cret C.GstFlowReturn // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = (*C.GstSample)(gextras.StructNative(unsafe.Pointer(sample)))

	_cret = C._gotk4_gstapp1_AppSrc_virtual_push_sample(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(sample)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

func (appsrc *AppSrc) seekData(offset uint64) bool {
	gclass := (*C.GstAppSrcClass)(coreglib.PeekParentClass(appsrc))
	fnarg := gclass.seek_data

	var _arg0 *C.GstAppSrc // out
	var _arg1 C.guint64    // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GstAppSrc)(unsafe.Pointer(coreglib.InternObject(appsrc).Native()))
	_arg1 = C.guint64(offset)

	_cret = C._gotk4_gstapp1_AppSrc_virtual_seek_data(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(appsrc)
	runtime.KeepAlive(offset)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AppSinkClass: instance of this type is always passed by reference.
type AppSinkClass struct {
	*appSinkClass
}

// appSinkClass is the struct that's finalized.
type appSinkClass struct {
	native *C.GstAppSinkClass
}

func (a *AppSinkClass) BasesinkClass() *gstbase.BaseSinkClass {
	valptr := &a.native.basesink_class
	var _v *gstbase.BaseSinkClass // out
	_v = (*gstbase.BaseSinkClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// AppSrcClass: instance of this type is always passed by reference.
type AppSrcClass struct {
	*appSrcClass
}

// appSrcClass is the struct that's finalized.
type appSrcClass struct {
	native *C.GstAppSrcClass
}

func (a *AppSrcClass) BasesrcClass() *gstbase.BaseSrcClass {
	valptr := &a.native.basesrc_class
	var _v *gstbase.BaseSrcClass // out
	_v = (*gstbase.BaseSrcClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
