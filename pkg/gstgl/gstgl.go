// Code generated by girgen. DO NOT EDIT.

package gstgl

import (
	"fmt"
	"runtime"
	_ "runtime/cgo"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/go-gst/go-gst/pkg/gst"
	"github.com/go-gst/go-gst/pkg/gstbase"
	"github.com/go-gst/go-gst/pkg/gstvideo"
)

// #cgo pkg-config: gstreamer-gl-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/gl/gl.h>
// extern void _gotk4_gstgl1_GLWindow_ConnectWindowHandleChanged(gpointer, guintptr);
// extern void _gotk4_gstgl1_GLWindow_ConnectScrollEvent(gpointer, gdouble, gdouble, gdouble, gdouble, guintptr);
// extern void _gotk4_gstgl1_GLWindow_ConnectMouseEvent(gpointer, gchar*, gint, gdouble, gdouble, guintptr);
// extern void _gotk4_gstgl1_GLWindow_ConnectKeyEvent(gpointer, gchar*, gchar*, guintptr);
// extern void _gotk4_gstgl1_GLWindowClass_show(GstGLWindow*);
// extern void _gotk4_gstgl1_GLWindowClass_set_window_handle(GstGLWindow*, guintptr);
// extern void _gotk4_gstgl1_GLWindowClass_set_preferred_size(GstGLWindow*, gint, gint);
// extern void _gotk4_gstgl1_GLWindowClass_run(GstGLWindow*);
// extern void _gotk4_gstgl1_GLWindowClass_quit(GstGLWindow*);
// extern void _gotk4_gstgl1_GLWindowClass_queue_resize(GstGLWindow*);
// extern void _gotk4_gstgl1_GLWindowClass_handle_events(GstGLWindow*, gboolean);
// extern void _gotk4_gstgl1_GLWindowClass_draw(GstGLWindow*);
// extern void _gotk4_gstgl1_GLWindowClass_close(GstGLWindow*);
// extern void _gotk4_gstgl1_GLContextClass_swap_buffers(GstGLContext*);
// extern void _gotk4_gstgl1_GLContextClass_get_gl_platform_version(GstGLContext*, gint*, gint*);
// extern void _gotk4_gstgl1_GLContextClass_destroy_context(GstGLContext*);
// extern void _gotk4_gstgl1_GLBaseSrcClass_gl_stop(GstGLBaseSrc*);
// extern void _gotk4_gstgl1_GLBaseMixerClass_gl_stop(GstGLBaseMixer*);
// extern void _gotk4_gstgl1_GLBaseFilterClass_gl_stop(GstGLBaseFilter*);
// extern guintptr _gotk4_gstgl1_GLWindowClass_get_window_handle(GstGLWindow*);
// extern guintptr _gotk4_gstgl1_GLWindowClass_get_display(GstGLWindow*);
// extern guintptr _gotk4_gstgl1_GLDisplayClass_get_handle(GstGLDisplay*);
// extern guintptr _gotk4_gstgl1_GLContextClass_get_gl_context(GstGLContext*);
// extern gboolean _gotk4_gstgl1_GLWindowClass_set_render_rectangle(GstGLWindow*, gint, gint, gint, gint);
// extern gboolean _gotk4_gstgl1_GLWindowClass_open(GstGLWindow*, GError**);
// extern gboolean _gotk4_gstgl1_GLWindowClass_has_output_surface(GstGLWindow*);
// extern gboolean _gotk4_gstgl1_GLWindowClass_controls_viewport(GstGLWindow*);
// extern gboolean _gotk4_gstgl1_GLMixerClass_process_textures(GstGLMixer*, GstGLMemory*);
// extern gboolean _gotk4_gstgl1_GLMixerClass_process_buffers(GstGLMixer*, GstBuffer*);
// extern gboolean _gotk4_gstgl1_GLFilterRenderFunc(GstGLFilter*, GstGLMemory*, gpointer);
// extern gboolean _gotk4_gstgl1_GLFilterClass_set_caps(GstGLFilter*, GstCaps*, GstCaps*);
// extern gboolean _gotk4_gstgl1_GLFilterClass_init_fbo(GstGLFilter*);
// extern gboolean _gotk4_gstgl1_GLFilterClass_filter_texture(GstGLFilter*, GstGLMemory*, GstGLMemory*);
// extern gboolean _gotk4_gstgl1_GLFilterClass_filter(GstGLFilter*, GstBuffer*, GstBuffer*);
// extern gboolean _gotk4_gstgl1_GLContextClass_request_config(GstGLContext*, GstStructure*);
// extern gboolean _gotk4_gstgl1_GLContextClass_create_context(GstGLContext*, GstGLAPI, GstGLContext*, GError**);
// extern gboolean _gotk4_gstgl1_GLContextClass_choose_format(GstGLContext*, GError**);
// extern gboolean _gotk4_gstgl1_GLContextClass_check_feature(GstGLContext*, gchar*);
// extern gboolean _gotk4_gstgl1_GLContextClass_activate(GstGLContext*, gboolean);
// extern gboolean _gotk4_gstgl1_GLBaseSrcClass_gl_start(GstGLBaseSrc*);
// extern gboolean _gotk4_gstgl1_GLBaseSrcClass_fill_gl_memory(GstGLBaseSrc*, GstGLMemory*);
// extern gboolean _gotk4_gstgl1_GLBaseMixerClass_gl_start(GstGLBaseMixer*);
// extern gboolean _gotk4_gstgl1_GLBaseFilterClass_gl_start(GstGLBaseFilter*);
// extern gboolean _gotk4_gstgl1_GLBaseFilterClass_gl_set_caps(GstGLBaseFilter*, GstCaps*, GstCaps*);
// extern GstStructure* _gotk4_gstgl1_GLContextClass_get_config(GstGLContext*);
// extern GstGLWindow* _gotk4_gstgl1_GLDisplayClass_create_window(GstGLDisplay*);
// extern GstGLPlatform _gotk4_gstgl1_GLContextClass_get_gl_platform(GstGLContext*);
// extern GstGLContext* _gotk4_gstgl1_GLDisplay_ConnectCreateContext(gpointer, GstGLContext*, guintptr);
// extern GstGLBaseMemory* _gotk4_gstgl1_GLBaseMemoryAllocatorClass_alloc(GstGLBaseMemoryAllocator*, GstGLAllocationParams*);
// extern GstGLAPI _gotk4_gstgl1_GLContextClass_get_gl_api(GstGLContext*);
// extern GstCaps* _gotk4_gstgl1_GLFilterClass_transform_internal_caps(GstGLFilter*, GstPadDirection, GstCaps*, GstCaps*);
// GstCaps* _gotk4_gstgl1_GLFilter_virtual_transform_internal_caps(void* fnptr, GstGLFilter* arg0, GstPadDirection arg1, GstCaps* arg2, GstCaps* arg3) {
//   return ((GstCaps* (*)(GstGLFilter*, GstPadDirection, GstCaps*, GstCaps*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GstGLAPI _gotk4_gstgl1_GLContext_virtual_get_gl_api(void* fnptr, GstGLContext* arg0) {
//   return ((GstGLAPI (*)(GstGLContext*))(fnptr))(arg0);
// };
// GstGLBaseMemory* _gotk4_gstgl1_GLBaseMemoryAllocator_virtual_alloc(void* fnptr, GstGLBaseMemoryAllocator* arg0, GstGLAllocationParams* arg1) {
//   return ((GstGLBaseMemory* (*)(GstGLBaseMemoryAllocator*, GstGLAllocationParams*))(fnptr))(arg0, arg1);
// };
// GstGLPlatform _gotk4_gstgl1_GLContext_virtual_get_gl_platform(void* fnptr, GstGLContext* arg0) {
//   return ((GstGLPlatform (*)(GstGLContext*))(fnptr))(arg0);
// };
// GstGLWindow* _gotk4_gstgl1_GLDisplay_virtual_create_window(void* fnptr, GstGLDisplay* arg0) {
//   return ((GstGLWindow* (*)(GstGLDisplay*))(fnptr))(arg0);
// };
// GstStructure* _gotk4_gstgl1_GLContext_virtual_get_config(void* fnptr, GstGLContext* arg0) {
//   return ((GstStructure* (*)(GstGLContext*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstgl1_GLBaseFilter_virtual_gl_set_caps(void* fnptr, GstGLBaseFilter* arg0, GstCaps* arg1, GstCaps* arg2) {
//   return ((gboolean (*)(GstGLBaseFilter*, GstCaps*, GstCaps*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gstgl1_GLBaseFilter_virtual_gl_start(void* fnptr, GstGLBaseFilter* arg0) {
//   return ((gboolean (*)(GstGLBaseFilter*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstgl1_GLBaseMixer_virtual_gl_start(void* fnptr, GstGLBaseMixer* arg0) {
//   return ((gboolean (*)(GstGLBaseMixer*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstgl1_GLBaseSrc_virtual_fill_gl_memory(void* fnptr, GstGLBaseSrc* arg0, GstGLMemory* arg1) {
//   return ((gboolean (*)(GstGLBaseSrc*, GstGLMemory*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstgl1_GLBaseSrc_virtual_gl_start(void* fnptr, GstGLBaseSrc* arg0) {
//   return ((gboolean (*)(GstGLBaseSrc*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstgl1_GLContext_virtual_activate(void* fnptr, GstGLContext* arg0, gboolean arg1) {
//   return ((gboolean (*)(GstGLContext*, gboolean))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstgl1_GLContext_virtual_check_feature(void* fnptr, GstGLContext* arg0, gchar* arg1) {
//   return ((gboolean (*)(GstGLContext*, gchar*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstgl1_GLContext_virtual_choose_format(void* fnptr, GstGLContext* arg0, GError** arg1) {
//   return ((gboolean (*)(GstGLContext*, GError**))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstgl1_GLContext_virtual_create_context(void* fnptr, GstGLContext* arg0, GstGLAPI arg1, GstGLContext* arg2, GError** arg3) {
//   return ((gboolean (*)(GstGLContext*, GstGLAPI, GstGLContext*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gstgl1_GLContext_virtual_request_config(void* fnptr, GstGLContext* arg0, GstStructure* arg1) {
//   return ((gboolean (*)(GstGLContext*, GstStructure*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstgl1_GLFilter_virtual_filter(void* fnptr, GstGLFilter* arg0, GstBuffer* arg1, GstBuffer* arg2) {
//   return ((gboolean (*)(GstGLFilter*, GstBuffer*, GstBuffer*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gstgl1_GLFilter_virtual_filter_texture(void* fnptr, GstGLFilter* arg0, GstGLMemory* arg1, GstGLMemory* arg2) {
//   return ((gboolean (*)(GstGLFilter*, GstGLMemory*, GstGLMemory*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gstgl1_GLFilter_virtual_init_fbo(void* fnptr, GstGLFilter* arg0) {
//   return ((gboolean (*)(GstGLFilter*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstgl1_GLFilter_virtual_set_caps(void* fnptr, GstGLFilter* arg0, GstCaps* arg1, GstCaps* arg2) {
//   return ((gboolean (*)(GstGLFilter*, GstCaps*, GstCaps*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gstgl1_GLMixer_virtual_process_buffers(void* fnptr, GstGLMixer* arg0, GstBuffer* arg1) {
//   return ((gboolean (*)(GstGLMixer*, GstBuffer*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstgl1_GLMixer_virtual_process_textures(void* fnptr, GstGLMixer* arg0, GstGLMemory* arg1) {
//   return ((gboolean (*)(GstGLMixer*, GstGLMemory*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstgl1_GLWindow_virtual_controls_viewport(void* fnptr, GstGLWindow* arg0) {
//   return ((gboolean (*)(GstGLWindow*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstgl1_GLWindow_virtual_has_output_surface(void* fnptr, GstGLWindow* arg0) {
//   return ((gboolean (*)(GstGLWindow*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstgl1_GLWindow_virtual_open(void* fnptr, GstGLWindow* arg0, GError** arg1) {
//   return ((gboolean (*)(GstGLWindow*, GError**))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstgl1_GLWindow_virtual_set_render_rectangle(void* fnptr, GstGLWindow* arg0, gint arg1, gint arg2, gint arg3, gint arg4) {
//   return ((gboolean (*)(GstGLWindow*, gint, gint, gint, gint))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// guintptr _gotk4_gstgl1_GLContext_virtual_get_gl_context(void* fnptr, GstGLContext* arg0) {
//   return ((guintptr (*)(GstGLContext*))(fnptr))(arg0);
// };
// guintptr _gotk4_gstgl1_GLDisplay_virtual_get_handle(void* fnptr, GstGLDisplay* arg0) {
//   return ((guintptr (*)(GstGLDisplay*))(fnptr))(arg0);
// };
// guintptr _gotk4_gstgl1_GLWindow_virtual_get_display(void* fnptr, GstGLWindow* arg0) {
//   return ((guintptr (*)(GstGLWindow*))(fnptr))(arg0);
// };
// guintptr _gotk4_gstgl1_GLWindow_virtual_get_window_handle(void* fnptr, GstGLWindow* arg0) {
//   return ((guintptr (*)(GstGLWindow*))(fnptr))(arg0);
// };
// void _gotk4_gstgl1_GLBaseFilter_virtual_gl_stop(void* fnptr, GstGLBaseFilter* arg0) {
//   ((void (*)(GstGLBaseFilter*))(fnptr))(arg0);
// };
// void _gotk4_gstgl1_GLBaseMixer_virtual_gl_stop(void* fnptr, GstGLBaseMixer* arg0) {
//   ((void (*)(GstGLBaseMixer*))(fnptr))(arg0);
// };
// void _gotk4_gstgl1_GLBaseSrc_virtual_gl_stop(void* fnptr, GstGLBaseSrc* arg0) {
//   ((void (*)(GstGLBaseSrc*))(fnptr))(arg0);
// };
// void _gotk4_gstgl1_GLContext_virtual_destroy_context(void* fnptr, GstGLContext* arg0) {
//   ((void (*)(GstGLContext*))(fnptr))(arg0);
// };
// void _gotk4_gstgl1_GLContext_virtual_get_gl_platform_version(void* fnptr, GstGLContext* arg0, gint* arg1, gint* arg2) {
//   ((void (*)(GstGLContext*, gint*, gint*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gstgl1_GLContext_virtual_swap_buffers(void* fnptr, GstGLContext* arg0) {
//   ((void (*)(GstGLContext*))(fnptr))(arg0);
// };
// void _gotk4_gstgl1_GLWindow_virtual_close(void* fnptr, GstGLWindow* arg0) {
//   ((void (*)(GstGLWindow*))(fnptr))(arg0);
// };
// void _gotk4_gstgl1_GLWindow_virtual_draw(void* fnptr, GstGLWindow* arg0) {
//   ((void (*)(GstGLWindow*))(fnptr))(arg0);
// };
// void _gotk4_gstgl1_GLWindow_virtual_handle_events(void* fnptr, GstGLWindow* arg0, gboolean arg1) {
//   ((void (*)(GstGLWindow*, gboolean))(fnptr))(arg0, arg1);
// };
// void _gotk4_gstgl1_GLWindow_virtual_queue_resize(void* fnptr, GstGLWindow* arg0) {
//   ((void (*)(GstGLWindow*))(fnptr))(arg0);
// };
// void _gotk4_gstgl1_GLWindow_virtual_quit(void* fnptr, GstGLWindow* arg0) {
//   ((void (*)(GstGLWindow*))(fnptr))(arg0);
// };
// void _gotk4_gstgl1_GLWindow_virtual_run(void* fnptr, GstGLWindow* arg0) {
//   ((void (*)(GstGLWindow*))(fnptr))(arg0);
// };
// void _gotk4_gstgl1_GLWindow_virtual_set_preferred_size(void* fnptr, GstGLWindow* arg0, gint arg1, gint arg2) {
//   ((void (*)(GstGLWindow*, gint, gint))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gstgl1_GLWindow_virtual_set_window_handle(void* fnptr, GstGLWindow* arg0, guintptr arg1) {
//   ((void (*)(GstGLWindow*, guintptr))(fnptr))(arg0, arg1);
// };
// void _gotk4_gstgl1_GLWindow_virtual_show(void* fnptr, GstGLWindow* arg0) {
//   ((void (*)(GstGLWindow*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeGLBaseMemoryError              = coreglib.Type(C.gst_gl_base_memory_error_get_type())
	GTypeGLConfigCaveat                 = coreglib.Type(C.gst_gl_config_caveat_get_type())
	GTypeGLContextError                 = coreglib.Type(C.gst_gl_context_error_get_type())
	GTypeGLFormat                       = coreglib.Type(C.gst_gl_format_get_type())
	GTypeGLQueryType                    = coreglib.Type(C.gst_gl_query_type_get_type())
	GTypeGLSLError                      = coreglib.Type(C.gst_glsl_error_get_type())
	GTypeGLSLVersion                    = coreglib.Type(C.gst_glsl_version_get_type())
	GTypeGLStereoDownmix                = coreglib.Type(C.gst_gl_stereo_downmix_get_type())
	GTypeGLTextureTarget                = coreglib.Type(C.gst_gl_texture_target_get_type())
	GTypeGLUploadReturn                 = coreglib.Type(C.gst_gl_upload_return_get_type())
	GTypeGLWindowError                  = coreglib.Type(C.gst_gl_window_error_get_type())
	GTypeGLAPI                          = coreglib.Type(C.gst_gl_api_get_type())
	GTypeGLBaseMemoryTransfer           = coreglib.Type(C.gst_gl_base_memory_transfer_get_type())
	GTypeGLConfigSurfaceType            = coreglib.Type(C.gst_gl_config_surface_type_get_type())
	GTypeGLDisplayType                  = coreglib.Type(C.gst_gl_display_type_get_type())
	GTypeGLPlatform                     = coreglib.Type(C.gst_gl_platform_get_type())
	GTypeGLSLProfile                    = coreglib.Type(C.gst_glsl_profile_get_type())
	GTypeGLBaseFilter                   = coreglib.Type(C.gst_gl_base_filter_get_type())
	GTypeGLBaseMemoryAllocator          = coreglib.Type(C.gst_gl_base_memory_allocator_get_type())
	GTypeGLBaseMixer                    = coreglib.Type(C.gst_gl_base_mixer_get_type())
	GTypeGLBaseMixerPad                 = coreglib.Type(C.gst_gl_base_mixer_pad_get_type())
	GTypeGLBaseSrc                      = coreglib.Type(C.gst_gl_base_src_get_type())
	GTypeGLBufferAllocator              = coreglib.Type(C.gst_gl_buffer_allocator_get_type())
	GTypeGLBufferPool                   = coreglib.Type(C.gst_gl_buffer_pool_get_type())
	GTypeGLColorConvert                 = coreglib.Type(C.gst_gl_color_convert_get_type())
	GTypeGLContext                      = coreglib.Type(C.gst_gl_context_get_type())
	GTypeGLDisplay                      = coreglib.Type(C.gst_gl_display_get_type())
	GTypeGLFilter                       = coreglib.Type(C.gst_gl_filter_get_type())
	GTypeGLFramebuffer                  = coreglib.Type(C.gst_gl_framebuffer_get_type())
	GTypeGLMemoryAllocator              = coreglib.Type(C.gst_gl_memory_allocator_get_type())
	GTypeGLMemoryPBOAllocator           = coreglib.Type(C.gst_gl_memory_pbo_allocator_get_type())
	GTypeGLMixer                        = coreglib.Type(C.gst_gl_mixer_get_type())
	GTypeGLMixerPad                     = coreglib.Type(C.gst_gl_mixer_pad_get_type())
	GTypeGLOverlayCompositor            = coreglib.Type(C.gst_gl_overlay_compositor_get_type())
	GTypeGLRenderbufferAllocator        = coreglib.Type(C.gst_gl_renderbuffer_allocator_get_type())
	GTypeGLSLStage                      = coreglib.Type(C.gst_glsl_stage_get_type())
	GTypeGLShader                       = coreglib.Type(C.gst_gl_shader_get_type())
	GTypeGLUpload                       = coreglib.Type(C.gst_gl_upload_get_type())
	GTypeGLViewConvert                  = coreglib.Type(C.gst_gl_view_convert_get_type())
	GTypeGLWindow                       = coreglib.Type(C.gst_gl_window_get_type())
	GTypeGLAllocationParams             = coreglib.Type(C.gst_gl_allocation_params_get_type())
	GTypeGLBaseMemory                   = coreglib.Type(C.gst_gl_base_memory_get_type())
	GTypeGLBuffer                       = coreglib.Type(C.gst_gl_buffer_get_type())
	GTypeGLBufferAllocationParams       = coreglib.Type(C.gst_gl_buffer_allocation_params_get_type())
	GTypeGLMemory                       = coreglib.Type(C.gst_gl_memory_get_type())
	GTypeGLMemoryPBO                    = coreglib.Type(C.gst_gl_memory_pbo_get_type())
	GTypeGLRenderbuffer                 = coreglib.Type(C.gst_gl_renderbuffer_get_type())
	GTypeGLRenderbufferAllocationParams = coreglib.Type(C.gst_gl_renderbuffer_allocation_params_get_type())
	GTypeGLVideoAllocationParams        = coreglib.Type(C.gst_gl_video_allocation_params_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeGLBaseMemoryError, F: marshalGLBaseMemoryError},
		coreglib.TypeMarshaler{T: GTypeGLConfigCaveat, F: marshalGLConfigCaveat},
		coreglib.TypeMarshaler{T: GTypeGLContextError, F: marshalGLContextError},
		coreglib.TypeMarshaler{T: GTypeGLFormat, F: marshalGLFormat},
		coreglib.TypeMarshaler{T: GTypeGLQueryType, F: marshalGLQueryType},
		coreglib.TypeMarshaler{T: GTypeGLSLError, F: marshalGLSLError},
		coreglib.TypeMarshaler{T: GTypeGLSLVersion, F: marshalGLSLVersion},
		coreglib.TypeMarshaler{T: GTypeGLStereoDownmix, F: marshalGLStereoDownmix},
		coreglib.TypeMarshaler{T: GTypeGLTextureTarget, F: marshalGLTextureTarget},
		coreglib.TypeMarshaler{T: GTypeGLUploadReturn, F: marshalGLUploadReturn},
		coreglib.TypeMarshaler{T: GTypeGLWindowError, F: marshalGLWindowError},
		coreglib.TypeMarshaler{T: GTypeGLAPI, F: marshalGLAPI},
		coreglib.TypeMarshaler{T: GTypeGLBaseMemoryTransfer, F: marshalGLBaseMemoryTransfer},
		coreglib.TypeMarshaler{T: GTypeGLConfigSurfaceType, F: marshalGLConfigSurfaceType},
		coreglib.TypeMarshaler{T: GTypeGLDisplayType, F: marshalGLDisplayType},
		coreglib.TypeMarshaler{T: GTypeGLPlatform, F: marshalGLPlatform},
		coreglib.TypeMarshaler{T: GTypeGLSLProfile, F: marshalGLSLProfile},
		coreglib.TypeMarshaler{T: GTypeGLBaseFilter, F: marshalGLBaseFilter},
		coreglib.TypeMarshaler{T: GTypeGLBaseMemoryAllocator, F: marshalGLBaseMemoryAllocator},
		coreglib.TypeMarshaler{T: GTypeGLBaseMixer, F: marshalGLBaseMixer},
		coreglib.TypeMarshaler{T: GTypeGLBaseMixerPad, F: marshalGLBaseMixerPad},
		coreglib.TypeMarshaler{T: GTypeGLBaseSrc, F: marshalGLBaseSrc},
		coreglib.TypeMarshaler{T: GTypeGLBufferAllocator, F: marshalGLBufferAllocator},
		coreglib.TypeMarshaler{T: GTypeGLBufferPool, F: marshalGLBufferPool},
		coreglib.TypeMarshaler{T: GTypeGLColorConvert, F: marshalGLColorConvert},
		coreglib.TypeMarshaler{T: GTypeGLContext, F: marshalGLContext},
		coreglib.TypeMarshaler{T: GTypeGLDisplay, F: marshalGLDisplay},
		coreglib.TypeMarshaler{T: GTypeGLFilter, F: marshalGLFilter},
		coreglib.TypeMarshaler{T: GTypeGLFramebuffer, F: marshalGLFramebuffer},
		coreglib.TypeMarshaler{T: GTypeGLMemoryAllocator, F: marshalGLMemoryAllocator},
		coreglib.TypeMarshaler{T: GTypeGLMemoryPBOAllocator, F: marshalGLMemoryPBOAllocator},
		coreglib.TypeMarshaler{T: GTypeGLMixer, F: marshalGLMixer},
		coreglib.TypeMarshaler{T: GTypeGLMixerPad, F: marshalGLMixerPad},
		coreglib.TypeMarshaler{T: GTypeGLOverlayCompositor, F: marshalGLOverlayCompositor},
		coreglib.TypeMarshaler{T: GTypeGLRenderbufferAllocator, F: marshalGLRenderbufferAllocator},
		coreglib.TypeMarshaler{T: GTypeGLSLStage, F: marshalGLSLStage},
		coreglib.TypeMarshaler{T: GTypeGLShader, F: marshalGLShader},
		coreglib.TypeMarshaler{T: GTypeGLUpload, F: marshalGLUpload},
		coreglib.TypeMarshaler{T: GTypeGLViewConvert, F: marshalGLViewConvert},
		coreglib.TypeMarshaler{T: GTypeGLWindow, F: marshalGLWindow},
		coreglib.TypeMarshaler{T: GTypeGLAllocationParams, F: marshalGLAllocationParams},
		coreglib.TypeMarshaler{T: GTypeGLBaseMemory, F: marshalGLBaseMemory},
		coreglib.TypeMarshaler{T: GTypeGLBuffer, F: marshalGLBuffer},
		coreglib.TypeMarshaler{T: GTypeGLBufferAllocationParams, F: marshalGLBufferAllocationParams},
		coreglib.TypeMarshaler{T: GTypeGLMemory, F: marshalGLMemory},
		coreglib.TypeMarshaler{T: GTypeGLMemoryPBO, F: marshalGLMemoryPBO},
		coreglib.TypeMarshaler{T: GTypeGLRenderbuffer, F: marshalGLRenderbuffer},
		coreglib.TypeMarshaler{T: GTypeGLRenderbufferAllocationParams, F: marshalGLRenderbufferAllocationParams},
		coreglib.TypeMarshaler{T: GTypeGLVideoAllocationParams, F: marshalGLVideoAllocationParams},
	})
}

// BUFFER_POOL_OPTION_GL_SYNC_META: option that can be activated on bufferpools
// to request OpenGL synchronization metadata on buffers from the pool.
const BUFFER_POOL_OPTION_GL_SYNC_META = "GstBufferPoolOptionGLSyncMeta"

// BUFFER_POOL_OPTION_GL_TEXTURE_TARGET_2D: string used for
// GST_GL_TEXTURE_TARGET_2D as a BufferPool pool option.
const BUFFER_POOL_OPTION_GL_TEXTURE_TARGET_2D = "GstBufferPoolOptionGLTextureTarget2D"

// BUFFER_POOL_OPTION_GL_TEXTURE_TARGET_EXTERNAL_OES: string used for
// GST_GL_TEXTURE_TARGET_EXTERNAL_OES as a BufferPool pool option.
const BUFFER_POOL_OPTION_GL_TEXTURE_TARGET_EXTERNAL_OES = "GstBufferPoolOptionGLTextureTargetExternalOES"

// BUFFER_POOL_OPTION_GL_TEXTURE_TARGET_RECTANGLE: string used for
// GST_GL_TEXTURE_TARGET_RECTANGLE as a BufferPool pool option.
const BUFFER_POOL_OPTION_GL_TEXTURE_TARGET_RECTANGLE = "GstBufferPoolOptionGLTextureTargetRectangle"

// CAPS_FEATURE_MEMORY_GL_BUFFER: name of the caps feature indicating the use of
// GL buffers.
const CAPS_FEATURE_MEMORY_GL_BUFFER = "memory:GLBuffer"

// CAPS_FEATURE_MEMORY_GL_MEMORY: name of the caps feature for indicating the
// use of GLMemory.
const CAPS_FEATURE_MEMORY_GL_MEMORY = "memory:GLMemory"

// GL_ALLOCATION_PARAMS_ALLOC_FLAG_ALLOC: GL Allocation flag indicating that the
// implementation should allocate the necessary resources.
const GL_ALLOCATION_PARAMS_ALLOC_FLAG_ALLOC = 1

// GL_ALLOCATION_PARAMS_ALLOC_FLAG_BUFFER: GL allocation flag indicating the
// allocation of a GL buffer.
const GL_ALLOCATION_PARAMS_ALLOC_FLAG_BUFFER = 16

// GL_ALLOCATION_PARAMS_ALLOC_FLAG_USER values >= than
// T_GL_ALLOCATION_PARAMS_ALLOC_FLAG_USER can be used for user-defined purposes.
const GL_ALLOCATION_PARAMS_ALLOC_FLAG_USER = 65536

// GL_ALLOCATION_PARAMS_ALLOC_FLAG_VIDEO: GL allocation flag indicating the
// allocation of 2D video frames.
const GL_ALLOCATION_PARAMS_ALLOC_FLAG_VIDEO = 8

// GL_ALLOCATION_PARAMS_ALLOC_FLAG_WRAP_GPU_HANDLE: GL Allocation flag for using
// the provided GPU handle as storage.
const GL_ALLOCATION_PARAMS_ALLOC_FLAG_WRAP_GPU_HANDLE = 4

// GL_ALLOCATION_PARAMS_ALLOC_FLAG_WRAP_SYSMEM: GL Allocation flag for using the
// provided system memory data as storage.
const GL_ALLOCATION_PARAMS_ALLOC_FLAG_WRAP_SYSMEM = 2

// GL_API_GLES1_NAME: name for GST_GL_API_GLES1 used in various places.
const GL_API_GLES1_NAME = "gles1"

// GL_API_GLES2_NAME: name for GST_GL_API_GLES2 used in various places.
const GL_API_GLES2_NAME = "gles2"

// GL_API_OPENGL3_NAME: name for GST_GL_API_OPENGL3 used in various places.
const GL_API_OPENGL3_NAME = "opengl3"

// GL_API_OPENGL_NAME: name for GST_GL_API_OPENGL used in various places.
const GL_API_OPENGL_NAME = "opengl"

// GL_BASE_MEMORY_ALLOCATOR_NAME: name of the GL buffer allocator.
const GL_BASE_MEMORY_ALLOCATOR_NAME = "GLBaseMemory"

// GL_BUFFER_ALLOCATOR_NAME: name of the GL buffer allocator.
const GL_BUFFER_ALLOCATOR_NAME = "GLBuffer"
const GL_COLOR_CONVERT_EXT_FORMATS = ", RGBA64_LE, BGR10A2_LE, RGB10A2_LE, P010_10LE, P012_LE, P016_LE, Y212_LE, Y412_LE, A444_16LE, A422_16LE, A420_16LE, A444_12LE, A422_12LE, A420_12LE, A420_10LE, A422_10LE, A444_10LE, I420_12LE, I420_10LE"

// GL_COLOR_CONVERT_FORMATS: currently supported formats that can be converted.
const GL_COLOR_CONVERT_FORMATS = "{ RGBA, RGB, RGBx, BGR, BGRx, BGRA, xRGB, xBGR, ARGB, ABGR, GBRA, GBR, RGBP, BGRP, Y444, I420, YV12, Y42B, Y41B, NV12, NV21, NV16, NV61, YUY2, UYVY, Y210, AYUV, VUYA, Y410, A444, A422, GRAY8, GRAY16_LE, GRAY16_BE, RGB16, BGR16, ARGB64, A420, AV12, NV12_16L32S, NV12_4L4, RBGA"

// GL_COLOR_CONVERT_VIDEO_CAPS: currently supported Caps that can be converted.
const GL_COLOR_CONVERT_VIDEO_CAPS = "video/x-raw("

// GL_CONFIG_STRUCTURE_NAME: canonical name of a Structure that contains a
// configuration for a GLContext.
const GL_CONFIG_STRUCTURE_NAME = "gst-gl-context-config"
const GL_CONTEXT_TYPE_CGL = "gst.gl.context.CGL"
const GL_CONTEXT_TYPE_EAGL = "gst.gl.context.EAGL"
const GL_CONTEXT_TYPE_EGL = "gst.gl.context.EGL"
const GL_CONTEXT_TYPE_GLX = "gst.gl.context.GLX"
const GL_CONTEXT_TYPE_WGL = "gst.gl.context.WGL"

// GL_DISPLAY_CONTEXT_TYPE: name used in Context queries for requesting a
// GLDisplay.
const GL_DISPLAY_CONTEXT_TYPE = "gst.gl.GLDisplay"

// GL_MEMORY_ALLOCATOR_NAME: name of the GL memory allocator.
const GL_MEMORY_ALLOCATOR_NAME = "GLMemory"

// GL_MEMORY_PBO_ALLOCATOR_NAME: name of the GL Memory PBO allocator.
const GL_MEMORY_PBO_ALLOCATOR_NAME = "GLMemoryPBO"
const GL_MEMORY_VIDEO_EXT_FORMATS = ", RGBA64_LE, BGR10A2_LE, RGB10A2_LE, P010_10LE, P012_LE, P016_LE, Y212_LE, Y412_LE, A444_16LE, A422_16LE, A420_16LE, A444_12LE, A422_12LE, A420_12LE, A420_10LE, A422_10LE, A444_10LE, I420_12LE, I420_10LE"

// GL_MEMORY_VIDEO_FORMATS_STR: list of video formats that are supported by
// GLMemory.
const GL_MEMORY_VIDEO_FORMATS_STR = "{ RGBA, BGRA, RGBx, BGRx, ARGB, ABGR, xRGB, xBGR, GBRA, GBR, RGBP, BGRP, RGB, BGR, RGB16, BGR16, AYUV, VUYA, A444, A422, Y410, I420, YV12, NV12, NV21, NV16, NV61, YUY2, UYVY, Y210, Y41B, Y42B, Y444, GRAY8, GRAY16_LE, GRAY16_BE, ARGB64, A420, AV12, NV12_16L32S, NV12_4L4, RBGA"

// GL_RENDERBUFFER_ALLOCATOR_NAME: name of the GL renderbuffer allocator.
const GL_RENDERBUFFER_ALLOCATOR_NAME = "GLRenderbuffer"

// GL_TEXTURE_TARGET_2D_STR: string used for GST_GL_TEXTURE_TARGET_2D in things
// like caps values.
const GL_TEXTURE_TARGET_2D_STR = "2D"

// GL_TEXTURE_TARGET_EXTERNAL_OES_STR: string used for
// GST_GL_TEXTURE_TARGET_EXTERNAL_OES in things like caps values.
const GL_TEXTURE_TARGET_EXTERNAL_OES_STR = "external-oes"

// GL_TEXTURE_TARGET_RECTANGLE_STR: string used for
// GST_GL_TEXTURE_TARGET_RECTANGLE in things like caps values.
const GL_TEXTURE_TARGET_RECTANGLE_STR = "rectangle"

// MAP_GL: flag indicating that we should map the GL object instead of to system
// memory.
//
// Combining T_MAP_GL with T_MAP_WRITE has the same semantics as though you are
// writing to OpenGL. Conversely, combining T_MAP_GL with T_MAP_READ has the
// same semantics as though you are reading from OpenGL.
const MAP_GL = 131072

type GLBaseMemoryError C.gint

const (
	// GLBaseMemoryErrorFailed: generic failure.
	GLBaseMemoryErrorFailed GLBaseMemoryError = iota
	// GLBaseMemoryErrorOldLibs: implementation is too old and doesn't implement
	// enough features.
	GLBaseMemoryErrorOldLibs
	// GLBaseMemoryErrorResourceUnavailable: resource could not be found.
	GLBaseMemoryErrorResourceUnavailable
)

func marshalGLBaseMemoryError(p uintptr) (interface{}, error) {
	return GLBaseMemoryError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for GLBaseMemoryError.
func (g GLBaseMemoryError) String() string {
	switch g {
	case GLBaseMemoryErrorFailed:
		return "Failed"
	case GLBaseMemoryErrorOldLibs:
		return "OldLibs"
	case GLBaseMemoryErrorResourceUnavailable:
		return "ResourceUnavailable"
	default:
		return fmt.Sprintf("GLBaseMemoryError(%d)", g)
	}
}

// The function returns the following values:
//
//   - quark used for GLBaseMemory in #GError's.
func GLBaseMemoryErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gst_gl_base_memory_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

type GLConfigCaveat C.gint

const (
	// GLConfigCaveatNone: none.
	GLConfigCaveatNone GLConfigCaveat = iota
	// GLConfigCaveatSlow: slow.
	GLConfigCaveatSlow
	// GLConfigCaveatNonConformant: non-conformant.
	GLConfigCaveatNonConformant
)

func marshalGLConfigCaveat(p uintptr) (interface{}, error) {
	return GLConfigCaveat(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for GLConfigCaveat.
func (g GLConfigCaveat) String() string {
	switch g {
	case GLConfigCaveatNone:
		return "None"
	case GLConfigCaveatSlow:
		return "Slow"
	case GLConfigCaveatNonConformant:
		return "NonConformant"
	default:
		return fmt.Sprintf("GLConfigCaveat(%d)", g)
	}
}

// The function takes the following parameters:
//
//   - caveat: GLConfigCaveat.
//
// The function returns the following values:
//
//   - utf8 (optional): string version of caveat or NULL if caveat does not
//     exist.
func GLConfigCaveatToString(caveat GLConfigCaveat) string {
	var _arg1 C.GstGLConfigCaveat // out
	var _cret *C.gchar            // in

	_arg1 = C.GstGLConfigCaveat(caveat)

	_cret = C.gst_gl_config_caveat_to_string(_arg1)
	runtime.KeepAlive(caveat)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// GLContextError: openGL context errors.
type GLContextError C.gint

const (
	// GLContextErrorFailed: failed for an unspecified reason.
	GLContextErrorFailed GLContextError = iota
	// GLContextErrorWrongConfig: configuration requested is not correct.
	GLContextErrorWrongConfig
	// GLContextErrorWrongApi: openGL API requested is not correct.
	GLContextErrorWrongApi
	// GLContextErrorOldLibs: openGL libraries are too old.
	GLContextErrorOldLibs
	// GLContextErrorCreateContext: glXCreateContext (or similar) failed.
	GLContextErrorCreateContext
	// GLContextErrorResourceUnavailable: resource is not available.
	GLContextErrorResourceUnavailable
)

func marshalGLContextError(p uintptr) (interface{}, error) {
	return GLContextError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for GLContextError.
func (g GLContextError) String() string {
	switch g {
	case GLContextErrorFailed:
		return "Failed"
	case GLContextErrorWrongConfig:
		return "WrongConfig"
	case GLContextErrorWrongApi:
		return "WrongApi"
	case GLContextErrorOldLibs:
		return "OldLibs"
	case GLContextErrorCreateContext:
		return "CreateContext"
	case GLContextErrorResourceUnavailable:
		return "ResourceUnavailable"
	default:
		return fmt.Sprintf("GLContextError(%d)", g)
	}
}

// The function returns the following values:
//
//   - quark used for GLContext in #GError's.
func GLContextErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gst_gl_context_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

type GLFormat C.gint

const (
	// GLLuminance: single component replicated across R, G, and B textures
	// components.
	GLLuminance GLFormat = 6409
	// GLAlpha: single component stored in the A texture component.
	GLAlpha GLFormat = 6406
	// GLLuminanceAlpha: combination of T_GL_LUMINANCE and T_GL_ALPHA.
	GLLuminanceAlpha GLFormat = 6410
	// GLRed: single component stored in the R texture component.
	GLRed GLFormat = 6403
	// GLR8: single 8-bit component stored in the R texture component.
	GLR8 GLFormat = 33321
	// GLRg: two components stored in the R and G texture components.
	GLRg GLFormat = 33319
	// GLRg8: two 8-bit components stored in the R and G texture components.
	GLRg8 GLFormat = 33323
	// GLRGB: three components stored in the R, G, and B texture components.
	GLRGB GLFormat = 6407
	// GLRGB8: three 8-bit components stored in the R, G, and B texture
	// components.
	GLRGB8 GLFormat = 32849
	// GLRGB565: three components of bit depth 5, 6 and 5 stored in the R, G,
	// and B texture components respectively.
	GLRGB565 GLFormat = 36194
	// GLRGB16: three 16-bit components stored in the R, G, and B texture
	// components.
	GLRGB16 GLFormat = 32852
	// GLRGBA: four components stored in the R, G, B, and A texture components
	// respectively.
	GLRGBA GLFormat = 6408
	// GLRGBA8: four 8-bit components stored in the R, G, B, and A texture
	// components respectively.
	GLRGBA8 GLFormat = 32856
	// GLRGBA16: four 16-bit components stored in the R, G, B, and A texture
	// components respectively.
	GLRGBA16 GLFormat = 32859
	// GLDepthComponent16: single 16-bit component for depth information.
	GLDepthComponent16 GLFormat = 33189
	// GLDepth24Stencil8: 24-bit component for depth information and a 8-bit
	// component for stencil informat.
	GLDepth24Stencil8 GLFormat = 35056
	GLRGB10A2         GLFormat = 32857
	// GLR16: single 16-bit component stored in the R texture component.
	GLR16 GLFormat = 33322
	// GLRg16: two 16-bit components stored in the R and G texture components.
	GLRg16 GLFormat = 33324
)

func marshalGLFormat(p uintptr) (interface{}, error) {
	return GLFormat(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for GLFormat.
func (g GLFormat) String() string {
	switch g {
	case GLLuminance:
		return "Luminance"
	case GLAlpha:
		return "Alpha"
	case GLLuminanceAlpha:
		return "LuminanceAlpha"
	case GLRed:
		return "Red"
	case GLR8:
		return "R8"
	case GLRg:
		return "Rg"
	case GLRg8:
		return "Rg8"
	case GLRGB:
		return "RGB"
	case GLRGB8:
		return "RGB8"
	case GLRGB565:
		return "RGB565"
	case GLRGB16:
		return "RGB16"
	case GLRGBA:
		return "RGBA"
	case GLRGBA8:
		return "RGBA8"
	case GLRGBA16:
		return "RGBA16"
	case GLDepthComponent16:
		return "DepthComponent16"
	case GLDepth24Stencil8:
		return "Depth24Stencil8"
	case GLRGB10A2:
		return "RGB10A2"
	case GLR16:
		return "R16"
	case GLRg16:
		return "Rg16"
	default:
		return fmt.Sprintf("GLFormat(%d)", g)
	}
}

// The function takes the following parameters:
//
//   - context: GLContext.
//   - vinfo: VideoInfo.
//   - plane number in vinfo.
//
// The function returns the following values:
//
//   - glFormat necessary for holding the data in plane of vinfo.
func GLFormatFromVideoInfo(context GLContexter, vinfo *gstvideo.VideoInfo, plane uint) GLFormat {
	var _arg1 *C.GstGLContext // out
	var _arg2 *C.GstVideoInfo // out
	var _arg3 C.guint         // out
	var _cret C.GstGLFormat   // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GstVideoInfo)(gextras.StructNative(unsafe.Pointer(vinfo)))
	_arg3 = C.guint(plane)

	_cret = C.gst_gl_format_from_video_info(_arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(vinfo)
	runtime.KeepAlive(plane)

	var _glFormat GLFormat // out

	_glFormat = GLFormat(_cret)

	return _glFormat
}

// The function takes the following parameters:
//
//   - context: GLContext.
//   - format to check is supported by context.
//
// The function returns the following values:
//
//   - ok: whether format is supported by context based on the OpenGL API,
//     version, or available OpenGL extension/s.
func GLFormatIsSupported(context GLContexter, format GLFormat) bool {
	var _arg1 *C.GstGLContext // out
	var _arg2 C.GstGLFormat   // out
	var _cret C.gboolean      // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.GstGLFormat(format)

	_cret = C.gst_gl_format_is_supported(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(format)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - glFormat: GLFormat.
//
// The function returns the following values:
//
//   - guint: number of components in a GLFormat.
func GLFormatNComponents(glFormat GLFormat) uint {
	var _arg1 C.GstGLFormat // out
	var _cret C.guint       // in

	_arg1 = C.GstGLFormat(glFormat)

	_cret = C.gst_gl_format_n_components(_arg1)
	runtime.KeepAlive(glFormat)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// GLFormatTypeFromSizedGLFormat: get the unsized format and type from format
// for usage in glReadPixels, glTex{Sub}Image*, glTexImage* and similar
// functions.
//
// The function takes the following parameters:
//
//   - format: sized internal GLFormat.
//
// The function returns the following values:
//
//   - unsizedFormat: location for the resulting unsized GLFormat.
//   - glType: location for the resulting GL type.
func GLFormatTypeFromSizedGLFormat(format GLFormat) (GLFormat, uint) {
	var _arg1 C.GstGLFormat // out
	var _arg2 C.GstGLFormat // in
	var _arg3 C.guint       // in

	_arg1 = C.GstGLFormat(format)

	C.gst_gl_format_type_from_sized_gl_format(_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(format)

	var _unsizedFormat GLFormat // out
	var _glType uint            // out

	_unsizedFormat = GLFormat(_arg2)
	_glType = uint(_arg3)

	return _unsizedFormat, _glType
}

// The function takes the following parameters:
//
//   - format: openGL format, GL_RGBA, GL_LUMINANCE, etc.
//   - typ: openGL type, GL_UNSIGNED_BYTE, GL_FLOAT, etc.
//
// The function returns the following values:
//
//   - guint: number of bytes the specified format, type combination takes per
//     pixel.
func GLFormatTypeNBytes(format, typ uint) uint {
	var _arg1 C.guint // out
	var _arg2 C.guint // out
	var _cret C.guint // in

	_arg1 = C.guint(format)
	_arg2 = C.guint(typ)

	_cret = C.gst_gl_format_type_n_bytes(_arg1, _arg2)
	runtime.KeepAlive(format)
	runtime.KeepAlive(typ)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

type GLQueryType C.gint

const (
	// GLQueryNone: no query.
	GLQueryNone GLQueryType = iota
	// GLQueryTimeElapsed: query the time elapsed.
	GLQueryTimeElapsed
	// GLQueryTimestamp: query the current time.
	GLQueryTimestamp
)

func marshalGLQueryType(p uintptr) (interface{}, error) {
	return GLQueryType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for GLQueryType.
func (g GLQueryType) String() string {
	switch g {
	case GLQueryNone:
		return "None"
	case GLQueryTimeElapsed:
		return "TimeElapsed"
	case GLQueryTimestamp:
		return "Timestamp"
	default:
		return fmt.Sprintf("GLQueryType(%d)", g)
	}
}

// GLSLError: compilation stage that caused an error.
type GLSLError C.gint

const (
	// GlslErrorCompile: compilation error occurred.
	GlslErrorCompile GLSLError = iota
	// GlslErrorLink: link error occurred.
	GlslErrorLink
	// GlslErrorProgram: general program error occurred.
	GlslErrorProgram
)

func marshalGLSLError(p uintptr) (interface{}, error) {
	return GLSLError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for GLSLError.
func (g GLSLError) String() string {
	switch g {
	case GlslErrorCompile:
		return "Compile"
	case GlslErrorLink:
		return "Link"
	case GlslErrorProgram:
		return "Program"
	default:
		return fmt.Sprintf("GLSLError(%d)", g)
	}
}

// The function returns the following values:
//
//   - quark used for GstGLSL in #GError's.
func GLSLErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gst_glsl_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// GLSLVersion: GLSL version list.
type GLSLVersion C.gint

const (
	// GlslVersionNone: no version.
	GlslVersionNone GLSLVersion = 0
	// GlslVersion100: version 100 (only valid for ES).
	GlslVersion100 GLSLVersion = 100
	// GlslVersion110: version 110 (only valid for compatibility desktop GL).
	GlslVersion110 GLSLVersion = 110
	// GlslVersion120: version 120 (only valid for compatibility desktop GL).
	GlslVersion120 GLSLVersion = 120
	// GlslVersion130: version 130 (only valid for compatibility desktop GL).
	GlslVersion130 GLSLVersion = 130
	// GlslVersion140: version 140 (only valid for compatibility desktop GL).
	GlslVersion140 GLSLVersion = 140
	// GlslVersion150: version 150 (valid for compatibility/core desktop GL).
	GlslVersion150 GLSLVersion = 150
	// GlslVersion300: version 300 (only valid for ES).
	GlslVersion300 GLSLVersion = 300
	// GlslVersion310: version 310 (only valid for ES).
	GlslVersion310 GLSLVersion = 310
	// GlslVersion320: version 320 (only valid for ES).
	GlslVersion320 GLSLVersion = 320
	// GlslVersion330: version 330 (valid for compatibility/core desktop GL).
	GlslVersion330 GLSLVersion = 330
	// GlslVersion400: version 400 (valid for compatibility/core desktop GL).
	GlslVersion400 GLSLVersion = 400
	// GlslVersion410: version 410 (valid for compatibility/core desktop GL).
	GlslVersion410 GLSLVersion = 410
	// GlslVersion420: version 420 (valid for compatibility/core desktop GL).
	GlslVersion420 GLSLVersion = 420
	// GlslVersion430: version 430 (valid for compatibility/core desktop GL).
	GlslVersion430 GLSLVersion = 430
	// GlslVersion440: version 440 (valid for compatibility/core desktop GL).
	GlslVersion440 GLSLVersion = 440
	// GlslVersion450: version 450 (valid for compatibility/core desktop GL).
	GlslVersion450 GLSLVersion = 450
)

func marshalGLSLVersion(p uintptr) (interface{}, error) {
	return GLSLVersion(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for GLSLVersion.
func (g GLSLVersion) String() string {
	switch g {
	case GlslVersionNone:
		return "None"
	case GlslVersion100:
		return "100"
	case GlslVersion110:
		return "110"
	case GlslVersion120:
		return "120"
	case GlslVersion130:
		return "130"
	case GlslVersion140:
		return "140"
	case GlslVersion150:
		return "150"
	case GlslVersion300:
		return "300"
	case GlslVersion310:
		return "310"
	case GlslVersion320:
		return "320"
	case GlslVersion330:
		return "330"
	case GlslVersion400:
		return "400"
	case GlslVersion410:
		return "410"
	case GlslVersion420:
		return "420"
	case GlslVersion430:
		return "430"
	case GlslVersion440:
		return "440"
	case GlslVersion450:
		return "450"
	default:
		return fmt.Sprintf("GLSLVersion(%d)", g)
	}
}

// The function takes the following parameters:
//
//   - str: GLSL version string.
//
// The function returns the following values:
//
//   - glslVersion of string or GST_GLSL_VERSION_NONE on error.
func GLSLVersionFromString(str string) GLSLVersion {
	var _arg1 *C.gchar         // out
	var _cret C.GstGLSLVersion // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_glsl_version_from_string(_arg1)
	runtime.KeepAlive(str)

	var _glslVersion GLSLVersion // out

	_glslVersion = GLSLVersion(_cret)

	return _glslVersion
}

// GLSLVersionProfileFromString: note: this function expects either a #version
// GLSL preprocesser directive or a valid GLSL version and/or profile.
//
// The function takes the following parameters:
//
//   - str: valid GLSL #version string.
//
// The function returns the following values:
//
//   - versionRet: resulting GLSLVersion.
//   - profileRet: resulting GLSLVersion.
//   - ok: TRUE if a valid #version string was found, FALSE otherwise.
func GLSLVersionProfileFromString(str string) (GLSLVersion, GLSLProfile, bool) {
	var _arg1 *C.gchar         // out
	var _arg2 C.GstGLSLVersion // in
	var _arg3 C.GstGLSLProfile // in
	var _cret C.gboolean       // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_glsl_version_profile_from_string(_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(str)

	var _versionRet GLSLVersion // out
	var _profileRet GLSLProfile // out
	var _ok bool                // out

	_versionRet = GLSLVersion(_arg2)
	_profileRet = GLSLProfile(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _versionRet, _profileRet, _ok
}

// The function takes the following parameters:
//
//   - version: GLSLVersion.
//   - profile: GLSLVersion.
//
// The function returns the following values:
//
//   - utf8 (optional): combined GLSL #version string for version and profile.
func GLSLVersionProfileToString(version GLSLVersion, profile GLSLProfile) string {
	var _arg1 C.GstGLSLVersion // out
	var _arg2 C.GstGLSLProfile // out
	var _cret *C.gchar         // in

	_arg1 = C.GstGLSLVersion(version)
	_arg2 = C.GstGLSLProfile(profile)

	_cret = C.gst_glsl_version_profile_to_string(_arg1, _arg2)
	runtime.KeepAlive(version)
	runtime.KeepAlive(profile)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// The function takes the following parameters:
//
//   - version: GLSLVersion.
//
// The function returns the following values:
//
//   - utf8 (optional): name of version or NULL on error.
func GLSLVersionToString(version GLSLVersion) string {
	var _arg1 C.GstGLSLVersion // out
	var _cret *C.gchar         // in

	_arg1 = C.GstGLSLVersion(version)

	_cret = C.gst_glsl_version_to_string(_arg1)
	runtime.KeepAlive(version)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// GLStereoDownmix: output anaglyph type to generate when downmixing to mono.
type GLStereoDownmix C.gint

const (
	// GLStereoDownmixAnaglyphGreenMagentaDubois dubois optimised Green-Magenta
	// anaglyph.
	GLStereoDownmixAnaglyphGreenMagentaDubois GLStereoDownmix = iota
	// GLStereoDownmixAnaglyphRedCyanDubois dubois optimised Red-Cyan anaglyph.
	GLStereoDownmixAnaglyphRedCyanDubois
	// GLStereoDownmixAnaglyphAmberBlueDubois dubois optimised Amber-Blue
	// anaglyph.
	GLStereoDownmixAnaglyphAmberBlueDubois
)

func marshalGLStereoDownmix(p uintptr) (interface{}, error) {
	return GLStereoDownmix(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for GLStereoDownmix.
func (g GLStereoDownmix) String() string {
	switch g {
	case GLStereoDownmixAnaglyphGreenMagentaDubois:
		return "GreenMagentaDubois"
	case GLStereoDownmixAnaglyphRedCyanDubois:
		return "RedCyanDubois"
	case GLStereoDownmixAnaglyphAmberBlueDubois:
		return "AmberBlueDubois"
	default:
		return fmt.Sprintf("GLStereoDownmix(%d)", g)
	}
}

// GLTextureTarget: openGL texture target that an OpenGL texture can
// be bound to. The gst_gl_value_set_texture_target_from_mask(),
// gst_gl_value_get_texture_target_mask(), and gst_gl_value_set_texture_target()
// functions can be used for handling texture targets with #GValue's when e.g.
// dealing with Caps.
type GLTextureTarget C.gint

const (
	// GLTextureTargetNone: no texture target.
	GLTextureTargetNone GLTextureTarget = iota
	// GLTextureTarget2D: 2D texture target (GL_TEXTURE_2D).
	GLTextureTarget2D
	// GLTextureTargetRectangle: rectangle texture target
	// (GL_TEXTURE_RECTANGLE).
	GLTextureTargetRectangle
	// GLTextureTargetExternalOes: external oes texture target
	// (GL_TEXTURE_EXTERNAL_OES).
	GLTextureTargetExternalOes
)

func marshalGLTextureTarget(p uintptr) (interface{}, error) {
	return GLTextureTarget(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for GLTextureTarget.
func (g GLTextureTarget) String() string {
	switch g {
	case GLTextureTargetNone:
		return "None"
	case GLTextureTarget2D:
		return "2D"
	case GLTextureTargetRectangle:
		return "Rectangle"
	case GLTextureTargetExternalOes:
		return "ExternalOes"
	default:
		return fmt.Sprintf("GLTextureTarget(%d)", g)
	}
}

// The function takes the following parameters:
//
//   - target: openGL texture binding target.
//
// The function returns the following values:
//
//   - glTextureTarget that's equiavalant to target or
//     GST_GL_TEXTURE_TARGET_NONE.
func GLTextureTargetFromGL(target uint) GLTextureTarget {
	var _arg1 C.guint              // out
	var _cret C.GstGLTextureTarget // in

	_arg1 = C.guint(target)

	_cret = C.gst_gl_texture_target_from_gl(_arg1)
	runtime.KeepAlive(target)

	var _glTextureTarget GLTextureTarget // out

	_glTextureTarget = GLTextureTarget(_cret)

	return _glTextureTarget
}

// The function takes the following parameters:
//
//   - str: string equivalent to one of the GST_GL_TEXTURE_TARGET_*_STR values.
//
// The function returns the following values:
//
//   - glTextureTarget represented by str or GST_GL_TEXTURE_TARGET_NONE.
func GLTextureTargetFromString(str string) GLTextureTarget {
	var _arg1 *C.gchar             // out
	var _cret C.GstGLTextureTarget // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_gl_texture_target_from_string(_arg1)
	runtime.KeepAlive(str)

	var _glTextureTarget GLTextureTarget // out

	_glTextureTarget = GLTextureTarget(_cret)

	return _glTextureTarget
}

// The function takes the following parameters:
//
//   - target: GLTextureTarget.
//
// The function returns the following values:
//
//   - utf8 (optional): string representing the GstBufferPoolOption specified by
//     target.
func GLTextureTargetToBufferPoolOption(target GLTextureTarget) string {
	var _arg1 C.GstGLTextureTarget // out
	var _cret *C.gchar             // in

	_arg1 = C.GstGLTextureTarget(target)

	_cret = C.gst_gl_texture_target_to_buffer_pool_option(_arg1)
	runtime.KeepAlive(target)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// The function takes the following parameters:
//
//   - target: GLTextureTarget.
//
// The function returns the following values:
//
//   - guint: openGL value for binding the target with glBindTexture() and
//     similar functions or 0.
func GLTextureTargetToGL(target GLTextureTarget) uint {
	var _arg1 C.GstGLTextureTarget // out
	var _cret C.guint              // in

	_arg1 = C.GstGLTextureTarget(target)

	_cret = C.gst_gl_texture_target_to_gl(_arg1)
	runtime.KeepAlive(target)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function takes the following parameters:
//
//   - target: GLTextureTarget.
//
// The function returns the following values:
//
//   - utf8 (optional): stringified version of target or NULL.
func GLTextureTargetToString(target GLTextureTarget) string {
	var _arg1 C.GstGLTextureTarget // out
	var _cret *C.gchar             // in

	_arg1 = C.GstGLTextureTarget(target)

	_cret = C.gst_gl_texture_target_to_string(_arg1)
	runtime.KeepAlive(target)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

type GLUploadReturn C.gint

const (
	// GLUploadDone: no further processing required.
	GLUploadDone GLUploadReturn = 1
	// GLUploadError: unspecified error occurred.
	GLUploadError GLUploadReturn = -1
	// GLUploadUnsupported: configuration is unsupported.
	GLUploadUnsupported GLUploadReturn = -2
	// GLUploadReconfigure: this element requires a reconfiguration.
	GLUploadReconfigure GLUploadReturn = -3
	// GLUploadUnsharedGLContext: private return value.
	GLUploadUnsharedGLContext GLUploadReturn = -100
)

func marshalGLUploadReturn(p uintptr) (interface{}, error) {
	return GLUploadReturn(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for GLUploadReturn.
func (g GLUploadReturn) String() string {
	switch g {
	case GLUploadDone:
		return "Done"
	case GLUploadError:
		return "Error"
	case GLUploadUnsupported:
		return "Unsupported"
	case GLUploadReconfigure:
		return "Reconfigure"
	case GLUploadUnsharedGLContext:
		return "UnsharedGLContext"
	default:
		return fmt.Sprintf("GLUploadReturn(%d)", g)
	}
}

type GLWindowError C.gint

const (
	// GLWindowErrorFailed: failed for a unspecified reason.
	GLWindowErrorFailed GLWindowError = iota
	// GLWindowErrorOldLibs: implementation is too old.
	GLWindowErrorOldLibs
	// GLWindowErrorResourceUnavailable: no such resource was found.
	GLWindowErrorResourceUnavailable
)

func marshalGLWindowError(p uintptr) (interface{}, error) {
	return GLWindowError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for GLWindowError.
func (g GLWindowError) String() string {
	switch g {
	case GLWindowErrorFailed:
		return "Failed"
	case GLWindowErrorOldLibs:
		return "OldLibs"
	case GLWindowErrorResourceUnavailable:
		return "ResourceUnavailable"
	default:
		return fmt.Sprintf("GLWindowError(%d)", g)
	}
}

// The function returns the following values:
//
//   - quark used for GLWindow in #GError's.
func GLWindowErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gst_gl_window_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

type GLAPI C.guint

const (
	// GLApiNone: no API.
	GLApiNone GLAPI = 0b0
	// GLApiOpengl: desktop OpenGL up to and including 3.1. The compatibility
	// profile when the OpenGL version is >= 3.2.
	GLApiOpengl GLAPI = 0b1
	// GLApiOpengl3: desktop OpenGL >= 3.2 core profile.
	GLApiOpengl3 GLAPI = 0b10
	// GLApiGles1: openGL ES 1.x.
	GLApiGles1 GLAPI = 0b1000000000000000
	// GLApiGles2: openGL ES 2.x and 3.x.
	GLApiGles2 GLAPI = 0b10000000000000000
	// GLApiAny: any OpenGL API.
	GLApiAny GLAPI = 0b11111111111111111111111111111111
)

func marshalGLAPI(p uintptr) (interface{}, error) {
	return GLAPI(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for GLAPI.
func (g GLAPI) String() string {
	if g == 0 {
		return "GLAPI(0)"
	}

	var builder strings.Builder
	builder.Grow(65)

	for g != 0 {
		next := g & (g - 1)
		bit := g - next

		switch bit {
		case GLApiNone:
			builder.WriteString("None|")
		case GLApiOpengl:
			builder.WriteString("Opengl|")
		case GLApiOpengl3:
			builder.WriteString("Opengl3|")
		case GLApiGles1:
			builder.WriteString("Gles1|")
		case GLApiGles2:
			builder.WriteString("Gles2|")
		case GLApiAny:
			builder.WriteString("Any|")
		default:
			builder.WriteString(fmt.Sprintf("GLAPI(0b%b)|", bit))
		}

		g = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if g contains other.
func (g GLAPI) Has(other GLAPI) bool {
	return (g & other) == other
}

// The function takes the following parameters:
//
//   - apiS: space separated string of OpenGL apis.
//
// The function returns the following values:
//
//   - glapI represented by api_s.
func GLAPIFromString(apiS string) GLAPI {
	var _arg1 *C.gchar   // out
	var _cret C.GstGLAPI // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(apiS)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_gl_api_from_string(_arg1)
	runtime.KeepAlive(apiS)

	var _glapI GLAPI // out

	_glapI = GLAPI(_cret)

	return _glapI
}

// The function takes the following parameters:
//
//   - api to stringify.
//
// The function returns the following values:
//
//   - utf8: space separated string of the OpenGL api's enabled in api.
func GLAPIToString(api GLAPI) string {
	var _arg1 C.GstGLAPI // out
	var _cret *C.gchar   // in

	_arg1 = C.GstGLAPI(api)

	_cret = C.gst_gl_api_to_string(_arg1)
	runtime.KeepAlive(api)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

type GLBaseMemoryTransfer C.guint

const (
	// GLBaseMemoryTransferNeedDownload: texture needs downloading to the data
	// pointer.
	GLBaseMemoryTransferNeedDownload GLBaseMemoryTransfer = 0b100000000000000000000
	// GLBaseMemoryTransferNeedUpload: data pointer needs uploading to the
	// texture.
	GLBaseMemoryTransferNeedUpload GLBaseMemoryTransfer = 0b1000000000000000000000
)

func marshalGLBaseMemoryTransfer(p uintptr) (interface{}, error) {
	return GLBaseMemoryTransfer(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for GLBaseMemoryTransfer.
func (g GLBaseMemoryTransfer) String() string {
	if g == 0 {
		return "GLBaseMemoryTransfer(0)"
	}

	var builder strings.Builder
	builder.Grow(63)

	for g != 0 {
		next := g & (g - 1)
		bit := g - next

		switch bit {
		case GLBaseMemoryTransferNeedDownload:
			builder.WriteString("Download|")
		case GLBaseMemoryTransferNeedUpload:
			builder.WriteString("Upload|")
		default:
			builder.WriteString(fmt.Sprintf("GLBaseMemoryTransfer(0b%b)|", bit))
		}

		g = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if g contains other.
func (g GLBaseMemoryTransfer) Has(other GLBaseMemoryTransfer) bool {
	return (g & other) == other
}

type GLConfigSurfaceType C.guint

const (
	// GLConfigSurfaceTypeNone: none.
	GLConfigSurfaceTypeNone GLConfigSurfaceType = 0b0
	// GLConfigSurfaceTypeWindow: window.
	GLConfigSurfaceTypeWindow GLConfigSurfaceType = 0b1
	// GLConfigSurfaceTypePbuffer: pbuffer.
	GLConfigSurfaceTypePbuffer GLConfigSurfaceType = 0b10
	// GLConfigSurfaceTypePixmap: pixmap.
	GLConfigSurfaceTypePixmap GLConfigSurfaceType = 0b100
)

func marshalGLConfigSurfaceType(p uintptr) (interface{}, error) {
	return GLConfigSurfaceType(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for GLConfigSurfaceType.
func (g GLConfigSurfaceType) String() string {
	if g == 0 {
		return "GLConfigSurfaceType(0)"
	}

	var builder strings.Builder
	builder.Grow(102)

	for g != 0 {
		next := g & (g - 1)
		bit := g - next

		switch bit {
		case GLConfigSurfaceTypeNone:
			builder.WriteString("None|")
		case GLConfigSurfaceTypeWindow:
			builder.WriteString("Window|")
		case GLConfigSurfaceTypePbuffer:
			builder.WriteString("Pbuffer|")
		case GLConfigSurfaceTypePixmap:
			builder.WriteString("Pixmap|")
		default:
			builder.WriteString(fmt.Sprintf("GLConfigSurfaceType(0b%b)|", bit))
		}

		g = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if g contains other.
func (g GLConfigSurfaceType) Has(other GLConfigSurfaceType) bool {
	return (g & other) == other
}

// The function takes the following parameters:
//
//   - surfaceType: GLConfigSurfaceType.
//
// The function returns the following values:
//
//   - utf8 (optional): string version of caveat or NULL if surface_type does
//     not exist.
func GLConfigSurfaceTypeToString(surfaceType GLConfigSurfaceType) string {
	var _arg1 C.GstGLConfigSurfaceType // out
	var _cret *C.gchar                 // in

	_arg1 = C.GstGLConfigSurfaceType(surfaceType)

	_cret = C.gst_gl_config_surface_type_to_string(_arg1)
	runtime.KeepAlive(surfaceType)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

type GLDisplayType C.guint

const (
	// GLDisplayTypeNone: no display type.
	GLDisplayTypeNone GLDisplayType = 0b0
	// GLDisplayTypeX11: x11 display.
	GLDisplayTypeX11 GLDisplayType = 0b1
	// GLDisplayTypeWayland: wayland display.
	GLDisplayTypeWayland GLDisplayType = 0b10
	// GLDisplayTypeCocoa: cocoa display.
	GLDisplayTypeCocoa GLDisplayType = 0b100
	// GLDisplayTypeWin32: win32 display.
	GLDisplayTypeWin32 GLDisplayType = 0b1000
	// GLDisplayTypeDispmanx: dispmanx display.
	GLDisplayTypeDispmanx GLDisplayType = 0b10000
	// GLDisplayTypeEgl: EGL display.
	GLDisplayTypeEgl GLDisplayType = 0b100000
	// GLDisplayTypeVivFb: vivante Framebuffer display.
	GLDisplayTypeVivFb GLDisplayType = 0b1000000
	// GLDisplayTypeGbm: mesa3D GBM display.
	GLDisplayTypeGbm GLDisplayType = 0b10000000
	// GLDisplayTypeEglDevice: EGLDevice display.
	GLDisplayTypeEglDevice GLDisplayType = 0b100000000
	// GLDisplayTypeEagl: EAGL display.
	GLDisplayTypeEagl GLDisplayType = 0b1000000000
	// GLDisplayTypeWinrt: winRT display.
	GLDisplayTypeWinrt GLDisplayType = 0b10000000000
	// GLDisplayTypeAndroid: android display.
	GLDisplayTypeAndroid GLDisplayType = 0b100000000000
	// GLDisplayTypeEglSurfaceless: mesa3D surfaceless display using the
	// EGL_PLATFORM_SURFACELESS_MESA extension.
	GLDisplayTypeEglSurfaceless GLDisplayType = 0b1000000000000
	// GLDisplayTypeAny: any display type.
	GLDisplayTypeAny GLDisplayType = 0b11111111111111111111111111111111
)

func marshalGLDisplayType(p uintptr) (interface{}, error) {
	return GLDisplayType(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for GLDisplayType.
func (g GLDisplayType) String() string {
	if g == 0 {
		return "GLDisplayType(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for g != 0 {
		next := g & (g - 1)
		bit := g - next

		switch bit {
		case GLDisplayTypeNone:
			builder.WriteString("None|")
		case GLDisplayTypeX11:
			builder.WriteString("X11|")
		case GLDisplayTypeWayland:
			builder.WriteString("Wayland|")
		case GLDisplayTypeCocoa:
			builder.WriteString("Cocoa|")
		case GLDisplayTypeWin32:
			builder.WriteString("Win32|")
		case GLDisplayTypeDispmanx:
			builder.WriteString("Dispmanx|")
		case GLDisplayTypeEgl:
			builder.WriteString("Egl|")
		case GLDisplayTypeVivFb:
			builder.WriteString("VivFb|")
		case GLDisplayTypeGbm:
			builder.WriteString("Gbm|")
		case GLDisplayTypeEglDevice:
			builder.WriteString("EglDevice|")
		case GLDisplayTypeEagl:
			builder.WriteString("Eagl|")
		case GLDisplayTypeWinrt:
			builder.WriteString("Winrt|")
		case GLDisplayTypeAndroid:
			builder.WriteString("Android|")
		case GLDisplayTypeEglSurfaceless:
			builder.WriteString("EglSurfaceless|")
		case GLDisplayTypeAny:
			builder.WriteString("Any|")
		default:
			builder.WriteString(fmt.Sprintf("GLDisplayType(0b%b)|", bit))
		}

		g = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if g contains other.
func (g GLDisplayType) Has(other GLDisplayType) bool {
	return (g & other) == other
}

type GLPlatform C.guint

const (
	// GLPlatformNone: no platform.
	GLPlatformNone GLPlatform = 0b0
	// GLPlatformEgl: EGL platform used primarily with the X11, wayland and
	// android window systems as well as on embedded Linux.
	GLPlatformEgl GLPlatform = 0b1
	// GLPlatformGLX: GLX platform used primarily with the X11 window system.
	GLPlatformGLX GLPlatform = 0b10
	// GLPlatformWgl: WGL platform used primarily on Windows.
	GLPlatformWgl GLPlatform = 0b100
	// GLPlatformCgl: CGL platform used primarily on OS X.
	GLPlatformCgl GLPlatform = 0b1000
	// GLPlatformEagl: EAGL platform used primarily on iOS.
	GLPlatformEagl GLPlatform = 0b10000
	// GLPlatformAny: any OpenGL platform.
	GLPlatformAny GLPlatform = 0b11111111111111111111111111111111
)

func marshalGLPlatform(p uintptr) (interface{}, error) {
	return GLPlatform(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for GLPlatform.
func (g GLPlatform) String() string {
	if g == 0 {
		return "GLPlatform(0)"
	}

	var builder strings.Builder
	builder.Grow(99)

	for g != 0 {
		next := g & (g - 1)
		bit := g - next

		switch bit {
		case GLPlatformNone:
			builder.WriteString("None|")
		case GLPlatformEgl:
			builder.WriteString("Egl|")
		case GLPlatformGLX:
			builder.WriteString("GLX|")
		case GLPlatformWgl:
			builder.WriteString("Wgl|")
		case GLPlatformCgl:
			builder.WriteString("Cgl|")
		case GLPlatformEagl:
			builder.WriteString("Eagl|")
		case GLPlatformAny:
			builder.WriteString("Any|")
		default:
			builder.WriteString(fmt.Sprintf("GLPlatform(0b%b)|", bit))
		}

		g = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if g contains other.
func (g GLPlatform) Has(other GLPlatform) bool {
	return (g & other) == other
}

// The function takes the following parameters:
//
//   - platformS: space separated string of OpenGL platformss.
//
// The function returns the following values:
//
//   - glPlatform represented by platform_s.
func GLPlatformFromString(platformS string) GLPlatform {
	var _arg1 *C.gchar        // out
	var _cret C.GstGLPlatform // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(platformS)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_gl_platform_from_string(_arg1)
	runtime.KeepAlive(platformS)

	var _glPlatform GLPlatform // out

	_glPlatform = GLPlatform(_cret)

	return _glPlatform
}

// The function takes the following parameters:
//
//   - platform to stringify.
//
// The function returns the following values:
//
//   - utf8: space separated string of the OpenGL platforms enabled in platform.
func GLPlatformToString(platform GLPlatform) string {
	var _arg1 C.GstGLPlatform // out
	var _cret *C.gchar        // in

	_arg1 = C.GstGLPlatform(platform)

	_cret = C.gst_gl_platform_to_string(_arg1)
	runtime.KeepAlive(platform)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// GLSLProfile: GLSL profiles.
type GLSLProfile C.guint

const (
	// GlslProfileNone: no profile supported/available.
	GlslProfileNone GLSLProfile = 0b0
	// GlslProfileES: openGL|ES profile.
	GlslProfileES GLSLProfile = 0b1
	// GlslProfileCore: openGL core profile.
	GlslProfileCore GLSLProfile = 0b10
	// GlslProfileCompatibility: openGL compatibility profile.
	GlslProfileCompatibility GLSLProfile = 0b100
	// GlslProfileAny: any OpenGL/OpenGL|ES profile.
	GlslProfileAny GLSLProfile = 0b11111111111111111111111111111111
)

func marshalGLSLProfile(p uintptr) (interface{}, error) {
	return GLSLProfile(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for GLSLProfile.
func (g GLSLProfile) String() string {
	if g == 0 {
		return "GLSLProfile(0)"
	}

	var builder strings.Builder
	builder.Grow(85)

	for g != 0 {
		next := g & (g - 1)
		bit := g - next

		switch bit {
		case GlslProfileNone:
			builder.WriteString("None|")
		case GlslProfileES:
			builder.WriteString("ES|")
		case GlslProfileCore:
			builder.WriteString("Core|")
		case GlslProfileCompatibility:
			builder.WriteString("Compatibility|")
		case GlslProfileAny:
			builder.WriteString("Any|")
		default:
			builder.WriteString(fmt.Sprintf("GLSLProfile(0b%b)|", bit))
		}

		g = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if g contains other.
func (g GLSLProfile) Has(other GLSLProfile) bool {
	return (g & other) == other
}

// The function takes the following parameters:
//
//   - str: GLSL version string.
//
// The function returns the following values:
//
//   - glslProfile of string or GST_GLSL_PROFILE_NONE on error.
func GLSLProfileFromString(str string) GLSLProfile {
	var _arg1 *C.gchar         // out
	var _cret C.GstGLSLProfile // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_glsl_profile_from_string(_arg1)
	runtime.KeepAlive(str)

	var _glslProfile GLSLProfile // out

	_glslProfile = GLSLProfile(_cret)

	return _glslProfile
}

// The function takes the following parameters:
//
//   - profile: GLSLProfile.
//
// The function returns the following values:
//
//   - utf8 (optional): name for profile or NULL on error.
func GLSLProfileToString(profile GLSLProfile) string {
	var _arg1 C.GstGLSLProfile // out
	var _cret *C.gchar         // in

	_arg1 = C.GstGLSLProfile(profile)

	_cret = C.gst_glsl_profile_to_string(_arg1)
	runtime.KeepAlive(profile)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

type GLAsyncDebugLogGetMessage func() (utf8 string)

type GLFilterRenderFunc func(filter *GLFilter, inTex *GLMemory) (ok bool)

// The function takes the following parameters:
//
//   - context: GLContext.
//   - buffer: Buffer.
//
// The function returns the following values:
//
//   - glSyncMeta added to Buffer.
func BufferAddGLSyncMeta(context GLContexter, buffer *gst.Buffer) *GLSyncMeta {
	var _arg1 *C.GstGLContext  // out
	var _arg2 *C.GstBuffer     // out
	var _cret *C.GstGLSyncMeta // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_buffer_add_gl_sync_meta(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(buffer)

	var _glSyncMeta *GLSyncMeta // out

	_glSyncMeta = (*GLSyncMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _glSyncMeta
}

// The function takes the following parameters:
//
//   - context: GLContext.
//   - buffer: Buffer.
//   - data (optional): sync data to hold.
//
// The function returns the following values:
//
//   - glSyncMeta added to Buffer.
func BufferAddGLSyncMetaFull(context GLContexter, buffer *gst.Buffer, data unsafe.Pointer) *GLSyncMeta {
	var _arg1 *C.GstGLContext  // out
	var _arg2 *C.GstBuffer     // out
	var _arg3 C.gpointer       // out
	var _cret *C.GstGLSyncMeta // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg3 = (C.gpointer)(unsafe.Pointer(data))

	_cret = C.gst_buffer_add_gl_sync_meta_full(_arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(data)

	var _glSyncMeta *GLSyncMeta // out

	_glSyncMeta = (*GLSyncMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _glSyncMeta
}

// The function takes the following parameters:
//
//   - config: buffer pool config.
//
// The function returns the following values:
//
//   - glAllocationParams (optional): currently set GLAllocationParams or NULL.
func BufferPoolConfigGetGLAllocationParams(config *gst.Structure) *GLAllocationParams {
	var _arg1 *C.GstStructure          // out
	var _cret *C.GstGLAllocationParams // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))

	_cret = C.gst_buffer_pool_config_get_gl_allocation_params(_arg1)
	runtime.KeepAlive(config)

	var _glAllocationParams *GLAllocationParams // out

	if _cret != nil {
		_glAllocationParams = (*GLAllocationParams)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_glAllocationParams)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_gl_allocation_params_free((*C.GstGLAllocationParams)(intern.C))
			},
		)
	}

	return _glAllocationParams
}

// BufferPoolConfigGetGLMinFreeQueueSize: see
// gst_buffer_pool_config_set_gl_min_free_queue_size().
//
// The function takes the following parameters:
//
//   - config: buffer pool config.
//
// The function returns the following values:
//
//   - guint: then number of buffers configured the free queue.
func BufferPoolConfigGetGLMinFreeQueueSize(config *gst.Structure) uint {
	var _arg1 *C.GstStructure // out
	var _cret C.guint         // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))

	_cret = C.gst_buffer_pool_config_get_gl_min_free_queue_size(_arg1)
	runtime.KeepAlive(config)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// BufferPoolConfigSetGLAllocationParams sets params on config.
//
// The function takes the following parameters:
//
//   - config: buffer pool config.
//   - params (optional): GLAllocationParams.
func BufferPoolConfigSetGLAllocationParams(config *gst.Structure, params *GLAllocationParams) {
	var _arg1 *C.GstStructure          // out
	var _arg2 *C.GstGLAllocationParams // out

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	if params != nil {
		_arg2 = (*C.GstGLAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))
	}

	C.gst_buffer_pool_config_set_gl_allocation_params(_arg1, _arg2)
	runtime.KeepAlive(config)
	runtime.KeepAlive(params)
}

// BufferPoolConfigSetGLMinFreeQueueSize instructs the GLBufferPool to keep
// queue_size amount of buffers around before allowing them for reuse.
//
// This is helpful to allow GPU processing to complete before the CPU operations
// on the same buffer could start. Particularly useful when uploading or
// downloading data to/from the GPU.
//
// A value of 0 disabled this functionality.
//
// This value must be less than the configured maximum amount of buffers for
// this config.
//
// The function takes the following parameters:
//
//   - config: buffer pool config.
//   - queueSize: number of buffers.
func BufferPoolConfigSetGLMinFreeQueueSize(config *gst.Structure, queueSize uint) {
	var _arg1 *C.GstStructure // out
	var _arg2 C.guint         // out

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))
	_arg2 = C.guint(queueSize)

	C.gst_buffer_pool_config_set_gl_min_free_queue_size(_arg1, _arg2)
	runtime.KeepAlive(config)
	runtime.KeepAlive(queueSize)
}

// The function takes the following parameters:
//
//   - context: Context.
//
// The function returns the following values:
//
//   - display (optional): resulting GLDisplay.
//   - ok: whether display was in context.
func ContextGetGLDisplay(context *gst.Context) (*GLDisplay, bool) {
	var _arg1 *C.GstContext   // out
	var _arg2 *C.GstGLDisplay // in
	var _cret C.gboolean      // in

	_arg1 = (*C.GstContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.gst_context_get_gl_display(_arg1, &_arg2)
	runtime.KeepAlive(context)

	var _display *GLDisplay // out
	var _ok bool            // out

	if _arg2 != nil {
		_display = wrapGLDisplay(coreglib.AssumeOwnership(unsafe.Pointer(_arg2)))
	}
	if _cret != 0 {
		_ok = true
	}

	return _display, _ok
}

// ContextSetGLDisplay sets display on context.
//
// The function takes the following parameters:
//
//   - context: Context.
//   - display (optional): resulting GLDisplay.
func ContextSetGLDisplay(context *gst.Context, display *GLDisplay) {
	var _arg1 *C.GstContext   // out
	var _arg2 *C.GstGLDisplay // out

	_arg1 = (*C.GstContext)(gextras.StructNative(unsafe.Pointer(context)))
	if display != nil {
		_arg2 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	}

	C.gst_context_set_gl_display(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(display)
}

// The function takes the following parameters:
//
//   - name: extension to search for.
//   - ext: list of possible extensions.
//
// The function returns the following values:
//
//   - ok: whether name is in the space separated list of ext.
func GLCheckExtension(name, ext string) bool {
	var _arg1 *C.char    // out
	var _arg2 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(ext)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_gl_check_extension(_arg1, _arg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(ext)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - element
//   - display
func GLElementPropagateDisplayContext(element gst.Elementer, display *GLDisplay) {
	var _arg1 *C.GstElement   // out
	var _arg2 *C.GstGLDisplay // out

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg2 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	C.gst_gl_element_propagate_display_context(_arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(display)
}

// GLGetAffineTransformationMetaAsNdc retrieves the stored 4x4 affine
// transformation matrix stored in meta in NDC coordinates. if meta is NULL,
// an identity matrix is returned.
//
// # NDC is a left-handed coordinate system
//
// - x - [-1, 1] - +ve X moves right
//
// - y - [-1, 1] - +ve Y moves up
//
// - z - [-1, 1] - +ve Z moves into.
//
// The function takes the following parameters:
//
//   - meta (optional): VideoAffineTransformationMeta.
//
// The function returns the following values:
//
//   - matrix: result of the 4x4 matrix.
func GLGetAffineTransformationMetaAsNdc(meta *gstvideo.VideoAffineTransformationMeta) [16]float32 {
	var _arg1 *C.GstVideoAffineTransformationMeta // out
	var _arg2 [16]C.gfloat                        // in

	if meta != nil {
		_arg1 = (*C.GstVideoAffineTransformationMeta)(gextras.StructNative(unsafe.Pointer(meta)))
	}

	C.gst_gl_get_affine_transformation_meta_as_ndc(_arg1, &_arg2[0])
	runtime.KeepAlive(meta)

	var _matrix [16]float32 // out

	_matrix = *(*[16]float32)(unsafe.Pointer(&_arg2))

	return _matrix
}

// GLGetPlaneDataSize: retrieve the size in bytes of a video plane of data with
// a certain alignment.
//
// The function takes the following parameters:
//
//   - info: VideoInfo.
//   - align or NULL.
//   - plane number in info to retrieve the data size of.
func GLGetPlaneDataSize(info *gstvideo.VideoInfo, align *gstvideo.VideoAlignment, plane uint) uint {
	var _arg1 *C.GstVideoInfo      // out
	var _arg2 *C.GstVideoAlignment // out
	var _arg3 C.guint              // out
	var _cret C.gsize              // in

	_arg1 = (*C.GstVideoInfo)(gextras.StructNative(unsafe.Pointer(info)))
	_arg2 = (*C.GstVideoAlignment)(gextras.StructNative(unsafe.Pointer(align)))
	_arg3 = C.guint(plane)

	_cret = C.gst_gl_get_plane_data_size(_arg1, _arg2, _arg3)
	runtime.KeepAlive(info)
	runtime.KeepAlive(align)
	runtime.KeepAlive(plane)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// The function takes the following parameters:
//
//   - info: VideoInfo.
//   - valign or NULL.
//   - plane number in info to retrieve the data size of.
//
// The function returns the following values:
//
//   - gsize: difference between the supposed start of the plane from the info
//     and where the data from the previous plane ends.
func GLGetPlaneStart(info *gstvideo.VideoInfo, valign *gstvideo.VideoAlignment, plane uint) uint {
	var _arg1 *C.GstVideoInfo      // out
	var _arg2 *C.GstVideoAlignment // out
	var _arg3 C.guint              // out
	var _cret C.gsize              // in

	_arg1 = (*C.GstVideoInfo)(gextras.StructNative(unsafe.Pointer(info)))
	_arg2 = (*C.GstVideoAlignment)(gextras.StructNative(unsafe.Pointer(valign)))
	_arg3 = C.guint(plane)

	_cret = C.gst_gl_get_plane_start(_arg1, _arg2, _arg3)
	runtime.KeepAlive(info)
	runtime.KeepAlive(valign)
	runtime.KeepAlive(plane)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// The function takes the following parameters:
//
//   - element: Element.
//   - query of type GST_QUERY_CONTEXT.
//   - display (optional): GLDisplay.
//   - context (optional): GLContext.
//   - otherContext (optional): application provided GLContext.
//
// The function returns the following values:
//
//   - ok: whether the query was successfully responded to from the passed
//     display, context, and other_context.
func GLHandleContextQuery(element gst.Elementer, query *gst.Query, display *GLDisplay, context, otherContext GLContexter) bool {
	var _arg1 *C.GstElement   // out
	var _arg2 *C.GstQuery     // out
	var _arg3 *C.GstGLDisplay // out
	var _arg4 *C.GstGLContext // out
	var _arg5 *C.GstGLContext // out
	var _cret C.gboolean      // in

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg2 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))
	if display != nil {
		_arg3 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	}
	if context != nil {
		_arg4 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	}
	if otherContext != nil {
		_arg5 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(otherContext).Native()))
	}

	_cret = C.gst_gl_handle_context_query(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(element)
	runtime.KeepAlive(query)
	runtime.KeepAlive(display)
	runtime.KeepAlive(context)
	runtime.KeepAlive(otherContext)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GLHandleSetContext: helper function for implementing
// ElementClass.set_context() in OpenGL capable elements.
//
// Retrieve's the GLDisplay or GLContext in context and places the result in
// display or other_context respectively.
//
// The function takes the following parameters:
//
//   - element: Element.
//   - context: Context.
//
// The function returns the following values:
//
//   - display: location of a GLDisplay.
//   - otherContext: location of a GLContext.
//   - ok: whether the display or other_context could be set successfully.
func GLHandleSetContext(element gst.Elementer, context *gst.Context) (*GLDisplay, GLContexter, bool) {
	var _arg1 *C.GstElement   // out
	var _arg2 *C.GstContext   // out
	var _arg3 *C.GstGLDisplay // in
	var _arg4 *C.GstGLContext // in
	var _cret C.gboolean      // in

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.InternObject(element).Native()))
	_arg2 = (*C.GstContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.gst_gl_handle_set_context(_arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(element)
	runtime.KeepAlive(context)

	var _display *GLDisplay       // out
	var _otherContext GLContexter // out
	var _ok bool                  // out

	_display = wrapGLDisplay(coreglib.AssumeOwnership(unsafe.Pointer(_arg3)))
	{
		objptr := unsafe.Pointer(_arg4)
		if objptr == nil {
			panic("object of type gstgl.GLContexter is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(GLContexter)
			return ok
		})
		rv, ok := casted.(GLContexter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstgl.GLContexter")
		}
		_otherContext = rv
	}
	if _cret != 0 {
		_ok = true
	}

	return _display, _otherContext, _ok
}

// GLMultiplyMatrix4 multiplies two 4x4 matrices, a and b, and stores the
// result, a 2-dimensional array of #gfloat, in result.
//
// The function takes the following parameters:
//
//   - a: 2-dimensional 4x4 array of #gfloat.
//   - b: another 2-dimensional 4x4 array of #gfloat.
//
// The function returns the following values:
//
//   - result of the multiplication.
func GLMultiplyMatrix4(a, b [16]float32) [16]float32 {
	var _arg1 *C.gfloat    // out
	var _arg2 *C.gfloat    // out
	var _arg3 [16]C.gfloat // in

	_arg1 = (*C.gfloat)(unsafe.Pointer(&a))
	_arg2 = (*C.gfloat)(unsafe.Pointer(&b))

	C.gst_gl_multiply_matrix4(_arg1, _arg2, &_arg3[0])
	runtime.KeepAlive(a)
	runtime.KeepAlive(b)

	var _result [16]float32 // out

	_result = *(*[16]float32)(unsafe.Pointer(&_arg3))

	return _result
}

// GLSetAffineTransformationMetaFromNdc: set the 4x4 affine transformation
// matrix stored in meta from the NDC coordinates in matrix.
//
// The function takes the following parameters:
//
//   - meta: VideoAffineTransformationMeta.
//   - matrix: 4x4 matrix.
func GLSetAffineTransformationMetaFromNdc(meta *gstvideo.VideoAffineTransformationMeta, matrix [16]float32) {
	var _arg1 *C.GstVideoAffineTransformationMeta // out
	var _arg2 *C.gfloat                           // out

	_arg1 = (*C.GstVideoAffineTransformationMeta)(gextras.StructNative(unsafe.Pointer(meta)))
	_arg2 = (*C.gfloat)(unsafe.Pointer(&matrix))

	C.gst_gl_set_affine_transformation_meta_from_ndc(_arg1, _arg2)
	runtime.KeepAlive(meta)
	runtime.KeepAlive(matrix)
}

// The function takes the following parameters:
//
//   - context: GLContext.
//   - format: openGL format, GL_RGBA, GL_LUMINANCE, etc.
//   - typ: openGL type, GL_UNSIGNED_BYTE, GL_FLOAT, etc.
//
// The function returns the following values:
//
//   - guint: sized internal format specified by format and type that can be
//     used in context.
func GLSizedGLFormatFromGLFormatType(context GLContexter, format, typ uint) uint {
	var _arg1 *C.GstGLContext // out
	var _arg2 C.guint         // out
	var _arg3 C.guint         // out
	var _cret C.guint         // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.guint(format)
	_arg3 = C.guint(typ)

	_cret = C.gst_gl_sized_gl_format_from_gl_format_type(_arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(format)
	runtime.KeepAlive(typ)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func GLStereoDownmixModeGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.gst_gl_stereo_downmix_mode_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// GLSwizzleInvert: given swizzle, produce inversion such that:
//
// swizzle[inversion[i]] == identity[i] where:
//
// - identity = {0, 1, 2,...}
//
// - unset fields are marked by -1.
//
// The function takes the following parameters:
//
//   - swizzle: input swizzle.
//
// The function returns the following values:
//
//   - inversion: resulting inversion.
func GLSwizzleInvert(swizzle [4]int) [4]int {
	var _arg1 *C.gint   // out
	var _arg2 [4]C.gint // in

	{
		var out [4]C.gint
		_arg1 = &out[0]
		for i := 0; i < 4; i++ {
			out[i] = C.gint(swizzle[i])
		}
	}

	C.gst_gl_swizzle_invert(_arg1, &_arg2[0])
	runtime.KeepAlive(swizzle)

	var _inversion [4]int // out

	{
		src := &_arg2
		for i := 0; i < 4; i++ {
			_inversion[i] = int(src[i])
		}
	}

	return _inversion
}

func GLSyncMetaApiGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.gst_gl_sync_meta_api_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// GLValueGetTextureTargetMask: see gst_gl_value_set_texture_target_from_mask()
// for what entails a mask.
//
// The function takes the following parameters:
//
//   - value: initialized #GValue of type G_TYPE_STRING.
//
// The function returns the following values:
//
//   - glTextureTarget: mask of GLTextureTarget's in value or
//     GST_GL_TEXTURE_TARGET_NONE on failure.
func GLValueGetTextureTargetMask(value *coreglib.Value) GLTextureTarget {
	var _arg1 *C.GValue            // out
	var _cret C.GstGLTextureTarget // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gst_gl_value_get_texture_target_mask(_arg1)
	runtime.KeepAlive(value)

	var _glTextureTarget GLTextureTarget // out

	_glTextureTarget = GLTextureTarget(_cret)

	return _glTextureTarget
}

// The function takes the following parameters:
//
//   - value: initialized #GValue of type G_TYPE_STRING.
//   - target: GLTextureTarget's.
//
// The function returns the following values:
//
//   - ok: whether the target could be set on value.
func GLValueSetTextureTarget(value *coreglib.Value, target GLTextureTarget) bool {
	var _arg1 *C.GValue            // out
	var _arg2 C.GstGLTextureTarget // out
	var _cret C.gboolean           // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.GstGLTextureTarget(target)

	_cret = C.gst_gl_value_set_texture_target(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(target)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GLValueSetTextureTargetFromMask: mask is a bitwise OR of (1 << target) where
// target is a valid GLTextureTarget.
//
// The function takes the following parameters:
//
//   - value: uninitialized #GValue.
//   - targetMask: bitwise mask of GLTextureTarget's.
//
// The function returns the following values:
//
//   - ok: whether the target_mask could be set on value.
func GLValueSetTextureTargetFromMask(value *coreglib.Value, targetMask GLTextureTarget) bool {
	var _arg1 *C.GValue            // out
	var _arg2 C.GstGLTextureTarget // out
	var _cret C.gboolean           // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = C.GstGLTextureTarget(targetMask)

	_cret = C.gst_gl_value_set_texture_target_from_mask(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(targetMask)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - glApi: GLAPI.
//   - maj: major GL version.
//   - min: minor GL version.
//
// The function returns the following values:
//
//   - glslVersion: minimum supported GLSLVersion available for gl_api, maj and
//     min.
func GLVersionToGlslVersion(glApi GLAPI, maj, min int) GLSLVersion {
	var _arg1 C.GstGLAPI       // out
	var _arg2 C.gint           // out
	var _arg3 C.gint           // out
	var _cret C.GstGLSLVersion // in

	_arg1 = C.GstGLAPI(glApi)
	_arg2 = C.gint(maj)
	_arg3 = C.gint(min)

	_cret = C.gst_gl_version_to_glsl_version(_arg1, _arg2, _arg3)
	runtime.KeepAlive(glApi)
	runtime.KeepAlive(maj)
	runtime.KeepAlive(min)

	var _glslVersion GLSLVersion // out

	_glslVersion = GLSLVersion(_cret)

	return _glslVersion
}

// GLVideoFormatSwizzle calculates the swizzle indices for video_format and
// gl_format in order to access a texture such that accessing a texel from a
// texture through the swizzle index produces values in the order (R, G, B,
// A) or (Y, U, V, A).
//
// For multi-planer formats, the swizzle index uses the same component order
// (RGBA/YUVA) and should be applied after combining multiple planes into a
// single rgba/yuva value. e.g. sampling from a NV12 format would have Y from
// one texture and UV from another texture into a (Y, U, V) value. Add an Aplha
// component and then perform swizzling. Sampling from NV21 would produce (Y, V,
// U) which is then swizzled to (Y, U, V).
//
// The function takes the following parameters:
//
//   - videoFormat in use.
//
// The function returns the following values:
//
//   - swizzle: returned swizzle indices.
//   - ok: whether valid swizzle indices could be found.
func GLVideoFormatSwizzle(videoFormat gstvideo.VideoFormat) ([4]int, bool) {
	var _arg1 C.GstVideoFormat // out
	var _arg2 [4]C.int         // in
	var _cret C.gboolean       // in

	_arg1 = C.GstVideoFormat(videoFormat)

	_cret = C.gst_gl_video_format_swizzle(_arg1, &_arg2[0])
	runtime.KeepAlive(videoFormat)

	var _swizzle [4]int // out
	var _ok bool        // out

	{
		src := &_arg2
		for i := 0; i < 4; i++ {
			_swizzle[i] = int(src[i])
		}
	}
	if _cret != 0 {
		_ok = true
	}

	return _swizzle, _ok
}

// GlslStringGetVersionProfile: note: this function first searches the
// first 1 kilobytes for a #version preprocessor directive and then executes
// gst_glsl_version_profile_from_string().
//
// The function takes the following parameters:
//
//   - s: string to search for a valid #version string.
//
// The function returns the following values:
//
//   - version: resulting GLSLVersion.
//   - profile: resulting GLSLProfile.
//   - ok: TRUE if a valid #version string was found, FALSE otherwise.
func GlslStringGetVersionProfile(s string) (GLSLVersion, GLSLProfile, bool) {
	var _arg1 *C.gchar         // out
	var _arg2 C.GstGLSLVersion // in
	var _arg3 C.GstGLSLProfile // in
	var _cret C.gboolean       // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(s)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_glsl_string_get_version_profile(_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(s)

	var _version GLSLVersion // out
	var _profile GLSLProfile // out
	var _ok bool             // out

	_version = GLSLVersion(_arg2)
	_profile = GLSLProfile(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _version, _profile, _ok
}

// The function takes the following parameters:
//
//   - mem: Memory.
//
// The function returns the following values:
//
//   - ok: whether the memory at mem is a GLBaseMemory.
func IsGLBaseMemory(mem *gst.Memory) bool {
	var _arg1 *C.GstMemory // out
	var _cret C.gboolean   // in

	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))

	_cret = C.gst_is_gl_base_memory(_arg1)
	runtime.KeepAlive(mem)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - mem: Memory.
//
// The function returns the following values:
//
//   - ok: whether the memory at mem is a GLBuffer.
func IsGLBuffer(mem *gst.Memory) bool {
	var _arg1 *C.GstMemory // out
	var _cret C.gboolean   // in

	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))

	_cret = C.gst_is_gl_buffer(_arg1)
	runtime.KeepAlive(mem)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - mem: Memory.
//
// The function returns the following values:
//
//   - ok: whether the memory at mem is a GLMemory.
func IsGLMemory(mem *gst.Memory) bool {
	var _arg1 *C.GstMemory // out
	var _cret C.gboolean   // in

	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))

	_cret = C.gst_is_gl_memory(_arg1)
	runtime.KeepAlive(mem)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - mem: Memory.
//
// The function returns the following values:
//
//   - ok: whether the memory at mem is a GLMemoryPBO.
func IsGLMemoryPbo(mem *gst.Memory) bool {
	var _arg1 *C.GstMemory // out
	var _cret C.gboolean   // in

	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))

	_cret = C.gst_is_gl_memory_pbo(_arg1)
	runtime.KeepAlive(mem)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - mem: Memory.
//
// The function returns the following values:
//
//   - ok: whether the memory at mem is a GLRenderbuffer.
func IsGLRenderbuffer(mem *gst.Memory) bool {
	var _arg1 *C.GstMemory // out
	var _cret C.gboolean   // in

	_arg1 = (*C.GstMemory)(gextras.StructNative(unsafe.Pointer(mem)))

	_cret = C.gst_is_gl_renderbuffer(_arg1)
	runtime.KeepAlive(mem)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GLBaseFilterOverrides contains methods that are overridable.
type GLBaseFilterOverrides struct {
	// GLSetCaps: called in the GL thread when caps are set on filter.
	// Note: this will also be called when changing OpenGL contexts where
	// BaseTransform::set_caps may not.
	//
	// The function takes the following parameters:
	//
	//   - incaps
	//   - outcaps
	GLSetCaps func(incaps, outcaps *gst.Caps) bool
	// GLStart: called in the GL thread to setup the element GL state.
	GLStart func() bool
	// GLStop: called in the GL thread to setup the element GL state.
	GLStop func()
}

func defaultGLBaseFilterOverrides(v *GLBaseFilter) GLBaseFilterOverrides {
	return GLBaseFilterOverrides{
		GLSetCaps: v.glSetCaps,
		GLStart:   v.glStart,
		GLStop:    v.glStop,
	}
}

// GLBaseFilter handles the nitty gritty details of retrieving an OpenGL
// context. It also provided some wrappers around BaseTransform's start(),
// stop() and set_caps() virtual methods that ensure an OpenGL context is
// available and current in the calling thread.
type GLBaseFilter struct {
	_ [0]func() // equal guard
	gstbase.BaseTransform
}

var (
	_ gstbase.BaseTransformer = (*GLBaseFilter)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLBaseFilter, *GLBaseFilterClass, GLBaseFilterOverrides](
		GTypeGLBaseFilter,
		initGLBaseFilterClass,
		wrapGLBaseFilter,
		defaultGLBaseFilterOverrides,
	)
}

func initGLBaseFilterClass(gclass unsafe.Pointer, overrides GLBaseFilterOverrides, classInitFunc func(*GLBaseFilterClass)) {
	pclass := (*C.GstGLBaseFilterClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeGLBaseFilter))))

	if overrides.GLSetCaps != nil {
		pclass.gl_set_caps = (*[0]byte)(C._gotk4_gstgl1_GLBaseFilterClass_gl_set_caps)
	}

	if overrides.GLStart != nil {
		pclass.gl_start = (*[0]byte)(C._gotk4_gstgl1_GLBaseFilterClass_gl_start)
	}

	if overrides.GLStop != nil {
		pclass.gl_stop = (*[0]byte)(C._gotk4_gstgl1_GLBaseFilterClass_gl_stop)
	}

	if classInitFunc != nil {
		class := (*GLBaseFilterClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLBaseFilter(obj *coreglib.Object) *GLBaseFilter {
	return &GLBaseFilter{
		BaseTransform: gstbase.BaseTransform{
			Element: gst.Element{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalGLBaseFilter(p uintptr) (interface{}, error) {
	return wrapGLBaseFilter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function returns the following values:
//
//   - ok: whether an OpenGL context could be retrieved or created successfully.
func (filter *GLBaseFilter) FindGLContext() bool {
	var _arg0 *C.GstGLBaseFilter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstGLBaseFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	_cret = C.gst_gl_base_filter_find_gl_context(_arg0)
	runtime.KeepAlive(filter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - glContext (optional) found by filter.
func (filter *GLBaseFilter) GLContext() GLContexter {
	var _arg0 *C.GstGLBaseFilter // out
	var _cret *C.GstGLContext    // in

	_arg0 = (*C.GstGLBaseFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	_cret = C.gst_gl_base_filter_get_gl_context(_arg0)
	runtime.KeepAlive(filter)

	var _glContext GLContexter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(GLContexter)
				return ok
			})
			rv, ok := casted.(GLContexter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstgl.GLContexter")
			}
			_glContext = rv
		}
	}

	return _glContext
}

// glSetCaps: called in the GL thread when caps are set on filter.
// Note: this will also be called when changing OpenGL contexts where
// BaseTransform::set_caps may not.
//
// The function takes the following parameters:
//
//   - incaps
//   - outcaps
func (filter *GLBaseFilter) glSetCaps(incaps, outcaps *gst.Caps) bool {
	gclass := (*C.GstGLBaseFilterClass)(coreglib.PeekParentClass(filter))
	fnarg := gclass.gl_set_caps

	var _arg0 *C.GstGLBaseFilter // out
	var _arg1 *C.GstCaps         // out
	var _arg2 *C.GstCaps         // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstGLBaseFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(incaps)))
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(outcaps)))

	_cret = C._gotk4_gstgl1_GLBaseFilter_virtual_gl_set_caps(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(incaps)
	runtime.KeepAlive(outcaps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// glStart: called in the GL thread to setup the element GL state.
func (filter *GLBaseFilter) glStart() bool {
	gclass := (*C.GstGLBaseFilterClass)(coreglib.PeekParentClass(filter))
	fnarg := gclass.gl_start

	var _arg0 *C.GstGLBaseFilter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstGLBaseFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	_cret = C._gotk4_gstgl1_GLBaseFilter_virtual_gl_start(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(filter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// glStop: called in the GL thread to setup the element GL state.
func (filter *GLBaseFilter) glStop() {
	gclass := (*C.GstGLBaseFilterClass)(coreglib.PeekParentClass(filter))
	fnarg := gclass.gl_stop

	var _arg0 *C.GstGLBaseFilter // out

	_arg0 = (*C.GstGLBaseFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	C._gotk4_gstgl1_GLBaseFilter_virtual_gl_stop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(filter)
}

// GLBaseMemoryAllocatorOverrides contains methods that are overridable.
type GLBaseMemoryAllocatorOverrides struct {
	// Alloc: GLBaseMemoryAllocatorAllocFunction.
	//
	// The function takes the following parameters:
	//
	//   - params to allocate the memory with.
	//
	// The function returns the following values:
	//
	//   - glBaseMemory (optional): newly allocated GLBaseMemory from allocator
	//     and params.
	Alloc func(params *GLAllocationParams) *GLBaseMemory
}

func defaultGLBaseMemoryAllocatorOverrides(v *GLBaseMemoryAllocator) GLBaseMemoryAllocatorOverrides {
	return GLBaseMemoryAllocatorOverrides{
		Alloc: v.alloc,
	}
}

// GLBaseMemoryAllocator: opaque GLBaseMemoryAllocator struct.
type GLBaseMemoryAllocator struct {
	_ [0]func() // equal guard
	gst.Allocator
}

var (
	_ gst.Allocatorrer = (*GLBaseMemoryAllocator)(nil)
)

// GLBaseMemoryAllocatorrer describes types inherited from class GLBaseMemoryAllocator.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type GLBaseMemoryAllocatorrer interface {
	coreglib.Objector
	baseGLBaseMemoryAllocator() *GLBaseMemoryAllocator
}

var _ GLBaseMemoryAllocatorrer = (*GLBaseMemoryAllocator)(nil)

func init() {
	coreglib.RegisterClassInfo[*GLBaseMemoryAllocator, *GLBaseMemoryAllocatorClass, GLBaseMemoryAllocatorOverrides](
		GTypeGLBaseMemoryAllocator,
		initGLBaseMemoryAllocatorClass,
		wrapGLBaseMemoryAllocator,
		defaultGLBaseMemoryAllocatorOverrides,
	)
}

func initGLBaseMemoryAllocatorClass(gclass unsafe.Pointer, overrides GLBaseMemoryAllocatorOverrides, classInitFunc func(*GLBaseMemoryAllocatorClass)) {
	pclass := (*C.GstGLBaseMemoryAllocatorClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeGLBaseMemoryAllocator))))

	if overrides.Alloc != nil {
		pclass.alloc = (*[0]byte)(C._gotk4_gstgl1_GLBaseMemoryAllocatorClass_alloc)
	}

	if classInitFunc != nil {
		class := (*GLBaseMemoryAllocatorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLBaseMemoryAllocator(obj *coreglib.Object) *GLBaseMemoryAllocator {
	return &GLBaseMemoryAllocator{
		Allocator: gst.Allocator{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalGLBaseMemoryAllocator(p uintptr) (interface{}, error) {
	return wrapGLBaseMemoryAllocator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *GLBaseMemoryAllocator) baseGLBaseMemoryAllocator() *GLBaseMemoryAllocator {
	return v
}

// BaseGLBaseMemoryAllocator returns the underlying base object.
func BaseGLBaseMemoryAllocator(obj GLBaseMemoryAllocatorrer) *GLBaseMemoryAllocator {
	return obj.baseGLBaseMemoryAllocator()
}

// Alloc: GLBaseMemoryAllocatorAllocFunction.
//
// The function takes the following parameters:
//
//   - params to allocate the memory with.
//
// The function returns the following values:
//
//   - glBaseMemory (optional): newly allocated GLBaseMemory from allocator and
//     params.
func (allocator *GLBaseMemoryAllocator) alloc(params *GLAllocationParams) *GLBaseMemory {
	gclass := (*C.GstGLBaseMemoryAllocatorClass)(coreglib.PeekParentClass(allocator))
	fnarg := gclass.alloc

	var _arg0 *C.GstGLBaseMemoryAllocator // out
	var _arg1 *C.GstGLAllocationParams    // out
	var _cret *C.GstGLBaseMemory          // in

	_arg0 = (*C.GstGLBaseMemoryAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	_arg1 = (*C.GstGLAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))

	_cret = C._gotk4_gstgl1_GLBaseMemoryAllocator_virtual_alloc(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(allocator)
	runtime.KeepAlive(params)

	var _glBaseMemory *GLBaseMemory // out

	if _cret != nil {
		_glBaseMemory = (*GLBaseMemory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_glBaseMemory)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _glBaseMemory
}

// GLBaseMixerOverrides contains methods that are overridable.
type GLBaseMixerOverrides struct {
	// GLStart: called in the GL thread to setup the element GL state.
	//
	// The function returns the following values:
	//
	//   - ok: whether the start was successful.
	GLStart func() bool
	// GLStop: called in the GL thread to setup the element GL state.
	GLStop func()
}

func defaultGLBaseMixerOverrides(v *GLBaseMixer) GLBaseMixerOverrides {
	return GLBaseMixerOverrides{
		GLStart: v.glStart,
		GLStop:  v.glStop,
	}
}

// GLBaseMixer handles the nitty gritty details of retrieving an OpenGL context.
// It provides some virtual methods to know when the OpenGL context is available
// and is not available within this element.
type GLBaseMixer struct {
	_ [0]func() // equal guard
	gstvideo.VideoAggregator
}

var (
	_ gstvideo.VideoAggregatorrer = (*GLBaseMixer)(nil)
)

// GLBaseMixerer describes types inherited from class GLBaseMixer.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type GLBaseMixerer interface {
	coreglib.Objector
	baseGLBaseMixer() *GLBaseMixer
}

var _ GLBaseMixerer = (*GLBaseMixer)(nil)

func init() {
	coreglib.RegisterClassInfo[*GLBaseMixer, *GLBaseMixerClass, GLBaseMixerOverrides](
		GTypeGLBaseMixer,
		initGLBaseMixerClass,
		wrapGLBaseMixer,
		defaultGLBaseMixerOverrides,
	)
}

func initGLBaseMixerClass(gclass unsafe.Pointer, overrides GLBaseMixerOverrides, classInitFunc func(*GLBaseMixerClass)) {
	pclass := (*C.GstGLBaseMixerClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeGLBaseMixer))))

	if overrides.GLStart != nil {
		pclass.gl_start = (*[0]byte)(C._gotk4_gstgl1_GLBaseMixerClass_gl_start)
	}

	if overrides.GLStop != nil {
		pclass.gl_stop = (*[0]byte)(C._gotk4_gstgl1_GLBaseMixerClass_gl_stop)
	}

	if classInitFunc != nil {
		class := (*GLBaseMixerClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLBaseMixer(obj *coreglib.Object) *GLBaseMixer {
	return &GLBaseMixer{
		VideoAggregator: gstvideo.VideoAggregator{
			Aggregator: gstbase.Aggregator{
				Element: gst.Element{
					GstObject: gst.GstObject{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
					},
				},
			},
		},
	}
}

func marshalGLBaseMixer(p uintptr) (interface{}, error) {
	return wrapGLBaseMixer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (mix *GLBaseMixer) baseGLBaseMixer() *GLBaseMixer {
	return mix
}

// BaseGLBaseMixer returns the underlying base object.
func BaseGLBaseMixer(obj GLBaseMixerer) *GLBaseMixer {
	return obj.baseGLBaseMixer()
}

// The function returns the following values:
//
//   - glContext (optional) found by mix.
func (mix *GLBaseMixer) GLContext() GLContexter {
	var _arg0 *C.GstGLBaseMixer // out
	var _cret *C.GstGLContext   // in

	_arg0 = (*C.GstGLBaseMixer)(unsafe.Pointer(coreglib.InternObject(mix).Native()))

	_cret = C.gst_gl_base_mixer_get_gl_context(_arg0)
	runtime.KeepAlive(mix)

	var _glContext GLContexter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(GLContexter)
				return ok
			})
			rv, ok := casted.(GLContexter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstgl.GLContexter")
			}
			_glContext = rv
		}
	}

	return _glContext
}

// glStart: called in the GL thread to setup the element GL state.
//
// The function returns the following values:
//
//   - ok: whether the start was successful.
func (mix *GLBaseMixer) glStart() bool {
	gclass := (*C.GstGLBaseMixerClass)(coreglib.PeekParentClass(mix))
	fnarg := gclass.gl_start

	var _arg0 *C.GstGLBaseMixer // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GstGLBaseMixer)(unsafe.Pointer(coreglib.InternObject(mix).Native()))

	_cret = C._gotk4_gstgl1_GLBaseMixer_virtual_gl_start(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(mix)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// glStop: called in the GL thread to setup the element GL state.
func (mix *GLBaseMixer) glStop() {
	gclass := (*C.GstGLBaseMixerClass)(coreglib.PeekParentClass(mix))
	fnarg := gclass.gl_stop

	var _arg0 *C.GstGLBaseMixer // out

	_arg0 = (*C.GstGLBaseMixer)(unsafe.Pointer(coreglib.InternObject(mix).Native()))

	C._gotk4_gstgl1_GLBaseMixer_virtual_gl_stop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(mix)
}

// GLBaseMixerPadOverrides contains methods that are overridable.
type GLBaseMixerPadOverrides struct {
}

func defaultGLBaseMixerPadOverrides(v *GLBaseMixerPad) GLBaseMixerPadOverrides {
	return GLBaseMixerPadOverrides{}
}

type GLBaseMixerPad struct {
	_ [0]func() // equal guard
	gstvideo.VideoAggregatorPad
}

var (
	_ gst.GstObjector = (*GLBaseMixerPad)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLBaseMixerPad, *GLBaseMixerPadClass, GLBaseMixerPadOverrides](
		GTypeGLBaseMixerPad,
		initGLBaseMixerPadClass,
		wrapGLBaseMixerPad,
		defaultGLBaseMixerPadOverrides,
	)
}

func initGLBaseMixerPadClass(gclass unsafe.Pointer, overrides GLBaseMixerPadOverrides, classInitFunc func(*GLBaseMixerPadClass)) {
	if classInitFunc != nil {
		class := (*GLBaseMixerPadClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLBaseMixerPad(obj *coreglib.Object) *GLBaseMixerPad {
	return &GLBaseMixerPad{
		VideoAggregatorPad: gstvideo.VideoAggregatorPad{
			AggregatorPad: gstbase.AggregatorPad{
				Pad: gst.Pad{
					GstObject: gst.GstObject{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
					},
				},
			},
		},
	}
}

func marshalGLBaseMixerPad(p uintptr) (interface{}, error) {
	return wrapGLBaseMixerPad(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// GLBaseSrcOverrides contains methods that are overridable.
type GLBaseSrcOverrides struct {
	// FillGLMemory: called in the GL thread to fill the current video texture.
	FillGLMemory func(mem *GLMemory) bool
	// GLStart: called in the GL thread to setup the element GL state.
	GLStart func() bool
	// GLStop: called in the GL thread to setup the element GL state.
	GLStop func()
}

func defaultGLBaseSrcOverrides(v *GLBaseSrc) GLBaseSrcOverrides {
	return GLBaseSrcOverrides{
		FillGLMemory: v.fillGLMemory,
		GLStart:      v.glStart,
		GLStop:       v.glStop,
	}
}

// GLBaseSrc handles the nitty gritty details of retrieving an OpenGL context.
// It also provided some wrappers around BaseSrc's start() and stop() virtual
// methods that ensure an OpenGL context is available and current in the calling
// thread.
type GLBaseSrc struct {
	_ [0]func() // equal guard
	gstbase.PushSrc
}

var (
	_ gstbase.BaseSrcer = (*GLBaseSrc)(nil)
)

// GLBaseSrcer describes types inherited from class GLBaseSrc.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type GLBaseSrcer interface {
	coreglib.Objector
	baseGLBaseSrc() *GLBaseSrc
}

var _ GLBaseSrcer = (*GLBaseSrc)(nil)

func init() {
	coreglib.RegisterClassInfo[*GLBaseSrc, *GLBaseSrcClass, GLBaseSrcOverrides](
		GTypeGLBaseSrc,
		initGLBaseSrcClass,
		wrapGLBaseSrc,
		defaultGLBaseSrcOverrides,
	)
}

func initGLBaseSrcClass(gclass unsafe.Pointer, overrides GLBaseSrcOverrides, classInitFunc func(*GLBaseSrcClass)) {
	pclass := (*C.GstGLBaseSrcClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeGLBaseSrc))))

	if overrides.FillGLMemory != nil {
		pclass.fill_gl_memory = (*[0]byte)(C._gotk4_gstgl1_GLBaseSrcClass_fill_gl_memory)
	}

	if overrides.GLStart != nil {
		pclass.gl_start = (*[0]byte)(C._gotk4_gstgl1_GLBaseSrcClass_gl_start)
	}

	if overrides.GLStop != nil {
		pclass.gl_stop = (*[0]byte)(C._gotk4_gstgl1_GLBaseSrcClass_gl_stop)
	}

	if classInitFunc != nil {
		class := (*GLBaseSrcClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLBaseSrc(obj *coreglib.Object) *GLBaseSrc {
	return &GLBaseSrc{
		PushSrc: gstbase.PushSrc{
			BaseSrc: gstbase.BaseSrc{
				Element: gst.Element{
					GstObject: gst.GstObject{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
					},
				},
			},
		},
	}
}

func marshalGLBaseSrc(p uintptr) (interface{}, error) {
	return wrapGLBaseSrc(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *GLBaseSrc) baseGLBaseSrc() *GLBaseSrc {
	return v
}

// BaseGLBaseSrc returns the underlying base object.
func BaseGLBaseSrc(obj GLBaseSrcer) *GLBaseSrc {
	return obj.baseGLBaseSrc()
}

// fillGLMemory: called in the GL thread to fill the current video texture.
func (src *GLBaseSrc) fillGLMemory(mem *GLMemory) bool {
	gclass := (*C.GstGLBaseSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.fill_gl_memory

	var _arg0 *C.GstGLBaseSrc // out
	var _arg1 *C.GstGLMemory  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(mem)))

	_cret = C._gotk4_gstgl1_GLBaseSrc_virtual_fill_gl_memory(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(mem)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// glStart: called in the GL thread to setup the element GL state.
func (src *GLBaseSrc) glStart() bool {
	gclass := (*C.GstGLBaseSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.gl_start

	var _arg0 *C.GstGLBaseSrc // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	_cret = C._gotk4_gstgl1_GLBaseSrc_virtual_gl_start(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(src)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// glStop: called in the GL thread to setup the element GL state.
func (src *GLBaseSrc) glStop() {
	gclass := (*C.GstGLBaseSrcClass)(coreglib.PeekParentClass(src))
	fnarg := gclass.gl_stop

	var _arg0 *C.GstGLBaseSrc // out

	_arg0 = (*C.GstGLBaseSrc)(unsafe.Pointer(coreglib.InternObject(src).Native()))

	C._gotk4_gstgl1_GLBaseSrc_virtual_gl_stop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(src)
}

// GLBufferAllocatorOverrides contains methods that are overridable.
type GLBufferAllocatorOverrides struct {
}

func defaultGLBufferAllocatorOverrides(v *GLBufferAllocator) GLBufferAllocatorOverrides {
	return GLBufferAllocatorOverrides{}
}

// GLBufferAllocator: opaque GLBufferAllocator struct.
type GLBufferAllocator struct {
	_ [0]func() // equal guard
	GLBaseMemoryAllocator
}

var (
	_ GLBaseMemoryAllocatorrer = (*GLBufferAllocator)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLBufferAllocator, *GLBufferAllocatorClass, GLBufferAllocatorOverrides](
		GTypeGLBufferAllocator,
		initGLBufferAllocatorClass,
		wrapGLBufferAllocator,
		defaultGLBufferAllocatorOverrides,
	)
}

func initGLBufferAllocatorClass(gclass unsafe.Pointer, overrides GLBufferAllocatorOverrides, classInitFunc func(*GLBufferAllocatorClass)) {
	if classInitFunc != nil {
		class := (*GLBufferAllocatorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLBufferAllocator(obj *coreglib.Object) *GLBufferAllocator {
	return &GLBufferAllocator{
		GLBaseMemoryAllocator: GLBaseMemoryAllocator{
			Allocator: gst.Allocator{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalGLBufferAllocator(p uintptr) (interface{}, error) {
	return wrapGLBufferAllocator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// GLBufferPoolOverrides contains methods that are overridable.
type GLBufferPoolOverrides struct {
}

func defaultGLBufferPoolOverrides(v *GLBufferPool) GLBufferPoolOverrides {
	return GLBufferPoolOverrides{}
}

// GLBufferPool is an object that allocates buffers with GLBaseMemory
//
// A GLBufferPool is created with gst_gl_buffer_pool_new()
//
// GLBufferPool implements the VideoMeta buffer pool option
// GST_BUFFER_POOL_OPTION_VIDEO_META, the VideoAligment buffer pool option
// GST_BUFFER_POOL_OPTION_VIDEO_ALIGNMENT as well as the OpenGL specific
// GST_BUFFER_POOL_OPTION_GL_SYNC_META buffer pool option.
type GLBufferPool struct {
	_ [0]func() // equal guard
	gst.BufferPool
}

var (
	_ gst.GstObjector = (*GLBufferPool)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLBufferPool, *GLBufferPoolClass, GLBufferPoolOverrides](
		GTypeGLBufferPool,
		initGLBufferPoolClass,
		wrapGLBufferPool,
		defaultGLBufferPoolOverrides,
	)
}

func initGLBufferPoolClass(gclass unsafe.Pointer, overrides GLBufferPoolOverrides, classInitFunc func(*GLBufferPoolClass)) {
	if classInitFunc != nil {
		class := (*GLBufferPoolClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLBufferPool(obj *coreglib.Object) *GLBufferPool {
	return &GLBufferPool{
		BufferPool: gst.BufferPool{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalGLBufferPool(p uintptr) (interface{}, error) {
	return wrapGLBufferPool(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function takes the following parameters:
//
//   - context to use.
//
// The function returns the following values:
//
//   - glBufferPool that allocates buffers with GLMemory.
func NewGLBufferPool(context GLContexter) *GLBufferPool {
	var _arg1 *C.GstGLContext  // out
	var _cret *C.GstBufferPool // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_buffer_pool_new(_arg1)
	runtime.KeepAlive(context)

	var _glBufferPool *GLBufferPool // out

	_glBufferPool = wrapGLBufferPool(coreglib.Take(unsafe.Pointer(_cret)))

	return _glBufferPool
}

// GLAllocationParams: returned GLAllocationParams will by NULL before the first
// successful call to gst_buffer_pool_set_config(). Subsequent successful calls
// to gst_buffer_pool_set_config() will cause this function to return a new
// GLAllocationParams which may or may not contain the same information.
//
// The function returns the following values:
//
//   - glAllocationParams (optional): copy of the GLAllocationParams being used
//     by the pool.
func (pool *GLBufferPool) GLAllocationParams() *GLAllocationParams {
	var _arg0 *C.GstGLBufferPool       // out
	var _cret *C.GstGLAllocationParams // in

	_arg0 = (*C.GstGLBufferPool)(unsafe.Pointer(coreglib.InternObject(pool).Native()))

	_cret = C.gst_gl_buffer_pool_get_gl_allocation_params(_arg0)
	runtime.KeepAlive(pool)

	var _glAllocationParams *GLAllocationParams // out

	if _cret != nil {
		_glAllocationParams = (*GLAllocationParams)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_glAllocationParams)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_gl_allocation_params_free((*C.GstGLAllocationParams)(intern.C))
			},
		)
	}

	return _glAllocationParams
}

// GLColorConvertOverrides contains methods that are overridable.
type GLColorConvertOverrides struct {
}

func defaultGLColorConvertOverrides(v *GLColorConvert) GLColorConvertOverrides {
	return GLColorConvertOverrides{}
}

// GLColorConvert is an object that converts between color spaces and/or formats
// using OpenGL Shaders.
//
// A GLColorConvert can be created with gst_gl_color_convert_new(), the
// configuration negotiated with gst_gl_color_convert_transform_caps() and the
// conversion performed with gst_gl_color_convert_perform().
//
// The glcolorconvertelement provides a GStreamer element that uses
// GLColorConvert to convert between video formats and color spaces.
type GLColorConvert struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*GLColorConvert)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLColorConvert, *GLColorConvertClass, GLColorConvertOverrides](
		GTypeGLColorConvert,
		initGLColorConvertClass,
		wrapGLColorConvert,
		defaultGLColorConvertOverrides,
	)
}

func initGLColorConvertClass(gclass unsafe.Pointer, overrides GLColorConvertOverrides, classInitFunc func(*GLColorConvertClass)) {
	if classInitFunc != nil {
		class := (*GLColorConvertClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLColorConvert(obj *coreglib.Object) *GLColorConvert {
	return &GLColorConvert{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalGLColorConvert(p uintptr) (interface{}, error) {
	return wrapGLColorConvert(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function takes the following parameters:
//
//   - context: GLContext.
//
// The function returns the following values:
//
//   - glColorConvert: new GLColorConvert object.
func NewGLColorConvert(context GLContexter) *GLColorConvert {
	var _arg1 *C.GstGLContext      // out
	var _cret *C.GstGLColorConvert // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_color_convert_new(_arg1)
	runtime.KeepAlive(context)

	var _glColorConvert *GLColorConvert // out

	_glColorConvert = wrapGLColorConvert(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glColorConvert
}

// DecideAllocation provides an implementation of
// BaseTransformClass.decide_allocation().
//
// The function takes the following parameters:
//
//   - query: completed ALLOCATION Query.
//
// The function returns the following values:
//
//   - ok: whether the allocation parameters were successfully chosen.
func (convert *GLColorConvert) DecideAllocation(query *gst.Query) bool {
	var _arg0 *C.GstGLColorConvert // out
	var _arg1 *C.GstQuery          // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstGLColorConvert)(unsafe.Pointer(coreglib.InternObject(convert).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_gl_color_convert_decide_allocation(_arg0, _arg1)
	runtime.KeepAlive(convert)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Perform converts the data contained by inbuf using the formats specified by
// the Caps passed to gst_gl_color_convert_set_caps().
//
// The function takes the following parameters:
//
//   - inbuf filled Buffer to convert.
//
// The function returns the following values:
//
//   - buffer (optional): converted Buffer or NULL.
func (convert *GLColorConvert) Perform(inbuf *gst.Buffer) *gst.Buffer {
	var _arg0 *C.GstGLColorConvert // out
	var _arg1 *C.GstBuffer         // out
	var _cret *C.GstBuffer         // in

	_arg0 = (*C.GstGLColorConvert)(unsafe.Pointer(coreglib.InternObject(convert).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(inbuf)))

	_cret = C.gst_gl_color_convert_perform(_arg0, _arg1)
	runtime.KeepAlive(convert)
	runtime.KeepAlive(inbuf)

	var _buffer *gst.Buffer // out

	if _cret != nil {
		_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_buffer)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _buffer
}

// SetCaps initializes convert with the information required for conversion.
//
// The function takes the following parameters:
//
//   - inCaps: input Caps.
//   - outCaps: output Caps.
func (convert *GLColorConvert) SetCaps(inCaps, outCaps *gst.Caps) bool {
	var _arg0 *C.GstGLColorConvert // out
	var _arg1 *C.GstCaps           // out
	var _arg2 *C.GstCaps           // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstGLColorConvert)(unsafe.Pointer(coreglib.InternObject(convert).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(inCaps)))
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(outCaps)))

	_cret = C.gst_gl_color_convert_set_caps(_arg0, _arg1, _arg2)
	runtime.KeepAlive(convert)
	runtime.KeepAlive(inCaps)
	runtime.KeepAlive(outCaps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GLColorConvertFixateCaps provides an implementation of
// BaseTransformClass.fixate_caps().
//
// The function takes the following parameters:
//
//   - context to use for transforming caps.
//   - direction: PadDirection.
//   - caps of direction.
//   - other to fixate.
//
// The function returns the following values:
//
//   - ret: fixated Caps.
func GLColorConvertFixateCaps(context GLContexter, direction gst.PadDirection, caps, other *gst.Caps) *gst.Caps {
	var _arg1 *C.GstGLContext   // out
	var _arg2 C.GstPadDirection // out
	var _arg3 *C.GstCaps        // out
	var _arg4 *C.GstCaps        // out
	var _cret *C.GstCaps        // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.GstPadDirection(direction)
	_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg4 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(other)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(other)), nil)

	_cret = C.gst_gl_color_convert_fixate_caps(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(context)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(other)

	var _ret *gst.Caps // out

	_ret = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _ret
}

// The function takes the following parameters:
//
//   - context: GLContext.
//
// The function returns the following values:
//
//   - utf8: shader string that can be used to swizzle vec components in a GLSL
//     shader.
func GLColorConvertSwizzleShaderString(context GLContexter) string {
	var _arg1 *C.GstGLContext // out
	var _cret *C.gchar        // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_color_convert_swizzle_shader_string(_arg1)
	runtime.KeepAlive(context)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// GLColorConvertTransformCaps provides an implementation of
// BaseTransformClass.transform_caps().
//
// The function takes the following parameters:
//
//   - context to use for transforming caps.
//   - direction: PadDirection.
//   - caps to transform.
//   - filter: set of filter Caps.
//
// The function returns the following values:
//
//   - ret: converted Caps.
func GLColorConvertTransformCaps(context GLContexter, direction gst.PadDirection, caps, filter *gst.Caps) *gst.Caps {
	var _arg1 *C.GstGLContext   // out
	var _arg2 C.GstPadDirection // out
	var _arg3 *C.GstCaps        // out
	var _arg4 *C.GstCaps        // out
	var _cret *C.GstCaps        // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.GstPadDirection(direction)
	_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg4 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))

	_cret = C.gst_gl_color_convert_transform_caps(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(context)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(filter)

	var _ret *gst.Caps // out

	_ret = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _ret
}

// GLColorConvertYuvToRGBShaderString: returned glsl function has declaration:
//
// vec3 yuv_to_rgb (vec3 rgb, vec3 offset, vec3 ycoeff, vec3 ucoeff, vec3
// vcoeff);
//
// The Y component is placed in the 0th index of the returned value, The U
// component in the 1st, and the V component in the 2nd. offset, ycoeff, ucoeff,
// and vcoeff are the specific coefficients and offset used for the conversion.
//
// The function takes the following parameters:
//
//   - context: GLContext.
//
// The function returns the following values:
//
//   - utf8: glsl function that can be used to convert from yuv to rgb.
func GLColorConvertYuvToRGBShaderString(context GLContexter) string {
	var _arg1 *C.GstGLContext // out
	var _cret *C.gchar        // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_color_convert_yuv_to_rgb_shader_string(_arg1)
	runtime.KeepAlive(context)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// GLContextOverrides contains methods that are overridable.
type GLContextOverrides struct {
	// Activate: (De)activate the OpenGL context represented by this context.
	//
	// In OpenGL terms, calls eglMakeCurrent or similar with this context and
	// the currently set window. See gst_gl_context_set_window() for details.
	//
	// The function takes the following parameters:
	//
	//   - activate: TRUE to activate, FALSE to deactivate.
	//
	// The function returns the following values:
	//
	//   - ok: whether the activation succeeded.
	Activate func(activate bool) bool
	// CheckFeature: check for an OpenGL feature being supported.
	//
	// Note: Most features require that the context be created before it is
	// possible to determine their existence and so will fail if that is not the
	// case.
	//
	// The function takes the following parameters:
	//
	//   - feature: platform specific feature.
	//
	// The function returns the following values:
	//
	//   - ok: whether feature is supported by context.
	CheckFeature func(feature string) bool
	// ChooseFormat: choose a format for the framebuffer.
	ChooseFormat func() error
	// CreateContext: create the OpenGL context.
	//
	// The function takes the following parameters:
	//
	//   - glApi
	//   - otherContext
	CreateContext func(glApi GLAPI, otherContext GLContexter) error
	// DestroyContext: destroy the OpenGL context.
	DestroyContext func()
	// Config: retrieve the OpenGL configuration for this context. The context
	// must have been successfully created for this function to return a valid
	// value.
	//
	// Not all implementations currently support retrieving the config and will
	// return NULL when not supported.
	//
	// The function returns the following values:
	//
	//   - structure (optional): configuration chosen for this OpenGL context.
	Config func() *gst.Structure
	// GLApi: get the currently enabled OpenGL api.
	//
	// The currently available API may be limited by the GLDisplay in use and/or
	// the GLWindow chosen.
	//
	// The function returns the following values:
	//
	//   - glapI: available OpenGL api.
	GLApi func() GLAPI
	// GLContext gets the backing OpenGL context used by context.
	//
	// The function returns the following values:
	//
	//   - guintptr: platform specific backing OpenGL context.
	GLContext func() uintptr
	// GLPlatform gets the OpenGL platform that used by context.
	//
	// The function returns the following values:
	//
	//   - glPlatform: platform specific backing OpenGL context.
	GLPlatform func() GLPlatform
	// GLPlatformVersion: get the version of the OpenGL platform (GLX, EGL,
	// etc) used. Only valid after a call to gst_gl_context_create().
	//
	// The function returns the following values:
	//
	//   - major: return for the major version.
	//   - minor: return for the minor version.
	GLPlatformVersion func() (major, minor int)
	// RequestConfig: set the OpenGL configuration for this context. The context
	// must not have been created for this function to succeed. Setting a NULL
	// config has the affect of removing any specific configuration request.
	//
	// Not all implementations currently support retrieving the config and this
	// function will return FALSE when not supported.
	//
	// Note that calling this function may cause a subsequent
	// gst_gl_context_create() to fail if config could not be matched with the
	// platform-specific configuration.
	//
	// Note that the actual config used may be differ from the requested values.
	//
	// The function takes the following parameters:
	//
	//   - glConfig (optional): configuration structure for configuring the
	//     OpenGL context.
	//
	// The function returns the following values:
	//
	//   - ok: whether gl_config could be successfully set on context.
	RequestConfig func(glConfig *gst.Structure) bool
	// SwapBuffers: swap the front and back buffers on the window attached to
	// context. This will display the frame on the next refresh cycle.
	SwapBuffers func()
}

func defaultGLContextOverrides(v *GLContext) GLContextOverrides {
	return GLContextOverrides{
		Activate:          v.activate,
		CheckFeature:      v.checkFeature,
		ChooseFormat:      v.chooseFormat,
		CreateContext:     v.createContext,
		DestroyContext:    v.destroyContext,
		Config:            v.config,
		GLApi:             v.glApi,
		GLContext:         v.glContext,
		GLPlatform:        v.glPlatform,
		GLPlatformVersion: v.glPlatformVersion,
		RequestConfig:     v.requestConfig,
		SwapBuffers:       v.swapBuffers,
	}
}

// GLContext wraps an OpenGL context object in a uniform API. As a result of the
// limitation on OpenGL context, this object is not thread safe unless specified
// and must only be activated in a single thread.
//
// Environment variables:
//
// - GST_GL_API: select which OpenGL API to create and OpenGL context for.
// Depending on the platform, the available values are 'opengl', 'opengl3' (core
// profile), and 'gles2'. See the the GLAPI enumeration for more details.
//
// - GST_GL_PLATFORM: select which OpenGL platform to create an OpenGL context
// with. Depending on the platform and the dependencies available build-time,
// the available values are, 'glx', 'egl', 'cgl', 'wgl', and 'eagl'
//
// - GST_GL_CONFIG: select the configuration used for creating
// the OpenGL context and OpenGL surface. Written out as a
// GstStructure that has been serialized to string. e.g.
// GST_GL_CONFIG="gst-gl-context-config,red-size=8,green-size=8,blue-size=8,alpha-size=8,depth-size=16".
// Not all platforms will support the same level of functionality.
type GLContext struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*GLContext)(nil)
)

// GLContexter describes types inherited from class GLContext.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type GLContexter interface {
	coreglib.Objector
	baseGLContext() *GLContext
}

var _ GLContexter = (*GLContext)(nil)

func init() {
	coreglib.RegisterClassInfo[*GLContext, *GLContextClass, GLContextOverrides](
		GTypeGLContext,
		initGLContextClass,
		wrapGLContext,
		defaultGLContextOverrides,
	)
}

func initGLContextClass(gclass unsafe.Pointer, overrides GLContextOverrides, classInitFunc func(*GLContextClass)) {
	pclass := (*C.GstGLContextClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeGLContext))))

	if overrides.Activate != nil {
		pclass.activate = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_activate)
	}

	if overrides.CheckFeature != nil {
		pclass.check_feature = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_check_feature)
	}

	if overrides.ChooseFormat != nil {
		pclass.choose_format = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_choose_format)
	}

	if overrides.CreateContext != nil {
		pclass.create_context = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_create_context)
	}

	if overrides.DestroyContext != nil {
		pclass.destroy_context = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_destroy_context)
	}

	if overrides.Config != nil {
		pclass.get_config = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_get_config)
	}

	if overrides.GLApi != nil {
		pclass.get_gl_api = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_get_gl_api)
	}

	if overrides.GLContext != nil {
		pclass.get_gl_context = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_get_gl_context)
	}

	if overrides.GLPlatform != nil {
		pclass.get_gl_platform = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_get_gl_platform)
	}

	if overrides.GLPlatformVersion != nil {
		pclass.get_gl_platform_version = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_get_gl_platform_version)
	}

	if overrides.RequestConfig != nil {
		pclass.request_config = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_request_config)
	}

	if overrides.SwapBuffers != nil {
		pclass.swap_buffers = (*[0]byte)(C._gotk4_gstgl1_GLContextClass_swap_buffers)
	}

	if classInitFunc != nil {
		class := (*GLContextClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLContext(obj *coreglib.Object) *GLContext {
	return &GLContext{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalGLContext(p uintptr) (interface{}, error) {
	return wrapGLContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (context *GLContext) baseGLContext() *GLContext {
	return context
}

// BaseGLContext returns the underlying base object.
func BaseGLContext(obj GLContexter) *GLContext {
	return obj.baseGLContext()
}

// NewGLContext: create a new GLContext with the specified display.
//
// The function takes the following parameters:
//
//   - display: GLDisplay.
//
// The function returns the following values:
//
//   - glContext: new GLContext.
func NewGLContext(display *GLDisplay) *GLContext {
	var _arg1 *C.GstGLDisplay // out
	var _cret *C.GstGLContext // in

	_arg1 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gst_gl_context_new(_arg1)
	runtime.KeepAlive(display)

	var _glContext *GLContext // out

	_glContext = wrapGLContext(coreglib.Take(unsafe.Pointer(_cret)))

	return _glContext
}

// NewGLContextWrapped wraps an existing OpenGL context into a GLContext.
//
// Note: The caller is responsible for ensuring that the OpenGL context
// represented by handle stays alive while the returned GLContext is active.
//
// context_type must not be GST_GL_PLATFORM_NONE or GST_GL_PLATFORM_ANY
//
// available_apis must not be GST_GL_API_NONE or GST_GL_API_ANY.
//
// The function takes the following parameters:
//
//   - display: GLDisplay.
//   - handle: openGL context to wrap.
//   - contextType specifying the type of context in handle.
//   - availableApis containing the available OpenGL apis in handle.
//
// The function returns the following values:
//
//   - glContext (optional) wrapping handle.
func NewGLContextWrapped(display *GLDisplay, handle uintptr, contextType GLPlatform, availableApis GLAPI) *GLContext {
	var _arg1 *C.GstGLDisplay // out
	var _arg2 C.guintptr      // out
	var _arg3 C.GstGLPlatform // out
	var _arg4 C.GstGLAPI      // out
	var _cret *C.GstGLContext // in

	_arg1 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg2 = C.guintptr(handle)
	_arg3 = C.GstGLPlatform(contextType)
	_arg4 = C.GstGLAPI(availableApis)

	_cret = C.gst_gl_context_new_wrapped(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(display)
	runtime.KeepAlive(handle)
	runtime.KeepAlive(contextType)
	runtime.KeepAlive(availableApis)

	var _glContext *GLContext // out

	if _cret != nil {
		_glContext = wrapGLContext(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _glContext
}

// Activate: (De)activate the OpenGL context represented by this context.
//
// In OpenGL terms, calls eglMakeCurrent or similar with this context and the
// currently set window. See gst_gl_context_set_window() for details.
//
// The function takes the following parameters:
//
//   - activate: TRUE to activate, FALSE to deactivate.
//
// The function returns the following values:
//
//   - ok: whether the activation succeeded.
func (context *GLContext) Activate(activate bool) bool {
	var _arg0 *C.GstGLContext // out
	var _arg1 C.gboolean      // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if activate {
		_arg1 = C.TRUE
	}

	_cret = C.gst_gl_context_activate(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(activate)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanShare: note: This will always fail for two wrapped GLContext's.
//
// The function takes the following parameters:
//
//   - otherContext: another GLContext.
//
// The function returns the following values:
//
//   - ok: whether context and other_context are able to share OpenGL resources.
func (context *GLContext) CanShare(otherContext GLContexter) bool {
	var _arg0 *C.GstGLContext // out
	var _arg1 *C.GstGLContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(otherContext).Native()))

	_cret = C.gst_gl_context_can_share(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(otherContext)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CheckFeature: check for an OpenGL feature being supported.
//
// Note: Most features require that the context be created before it is possible
// to determine their existence and so will fail if that is not the case.
//
// The function takes the following parameters:
//
//   - feature: platform specific feature.
//
// The function returns the following values:
//
//   - ok: whether feature is supported by context.
func (context *GLContext) CheckFeature(feature string) bool {
	var _arg0 *C.GstGLContext // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(feature)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_gl_context_check_feature(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(feature)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CheckFramebufferStatus: must be called with context current.
//
// The function takes the following parameters:
//
//   - fboTarget: GL value of the framebuffer target, GL_FRAMEBUFFER,
//     GL_READ_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER.
//
// The function returns the following values:
//
//   - ok: whether whether the current framebuffer is complete.
func (context *GLContext) CheckFramebufferStatus(fboTarget uint) bool {
	var _arg0 *C.GstGLContext // out
	var _arg1 C.guint         // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.guint(fboTarget)

	_cret = C.gst_gl_context_check_framebuffer_status(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(fboTarget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - api type required.
//   - maj: major version required.
//   - min: minor version required.
//
// The function returns the following values:
//
//   - ok: whether OpenGL context implements the required api and specified
//     version.
func (context *GLContext) CheckGLVersion(api GLAPI, maj, min int) bool {
	var _arg0 *C.GstGLContext // out
	var _arg1 C.GstGLAPI      // out
	var _arg2 C.gint          // out
	var _arg3 C.gint          // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.GstGLAPI(api)
	_arg2 = C.gint(maj)
	_arg3 = C.gint(min)

	_cret = C.gst_gl_context_check_gl_version(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(api)
	runtime.KeepAlive(maj)
	runtime.KeepAlive(min)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ClearFramebuffer: unbind the current framebuffer.
func (context *GLContext) ClearFramebuffer() {
	var _arg0 *C.GstGLContext // out

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gst_gl_context_clear_framebuffer(_arg0)
	runtime.KeepAlive(context)
}

// ClearShader clear's the currently set shader from the GL state machine.
//
// Note: must be called in the GL thread.
func (context *GLContext) ClearShader() {
	var _arg0 *C.GstGLContext // out

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gst_gl_context_clear_shader(_arg0)
	runtime.KeepAlive(context)
}

// Create creates an OpenGL context with the specified other_context as a
// context to share shareable OpenGL objects with. See the OpenGL specification
// for what is shared between OpenGL contexts.
//
// Since 1.20, the configuration can be overriden with the environment variable
// GST_GL_CONFIG which is a stringified Structure as would be returned from
// gst_gl_context_get_config(). If GST_GL_CONFIG is not set, then the config
// will be chosen from other_context by calling gst_gl_context_get_config() on
// other_context. Otherwise, a default configuration is used.
//
// Calling gst_gl_context_request_config()) before calling
// gst_gl_context_create() will override the config from other_context but will
// not override the GST_GL_CONFIG environment variable.
//
// If an error occurs, and error is not NULL, then error will contain details of
// the error and FALSE will be returned.
//
// Should only be called once.
//
// The function takes the following parameters:
//
//   - otherContext (optional) to share OpenGL objects with.
func (context *GLContext) Create(otherContext GLContexter) error {
	var _arg0 *C.GstGLContext // out
	var _arg1 *C.GstGLContext // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if otherContext != nil {
		_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(otherContext).Native()))
	}

	C.gst_gl_context_create(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(context)
	runtime.KeepAlive(otherContext)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Destroy destroys an OpenGL context.
//
// Should only be called after gst_gl_context_create() has been successfully
// called for this context.
func (context *GLContext) Destroy() {
	var _arg0 *C.GstGLContext // out

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gst_gl_context_destroy(_arg0)
	runtime.KeepAlive(context)
}

// FillInfo fills context's info (version, extensions, vtable, etc) from the GL
// context in the current thread. Typically used with wrapped contexts to allow
// wrapped contexts to be used as regular GLContext's.
func (context *GLContext) FillInfo() error {
	var _arg0 *C.GstGLContext // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gst_gl_context_fill_info(_arg0, &_cerr)
	runtime.KeepAlive(context)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Config: retrieve the OpenGL configuration for this context. The context must
// have been successfully created for this function to return a valid value.
//
// Not all implementations currently support retrieving the config and will
// return NULL when not supported.
//
// The function returns the following values:
//
//   - structure (optional): configuration chosen for this OpenGL context.
func (context *GLContext) Config() *gst.Structure {
	var _arg0 *C.GstGLContext // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_context_get_config(_arg0)
	runtime.KeepAlive(context)

	var _structure *gst.Structure // out

	if _cret != nil {
		_structure = (*gst.Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_structure)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _structure
}

// The function returns the following values:
//
//   - glDisplay associated with this context.
func (context *GLContext) Display() *GLDisplay {
	var _arg0 *C.GstGLContext // out
	var _cret *C.GstGLDisplay // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_context_get_display(_arg0)
	runtime.KeepAlive(context)

	var _glDisplay *GLDisplay // out

	_glDisplay = wrapGLDisplay(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glDisplay
}

// GLApi: get the currently enabled OpenGL api.
//
// The currently available API may be limited by the GLDisplay in use and/or the
// GLWindow chosen.
//
// The function returns the following values:
//
//   - glapI: available OpenGL api.
func (context *GLContext) GLApi() GLAPI {
	var _arg0 *C.GstGLContext // out
	var _cret C.GstGLAPI      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_context_get_gl_api(_arg0)
	runtime.KeepAlive(context)

	var _glapI GLAPI // out

	_glapI = GLAPI(_cret)

	return _glapI
}

// GLContext gets the backing OpenGL context used by context.
//
// The function returns the following values:
//
//   - guintptr: platform specific backing OpenGL context.
func (context *GLContext) GLContext() uintptr {
	var _arg0 *C.GstGLContext // out
	var _cret C.guintptr      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_context_get_gl_context(_arg0)
	runtime.KeepAlive(context)

	var _guintptr uintptr // out

	_guintptr = uintptr(_cret)

	return _guintptr
}

// GLPlatform gets the OpenGL platform that used by context.
//
// The function returns the following values:
//
//   - glPlatform: platform specific backing OpenGL context.
func (context *GLContext) GLPlatform() GLPlatform {
	var _arg0 *C.GstGLContext // out
	var _cret C.GstGLPlatform // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_context_get_gl_platform(_arg0)
	runtime.KeepAlive(context)

	var _glPlatform GLPlatform // out

	_glPlatform = GLPlatform(_cret)

	return _glPlatform
}

// GLPlatformVersion: get the version of the OpenGL platform (GLX, EGL, etc)
// used. Only valid after a call to gst_gl_context_create().
//
// The function returns the following values:
//
//   - major: return for the major version.
//   - minor: return for the minor version.
func (context *GLContext) GLPlatformVersion() (major, minor int) {
	var _arg0 *C.GstGLContext // out
	var _arg1 C.gint          // in
	var _arg2 C.gint          // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gst_gl_context_get_gl_platform_version(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(context)

	var _major int // out
	var _minor int // out

	_major = int(_arg1)
	_minor = int(_arg2)

	return _major, _minor
}

// GLVersion returns the OpenGL version implemented by context. See
// gst_gl_context_get_gl_api() for retrieving the OpenGL api implemented by
// context.
//
// The function returns the following values:
//
//   - maj: resulting major version.
//   - min: resulting minor version.
func (context *GLContext) GLVersion() (maj, min int) {
	var _arg0 *C.GstGLContext // out
	var _arg1 C.gint          // in
	var _arg2 C.gint          // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gst_gl_context_get_gl_version(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(context)

	var _maj int // out
	var _min int // out

	_maj = int(_arg1)
	_min = int(_arg2)

	return _maj, _min
}

// ProcAddress: get a function pointer to a specified opengl function, name.
// If the the specific function does not exist, NULL is returned instead.
//
// Platform specific functions (names starting 'egl', 'glX', 'wgl', etc) can
// also be retrieved using this method.
//
// Note: This function may return valid function pointers that may not be valid
// to call in context. The caller is responsible for ensuring that the returned
// function is a valid function to call in context by either checking the OpenGL
// API and version or for an appropriate OpenGL extension.
//
// Note: On success, you need to cast the returned function pointer to the
// correct type to be able to call it correctly. On 32-bit Windows, this will
// include the GSTGLAPI identifier to use the correct calling convention. e.g.
//
//	void (GSTGLAPI *PFN_glGetIntegerv) (GLenum name, GLint * ret).
//
// The function takes the following parameters:
//
//   - name: opengl function name.
//
// The function returns the following values:
//
//   - gpointer (optional): function pointer or NULL.
func (context *GLContext) ProcAddress(name string) unsafe.Pointer {
	var _arg0 *C.GstGLContext // out
	var _arg1 *C.gchar        // out
	var _cret C.gpointer      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_gl_context_get_proc_address(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(name)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// The function returns the following values:
//
//   - glWindow (optional): currently set window.
func (context *GLContext) Window() GLWindower {
	var _arg0 *C.GstGLContext // out
	var _cret *C.GstGLWindow  // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_context_get_window(_arg0)
	runtime.KeepAlive(context)

	var _glWindow GLWindower // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(GLWindower)
				return ok
			})
			rv, ok := casted.(GLWindower)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstgl.GLWindower")
			}
			_glWindow = rv
		}
	}

	return _glWindow
}

// The function returns the following values:
//
//   - ok: whether the GLContext has been shared with another GLContext.
func (context *GLContext) IsShared() bool {
	var _arg0 *C.GstGLContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_context_is_shared(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RequestConfig: set the OpenGL configuration for this context. The context
// must not have been created for this function to succeed. Setting a NULL
// config has the affect of removing any specific configuration request.
//
// Not all implementations currently support retrieving the config and this
// function will return FALSE when not supported.
//
// Note that calling this function may cause a subsequent
// gst_gl_context_create() to fail if config could not be matched with the
// platform-specific configuration.
//
// Note that the actual config used may be differ from the requested values.
//
// The function takes the following parameters:
//
//   - glConfig (optional): configuration structure for configuring the OpenGL
//     context.
//
// The function returns the following values:
//
//   - ok: whether gl_config could be successfully set on context.
func (context *GLContext) RequestConfig(glConfig *gst.Structure) bool {
	var _arg0 *C.GstGLContext // out
	var _arg1 *C.GstStructure // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if glConfig != nil {
		_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(glConfig)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(glConfig)), nil)
	}

	_cret = C.gst_gl_context_request_config(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(glConfig)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSharedWith will internally set context as shared with share.
//
// The function takes the following parameters:
//
//   - share: another GLContext.
func (context *GLContext) SetSharedWith(share GLContexter) {
	var _arg0 *C.GstGLContext // out
	var _arg1 *C.GstGLContext // out

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(share).Native()))

	C.gst_gl_context_set_shared_with(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(share)
}

// SetWindow set's the current window on context to window. The window can only
// be changed before gst_gl_context_create() has been called and the window is
// not already running.
//
// The function takes the following parameters:
//
//   - window: GLWindow.
//
// The function returns the following values:
//
//   - ok: whether the window was successfully updated.
func (context *GLContext) SetWindow(window GLWindower) bool {
	var _arg0 *C.GstGLContext // out
	var _arg1 *C.GstGLWindow  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(window).Native()))

	_cret = C.gst_gl_context_set_window(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - version: GLSLVersion.
//   - profile: GLSLProfile.
//
// The function returns the following values:
//
//   - ok: whether context supports the combination of version with profile.
func (context *GLContext) SupportsGlslProfileVersion(version GLSLVersion, profile GLSLProfile) bool {
	var _arg0 *C.GstGLContext  // out
	var _arg1 C.GstGLSLVersion // out
	var _arg2 C.GstGLSLProfile // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.GstGLSLVersion(version)
	_arg2 = C.GstGLSLProfile(profile)

	_cret = C.gst_gl_context_supports_glsl_profile_version(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(version)
	runtime.KeepAlive(profile)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - version: GLSLVersion.
//   - profile: GLSLProfile.
//
// The function returns the following values:
//
//   - ok: whether context supports the 'precision' specifier in GLSL shaders.
func (context *GLContext) SupportsPrecision(version GLSLVersion, profile GLSLProfile) bool {
	var _arg0 *C.GstGLContext  // out
	var _arg1 C.GstGLSLVersion // out
	var _arg2 C.GstGLSLProfile // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.GstGLSLVersion(version)
	_arg2 = C.GstGLSLProfile(profile)

	_cret = C.gst_gl_context_supports_precision(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(version)
	runtime.KeepAlive(profile)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - version: GLSLVersion.
//   - profile: GLSLProfile.
//
// The function returns the following values:
//
//   - ok: whether context supports the 'precision highp' specifier in GLSL
//     shaders.
func (context *GLContext) SupportsPrecisionHighp(version GLSLVersion, profile GLSLProfile) bool {
	var _arg0 *C.GstGLContext  // out
	var _arg1 C.GstGLSLVersion // out
	var _arg2 C.GstGLSLProfile // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.GstGLSLVersion(version)
	_arg2 = C.GstGLSLProfile(profile)

	_cret = C.gst_gl_context_supports_precision_highp(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(version)
	runtime.KeepAlive(profile)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SwapBuffers: swap the front and back buffers on the window attached to
// context. This will display the frame on the next refresh cycle.
func (context *GLContext) SwapBuffers() {
	var _arg0 *C.GstGLContext // out

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gst_gl_context_swap_buffers(_arg0)
	runtime.KeepAlive(context)
}

// Activate the OpenGL context represented by this context.
//
// In OpenGL terms, calls eglMakeCurrent or similar with this context and the
// currently set window. See gst_gl_context_set_window() for details.
//
// The function takes the following parameters:
//
//   - activate: TRUE to activate, FALSE to deactivate.
//
// The function returns the following values:
//
//   - ok: whether the activation succeeded.
func (context *GLContext) activate(activate bool) bool {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.activate

	var _arg0 *C.GstGLContext // out
	var _arg1 C.gboolean      // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if activate {
		_arg1 = C.TRUE
	}

	_cret = C._gotk4_gstgl1_GLContext_virtual_activate(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(activate)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// checkFeature: check for an OpenGL feature being supported.
//
// Note: Most features require that the context be created before it is possible
// to determine their existence and so will fail if that is not the case.
//
// The function takes the following parameters:
//
//   - feature: platform specific feature.
//
// The function returns the following values:
//
//   - ok: whether feature is supported by context.
func (context *GLContext) checkFeature(feature string) bool {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.check_feature

	var _arg0 *C.GstGLContext // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(feature)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gstgl1_GLContext_virtual_check_feature(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(feature)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// chooseFormat: choose a format for the framebuffer.
func (context *GLContext) chooseFormat() error {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.choose_format

	var _arg0 *C.GstGLContext // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gstgl1_GLContext_virtual_choose_format(unsafe.Pointer(fnarg), _arg0, &_cerr)
	runtime.KeepAlive(context)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// createContext: create the OpenGL context.
//
// The function takes the following parameters:
//
//   - glApi
//   - otherContext
func (context *GLContext) createContext(glApi GLAPI, otherContext GLContexter) error {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.create_context

	var _arg0 *C.GstGLContext // out
	var _arg1 C.GstGLAPI      // out
	var _arg2 *C.GstGLContext // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.GstGLAPI(glApi)
	_arg2 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(otherContext).Native()))

	C._gotk4_gstgl1_GLContext_virtual_create_context(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(context)
	runtime.KeepAlive(glApi)
	runtime.KeepAlive(otherContext)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// destroyContext: destroy the OpenGL context.
func (context *GLContext) destroyContext() {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.destroy_context

	var _arg0 *C.GstGLContext // out

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gstgl1_GLContext_virtual_destroy_context(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(context)
}

// Config: retrieve the OpenGL configuration for this context. The context must
// have been successfully created for this function to return a valid value.
//
// Not all implementations currently support retrieving the config and will
// return NULL when not supported.
//
// The function returns the following values:
//
//   - structure (optional): configuration chosen for this OpenGL context.
func (context *GLContext) config() *gst.Structure {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.get_config

	var _arg0 *C.GstGLContext // out
	var _cret *C.GstStructure // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C._gotk4_gstgl1_GLContext_virtual_get_config(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(context)

	var _structure *gst.Structure // out

	if _cret != nil {
		_structure = (*gst.Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_structure)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _structure
}

// glApi: get the currently enabled OpenGL api.
//
// The currently available API may be limited by the GLDisplay in use and/or the
// GLWindow chosen.
//
// The function returns the following values:
//
//   - glapI: available OpenGL api.
func (context *GLContext) glApi() GLAPI {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.get_gl_api

	var _arg0 *C.GstGLContext // out
	var _cret C.GstGLAPI      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C._gotk4_gstgl1_GLContext_virtual_get_gl_api(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(context)

	var _glapI GLAPI // out

	_glapI = GLAPI(_cret)

	return _glapI
}

// glContext gets the backing OpenGL context used by context.
//
// The function returns the following values:
//
//   - guintptr: platform specific backing OpenGL context.
func (context *GLContext) glContext() uintptr {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.get_gl_context

	var _arg0 *C.GstGLContext // out
	var _cret C.guintptr      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C._gotk4_gstgl1_GLContext_virtual_get_gl_context(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(context)

	var _guintptr uintptr // out

	_guintptr = uintptr(_cret)

	return _guintptr
}

// glPlatform gets the OpenGL platform that used by context.
//
// The function returns the following values:
//
//   - glPlatform: platform specific backing OpenGL context.
func (context *GLContext) glPlatform() GLPlatform {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.get_gl_platform

	var _arg0 *C.GstGLContext // out
	var _cret C.GstGLPlatform // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C._gotk4_gstgl1_GLContext_virtual_get_gl_platform(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(context)

	var _glPlatform GLPlatform // out

	_glPlatform = GLPlatform(_cret)

	return _glPlatform
}

// glPlatformVersion: get the version of the OpenGL platform (GLX, EGL, etc)
// used. Only valid after a call to gst_gl_context_create().
//
// The function returns the following values:
//
//   - major: return for the major version.
//   - minor: return for the minor version.
func (context *GLContext) glPlatformVersion() (major, minor int) {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.get_gl_platform_version

	var _arg0 *C.GstGLContext // out
	var _arg1 C.gint          // in
	var _arg2 C.gint          // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gstgl1_GLContext_virtual_get_gl_platform_version(unsafe.Pointer(fnarg), _arg0, &_arg1, &_arg2)
	runtime.KeepAlive(context)

	var _major int // out
	var _minor int // out

	_major = int(_arg1)
	_minor = int(_arg2)

	return _major, _minor
}

// requestConfig: set the OpenGL configuration for this context. The context
// must not have been created for this function to succeed. Setting a NULL
// config has the affect of removing any specific configuration request.
//
// Not all implementations currently support retrieving the config and this
// function will return FALSE when not supported.
//
// Note that calling this function may cause a subsequent
// gst_gl_context_create() to fail if config could not be matched with the
// platform-specific configuration.
//
// Note that the actual config used may be differ from the requested values.
//
// The function takes the following parameters:
//
//   - glConfig (optional): configuration structure for configuring the OpenGL
//     context.
//
// The function returns the following values:
//
//   - ok: whether gl_config could be successfully set on context.
func (context *GLContext) requestConfig(glConfig *gst.Structure) bool {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.request_config

	var _arg0 *C.GstGLContext // out
	var _arg1 *C.GstStructure // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if glConfig != nil {
		_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(glConfig)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(glConfig)), nil)
	}

	_cret = C._gotk4_gstgl1_GLContext_virtual_request_config(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(glConfig)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// swapBuffers: swap the front and back buffers on the window attached to
// context. This will display the frame on the next refresh cycle.
func (context *GLContext) swapBuffers() {
	gclass := (*C.GstGLContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.swap_buffers

	var _arg0 *C.GstGLContext // out

	_arg0 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gstgl1_GLContext_virtual_swap_buffers(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(context)
}

// GLContextDefaultGetProcAddress: default implementation of the various
// GetProcAddress functions that looks for name in the OpenGL shared libraries
// or in the current process.
//
// See also: gst_gl_context_get_proc_address().
//
// The function takes the following parameters:
//
//   - glApi: GLAPI.
//   - name: then function to get the address of.
//
// The function returns the following values:
//
//   - gpointer (optional) address pointing to name or NULL.
func GLContextDefaultGetProcAddress(glApi GLAPI, name string) unsafe.Pointer {
	var _arg1 C.GstGLAPI // out
	var _arg2 *C.gchar   // out
	var _cret C.gpointer // in

	_arg1 = C.GstGLAPI(glApi)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_gl_context_default_get_proc_address(_arg1, _arg2)
	runtime.KeepAlive(glApi)
	runtime.KeepAlive(name)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// GLContextGetCurrent: see also gst_gl_context_activate().
//
// The function returns the following values:
//
//   - glContext (optional) active in the current thread or NULL.
func GLContextGetCurrent() GLContexter {
	var _cret *C.GstGLContext // in

	_cret = C.gst_gl_context_get_current()

	var _glContext GLContexter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(GLContexter)
				return ok
			})
			rv, ok := casted.(GLContexter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstgl.GLContexter")
			}
			_glContext = rv
		}
	}

	return _glContext
}

// GLContextGetCurrentGLApi: if an error occurs, major and minor are not
// modified and GST_GL_API_NONE is returned.
//
// The function takes the following parameters:
//
//   - platform to retrieve the API for.
//
// The function returns the following values:
//
//   - major (optional) version.
//   - minor (optional) version.
//   - glapI: version supported by the OpenGL context current in the calling
//     thread or GST_GL_API_NONE.
func GLContextGetCurrentGLApi(platform GLPlatform) (major, minor uint, glapI GLAPI) {
	var _arg1 C.GstGLPlatform // out
	var _arg2 C.guint         // in
	var _arg3 C.guint         // in
	var _cret C.GstGLAPI      // in

	_arg1 = C.GstGLPlatform(platform)

	_cret = C.gst_gl_context_get_current_gl_api(_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(platform)

	var _major uint  // out
	var _minor uint  // out
	var _glapI GLAPI // out

	_major = uint(_arg2)
	_minor = uint(_arg3)
	_glapI = GLAPI(_cret)

	return _major, _minor, _glapI
}

// The function takes the following parameters:
//
//   - contextType specifying the type of context to retrieve.
//
// The function returns the following values:
//
//   - guintptr (optional): openGL context handle current in the calling thread
//     or NULL.
func GLContextGetCurrentGLContext(contextType GLPlatform) uintptr {
	var _arg1 C.GstGLPlatform // out
	var _cret C.guintptr      // in

	_arg1 = C.GstGLPlatform(contextType)

	_cret = C.gst_gl_context_get_current_gl_context(_arg1)
	runtime.KeepAlive(contextType)

	var _guintptr uintptr // out

	_guintptr = uintptr(_cret)

	return _guintptr
}

// GLContextGetProcAddressWithPlatform attempts to use the context_type specific
// GetProcAddress implementations to retrieve name.
//
// See also gst_gl_context_get_proc_address().
//
// The function takes the following parameters:
//
//   - contextType: GLPlatform.
//   - glApi: GLAPI.
//   - name of the function to retrieve.
//
// The function returns the following values:
//
//   - gpointer (optional): function pointer for name, or NULL.
func GLContextGetProcAddressWithPlatform(contextType GLPlatform, glApi GLAPI, name string) unsafe.Pointer {
	var _arg1 C.GstGLPlatform // out
	var _arg2 C.GstGLAPI      // out
	var _arg3 *C.gchar        // out
	var _cret C.gpointer      // in

	_arg1 = C.GstGLPlatform(contextType)
	_arg2 = C.GstGLAPI(glApi)
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gst_gl_context_get_proc_address_with_platform(_arg1, _arg2, _arg3)
	runtime.KeepAlive(contextType)
	runtime.KeepAlive(glApi)
	runtime.KeepAlive(name)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// GLDisplayOverrides contains methods that are overridable.
type GLDisplayOverrides struct {
	// The function returns the following values:
	//
	//   - glWindow (optional): new GLWindow for display or NULL.
	CreateWindow func() GLWindower
	// The function returns the following values:
	//
	//   - guintptr: native handle for the display.
	Handle func() uintptr
}

func defaultGLDisplayOverrides(v *GLDisplay) GLDisplayOverrides {
	return GLDisplayOverrides{
		CreateWindow: v.createWindow,
		Handle:       v.handle,
	}
}

// GLDisplay represents a connection to the underlying windowing system.
// Elements are required to make use of Context to share and propagate a
// GLDisplay.
//
// There are a number of environment variables that influence the choice of
// platform and window system specific functionality.
//
// - GST_GL_WINDOW influences the window system to use. Common values are 'x11',
// 'wayland', 'surfaceless', 'win32' or 'cocoa'.
//
// - GST_GL_PLATFORM influences the OpenGL platform to use. Common values are
// 'egl', 'glx', 'wgl' or 'cgl'.
//
// - GST_GL_API influences the OpenGL API requested by the OpenGL platform.
// Common values are 'opengl', 'opengl3' and 'gles2'.
//
// > Certain window systems require a special function to be called to >
// initialize threading support. As this GStreamer GL library does not preclude
// > concurrent access to the windowing system, it is strongly advised that >
// applications ensure that threading support has been initialized before any
// > other toolkit/library functionality is accessed. Failure to do so could >
// result in sudden application abortion during execution. The most notably >
// example of such a function is X11's XInitThreads\().
type GLDisplay struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*GLDisplay)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLDisplay, *GLDisplayClass, GLDisplayOverrides](
		GTypeGLDisplay,
		initGLDisplayClass,
		wrapGLDisplay,
		defaultGLDisplayOverrides,
	)
}

func initGLDisplayClass(gclass unsafe.Pointer, overrides GLDisplayOverrides, classInitFunc func(*GLDisplayClass)) {
	pclass := (*C.GstGLDisplayClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeGLDisplay))))

	if overrides.CreateWindow != nil {
		pclass.create_window = (*[0]byte)(C._gotk4_gstgl1_GLDisplayClass_create_window)
	}

	if overrides.Handle != nil {
		pclass.get_handle = (*[0]byte)(C._gotk4_gstgl1_GLDisplayClass_get_handle)
	}

	if classInitFunc != nil {
		class := (*GLDisplayClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLDisplay(obj *coreglib.Object) *GLDisplay {
	return &GLDisplay{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalGLDisplay(p uintptr) (interface{}, error) {
	return wrapGLDisplay(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectCreateContext overrides the GstGLContext creation mechanism. It can be
// called in any thread and it is emitted with display's object lock held.
func (display *GLDisplay) ConnectCreateContext(f func(context GLContexter) (glContext GLContexter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(display, "create-context", false, unsafe.Pointer(C._gotk4_gstgl1_GLDisplay_ConnectCreateContext), f)
}

// The function returns the following values:
//
//   - glDisplay: new GLDisplay.
func NewGLDisplay() *GLDisplay {
	var _cret *C.GstGLDisplay // in

	_cret = C.gst_gl_display_new()

	var _glDisplay *GLDisplay // out

	_glDisplay = wrapGLDisplay(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glDisplay
}

// NewGLDisplayWithType will always return a GLDisplay of a single type.
// This differs from gst_gl_display_new() and the seemingly equivalent call
// gst_gl_display_new_with_type (GST_GL_DISPLAY_TYPE_ANY) in that the latter may
// return NULL.
//
// The function takes the following parameters:
//
//   - typ: GLDisplayType.
//
// The function returns the following values:
//
//   - glDisplay (optional): new GLDisplay or NULL if type is not supported.
func NewGLDisplayWithType(typ GLDisplayType) *GLDisplay {
	var _arg1 C.GstGLDisplayType // out
	var _cret *C.GstGLDisplay    // in

	_arg1 = C.GstGLDisplayType(typ)

	_cret = C.gst_gl_display_new_with_type(_arg1)
	runtime.KeepAlive(typ)

	var _glDisplay *GLDisplay // out

	if _cret != nil {
		_glDisplay = wrapGLDisplay(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _glDisplay
}

// The function takes the following parameters:
//
//   - context: GLContext.
//
// The function returns the following values:
//
//   - ok: whether context was successfully added. FALSE may be returned if
//     there already exists another context for context's active thread.
//
//     Must be called with the object lock held.
func (display *GLDisplay) AddContext(context GLContexter) bool {
	var _arg0 *C.GstGLDisplay // out
	var _arg1 *C.GstGLContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_display_add_context(_arg0, _arg1)
	runtime.KeepAlive(display)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CreateContext: it requires the display's object lock to be held.
//
// The function takes the following parameters:
//
//   - otherContext (optional): other GLContext to share resources with.
//
// The function returns the following values:
//
//   - pContext: resulting GLContext.
func (display *GLDisplay) CreateContext(otherContext GLContexter) (GLContexter, error) {
	var _arg0 *C.GstGLDisplay // out
	var _arg1 *C.GstGLContext // out
	var _arg2 *C.GstGLContext // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	if otherContext != nil {
		_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(otherContext).Native()))
	}

	C.gst_gl_display_create_context(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(display)
	runtime.KeepAlive(otherContext)

	var _pContext GLContexter // out
	var _goerr error          // out

	{
		objptr := unsafe.Pointer(_arg2)
		if objptr == nil {
			panic("object of type gstgl.GLContexter is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(GLContexter)
			return ok
		})
		rv, ok := casted.(GLContexter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstgl.GLContexter")
		}
		_pContext = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _pContext, _goerr
}

// The function returns the following values:
//
//   - glWindow (optional): new GLWindow for display or NULL.
func (display *GLDisplay) CreateWindow() GLWindower {
	var _arg0 *C.GstGLDisplay // out
	var _cret *C.GstGLWindow  // in

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gst_gl_display_create_window(_arg0)
	runtime.KeepAlive(display)

	var _glWindow GLWindower // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(GLWindower)
				return ok
			})
			rv, ok := casted.(GLWindower)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstgl.GLWindower")
			}
			_glWindow = rv
		}
	}

	return _glWindow
}

// FilterGLApi: limit the use of OpenGL to the requested gl_api. This is
// intended to allow application and elements to request a specific set of
// OpenGL API's based on what they support. See gst_gl_context_get_gl_api() for
// the retrieving the API supported by a GLContext.
//
// The function takes the following parameters:
//
//   - glApi to filter with.
func (display *GLDisplay) FilterGLApi(glApi GLAPI) {
	var _arg0 *C.GstGLDisplay // out
	var _arg1 C.GstGLAPI      // out

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = C.GstGLAPI(glApi)

	C.gst_gl_display_filter_gl_api(_arg0, _arg1)
	runtime.KeepAlive(display)
	runtime.KeepAlive(glApi)
}

// GLApi: see gst_gl_display_filter_gl_api() for what the returned value
// represents.
//
// The function returns the following values:
//
//   - glapI configured for display.
func (display *GLDisplay) GLApi() GLAPI {
	var _arg0 *C.GstGLDisplay // out
	var _cret C.GstGLAPI      // in

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gst_gl_display_get_gl_api(_arg0)
	runtime.KeepAlive(display)

	var _glapI GLAPI // out

	_glapI = GLAPI(_cret)

	return _glapI
}

func (display *GLDisplay) GLApiUnlocked() GLAPI {
	var _arg0 *C.GstGLDisplay // out
	var _cret C.GstGLAPI      // in

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gst_gl_display_get_gl_api_unlocked(_arg0)
	runtime.KeepAlive(display)

	var _glapI GLAPI // out

	_glapI = GLAPI(_cret)

	return _glapI
}

// The function returns the following values:
//
//   - guintptr: native handle for the display.
func (display *GLDisplay) Handle() uintptr {
	var _arg0 *C.GstGLDisplay // out
	var _cret C.guintptr      // in

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gst_gl_display_get_handle(_arg0)
	runtime.KeepAlive(display)

	var _guintptr uintptr // out

	_guintptr = uintptr(_cret)

	return _guintptr
}

// The function returns the following values:
//
//   - glDisplayType of display.
func (display *GLDisplay) HandleType() GLDisplayType {
	var _arg0 *C.GstGLDisplay    // out
	var _cret C.GstGLDisplayType // in

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gst_gl_display_get_handle_type(_arg0)
	runtime.KeepAlive(display)

	var _glDisplayType GLDisplayType // out

	_glDisplayType = GLDisplayType(_cret)

	return _glDisplayType
}

// RemoveContext: must be called with the object lock held.
//
// The function takes the following parameters:
//
//   - context to remove.
func (display *GLDisplay) RemoveContext(context GLContexter) {
	var _arg0 *C.GstGLDisplay // out
	var _arg1 *C.GstGLContext // out

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gst_gl_display_remove_context(_arg0, _arg1)
	runtime.KeepAlive(display)
	runtime.KeepAlive(context)
}

// The function takes the following parameters:
//
//   - window to remove.
//
// The function returns the following values:
//
//   - ok: if window could be removed from display.
func (display *GLDisplay) RemoveWindow(window GLWindower) bool {
	var _arg0 *C.GstGLDisplay // out
	var _arg1 *C.GstGLWindow  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gst_gl_display_remove_window(_arg0, _arg1)
	runtime.KeepAlive(display)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - glWindow (optional): new GLWindow for display or NULL.
func (display *GLDisplay) createWindow() GLWindower {
	gclass := (*C.GstGLDisplayClass)(coreglib.PeekParentClass(display))
	fnarg := gclass.create_window

	var _arg0 *C.GstGLDisplay // out
	var _cret *C.GstGLWindow  // in

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C._gotk4_gstgl1_GLDisplay_virtual_create_window(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(display)

	var _glWindow GLWindower // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(GLWindower)
				return ok
			})
			rv, ok := casted.(GLWindower)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstgl.GLWindower")
			}
			_glWindow = rv
		}
	}

	return _glWindow
}

// The function returns the following values:
//
//   - guintptr: native handle for the display.
func (display *GLDisplay) handle() uintptr {
	gclass := (*C.GstGLDisplayClass)(coreglib.PeekParentClass(display))
	fnarg := gclass.get_handle

	var _arg0 *C.GstGLDisplay // out
	var _cret C.guintptr      // in

	_arg0 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C._gotk4_gstgl1_GLDisplay_virtual_get_handle(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(display)

	var _guintptr uintptr // out

	_guintptr = uintptr(_cret)

	return _guintptr
}

// GLFilterOverrides contains methods that are overridable.
type GLFilterOverrides struct {
	// Filter: perform operations on the input and output buffers. In general,
	// you should avoid using this method if at all possible. One valid use-case
	// for using this is keeping previous buffers for future calculations. Note:
	// If filter exists, then filter_texture is not run.
	//
	// The function takes the following parameters:
	//
	//   - inbuf
	//   - outbuf
	Filter func(inbuf, outbuf *gst.Buffer) bool
	// FilterTexture calls filter_texture vfunc with correctly mapped GLMemorys.
	//
	// The function takes the following parameters:
	//
	//   - input buffer.
	//   - output buffer.
	//
	// The function returns the following values:
	//
	//   - ok: whether the transformation succeeded.
	FilterTexture func(input, output *GLMemory) bool
	// InitFbo: perform initialization when the Framebuffer object is created.
	InitFbo func() bool
	// SetCaps: mirror from BaseTransform.
	//
	// The function takes the following parameters:
	//
	//   - incaps
	//   - outcaps
	SetCaps func(incaps, outcaps *gst.Caps) bool
	// TransformInternalCaps: perform sub-class specific modifications of the
	// caps to be processed between upload on input and before download for
	// output.
	//
	// The function takes the following parameters:
	//
	//   - direction
	//   - caps
	//   - filterCaps
	TransformInternalCaps func(direction gst.PadDirection, caps, filterCaps *gst.Caps) *gst.Caps
}

func defaultGLFilterOverrides(v *GLFilter) GLFilterOverrides {
	return GLFilterOverrides{
		Filter:                v.filter,
		FilterTexture:         v.filterTexture,
		InitFbo:               v.initFbo,
		SetCaps:               v.setCaps,
		TransformInternalCaps: v.transformInternalCaps,
	}
}

// GLFilter helps to implement simple OpenGL filter elements taking a single
// input and producing a single output with a GLFramebuffer.
type GLFilter struct {
	_ [0]func() // equal guard
	GLBaseFilter
}

var (
	_ gstbase.BaseTransformer = (*GLFilter)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLFilter, *GLFilterClass, GLFilterOverrides](
		GTypeGLFilter,
		initGLFilterClass,
		wrapGLFilter,
		defaultGLFilterOverrides,
	)
}

func initGLFilterClass(gclass unsafe.Pointer, overrides GLFilterOverrides, classInitFunc func(*GLFilterClass)) {
	pclass := (*C.GstGLFilterClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeGLFilter))))

	if overrides.Filter != nil {
		pclass.filter = (*[0]byte)(C._gotk4_gstgl1_GLFilterClass_filter)
	}

	if overrides.FilterTexture != nil {
		pclass.filter_texture = (*[0]byte)(C._gotk4_gstgl1_GLFilterClass_filter_texture)
	}

	if overrides.InitFbo != nil {
		pclass.init_fbo = (*[0]byte)(C._gotk4_gstgl1_GLFilterClass_init_fbo)
	}

	if overrides.SetCaps != nil {
		pclass.set_caps = (*[0]byte)(C._gotk4_gstgl1_GLFilterClass_set_caps)
	}

	if overrides.TransformInternalCaps != nil {
		pclass.transform_internal_caps = (*[0]byte)(C._gotk4_gstgl1_GLFilterClass_transform_internal_caps)
	}

	if classInitFunc != nil {
		class := (*GLFilterClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLFilter(obj *coreglib.Object) *GLFilter {
	return &GLFilter{
		GLBaseFilter: GLBaseFilter{
			BaseTransform: gstbase.BaseTransform{
				Element: gst.Element{
					GstObject: gst.GstObject{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
					},
				},
			},
		},
	}
}

func marshalGLFilter(p uintptr) (interface{}, error) {
	return wrapGLFilter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// DrawFullscreenQuad: render a fullscreen quad using the current GL state.
// The only GL state this modifies is the necessary vertex/index buffers and, if
// necessary, a Vertex Array Object for drawing a fullscreen quad. Framebuffer
// state, any shaders, viewport state, etc must be setup by the caller.
func (filter *GLFilter) DrawFullscreenQuad() {
	var _arg0 *C.GstGLFilter // out

	_arg0 = (*C.GstGLFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	C.gst_gl_filter_draw_fullscreen_quad(_arg0)
	runtime.KeepAlive(filter)
}

// FilterTexture calls filter_texture vfunc with correctly mapped GLMemorys.
//
// The function takes the following parameters:
//
//   - input buffer.
//   - output buffer.
//
// The function returns the following values:
//
//   - ok: whether the transformation succeeded.
func (filter *GLFilter) FilterTexture(input, output *gst.Buffer) bool {
	var _arg0 *C.GstGLFilter // out
	var _arg1 *C.GstBuffer   // out
	var _arg2 *C.GstBuffer   // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGLFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(input)))
	_arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C.gst_gl_filter_filter_texture(_arg0, _arg1, _arg2)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(input)
	runtime.KeepAlive(output)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RenderToTarget transforms input into output using func on through FBO.
//
// The function takes the following parameters:
//
//   - input texture.
//   - output texture.
//   - fn: function to transform input into output. called with data.
//
// The function returns the following values:
//
//   - ok: return value of func.
func (filter *GLFilter) RenderToTarget(input, output *GLMemory, fn GLFilterRenderFunc) bool {
	var _arg0 *C.GstGLFilter          // out
	var _arg1 *C.GstGLMemory          // out
	var _arg2 *C.GstGLMemory          // out
	var _arg3 C.GstGLFilterRenderFunc // out
	var _arg4 C.gpointer
	var _cret C.gboolean // in

	_arg0 = (*C.GstGLFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(input)))
	_arg2 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(output)))
	_arg3 = (*[0]byte)(C._gotk4_gstgl1_GLFilterRenderFunc)
	_arg4 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg4))

	_cret = C.gst_gl_filter_render_to_target(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(input)
	runtime.KeepAlive(output)
	runtime.KeepAlive(fn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RenderToTargetWithShader transforms input into output using shader with a
// FBO.
//
// See also: gst_gl_filter_render_to_target().
//
// The function takes the following parameters:
//
//   - input texture.
//   - output texture.
//   - shader to use.
func (filter *GLFilter) RenderToTargetWithShader(input, output *GLMemory, shader *GLShader) {
	var _arg0 *C.GstGLFilter // out
	var _arg1 *C.GstGLMemory // out
	var _arg2 *C.GstGLMemory // out
	var _arg3 *C.GstGLShader // out

	_arg0 = (*C.GstGLFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(input)))
	_arg2 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(output)))
	_arg3 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))

	C.gst_gl_filter_render_to_target_with_shader(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(input)
	runtime.KeepAlive(output)
	runtime.KeepAlive(shader)
}

// Filter: perform operations on the input and output buffers. In general,
// you should avoid using this method if at all possible. One valid use-case
// for using this is keeping previous buffers for future calculations. Note:
// If filter exists, then filter_texture is not run.
//
// The function takes the following parameters:
//
//   - inbuf
//   - outbuf
func (filter *GLFilter) filter(inbuf, outbuf *gst.Buffer) bool {
	gclass := (*C.GstGLFilterClass)(coreglib.PeekParentClass(filter))
	fnarg := gclass.filter

	var _arg0 *C.GstGLFilter // out
	var _arg1 *C.GstBuffer   // out
	var _arg2 *C.GstBuffer   // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGLFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(inbuf)))
	_arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(outbuf)))

	_cret = C._gotk4_gstgl1_GLFilter_virtual_filter(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(inbuf)
	runtime.KeepAlive(outbuf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// filterTexture calls filter_texture vfunc with correctly mapped GLMemorys.
//
// The function takes the following parameters:
//
//   - input buffer.
//   - output buffer.
//
// The function returns the following values:
//
//   - ok: whether the transformation succeeded.
func (filter *GLFilter) filterTexture(input, output *GLMemory) bool {
	gclass := (*C.GstGLFilterClass)(coreglib.PeekParentClass(filter))
	fnarg := gclass.filter_texture

	var _arg0 *C.GstGLFilter // out
	var _arg1 *C.GstGLMemory // out
	var _arg2 *C.GstGLMemory // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGLFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(input)))
	_arg2 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(output)))

	_cret = C._gotk4_gstgl1_GLFilter_virtual_filter_texture(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(input)
	runtime.KeepAlive(output)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// initFbo: perform initialization when the Framebuffer object is created.
func (filter *GLFilter) initFbo() bool {
	gclass := (*C.GstGLFilterClass)(coreglib.PeekParentClass(filter))
	fnarg := gclass.init_fbo

	var _arg0 *C.GstGLFilter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGLFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	_cret = C._gotk4_gstgl1_GLFilter_virtual_init_fbo(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(filter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// setCaps: mirror from BaseTransform.
//
// The function takes the following parameters:
//
//   - incaps
//   - outcaps
func (filter *GLFilter) setCaps(incaps, outcaps *gst.Caps) bool {
	gclass := (*C.GstGLFilterClass)(coreglib.PeekParentClass(filter))
	fnarg := gclass.set_caps

	var _arg0 *C.GstGLFilter // out
	var _arg1 *C.GstCaps     // out
	var _arg2 *C.GstCaps     // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGLFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(incaps)))
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(outcaps)))

	_cret = C._gotk4_gstgl1_GLFilter_virtual_set_caps(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(incaps)
	runtime.KeepAlive(outcaps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// transformInternalCaps: perform sub-class specific modifications of the caps
// to be processed between upload on input and before download for output.
//
// The function takes the following parameters:
//
//   - direction
//   - caps
//   - filterCaps
func (filter *GLFilter) transformInternalCaps(direction gst.PadDirection, caps, filterCaps *gst.Caps) *gst.Caps {
	gclass := (*C.GstGLFilterClass)(coreglib.PeekParentClass(filter))
	fnarg := gclass.transform_internal_caps

	var _arg0 *C.GstGLFilter    // out
	var _arg1 C.GstPadDirection // out
	var _arg2 *C.GstCaps        // out
	var _arg3 *C.GstCaps        // out
	var _cret *C.GstCaps        // in

	_arg0 = (*C.GstGLFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = C.GstPadDirection(direction)
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filterCaps)))

	_cret = C._gotk4_gstgl1_GLFilter_virtual_transform_internal_caps(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(filterCaps)

	var _ret *gst.Caps // out

	_ret = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _ret
}

func GLFilterAddRGBAPadTemplates(klass *GLFilterClass) {
	var _arg1 *C.GstGLFilterClass // out

	_arg1 = (*C.GstGLFilterClass)(gextras.StructNative(unsafe.Pointer(klass)))

	C.gst_gl_filter_add_rgba_pad_templates(_arg1)
	runtime.KeepAlive(klass)
}

// GLFramebufferOverrides contains methods that are overridable.
type GLFramebufferOverrides struct {
}

func defaultGLFramebufferOverrides(v *GLFramebuffer) GLFramebufferOverrides {
	return GLFramebufferOverrides{}
}

// GLFramebuffer represents and holds an OpenGL framebuffer object with it's
// associated attachments.
//
// A GLFramebuffer can be created with gst_gl_framebuffer_new()
// or gst_gl_framebuffer_new_with_default_depth() and bound with
// gst_gl_framebuffer_bind(). Other resources can be bound with
// gst_gl_framebuffer_attach()
//
// Note: OpenGL framebuffers are not shareable resources so cannot be used
// between multiple OpenGL contexts.
type GLFramebuffer struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*GLFramebuffer)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLFramebuffer, *GLFramebufferClass, GLFramebufferOverrides](
		GTypeGLFramebuffer,
		initGLFramebufferClass,
		wrapGLFramebuffer,
		defaultGLFramebufferOverrides,
	)
}

func initGLFramebufferClass(gclass unsafe.Pointer, overrides GLFramebufferOverrides, classInitFunc func(*GLFramebufferClass)) {
	if classInitFunc != nil {
		class := (*GLFramebufferClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLFramebuffer(obj *coreglib.Object) *GLFramebuffer {
	return &GLFramebuffer{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalGLFramebuffer(p uintptr) (interface{}, error) {
	return wrapGLFramebuffer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewGLFramebuffer: this function will internally create an OpenGL framebuffer
// object and must be called on context's OpenGL thread.
//
// The function takes the following parameters:
//
//   - context: GLContext.
//
// The function returns the following values:
//
//   - glFramebuffer: new GLFramebuffer.
func NewGLFramebuffer(context GLContexter) *GLFramebuffer {
	var _arg1 *C.GstGLContext     // out
	var _cret *C.GstGLFramebuffer // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_framebuffer_new(_arg1)
	runtime.KeepAlive(context)

	var _glFramebuffer *GLFramebuffer // out

	_glFramebuffer = wrapGLFramebuffer(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glFramebuffer
}

// NewGLFramebufferWithDefaultDepth: this function will internally create an
// OpenGL framebuffer object and must be called on context's OpenGL thread.
//
// The function takes the following parameters:
//
//   - context: GLContext.
//   - width for the depth buffer.
//   - height: for the depth buffer.
//
// The function returns the following values:
//
//   - glFramebuffer: new GLFramebuffer with a depth buffer of width and height.
func NewGLFramebufferWithDefaultDepth(context GLContexter, width, height uint) *GLFramebuffer {
	var _arg1 *C.GstGLContext     // out
	var _arg2 C.guint             // out
	var _arg3 C.guint             // out
	var _cret *C.GstGLFramebuffer // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.guint(width)
	_arg3 = C.guint(height)

	_cret = C.gst_gl_framebuffer_new_with_default_depth(_arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)

	var _glFramebuffer *GLFramebuffer // out

	_glFramebuffer = wrapGLFramebuffer(coreglib.Take(unsafe.Pointer(_cret)))

	return _glFramebuffer
}

// Attach: attach mem to attachment_point
//
// Must be called with the same OpenGL context current that fb was created with.
//
// The function takes the following parameters:
//
//   - attachmentPoint: openGL attachment point to bind mem to.
//   - mem: memory object to bind to attachment_point.
func (fb *GLFramebuffer) Attach(attachmentPoint uint, mem *GLBaseMemory) {
	var _arg0 *C.GstGLFramebuffer // out
	var _arg1 C.guint             // out
	var _arg2 *C.GstGLBaseMemory  // out

	_arg0 = (*C.GstGLFramebuffer)(unsafe.Pointer(coreglib.InternObject(fb).Native()))
	_arg1 = C.guint(attachmentPoint)
	_arg2 = (*C.GstGLBaseMemory)(gextras.StructNative(unsafe.Pointer(mem)))

	C.gst_gl_framebuffer_attach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(fb)
	runtime.KeepAlive(attachmentPoint)
	runtime.KeepAlive(mem)
}

// Bind fb into the current thread
//
// Must be called with the same OpenGL context current that fb was created with.
func (fb *GLFramebuffer) Bind() {
	var _arg0 *C.GstGLFramebuffer // out

	_arg0 = (*C.GstGLFramebuffer)(unsafe.Pointer(coreglib.InternObject(fb).Native()))

	C.gst_gl_framebuffer_bind(_arg0)
	runtime.KeepAlive(fb)
}

// EffectiveDimensions: retrieve the effective dimensions from the current
// attachments attached to fb.
//
// The function returns the following values:
//
//   - width (optional): output width.
//   - height (optional): output height.
func (fb *GLFramebuffer) EffectiveDimensions() (width, height uint) {
	var _arg0 *C.GstGLFramebuffer // out
	var _arg1 C.guint             // in
	var _arg2 C.guint             // in

	_arg0 = (*C.GstGLFramebuffer)(unsafe.Pointer(coreglib.InternObject(fb).Native()))

	C.gst_gl_framebuffer_get_effective_dimensions(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(fb)

	var _width uint  // out
	var _height uint // out

	_width = uint(_arg1)
	_height = uint(_arg2)

	return _width, _height
}

// The function returns the following values:
//
//   - guint: openGL id for fb.
func (fb *GLFramebuffer) ID() uint {
	var _arg0 *C.GstGLFramebuffer // out
	var _cret C.guint             // in

	_arg0 = (*C.GstGLFramebuffer)(unsafe.Pointer(coreglib.InternObject(fb).Native()))

	_cret = C.gst_gl_framebuffer_get_id(_arg0)
	runtime.KeepAlive(fb)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// GLMemoryAllocatorOverrides contains methods that are overridable.
type GLMemoryAllocatorOverrides struct {
}

func defaultGLMemoryAllocatorOverrides(v *GLMemoryAllocator) GLMemoryAllocatorOverrides {
	return GLMemoryAllocatorOverrides{}
}

// GLMemoryAllocator: opaque GLMemoryAllocator struct.
type GLMemoryAllocator struct {
	_ [0]func() // equal guard
	GLBaseMemoryAllocator
}

var (
	_ GLBaseMemoryAllocatorrer = (*GLMemoryAllocator)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLMemoryAllocator, *GLMemoryAllocatorClass, GLMemoryAllocatorOverrides](
		GTypeGLMemoryAllocator,
		initGLMemoryAllocatorClass,
		wrapGLMemoryAllocator,
		defaultGLMemoryAllocatorOverrides,
	)
}

func initGLMemoryAllocatorClass(gclass unsafe.Pointer, overrides GLMemoryAllocatorOverrides, classInitFunc func(*GLMemoryAllocatorClass)) {
	if classInitFunc != nil {
		class := (*GLMemoryAllocatorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLMemoryAllocator(obj *coreglib.Object) *GLMemoryAllocator {
	return &GLMemoryAllocator{
		GLBaseMemoryAllocator: GLBaseMemoryAllocator{
			Allocator: gst.Allocator{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalGLMemoryAllocator(p uintptr) (interface{}, error) {
	return wrapGLMemoryAllocator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function takes the following parameters:
//
//   - context: GLContext.
//
// The function returns the following values:
//
//   - glMemoryAllocator: default GLMemoryAllocator supported by context.
func GLMemoryAllocatorGetDefault(context GLContexter) *GLMemoryAllocator {
	var _arg1 *C.GstGLContext         // out
	var _cret *C.GstGLMemoryAllocator // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_memory_allocator_get_default(_arg1)
	runtime.KeepAlive(context)

	var _glMemoryAllocator *GLMemoryAllocator // out

	_glMemoryAllocator = wrapGLMemoryAllocator(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glMemoryAllocator
}

// GLMemoryPBOAllocatorOverrides contains methods that are overridable.
type GLMemoryPBOAllocatorOverrides struct {
}

func defaultGLMemoryPBOAllocatorOverrides(v *GLMemoryPBOAllocator) GLMemoryPBOAllocatorOverrides {
	return GLMemoryPBOAllocatorOverrides{}
}

// GLMemoryPBOAllocator: opaque GLMemoryPBOAllocator struct.
type GLMemoryPBOAllocator struct {
	_ [0]func() // equal guard
	GLMemoryAllocator
}

var (
	_ GLBaseMemoryAllocatorrer = (*GLMemoryPBOAllocator)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLMemoryPBOAllocator, *GLMemoryPBOAllocatorClass, GLMemoryPBOAllocatorOverrides](
		GTypeGLMemoryPBOAllocator,
		initGLMemoryPBOAllocatorClass,
		wrapGLMemoryPBOAllocator,
		defaultGLMemoryPBOAllocatorOverrides,
	)
}

func initGLMemoryPBOAllocatorClass(gclass unsafe.Pointer, overrides GLMemoryPBOAllocatorOverrides, classInitFunc func(*GLMemoryPBOAllocatorClass)) {
	if classInitFunc != nil {
		class := (*GLMemoryPBOAllocatorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLMemoryPBOAllocator(obj *coreglib.Object) *GLMemoryPBOAllocator {
	return &GLMemoryPBOAllocator{
		GLMemoryAllocator: GLMemoryAllocator{
			GLBaseMemoryAllocator: GLBaseMemoryAllocator{
				Allocator: gst.Allocator{
					GstObject: gst.GstObject{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
					},
				},
			},
		},
	}
}

func marshalGLMemoryPBOAllocator(p uintptr) (interface{}, error) {
	return wrapGLMemoryPBOAllocator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// GLMixerOverrides contains methods that are overridable.
type GLMixerOverrides struct {
	// ProcessBuffers: perform operations on the input buffers to produce an
	// output buffer.
	ProcessBuffers func(outbuf *gst.Buffer) bool
	// ProcessTextures: perform processing required and call
	// GLMixerClass::process_textures(). Intended for use within implementations
	// of GLMixerClass::process_buffers().
	//
	// The function returns the following values:
	//
	//   - ok: whether processing of textures succeeded.
	ProcessTextures func(outTex *GLMemory) bool
}

func defaultGLMixerOverrides(v *GLMixer) GLMixerOverrides {
	return GLMixerOverrides{
		ProcessBuffers:  v.processBuffers,
		ProcessTextures: v.processTextures,
	}
}

// GLMixer helps implement an element that operates on RGBA textures.
type GLMixer struct {
	_ [0]func() // equal guard
	GLBaseMixer
}

var (
	_ GLBaseMixerer = (*GLMixer)(nil)
)

// GLMixerer describes types inherited from class GLMixer.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type GLMixerer interface {
	coreglib.Objector
	baseGLMixer() *GLMixer
}

var _ GLMixerer = (*GLMixer)(nil)

func init() {
	coreglib.RegisterClassInfo[*GLMixer, *GLMixerClass, GLMixerOverrides](
		GTypeGLMixer,
		initGLMixerClass,
		wrapGLMixer,
		defaultGLMixerOverrides,
	)
}

func initGLMixerClass(gclass unsafe.Pointer, overrides GLMixerOverrides, classInitFunc func(*GLMixerClass)) {
	pclass := (*C.GstGLMixerClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeGLMixer))))

	if overrides.ProcessBuffers != nil {
		pclass.process_buffers = (*[0]byte)(C._gotk4_gstgl1_GLMixerClass_process_buffers)
	}

	if overrides.ProcessTextures != nil {
		pclass.process_textures = (*[0]byte)(C._gotk4_gstgl1_GLMixerClass_process_textures)
	}

	if classInitFunc != nil {
		class := (*GLMixerClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLMixer(obj *coreglib.Object) *GLMixer {
	return &GLMixer{
		GLBaseMixer: GLBaseMixer{
			VideoAggregator: gstvideo.VideoAggregator{
				Aggregator: gstbase.Aggregator{
					Element: gst.Element{
						GstObject: gst.GstObject{
							InitiallyUnowned: coreglib.InitiallyUnowned{
								Object: obj,
							},
						},
					},
				},
			},
		},
	}
}

func marshalGLMixer(p uintptr) (interface{}, error) {
	return wrapGLMixer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (mix *GLMixer) baseGLMixer() *GLMixer {
	return mix
}

// BaseGLMixer returns the underlying base object.
func BaseGLMixer(obj GLMixerer) *GLMixer {
	return obj.baseGLMixer()
}

// The function returns the following values:
//
//   - glFramebuffer: (nullable): The GLFramebuffer in use by this mix.
func (mix *GLMixer) Framebuffer() *GLFramebuffer {
	var _arg0 *C.GstGLMixer       // out
	var _cret *C.GstGLFramebuffer // in

	_arg0 = (*C.GstGLMixer)(unsafe.Pointer(coreglib.InternObject(mix).Native()))

	_cret = C.gst_gl_mixer_get_framebuffer(_arg0)
	runtime.KeepAlive(mix)

	var _glFramebuffer *GLFramebuffer // out

	_glFramebuffer = wrapGLFramebuffer(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glFramebuffer
}

// ProcessTextures: perform processing required and call
// GLMixerClass::process_textures(). Intended for use within implementations of
// GLMixerClass::process_buffers().
//
// The function takes the following parameters:
//
//   - outbuf: output GstBuffer.
//
// The function returns the following values:
//
//   - ok: whether processing of textures succeeded.
func (mix *GLMixer) ProcessTextures(outbuf *gst.Buffer) bool {
	var _arg0 *C.GstGLMixer // out
	var _arg1 *C.GstBuffer  // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstGLMixer)(unsafe.Pointer(coreglib.InternObject(mix).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(outbuf)))

	_cret = C.gst_gl_mixer_process_textures(_arg0, _arg1)
	runtime.KeepAlive(mix)
	runtime.KeepAlive(outbuf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// processBuffers: perform operations on the input buffers to produce an output
// buffer.
func (mix *GLMixer) processBuffers(outbuf *gst.Buffer) bool {
	gclass := (*C.GstGLMixerClass)(coreglib.PeekParentClass(mix))
	fnarg := gclass.process_buffers

	var _arg0 *C.GstGLMixer // out
	var _arg1 *C.GstBuffer  // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GstGLMixer)(unsafe.Pointer(coreglib.InternObject(mix).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(outbuf)))

	_cret = C._gotk4_gstgl1_GLMixer_virtual_process_buffers(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(mix)
	runtime.KeepAlive(outbuf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// processTextures: perform processing required and call
// GLMixerClass::process_textures(). Intended for use within implementations of
// GLMixerClass::process_buffers().
//
// The function returns the following values:
//
//   - ok: whether processing of textures succeeded.
func (mix *GLMixer) processTextures(outTex *GLMemory) bool {
	gclass := (*C.GstGLMixerClass)(coreglib.PeekParentClass(mix))
	fnarg := gclass.process_textures

	var _arg0 *C.GstGLMixer  // out
	var _arg1 *C.GstGLMemory // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGLMixer)(unsafe.Pointer(coreglib.InternObject(mix).Native()))
	_arg1 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(outTex)))

	_cret = C._gotk4_gstgl1_GLMixer_virtual_process_textures(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(mix)
	runtime.KeepAlive(outTex)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GLMixerPadOverrides contains methods that are overridable.
type GLMixerPadOverrides struct {
}

func defaultGLMixerPadOverrides(v *GLMixerPad) GLMixerPadOverrides {
	return GLMixerPadOverrides{}
}

type GLMixerPad struct {
	_ [0]func() // equal guard
	GLBaseMixerPad
}

var (
	_ gst.GstObjector = (*GLMixerPad)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLMixerPad, *GLMixerPadClass, GLMixerPadOverrides](
		GTypeGLMixerPad,
		initGLMixerPadClass,
		wrapGLMixerPad,
		defaultGLMixerPadOverrides,
	)
}

func initGLMixerPadClass(gclass unsafe.Pointer, overrides GLMixerPadOverrides, classInitFunc func(*GLMixerPadClass)) {
	if classInitFunc != nil {
		class := (*GLMixerPadClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLMixerPad(obj *coreglib.Object) *GLMixerPad {
	return &GLMixerPad{
		GLBaseMixerPad: GLBaseMixerPad{
			VideoAggregatorPad: gstvideo.VideoAggregatorPad{
				AggregatorPad: gstbase.AggregatorPad{
					Pad: gst.Pad{
						GstObject: gst.GstObject{
							InitiallyUnowned: coreglib.InitiallyUnowned{
								Object: obj,
							},
						},
					},
				},
			},
		},
	}
}

func marshalGLMixerPad(p uintptr) (interface{}, error) {
	return wrapGLMixerPad(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// GLOverlayCompositorOverrides contains methods that are overridable.
type GLOverlayCompositorOverrides struct {
}

func defaultGLOverlayCompositorOverrides(v *GLOverlayCompositor) GLOverlayCompositorOverrides {
	return GLOverlayCompositorOverrides{}
}

// GLOverlayCompositor: opaque GLOverlayCompositor object.
type GLOverlayCompositor struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*GLOverlayCompositor)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLOverlayCompositor, *GLOverlayCompositorClass, GLOverlayCompositorOverrides](
		GTypeGLOverlayCompositor,
		initGLOverlayCompositorClass,
		wrapGLOverlayCompositor,
		defaultGLOverlayCompositorOverrides,
	)
}

func initGLOverlayCompositorClass(gclass unsafe.Pointer, overrides GLOverlayCompositorOverrides, classInitFunc func(*GLOverlayCompositorClass)) {
	if classInitFunc != nil {
		class := (*GLOverlayCompositorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLOverlayCompositor(obj *coreglib.Object) *GLOverlayCompositor {
	return &GLOverlayCompositor{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalGLOverlayCompositor(p uintptr) (interface{}, error) {
	return wrapGLOverlayCompositor(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func NewGLOverlayCompositor(context GLContexter) *GLOverlayCompositor {
	var _arg1 *C.GstGLContext           // out
	var _cret *C.GstGLOverlayCompositor // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_overlay_compositor_new(_arg1)
	runtime.KeepAlive(context)

	var _glOverlayCompositor *GLOverlayCompositor // out

	_glOverlayCompositor = wrapGLOverlayCompositor(coreglib.Take(unsafe.Pointer(_cret)))

	return _glOverlayCompositor
}

func (compositor *GLOverlayCompositor) DrawOverlays() {
	var _arg0 *C.GstGLOverlayCompositor // out

	_arg0 = (*C.GstGLOverlayCompositor)(unsafe.Pointer(coreglib.InternObject(compositor).Native()))

	C.gst_gl_overlay_compositor_draw_overlays(_arg0)
	runtime.KeepAlive(compositor)
}

func (compositor *GLOverlayCompositor) FreeOverlays() {
	var _arg0 *C.GstGLOverlayCompositor // out

	_arg0 = (*C.GstGLOverlayCompositor)(unsafe.Pointer(coreglib.InternObject(compositor).Native()))

	C.gst_gl_overlay_compositor_free_overlays(_arg0)
	runtime.KeepAlive(compositor)
}

func (compositor *GLOverlayCompositor) UploadOverlays(buf *gst.Buffer) {
	var _arg0 *C.GstGLOverlayCompositor // out
	var _arg1 *C.GstBuffer              // out

	_arg0 = (*C.GstGLOverlayCompositor)(unsafe.Pointer(coreglib.InternObject(compositor).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buf)))

	C.gst_gl_overlay_compositor_upload_overlays(_arg0, _arg1)
	runtime.KeepAlive(compositor)
	runtime.KeepAlive(buf)
}

func GLOverlayCompositorAddCaps(caps *gst.Caps) *gst.Caps {
	var _arg1 *C.GstCaps // out
	var _cret *C.GstCaps // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_gl_overlay_compositor_add_caps(_arg1)
	runtime.KeepAlive(caps)

	var _ret *gst.Caps // out

	_ret = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _ret
}

// GLRenderbufferAllocatorOverrides contains methods that are overridable.
type GLRenderbufferAllocatorOverrides struct {
}

func defaultGLRenderbufferAllocatorOverrides(v *GLRenderbufferAllocator) GLRenderbufferAllocatorOverrides {
	return GLRenderbufferAllocatorOverrides{}
}

// GLRenderbufferAllocator: opaque GLRenderbufferAllocator struct.
type GLRenderbufferAllocator struct {
	_ [0]func() // equal guard
	GLBaseMemoryAllocator
}

var (
	_ GLBaseMemoryAllocatorrer = (*GLRenderbufferAllocator)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLRenderbufferAllocator, *GLRenderbufferAllocatorClass, GLRenderbufferAllocatorOverrides](
		GTypeGLRenderbufferAllocator,
		initGLRenderbufferAllocatorClass,
		wrapGLRenderbufferAllocator,
		defaultGLRenderbufferAllocatorOverrides,
	)
}

func initGLRenderbufferAllocatorClass(gclass unsafe.Pointer, overrides GLRenderbufferAllocatorOverrides, classInitFunc func(*GLRenderbufferAllocatorClass)) {
	if classInitFunc != nil {
		class := (*GLRenderbufferAllocatorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLRenderbufferAllocator(obj *coreglib.Object) *GLRenderbufferAllocator {
	return &GLRenderbufferAllocator{
		GLBaseMemoryAllocator: GLBaseMemoryAllocator{
			Allocator: gst.Allocator{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalGLRenderbufferAllocator(p uintptr) (interface{}, error) {
	return wrapGLRenderbufferAllocator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// GLSLStageOverrides contains methods that are overridable.
type GLSLStageOverrides struct {
}

func defaultGLSLStageOverrides(v *GLSLStage) GLSLStageOverrides {
	return GLSLStageOverrides{}
}

// GLSLStage holds and represents a single OpenGL shader stage.
type GLSLStage struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*GLSLStage)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLSLStage, *GLSLStageClass, GLSLStageOverrides](
		GTypeGLSLStage,
		initGLSLStageClass,
		wrapGLSLStage,
		defaultGLSLStageOverrides,
	)
}

func initGLSLStageClass(gclass unsafe.Pointer, overrides GLSLStageOverrides, classInitFunc func(*GLSLStageClass)) {
	if classInitFunc != nil {
		class := (*GLSLStageClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLSLStage(obj *coreglib.Object) *GLSLStage {
	return &GLSLStage{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalGLSLStage(p uintptr) (interface{}, error) {
	return wrapGLSLStage(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function takes the following parameters:
//
//   - context: GLContext.
//   - typ: GL enum shader stage type.
//
// The function returns the following values:
//
//   - glslStage: new GLSLStage of the specified type.
func NewGLSLStage(context GLContexter, typ uint) *GLSLStage {
	var _arg1 *C.GstGLContext // out
	var _arg2 C.guint         // out
	var _cret *C.GstGLSLStage // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.guint(typ)

	_cret = C.gst_glsl_stage_new(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(typ)

	var _glslStage *GLSLStage // out

	_glslStage = wrapGLSLStage(coreglib.Take(unsafe.Pointer(_cret)))

	return _glslStage
}

// The function takes the following parameters:
//
//   - context: GLContext.
//
// The function returns the following values:
//
//   - glslStage: new GLSLStage with the default fragment shader.
func NewGLSLStageDefaultFragment(context GLContexter) *GLSLStage {
	var _arg1 *C.GstGLContext // out
	var _cret *C.GstGLSLStage // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_glsl_stage_new_default_fragment(_arg1)
	runtime.KeepAlive(context)

	var _glslStage *GLSLStage // out

	_glslStage = wrapGLSLStage(coreglib.Take(unsafe.Pointer(_cret)))

	return _glslStage
}

// The function takes the following parameters:
//
//   - context: GLContext.
//
// The function returns the following values:
//
//   - glslStage: new GLSLStage with the default vertex shader.
func NewGLSLStageDefaultVertex(context GLContexter) *GLSLStage {
	var _arg1 *C.GstGLContext // out
	var _cret *C.GstGLSLStage // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_glsl_stage_new_default_vertex(_arg1)
	runtime.KeepAlive(context)

	var _glslStage *GLSLStage // out

	_glslStage = wrapGLSLStage(coreglib.Take(unsafe.Pointer(_cret)))

	return _glslStage
}

// The function takes the following parameters:
//
//   - context: GLContext.
//   - typ: GL enum shader stage type.
//   - version: GLSLVersion.
//   - profile: GLSLProfile.
//   - str: shader string.
//
// The function returns the following values:
//
//   - glslStage: new GLSLStage of the specified type.
func NewGLSLStageWithString(context GLContexter, typ uint, version GLSLVersion, profile GLSLProfile, str string) *GLSLStage {
	var _arg1 *C.GstGLContext  // out
	var _arg2 C.guint          // out
	var _arg3 C.GstGLSLVersion // out
	var _arg4 C.GstGLSLProfile // out
	var _arg5 *C.gchar         // out
	var _cret *C.GstGLSLStage  // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.guint(typ)
	_arg3 = C.GstGLSLVersion(version)
	_arg4 = C.GstGLSLProfile(profile)
	_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg5))

	_cret = C.gst_glsl_stage_new_with_string(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(context)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(version)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(str)

	var _glslStage *GLSLStage // out

	_glslStage = wrapGLSLStage(coreglib.Take(unsafe.Pointer(_cret)))

	return _glslStage
}

// The function takes the following parameters:
//
//   - context: GLContext.
//   - typ: GL enum shader stage type.
//   - version: GLSLVersion.
//   - profile: GLSLProfile.
//   - str: an array of strings concatted together to produce a shader.
//
// The function returns the following values:
//
//   - glslStage: new GLSLStage of the specified type.
func NewGLSLStageWithStrings(context GLContexter, typ uint, version GLSLVersion, profile GLSLProfile, str []string) *GLSLStage {
	var _arg1 *C.GstGLContext  // out
	var _arg2 C.guint          // out
	var _arg3 C.GstGLSLVersion // out
	var _arg4 C.GstGLSLProfile // out
	var _arg6 **C.gchar        // out
	var _arg5 C.gint
	var _cret *C.GstGLSLStage // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.guint(typ)
	_arg3 = C.GstGLSLVersion(version)
	_arg4 = C.GstGLSLProfile(profile)
	_arg5 = (C.gint)(len(str))
	_arg6 = (**C.gchar)(C.calloc(C.size_t(len(str)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg6))
	{
		out := unsafe.Slice((**C.gchar)(_arg6), len(str))
		for i := range str {
			out[i] = (*C.gchar)(unsafe.Pointer(C.CString(str[i])))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.gst_glsl_stage_new_with_strings(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(context)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(version)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(str)

	var _glslStage *GLSLStage // out

	_glslStage = wrapGLSLStage(coreglib.Take(unsafe.Pointer(_cret)))

	return _glslStage
}

func (stage *GLSLStage) Compile() error {
	var _arg0 *C.GstGLSLStage // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GstGLSLStage)(unsafe.Pointer(coreglib.InternObject(stage).Native()))

	C.gst_glsl_stage_compile(_arg0, &_cerr)
	runtime.KeepAlive(stage)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// The function returns the following values:
//
//   - guint: GL handle for this shader stage.
func (stage *GLSLStage) Handle() uint {
	var _arg0 *C.GstGLSLStage // out
	var _cret C.guint         // in

	_arg0 = (*C.GstGLSLStage)(unsafe.Pointer(coreglib.InternObject(stage).Native()))

	_cret = C.gst_glsl_stage_get_handle(_arg0)
	runtime.KeepAlive(stage)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - glslProfile: GLSL profile for the current shader stage.
func (stage *GLSLStage) Profile() GLSLProfile {
	var _arg0 *C.GstGLSLStage  // out
	var _cret C.GstGLSLProfile // in

	_arg0 = (*C.GstGLSLStage)(unsafe.Pointer(coreglib.InternObject(stage).Native()))

	_cret = C.gst_glsl_stage_get_profile(_arg0)
	runtime.KeepAlive(stage)

	var _glslProfile GLSLProfile // out

	_glslProfile = GLSLProfile(_cret)

	return _glslProfile
}

// The function returns the following values:
//
//   - guint: GL shader type for this shader stage.
func (stage *GLSLStage) ShaderType() uint {
	var _arg0 *C.GstGLSLStage // out
	var _cret C.guint         // in

	_arg0 = (*C.GstGLSLStage)(unsafe.Pointer(coreglib.InternObject(stage).Native()))

	_cret = C.gst_glsl_stage_get_shader_type(_arg0)
	runtime.KeepAlive(stage)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - glslVersion: GLSL version for the current shader stage.
func (stage *GLSLStage) Version() GLSLVersion {
	var _arg0 *C.GstGLSLStage  // out
	var _cret C.GstGLSLVersion // in

	_arg0 = (*C.GstGLSLStage)(unsafe.Pointer(coreglib.InternObject(stage).Native()))

	_cret = C.gst_glsl_stage_get_version(_arg0)
	runtime.KeepAlive(stage)

	var _glslVersion GLSLVersion // out

	_glslVersion = GLSLVersion(_cret)

	return _glslVersion
}

// SetStrings replaces the current shader string with str.
//
// The function takes the following parameters:
//
//   - version: GLSLVersion.
//   - profile: GLSLProfile.
//   - str: GLSL shader string.
func (stage *GLSLStage) SetStrings(version GLSLVersion, profile GLSLProfile, str []string) bool {
	var _arg0 *C.GstGLSLStage  // out
	var _arg1 C.GstGLSLVersion // out
	var _arg2 C.GstGLSLProfile // out
	var _arg4 **C.gchar        // out
	var _arg3 C.gint
	var _cret C.gboolean // in

	_arg0 = (*C.GstGLSLStage)(unsafe.Pointer(coreglib.InternObject(stage).Native()))
	_arg1 = C.GstGLSLVersion(version)
	_arg2 = C.GstGLSLProfile(profile)
	_arg3 = (C.gint)(len(str))
	_arg4 = (**C.gchar)(C.calloc(C.size_t(len(str)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((**C.gchar)(_arg4), len(str))
		for i := range str {
			out[i] = (*C.gchar)(unsafe.Pointer(C.CString(str[i])))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.gst_glsl_stage_set_strings(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(stage)
	runtime.KeepAlive(version)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(str)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GLShaderOverrides contains methods that are overridable.
type GLShaderOverrides struct {
}

func defaultGLShaderOverrides(v *GLShader) GLShaderOverrides {
	return GLShaderOverrides{}
}

type GLShader struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*GLShader)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLShader, *GLShaderClass, GLShaderOverrides](
		GTypeGLShader,
		initGLShaderClass,
		wrapGLShader,
		defaultGLShaderOverrides,
	)
}

func initGLShaderClass(gclass unsafe.Pointer, overrides GLShaderOverrides, classInitFunc func(*GLShaderClass)) {
	if classInitFunc != nil {
		class := (*GLShaderClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLShader(obj *coreglib.Object) *GLShader {
	return &GLShader{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalGLShader(p uintptr) (interface{}, error) {
	return wrapGLShader(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewGLShader: note: must be called in the GL thread.
//
// The function takes the following parameters:
//
//   - context: GLContext.
//
// The function returns the following values:
//
//   - glShader: new empty shader.
func NewGLShader(context GLContexter) *GLShader {
	var _arg1 *C.GstGLContext // out
	var _cret *C.GstGLShader  // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_shader_new(_arg1)
	runtime.KeepAlive(context)

	var _glShader *GLShader // out

	_glShader = wrapGLShader(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glShader
}

// NewGLShaderDefault: note: must be called in the GL thread.
//
// The function takes the following parameters:
//
//   - context: GLContext.
//
// The function returns the following values:
//
//   - glShader: default shader or NULL on failure.
func NewGLShaderDefault(context GLContexter) (*GLShader, error) {
	var _arg1 *C.GstGLContext // out
	var _cret *C.GstGLShader  // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_shader_new_default(_arg1, &_cerr)
	runtime.KeepAlive(context)

	var _glShader *GLShader // out
	var _goerr error        // out

	_glShader = wrapGLShader(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _glShader, _goerr
}

// Attach attaches stage to shader. stage must have been successfully compiled
// with gst_glsl_stage_compile().
//
// Note: must be called in the GL thread.
//
// The function takes the following parameters:
//
//   - stage to attach.
//
// The function returns the following values:
//
//   - ok: whether stage could be attached to shader.
func (shader *GLShader) Attach(stage *GLSLStage) bool {
	var _arg0 *C.GstGLShader  // out
	var _arg1 *C.GstGLSLStage // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.GstGLSLStage)(unsafe.Pointer(coreglib.InternObject(stage).Native()))

	_cret = C.gst_gl_shader_attach(_arg0, _arg1)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(stage)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AttachUnlocked attaches stage to shader. stage must have been successfully
// compiled with gst_glsl_stage_compile().
//
// Note: must be called in the GL thread.
//
// The function takes the following parameters:
//
//   - stage to attach.
//
// The function returns the following values:
//
//   - ok: whether stage could be attached to shader.
func (shader *GLShader) AttachUnlocked(stage *GLSLStage) bool {
	var _arg0 *C.GstGLShader  // out
	var _arg1 *C.GstGLSLStage // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.GstGLSLStage)(unsafe.Pointer(coreglib.InternObject(stage).Native()))

	_cret = C.gst_gl_shader_attach_unlocked(_arg0, _arg1)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(stage)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BindAttributeLocation: bind attribute name to the specified location index
// using glBindAttributeLocation().
//
// The function takes the following parameters:
//
//   - index: attribute index to set.
//   - name of the attribute.
func (shader *GLShader) BindAttributeLocation(index uint, name string) {
	var _arg0 *C.GstGLShader // out
	var _arg1 C.guint        // out
	var _arg2 *C.gchar       // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = C.guint(index)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gst_gl_shader_bind_attribute_location(_arg0, _arg1, _arg2)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(index)
	runtime.KeepAlive(name)
}

// BindFragDataLocation: bind attribute name to the specified location index
// using glBindFragDataLocation().
//
// The function takes the following parameters:
//
//   - index: attribute index to set.
//   - name of the attribute.
func (shader *GLShader) BindFragDataLocation(index uint, name string) {
	var _arg0 *C.GstGLShader // out
	var _arg1 C.guint        // out
	var _arg2 *C.gchar       // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = C.guint(index)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gst_gl_shader_bind_frag_data_location(_arg0, _arg1, _arg2)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(index)
	runtime.KeepAlive(name)
}

// CompileAttachStage compiles stage and attaches it to shader.
//
// Note: must be called in the GL thread.
//
// The function takes the following parameters:
//
//   - stage to attach.
func (shader *GLShader) CompileAttachStage(stage *GLSLStage) error {
	var _arg0 *C.GstGLShader  // out
	var _arg1 *C.GstGLSLStage // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.GstGLSLStage)(unsafe.Pointer(coreglib.InternObject(stage).Native()))

	C.gst_gl_shader_compile_attach_stage(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(stage)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Detach detaches stage from shader. stage must have been successfully attached
// to shader with gst_gl_shader_attach() or gst_gl_shader_attach_unlocked().
//
// Note: must be called in the GL thread.
//
// The function takes the following parameters:
//
//   - stage to attach.
func (shader *GLShader) Detach(stage *GLSLStage) {
	var _arg0 *C.GstGLShader  // out
	var _arg1 *C.GstGLSLStage // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.GstGLSLStage)(unsafe.Pointer(coreglib.InternObject(stage).Native()))

	C.gst_gl_shader_detach(_arg0, _arg1)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(stage)
}

// DetachUnlocked detaches stage from shader. stage must have been
// successfully attached to shader with gst_gl_shader_attach() or
// gst_gl_shader_attach_unlocked().
//
// Note: must be called in the GL thread.
//
// The function takes the following parameters:
//
//   - stage to attach.
func (shader *GLShader) DetachUnlocked(stage *GLSLStage) {
	var _arg0 *C.GstGLShader  // out
	var _arg1 *C.GstGLSLStage // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.GstGLSLStage)(unsafe.Pointer(coreglib.InternObject(stage).Native()))

	C.gst_gl_shader_detach_unlocked(_arg0, _arg1)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(stage)
}

// The function takes the following parameters:
//
//   - name of the attribute.
//
// The function returns the following values:
//
//   - gint: attribute index for name in shader or -1 on failure.
func (shader *GLShader) AttributeLocation(name string) int {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _cret C.gint         // in

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_gl_shader_get_attribute_location(_arg0, _arg1)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
//   - gint: GL program handle for this shader.
func (shader *GLShader) ProgramHandle() int {
	var _arg0 *C.GstGLShader // out
	var _cret C.int          // in

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))

	_cret = C.gst_gl_shader_get_program_handle(_arg0)
	runtime.KeepAlive(shader)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IsLinked: note: must be called in the GL thread.
//
// The function returns the following values:
//
//   - ok: whether shader has been successfully linked.
func (shader *GLShader) IsLinked() bool {
	var _arg0 *C.GstGLShader // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))

	_cret = C.gst_gl_shader_is_linked(_arg0)
	runtime.KeepAlive(shader)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Link links the current list of GLSLStage's in shader.
//
// Note: must be called in the GL thread.
func (shader *GLShader) Link() error {
	var _arg0 *C.GstGLShader // out
	var _cerr *C.GError      // in

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))

	C.gst_gl_shader_link(_arg0, &_cerr)
	runtime.KeepAlive(shader)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Release releases the shader and stages.
//
// Note: must be called in the GL thread.
func (shader *GLShader) Release() {
	var _arg0 *C.GstGLShader // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))

	C.gst_gl_shader_release(_arg0)
	runtime.KeepAlive(shader)
}

// ReleaseUnlocked releases the shader and stages.
//
// Note: must be called in the GL thread.
func (shader *GLShader) ReleaseUnlocked() {
	var _arg0 *C.GstGLShader // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))

	C.gst_gl_shader_release_unlocked(_arg0)
	runtime.KeepAlive(shader)
}

// SetUniform1F: perform glUniform1f() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - value to set.
func (shader *GLShader) SetUniform1F(name string, value float32) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg2 C.gfloat       // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gfloat(value)

	C.gst_gl_shader_set_uniform_1f(_arg0, _arg1, _arg2)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(value)
}

// SetUniform1Fv: perform glUniform1fv() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - value values to set.
func (shader *GLShader) SetUniform1Fv(name string, value []float32) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg3 *C.gfloat      // out
	var _arg2 C.guint

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint)(len(value))
	if len(value) > 0 {
		_arg3 = (*C.gfloat)(unsafe.Pointer(&value[0]))
	}

	C.gst_gl_shader_set_uniform_1fv(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(value)
}

// SetUniform1I: perform glUniform1i() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - value to set.
func (shader *GLShader) SetUniform1I(name string, value int) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg2 C.gint         // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(value)

	C.gst_gl_shader_set_uniform_1i(_arg0, _arg1, _arg2)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(value)
}

// SetUniform1Iv: perform glUniform1iv() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - value values to set.
func (shader *GLShader) SetUniform1Iv(name string, value []int) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg3 *C.gint        // out
	var _arg2 C.guint

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint)(len(value))
	_arg3 = (*C.gint)(C.calloc(C.size_t(len(value)), C.size_t(C.sizeof_gint)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice((*C.gint)(_arg3), len(value))
		for i := range value {
			out[i] = C.gint(value[i])
		}
	}

	C.gst_gl_shader_set_uniform_1iv(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(value)
}

// SetUniform2F: perform glUniform2f() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - v0: first value to set.
//   - v1: second value to set.
func (shader *GLShader) SetUniform2F(name string, v0, v1 float32) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg2 C.gfloat       // out
	var _arg3 C.gfloat       // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gfloat(v0)
	_arg3 = C.gfloat(v1)

	C.gst_gl_shader_set_uniform_2f(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(v0)
	runtime.KeepAlive(v1)
}

// SetUniform2Fv: perform glUniform2fv() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - value values to set.
func (shader *GLShader) SetUniform2Fv(name string, value []float32) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg3 *C.gfloat      // out
	var _arg2 C.guint

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint)(len(value))
	if len(value) > 0 {
		_arg3 = (*C.gfloat)(unsafe.Pointer(&value[0]))
	}

	C.gst_gl_shader_set_uniform_2fv(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(value)
}

// SetUniform2I: perform glUniform2i() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - v0: first value to set.
//   - v1: second value to set.
func (shader *GLShader) SetUniform2I(name string, v0, v1 int) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg2 C.gint         // out
	var _arg3 C.gint         // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(v0)
	_arg3 = C.gint(v1)

	C.gst_gl_shader_set_uniform_2i(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(v0)
	runtime.KeepAlive(v1)
}

// SetUniform2Iv: perform glUniform2iv() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - value values to set.
func (shader *GLShader) SetUniform2Iv(name string, value []int) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg3 *C.gint        // out
	var _arg2 C.guint

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint)(len(value))
	_arg3 = (*C.gint)(C.calloc(C.size_t(len(value)), C.size_t(C.sizeof_gint)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice((*C.gint)(_arg3), len(value))
		for i := range value {
			out[i] = C.gint(value[i])
		}
	}

	C.gst_gl_shader_set_uniform_2iv(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(value)
}

// SetUniform3F: perform glUniform3f() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - v0: first value to set.
//   - v1: second value to set.
//   - v2: third value to set.
func (shader *GLShader) SetUniform3F(name string, v0, v1, v2 float32) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg2 C.gfloat       // out
	var _arg3 C.gfloat       // out
	var _arg4 C.gfloat       // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gfloat(v0)
	_arg3 = C.gfloat(v1)
	_arg4 = C.gfloat(v2)

	C.gst_gl_shader_set_uniform_3f(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(v0)
	runtime.KeepAlive(v1)
	runtime.KeepAlive(v2)
}

// SetUniform3Fv: perform glUniform3fv() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - value values to set.
func (shader *GLShader) SetUniform3Fv(name string, value []float32) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg3 *C.gfloat      // out
	var _arg2 C.guint

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint)(len(value))
	if len(value) > 0 {
		_arg3 = (*C.gfloat)(unsafe.Pointer(&value[0]))
	}

	C.gst_gl_shader_set_uniform_3fv(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(value)
}

// SetUniform3I: perform glUniform3i() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - v0: first value to set.
//   - v1: second value to set.
//   - v2: third value to set.
func (shader *GLShader) SetUniform3I(name string, v0, v1, v2 int) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg2 C.gint         // out
	var _arg3 C.gint         // out
	var _arg4 C.gint         // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(v0)
	_arg3 = C.gint(v1)
	_arg4 = C.gint(v2)

	C.gst_gl_shader_set_uniform_3i(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(v0)
	runtime.KeepAlive(v1)
	runtime.KeepAlive(v2)
}

// SetUniform3Iv: perform glUniform3iv() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - value values to set.
func (shader *GLShader) SetUniform3Iv(name string, value []int) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg3 *C.gint        // out
	var _arg2 C.guint

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint)(len(value))
	_arg3 = (*C.gint)(C.calloc(C.size_t(len(value)), C.size_t(C.sizeof_gint)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice((*C.gint)(_arg3), len(value))
		for i := range value {
			out[i] = C.gint(value[i])
		}
	}

	C.gst_gl_shader_set_uniform_3iv(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(value)
}

// SetUniform4F: perform glUniform4f() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - v0: first value to set.
//   - v1: second value to set.
//   - v2: third value to set.
//   - v3: fourth value to set.
func (shader *GLShader) SetUniform4F(name string, v0, v1, v2, v3 float32) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg2 C.gfloat       // out
	var _arg3 C.gfloat       // out
	var _arg4 C.gfloat       // out
	var _arg5 C.gfloat       // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gfloat(v0)
	_arg3 = C.gfloat(v1)
	_arg4 = C.gfloat(v2)
	_arg5 = C.gfloat(v3)

	C.gst_gl_shader_set_uniform_4f(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(v0)
	runtime.KeepAlive(v1)
	runtime.KeepAlive(v2)
	runtime.KeepAlive(v3)
}

// SetUniform4Fv: perform glUniform4fv() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - value values to set.
func (shader *GLShader) SetUniform4Fv(name string, value []float32) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg3 *C.gfloat      // out
	var _arg2 C.guint

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint)(len(value))
	if len(value) > 0 {
		_arg3 = (*C.gfloat)(unsafe.Pointer(&value[0]))
	}

	C.gst_gl_shader_set_uniform_4fv(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(value)
}

// SetUniform4I: perform glUniform4i() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - v0: first value to set.
//   - v1: second value to set.
//   - v2: third value to set.
//   - v3: fourth value to set.
func (shader *GLShader) SetUniform4I(name string, v0, v1, v2, v3 int) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg2 C.gint         // out
	var _arg3 C.gint         // out
	var _arg4 C.gint         // out
	var _arg5 C.gint         // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(v0)
	_arg3 = C.gint(v1)
	_arg4 = C.gint(v2)
	_arg5 = C.gint(v3)

	C.gst_gl_shader_set_uniform_4i(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(v0)
	runtime.KeepAlive(v1)
	runtime.KeepAlive(v2)
	runtime.KeepAlive(v3)
}

// SetUniform4Iv: perform glUniform4iv() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - value values to set.
func (shader *GLShader) SetUniform4Iv(name string, value []int) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg3 *C.gint        // out
	var _arg2 C.guint

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.guint)(len(value))
	_arg3 = (*C.gint)(C.calloc(C.size_t(len(value)), C.size_t(C.sizeof_gint)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice((*C.gint)(_arg3), len(value))
		for i := range value {
			out[i] = C.gint(value[i])
		}
	}

	C.gst_gl_shader_set_uniform_4iv(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(value)
}

// SetUniformMatrix2Fv: perform glUniformMatrix2fv() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - count: number of 2x2 matrices to set.
//   - transpose the matrix.
//   - value: matrix to set.
func (shader *GLShader) SetUniformMatrix2Fv(name string, count int, transpose bool, value *float32) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg2 C.gint         // out
	var _arg3 C.gboolean     // out
	var _arg4 *C.gfloat      // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(count)
	if transpose {
		_arg3 = C.TRUE
	}
	_arg4 = (*C.gfloat)(unsafe.Pointer(value))

	C.gst_gl_shader_set_uniform_matrix_2fv(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(count)
	runtime.KeepAlive(transpose)
	runtime.KeepAlive(value)
}

// SetUniformMatrix2X3Fv: perform glUniformMatrix2x3fv() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - count: number of 2x3 matrices to set.
//   - transpose the matrix.
//   - value values to set.
func (shader *GLShader) SetUniformMatrix2X3Fv(name string, count int, transpose bool, value *float32) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg2 C.gint         // out
	var _arg3 C.gboolean     // out
	var _arg4 *C.gfloat      // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(count)
	if transpose {
		_arg3 = C.TRUE
	}
	_arg4 = (*C.gfloat)(unsafe.Pointer(value))

	C.gst_gl_shader_set_uniform_matrix_2x3fv(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(count)
	runtime.KeepAlive(transpose)
	runtime.KeepAlive(value)
}

// SetUniformMatrix2X4Fv: perform glUniformMatrix2x4fv() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - count: number of 2x4 matrices to set.
//   - transpose the matrix.
//   - value values to set.
func (shader *GLShader) SetUniformMatrix2X4Fv(name string, count int, transpose bool, value *float32) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg2 C.gint         // out
	var _arg3 C.gboolean     // out
	var _arg4 *C.gfloat      // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(count)
	if transpose {
		_arg3 = C.TRUE
	}
	_arg4 = (*C.gfloat)(unsafe.Pointer(value))

	C.gst_gl_shader_set_uniform_matrix_2x4fv(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(count)
	runtime.KeepAlive(transpose)
	runtime.KeepAlive(value)
}

// SetUniformMatrix3Fv: perform glUniformMatrix3fv() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - count: number of 3x3 matrices to set.
//   - transpose the matrix.
//   - value values to set.
func (shader *GLShader) SetUniformMatrix3Fv(name string, count int, transpose bool, value *float32) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg2 C.gint         // out
	var _arg3 C.gboolean     // out
	var _arg4 *C.gfloat      // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(count)
	if transpose {
		_arg3 = C.TRUE
	}
	_arg4 = (*C.gfloat)(unsafe.Pointer(value))

	C.gst_gl_shader_set_uniform_matrix_3fv(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(count)
	runtime.KeepAlive(transpose)
	runtime.KeepAlive(value)
}

// SetUniformMatrix3X2Fv: perform glUniformMatrix3x2fv() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - count: number of 3x2 matrices to set.
//   - transpose the matrix.
//   - value values to set.
func (shader *GLShader) SetUniformMatrix3X2Fv(name string, count int, transpose bool, value *float32) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg2 C.gint         // out
	var _arg3 C.gboolean     // out
	var _arg4 *C.gfloat      // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(count)
	if transpose {
		_arg3 = C.TRUE
	}
	_arg4 = (*C.gfloat)(unsafe.Pointer(value))

	C.gst_gl_shader_set_uniform_matrix_3x2fv(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(count)
	runtime.KeepAlive(transpose)
	runtime.KeepAlive(value)
}

// SetUniformMatrix3X4Fv: perform glUniformMatrix3x4fv() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - count: number of 3x4 matrices to set.
//   - transpose the matrix.
//   - value values to set.
func (shader *GLShader) SetUniformMatrix3X4Fv(name string, count int, transpose bool, value *float32) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg2 C.gint         // out
	var _arg3 C.gboolean     // out
	var _arg4 *C.gfloat      // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(count)
	if transpose {
		_arg3 = C.TRUE
	}
	_arg4 = (*C.gfloat)(unsafe.Pointer(value))

	C.gst_gl_shader_set_uniform_matrix_3x4fv(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(count)
	runtime.KeepAlive(transpose)
	runtime.KeepAlive(value)
}

// SetUniformMatrix4Fv: perform glUniformMatrix4fv() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - count: number of 4x4 matrices to set.
//   - transpose the matrix.
//   - value values to set.
func (shader *GLShader) SetUniformMatrix4Fv(name string, count int, transpose bool, value *float32) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg2 C.gint         // out
	var _arg3 C.gboolean     // out
	var _arg4 *C.gfloat      // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(count)
	if transpose {
		_arg3 = C.TRUE
	}
	_arg4 = (*C.gfloat)(unsafe.Pointer(value))

	C.gst_gl_shader_set_uniform_matrix_4fv(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(count)
	runtime.KeepAlive(transpose)
	runtime.KeepAlive(value)
}

// SetUniformMatrix4X2Fv: perform glUniformMatrix4x2fv() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - count: number of 4x2 matrices to set.
//   - transpose the matrix.
//   - value values to set.
func (shader *GLShader) SetUniformMatrix4X2Fv(name string, count int, transpose bool, value *float32) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg2 C.gint         // out
	var _arg3 C.gboolean     // out
	var _arg4 *C.gfloat      // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(count)
	if transpose {
		_arg3 = C.TRUE
	}
	_arg4 = (*C.gfloat)(unsafe.Pointer(value))

	C.gst_gl_shader_set_uniform_matrix_4x2fv(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(count)
	runtime.KeepAlive(transpose)
	runtime.KeepAlive(value)
}

// SetUniformMatrix4X3Fv: perform glUniformMatrix4x3fv() for name on shader.
//
// The function takes the following parameters:
//
//   - name of the uniform.
//   - count: number of 4x3 matrices to set.
//   - transpose the matrix.
//   - value values to set.
func (shader *GLShader) SetUniformMatrix4X3Fv(name string, count int, transpose bool, value *float32) {
	var _arg0 *C.GstGLShader // out
	var _arg1 *C.gchar       // out
	var _arg2 C.gint         // out
	var _arg3 C.gboolean     // out
	var _arg4 *C.gfloat      // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(count)
	if transpose {
		_arg3 = C.TRUE
	}
	_arg4 = (*C.gfloat)(unsafe.Pointer(value))

	C.gst_gl_shader_set_uniform_matrix_4x3fv(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(name)
	runtime.KeepAlive(count)
	runtime.KeepAlive(transpose)
	runtime.KeepAlive(value)
}

// Use mark's shader as being used for the next GL draw command.
//
// Note: must be called in the GL thread and shader must have been linked.
func (shader *GLShader) Use() {
	var _arg0 *C.GstGLShader // out

	_arg0 = (*C.GstGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))

	C.gst_gl_shader_use(_arg0)
	runtime.KeepAlive(shader)
}

// The function takes the following parameters:
//
//   - context: GLContext.
//   - version: GLSLVersion.
//   - profile: GLSLProfile.
//
// The function returns the following values:
//
//   - utf8: passthrough shader string for copying an input external-oes texture
//     to the output.
func GLShaderStringFragmentExternalOesGetDefault(context GLContexter, version GLSLVersion, profile GLSLProfile) string {
	var _arg1 *C.GstGLContext  // out
	var _arg2 C.GstGLSLVersion // out
	var _arg3 C.GstGLSLProfile // out
	var _cret *C.gchar         // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.GstGLSLVersion(version)
	_arg3 = C.GstGLSLProfile(profile)

	_cret = C.gst_gl_shader_string_fragment_external_oes_get_default(_arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(version)
	runtime.KeepAlive(profile)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// The function takes the following parameters:
//
//   - context: GLContext.
//   - version: GLSLVersion.
//   - profile: GLSLProfile.
//
// The function returns the following values:
//
//   - utf8: passthrough shader string for copying an input texture to the
//     output.
func GLShaderStringFragmentGetDefault(context GLContexter, version GLSLVersion, profile GLSLProfile) string {
	var _arg1 *C.GstGLContext  // out
	var _arg2 C.GstGLSLVersion // out
	var _arg3 C.GstGLSLProfile // out
	var _cret *C.gchar         // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.GstGLSLVersion(version)
	_arg3 = C.GstGLSLProfile(profile)

	_cret = C.gst_gl_shader_string_fragment_get_default(_arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(version)
	runtime.KeepAlive(profile)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// GLShaderStringGetHighestPrecision generates a shader string that defines the
// precision of float types in GLSL shaders. This is particularly needed for
// fragment shaders in a GLSL ES context where there is no default precision
// specified.
//
// Practically, this will return the string 'precision mediump float' or
// 'precision highp float' depending on if high precision floats are determined
// to be supported.
//
// The function takes the following parameters:
//
//   - context: GLContext.
//   - version: GLSLVersion.
//   - profile: GLSLProfile.
//
// The function returns the following values:
//
//   - utf8: shader string defining the precision of float types based on
//     context, version and profile.
func GLShaderStringGetHighestPrecision(context GLContexter, version GLSLVersion, profile GLSLProfile) string {
	var _arg1 *C.GstGLContext  // out
	var _arg2 C.GstGLSLVersion // out
	var _arg3 C.GstGLSLProfile // out
	var _cret *C.gchar         // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.GstGLSLVersion(version)
	_arg3 = C.GstGLSLProfile(profile)

	_cret = C.gst_gl_shader_string_get_highest_precision(_arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(version)
	runtime.KeepAlive(profile)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// GLUploadOverrides contains methods that are overridable.
type GLUploadOverrides struct {
}

func defaultGLUploadOverrides(v *GLUpload) GLUploadOverrides {
	return GLUploadOverrides{}
}

// GLUpload is an object that uploads data from system memory into GL textures.
//
// A GLUpload can be created with gst_gl_upload_new().
type GLUpload struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*GLUpload)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLUpload, *GLUploadClass, GLUploadOverrides](
		GTypeGLUpload,
		initGLUploadClass,
		wrapGLUpload,
		defaultGLUploadOverrides,
	)
}

func initGLUploadClass(gclass unsafe.Pointer, overrides GLUploadOverrides, classInitFunc func(*GLUploadClass)) {
	if classInitFunc != nil {
		class := (*GLUploadClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLUpload(obj *coreglib.Object) *GLUpload {
	return &GLUpload{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalGLUpload(p uintptr) (interface{}, error) {
	return wrapGLUpload(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function takes the following parameters:
//
//   - context: GLContext.
//
// The function returns the following values:
//
//   - glUpload: new GLUpload object.
func NewGLUpload(context GLContexter) *GLUpload {
	var _arg1 *C.GstGLContext // out
	var _cret *C.GstGLUpload  // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gst_gl_upload_new(_arg1)
	runtime.KeepAlive(context)

	var _glUpload *GLUpload // out

	_glUpload = wrapGLUpload(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glUpload
}

// FixateCaps: fixate the othercaps based on the information of the caps.
//
// The function takes the following parameters:
//
//   - direction: pad PadDirection.
//   - caps as the reference.
//   - othercaps to fixate.
//
// The function returns the following values:
//
//   - ret: fixated caps.
func (upload *GLUpload) FixateCaps(direction gst.PadDirection, caps, othercaps *gst.Caps) *gst.Caps {
	var _arg0 *C.GstGLUpload    // out
	var _arg1 C.GstPadDirection // out
	var _arg2 *C.GstCaps        // out
	var _arg3 *C.GstCaps        // out
	var _cret *C.GstCaps        // in

	_arg0 = (*C.GstGLUpload)(unsafe.Pointer(coreglib.InternObject(upload).Native()))
	_arg1 = C.GstPadDirection(direction)
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(othercaps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(othercaps)), nil)

	_cret = C.gst_gl_upload_fixate_caps(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(upload)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(othercaps)

	var _ret *gst.Caps // out

	_ret = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _ret
}

// The function returns the following values:
//
//   - inCaps (optional): input Caps.
//   - outCaps (optional): output Caps.
func (upload *GLUpload) Caps() (inCaps, outCaps *gst.Caps) {
	var _arg0 *C.GstGLUpload // out
	var _arg1 *C.GstCaps     // in
	var _arg2 *C.GstCaps     // in

	_arg0 = (*C.GstGLUpload)(unsafe.Pointer(coreglib.InternObject(upload).Native()))

	C.gst_gl_upload_get_caps(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(upload)

	var _inCaps *gst.Caps  // out
	var _outCaps *gst.Caps // out

	if _arg1 != nil {
		_inCaps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_inCaps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}
	if _arg2 != nil {
		_outCaps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_outCaps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _inCaps, _outCaps
}

// PerformWithBuffer uploads buffer using the transformation specified by
// gst_gl_upload_set_caps() creating a new Buffer in outbuf_ptr.
//
// The function takes the following parameters:
//
//   - buffer: input Buffer.
//
// The function returns the following values:
//
//   - outbufPtr: resulting Buffer.
//   - glUploadReturn: whether the upload was successful.
func (upload *GLUpload) PerformWithBuffer(buffer *gst.Buffer) (*gst.Buffer, GLUploadReturn) {
	var _arg0 *C.GstGLUpload      // out
	var _arg1 *C.GstBuffer        // out
	var _arg2 *C.GstBuffer        // in
	var _cret C.GstGLUploadReturn // in

	_arg0 = (*C.GstGLUpload)(unsafe.Pointer(coreglib.InternObject(upload).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_gl_upload_perform_with_buffer(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(upload)
	runtime.KeepAlive(buffer)

	var _outbufPtr *gst.Buffer         // out
	var _glUploadReturn GLUploadReturn // out

	_outbufPtr = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_outbufPtr)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})
	_glUploadReturn = GLUploadReturn(_cret)

	return _outbufPtr, _glUploadReturn
}

// ProposeAllocation adds the required allocation parameters to support
// uploading.
//
// The function takes the following parameters:
//
//   - decideQuery (optional) from a decide allocation.
//   - query: proposed allocation query.
func (upload *GLUpload) ProposeAllocation(decideQuery, query *gst.Query) {
	var _arg0 *C.GstGLUpload // out
	var _arg1 *C.GstQuery    // out
	var _arg2 *C.GstQuery    // out

	_arg0 = (*C.GstGLUpload)(unsafe.Pointer(coreglib.InternObject(upload).Native()))
	if decideQuery != nil {
		_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(decideQuery)))
	}
	_arg2 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_gl_upload_propose_allocation(_arg0, _arg1, _arg2)
	runtime.KeepAlive(upload)
	runtime.KeepAlive(decideQuery)
	runtime.KeepAlive(query)
}

// SetCaps initializes upload with the information required for upload.
//
// The function takes the following parameters:
//
//   - inCaps: input Caps.
//   - outCaps: output Caps.
//
// The function returns the following values:
//
//   - ok: whether in_caps and out_caps could be set on upload.
func (upload *GLUpload) SetCaps(inCaps, outCaps *gst.Caps) bool {
	var _arg0 *C.GstGLUpload // out
	var _arg1 *C.GstCaps     // out
	var _arg2 *C.GstCaps     // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGLUpload)(unsafe.Pointer(coreglib.InternObject(upload).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(inCaps)))
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(outCaps)))

	_cret = C.gst_gl_upload_set_caps(_arg0, _arg1, _arg2)
	runtime.KeepAlive(upload)
	runtime.KeepAlive(inCaps)
	runtime.KeepAlive(outCaps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (upload *GLUpload) SetContext(context GLContexter) {
	var _arg0 *C.GstGLUpload  // out
	var _arg1 *C.GstGLContext // out

	_arg0 = (*C.GstGLUpload)(unsafe.Pointer(coreglib.InternObject(upload).Native()))
	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gst_gl_upload_set_context(_arg0, _arg1)
	runtime.KeepAlive(upload)
	runtime.KeepAlive(context)
}

// The function takes the following parameters:
//
//   - context
//   - direction
//   - caps
//   - filter
func (upload *GLUpload) TransformCaps(context GLContexter, direction gst.PadDirection, caps, filter *gst.Caps) *gst.Caps {
	var _arg0 *C.GstGLUpload    // out
	var _arg1 *C.GstGLContext   // out
	var _arg2 C.GstPadDirection // out
	var _arg3 *C.GstCaps        // out
	var _arg4 *C.GstCaps        // out
	var _cret *C.GstCaps        // in

	_arg0 = (*C.GstGLUpload)(unsafe.Pointer(coreglib.InternObject(upload).Native()))
	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.GstPadDirection(direction)
	_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg4 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))

	_cret = C.gst_gl_upload_transform_caps(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(upload)
	runtime.KeepAlive(context)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(filter)

	var _ret *gst.Caps // out

	_ret = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _ret
}

func GLUploadGetInputTemplateCaps() *gst.Caps {
	var _cret *C.GstCaps // in

	_cret = C.gst_gl_upload_get_input_template_caps()

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _caps
}

// GLViewConvertOverrides contains methods that are overridable.
type GLViewConvertOverrides struct {
}

func defaultGLViewConvertOverrides(v *GLViewConvert) GLViewConvertOverrides {
	return GLViewConvertOverrides{}
}

// GLViewConvert: convert stereoscopic/multiview video using fragment shaders.
type GLViewConvert struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*GLViewConvert)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLViewConvert, *GLViewConvertClass, GLViewConvertOverrides](
		GTypeGLViewConvert,
		initGLViewConvertClass,
		wrapGLViewConvert,
		defaultGLViewConvertOverrides,
	)
}

func initGLViewConvertClass(gclass unsafe.Pointer, overrides GLViewConvertOverrides, classInitFunc func(*GLViewConvertClass)) {
	if classInitFunc != nil {
		class := (*GLViewConvertClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLViewConvert(obj *coreglib.Object) *GLViewConvert {
	return &GLViewConvert{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalGLViewConvert(p uintptr) (interface{}, error) {
	return wrapGLViewConvert(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function returns the following values:
//
//   - glViewConvert: new GLViewConvert.
func NewGLViewConvert() *GLViewConvert {
	var _cret *C.GstGLViewConvert // in

	_cret = C.gst_gl_view_convert_new()

	var _glViewConvert *GLViewConvert // out

	_glViewConvert = wrapGLViewConvert(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glViewConvert
}

// FixateCaps provides an implementation of BaseTransformClass.fixate_caps().
//
// The function takes the following parameters:
//
//   - direction: PadDirection.
//   - caps of direction.
//   - othercaps to fixate.
//
// The function returns the following values:
//
//   - ret: fixated Caps.
func (viewconvert *GLViewConvert) FixateCaps(direction gst.PadDirection, caps, othercaps *gst.Caps) *gst.Caps {
	var _arg0 *C.GstGLViewConvert // out
	var _arg1 C.GstPadDirection   // out
	var _arg2 *C.GstCaps          // out
	var _arg3 *C.GstCaps          // out
	var _cret *C.GstCaps          // in

	_arg0 = (*C.GstGLViewConvert)(unsafe.Pointer(coreglib.InternObject(viewconvert).Native()))
	_arg1 = C.GstPadDirection(direction)
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(othercaps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(othercaps)), nil)

	_cret = C.gst_gl_view_convert_fixate_caps(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(viewconvert)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(othercaps)

	var _ret *gst.Caps // out

	_ret = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _ret
}

// Output: retrieve the processed output buffer placing the output in
// outbuf_ptr.
//
// The function returns the following values:
//
//   - outbufPtr: Buffer.
//   - flowReturn: FlowReturn.
func (viewconvert *GLViewConvert) Output() (*gst.Buffer, gst.FlowReturn) {
	var _arg0 *C.GstGLViewConvert // out
	var _arg1 *C.GstBuffer        // in
	var _cret C.GstFlowReturn     // in

	_arg0 = (*C.GstGLViewConvert)(unsafe.Pointer(coreglib.InternObject(viewconvert).Native()))

	_cret = C.gst_gl_view_convert_get_output(_arg0, &_arg1)
	runtime.KeepAlive(viewconvert)

	var _outbufPtr *gst.Buffer     // out
	var _flowReturn gst.FlowReturn // out

	_outbufPtr = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_outbufPtr)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})
	_flowReturn = gst.FlowReturn(_cret)

	return _outbufPtr, _flowReturn
}

// Perform converts the data contained by inbuf using the formats specified by
// the Caps passed to gst_gl_view_convert_set_caps().
//
// The function takes the following parameters:
//
//   - inbuf filled Buffer to convert.
//
// The function returns the following values:
//
//   - buffer (optional): converted Buffer or NULL.
func (viewconvert *GLViewConvert) Perform(inbuf *gst.Buffer) *gst.Buffer {
	var _arg0 *C.GstGLViewConvert // out
	var _arg1 *C.GstBuffer        // out
	var _cret *C.GstBuffer        // in

	_arg0 = (*C.GstGLViewConvert)(unsafe.Pointer(coreglib.InternObject(viewconvert).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(inbuf)))

	_cret = C.gst_gl_view_convert_perform(_arg0, _arg1)
	runtime.KeepAlive(viewconvert)
	runtime.KeepAlive(inbuf)

	var _buffer *gst.Buffer // out

	if _cret != nil {
		_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_buffer)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _buffer
}

// Reset viewconvert to the default state. Further operation will require
// setting the caps with gst_gl_view_convert_set_caps().
func (viewconvert *GLViewConvert) Reset() {
	var _arg0 *C.GstGLViewConvert // out

	_arg0 = (*C.GstGLViewConvert)(unsafe.Pointer(coreglib.InternObject(viewconvert).Native()))

	C.gst_gl_view_convert_reset(_arg0)
	runtime.KeepAlive(viewconvert)
}

// SetCaps initializes viewconvert with the information required for conversion.
//
// The function takes the following parameters:
//
//   - inCaps: input Caps.
//   - outCaps: output Caps.
func (viewconvert *GLViewConvert) SetCaps(inCaps, outCaps *gst.Caps) bool {
	var _arg0 *C.GstGLViewConvert // out
	var _arg1 *C.GstCaps          // out
	var _arg2 *C.GstCaps          // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GstGLViewConvert)(unsafe.Pointer(coreglib.InternObject(viewconvert).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(inCaps)))
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(outCaps)))

	_cret = C.gst_gl_view_convert_set_caps(_arg0, _arg1, _arg2)
	runtime.KeepAlive(viewconvert)
	runtime.KeepAlive(inCaps)
	runtime.KeepAlive(outCaps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetContext: set context on viewconvert.
//
// The function takes the following parameters:
//
//   - context to set.
func (viewconvert *GLViewConvert) SetContext(context GLContexter) {
	var _arg0 *C.GstGLViewConvert // out
	var _arg1 *C.GstGLContext     // out

	_arg0 = (*C.GstGLViewConvert)(unsafe.Pointer(coreglib.InternObject(viewconvert).Native()))
	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gst_gl_view_convert_set_context(_arg0, _arg1)
	runtime.KeepAlive(viewconvert)
	runtime.KeepAlive(context)
}

// SubmitInputBuffer: submit input to be processed by viewconvert.
//
// The function takes the following parameters:
//
//   - isDiscont: true if we have a discontinuity.
//   - input: Buffer.
//
// The function returns the following values:
//
//   - flowReturn: FlowReturn.
func (viewconvert *GLViewConvert) SubmitInputBuffer(isDiscont bool, input *gst.Buffer) gst.FlowReturn {
	var _arg0 *C.GstGLViewConvert // out
	var _arg1 C.gboolean          // out
	var _arg2 *C.GstBuffer        // out
	var _cret C.GstFlowReturn     // in

	_arg0 = (*C.GstGLViewConvert)(unsafe.Pointer(coreglib.InternObject(viewconvert).Native()))
	if isDiscont {
		_arg1 = C.TRUE
	}
	_arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(input)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(input)), nil)

	_cret = C.gst_gl_view_convert_submit_input_buffer(_arg0, _arg1, _arg2)
	runtime.KeepAlive(viewconvert)
	runtime.KeepAlive(isDiscont)
	runtime.KeepAlive(input)

	var _flowReturn gst.FlowReturn // out

	_flowReturn = gst.FlowReturn(_cret)

	return _flowReturn
}

// TransformCaps provides an implementation of
// BaseTransformClass.transform_caps().
//
// The function takes the following parameters:
//
//   - direction: PadDirection.
//   - caps to transform.
//   - filter: set of filter Caps.
//
// The function returns the following values:
//
//   - ret: converted Caps.
func (viewconvert *GLViewConvert) TransformCaps(direction gst.PadDirection, caps, filter *gst.Caps) *gst.Caps {
	var _arg0 *C.GstGLViewConvert // out
	var _arg1 C.GstPadDirection   // out
	var _arg2 *C.GstCaps          // out
	var _arg3 *C.GstCaps          // out
	var _cret *C.GstCaps          // in

	_arg0 = (*C.GstGLViewConvert)(unsafe.Pointer(coreglib.InternObject(viewconvert).Native()))
	_arg1 = C.GstPadDirection(direction)
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(filter)))

	_cret = C.gst_gl_view_convert_transform_caps(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(viewconvert)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(filter)

	var _ret *gst.Caps // out

	_ret = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _ret
}

// GLWindowOverrides contains methods that are overridable.
type GLWindowOverrides struct {
	// Close: close the connection to the display.
	Close func()
	// ControlsViewport checks if window controls the GL viewport.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if window controls the GL viewport, otherwise FALSE.
	ControlsViewport func() bool
	// Draw: redraw the window contents. Implementations should invoke the draw
	// callback.
	Draw func()
	// Display gets the current windowing system display connection.
	//
	// The function returns the following values:
	//
	//   - guintptr: windowing system display handle for this window.
	Display func() uintptr
	// WindowHandle gets the current window handle that this GLWindow is
	// rendering into. This may return a different value to what is passed into
	// set_window_handle.
	//
	// The function returns the following values:
	//
	//   - guintptr: window handle we are currently rendering into.
	WindowHandle func() uintptr
	// HandleEvents: tell a window that it should handle events from the window
	// system. These events are forwarded upstream as navigation events. In some
	// window systems events are not propagated in the window hierarchy if a
	// client is listening for them. This method allows you to disable events
	// handling completely from the window.
	//
	// The function takes the following parameters:
	//
	//   - handleEvents indicating if events should be handled or not.
	HandleEvents func(handleEvents bool)
	// HasOutputSurface: query whether window has output surface or not.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if window has useable output surface.
	HasOutputSurface func() bool
	// Open: open the connection to the display.
	Open func() error
	// QueueResize: queue resizing of window.
	QueueResize func()
	// Quit the runloop's execution.
	Quit func()
	// Run: start the execution of the runloop.
	Run func()
	// SetPreferredSize: set the preferred width and height of the window.
	// Implementations are free to ignore this information.
	//
	// The function takes the following parameters:
	//
	//   - width: new preferred width.
	//   - height: new preferred height.
	SetPreferredSize func(width, height int)
	// SetRenderRectangle: tell a window that it should render into a specific
	// region of the window according to the VideoOverlay interface.
	//
	// The function takes the following parameters:
	//
	//   - x position.
	//   - y position.
	//   - width: width.
	//   - height: height.
	//
	// The function returns the following values:
	//
	//   - ok: whether the specified region could be set.
	SetRenderRectangle func(x, y, width, height int) bool
	// SetWindowHandle sets the window that this window should render into.
	// Some implementations require this to be called with a valid handle before
	// drawing can commence.
	//
	// The function takes the following parameters:
	//
	//   - handle to the window.
	SetWindowHandle func(handle uintptr)
	// Show: present the window to the screen.
	Show func()
}

func defaultGLWindowOverrides(v *GLWindow) GLWindowOverrides {
	return GLWindowOverrides{
		Close:              v.close,
		ControlsViewport:   v.controlsViewport,
		Draw:               v.draw,
		Display:            v.display,
		WindowHandle:       v.windowHandle,
		HandleEvents:       v.handleEvents,
		HasOutputSurface:   v.hasOutputSurface,
		Open:               v.open,
		QueueResize:        v.queueResize,
		Quit:               v.quit,
		Run:                v.run,
		SetPreferredSize:   v.setPreferredSize,
		SetRenderRectangle: v.setRenderRectangle,
		SetWindowHandle:    v.setWindowHandle,
		Show:               v.show,
	}
}

// GLWindow represents a window that elements can render into. A window can
// either be a user visible window (onscreen) or hidden (offscreen).
type GLWindow struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*GLWindow)(nil)
)

// GLWindower describes types inherited from class GLWindow.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type GLWindower interface {
	coreglib.Objector
	baseGLWindow() *GLWindow
}

var _ GLWindower = (*GLWindow)(nil)

func init() {
	coreglib.RegisterClassInfo[*GLWindow, *GLWindowClass, GLWindowOverrides](
		GTypeGLWindow,
		initGLWindowClass,
		wrapGLWindow,
		defaultGLWindowOverrides,
	)
}

func initGLWindowClass(gclass unsafe.Pointer, overrides GLWindowOverrides, classInitFunc func(*GLWindowClass)) {
	pclass := (*C.GstGLWindowClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeGLWindow))))

	if overrides.Close != nil {
		pclass.close = (*[0]byte)(C._gotk4_gstgl1_GLWindowClass_close)
	}

	if overrides.ControlsViewport != nil {
		pclass.controls_viewport = (*[0]byte)(C._gotk4_gstgl1_GLWindowClass_controls_viewport)
	}

	if overrides.Draw != nil {
		pclass.draw = (*[0]byte)(C._gotk4_gstgl1_GLWindowClass_draw)
	}

	if overrides.Display != nil {
		pclass.get_display = (*[0]byte)(C._gotk4_gstgl1_GLWindowClass_get_display)
	}

	if overrides.WindowHandle != nil {
		pclass.get_window_handle = (*[0]byte)(C._gotk4_gstgl1_GLWindowClass_get_window_handle)
	}

	if overrides.HandleEvents != nil {
		pclass.handle_events = (*[0]byte)(C._gotk4_gstgl1_GLWindowClass_handle_events)
	}

	if overrides.HasOutputSurface != nil {
		pclass.has_output_surface = (*[0]byte)(C._gotk4_gstgl1_GLWindowClass_has_output_surface)
	}

	if overrides.Open != nil {
		pclass.open = (*[0]byte)(C._gotk4_gstgl1_GLWindowClass_open)
	}

	if overrides.QueueResize != nil {
		pclass.queue_resize = (*[0]byte)(C._gotk4_gstgl1_GLWindowClass_queue_resize)
	}

	if overrides.Quit != nil {
		pclass.quit = (*[0]byte)(C._gotk4_gstgl1_GLWindowClass_quit)
	}

	if overrides.Run != nil {
		pclass.run = (*[0]byte)(C._gotk4_gstgl1_GLWindowClass_run)
	}

	if overrides.SetPreferredSize != nil {
		pclass.set_preferred_size = (*[0]byte)(C._gotk4_gstgl1_GLWindowClass_set_preferred_size)
	}

	if overrides.SetRenderRectangle != nil {
		pclass.set_render_rectangle = (*[0]byte)(C._gotk4_gstgl1_GLWindowClass_set_render_rectangle)
	}

	if overrides.SetWindowHandle != nil {
		pclass.set_window_handle = (*[0]byte)(C._gotk4_gstgl1_GLWindowClass_set_window_handle)
	}

	if overrides.Show != nil {
		pclass.show = (*[0]byte)(C._gotk4_gstgl1_GLWindowClass_show)
	}

	if classInitFunc != nil {
		class := (*GLWindowClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLWindow(obj *coreglib.Object) *GLWindow {
	return &GLWindow{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalGLWindow(p uintptr) (interface{}, error) {
	return wrapGLWindow(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (window *GLWindow) baseGLWindow() *GLWindow {
	return window
}

// BaseGLWindow returns the underlying base object.
func BaseGLWindow(obj GLWindower) *GLWindow {
	return obj.baseGLWindow()
}

// ConnectKeyEvent will be emitted when a key event is received by the
// GstGLwindow.
func (window *GLWindow) ConnectKeyEvent(f func(id, key string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(window, "key-event", false, unsafe.Pointer(C._gotk4_gstgl1_GLWindow_ConnectKeyEvent), f)
}

// ConnectMouseEvent will be emitted when a mouse event is received by the
// GstGLwindow.
func (window *GLWindow) ConnectMouseEvent(f func(id string, button int, x, y float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(window, "mouse-event", false, unsafe.Pointer(C._gotk4_gstgl1_GLWindow_ConnectMouseEvent), f)
}

// ConnectScrollEvent will be emitted when a mouse scroll event is received by
// the GstGLwindow.
func (window *GLWindow) ConnectScrollEvent(f func(x, y, deltaX, deltaY float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(window, "scroll-event", false, unsafe.Pointer(C._gotk4_gstgl1_GLWindow_ConnectScrollEvent), f)
}

// ConnectWindowHandleChanged will be emitted when the window handle has been
// set into the native implementation, but before the context is re-activated.
// By using this signal, elements can refresh associated resource without
// relying on direct handle comparision.
func (window *GLWindow) ConnectWindowHandleChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(window, "window-handle-changed", false, unsafe.Pointer(C._gotk4_gstgl1_GLWindow_ConnectWindowHandleChanged), f)
}

// The function takes the following parameters:
//
//   - display: GLDisplay.
//
// The function returns the following values:
//
//   - glWindow: new GLWindow using display's connection.
func NewGLWindow(display *GLDisplay) *GLWindow {
	var _arg1 *C.GstGLDisplay // out
	var _cret *C.GstGLWindow  // in

	_arg1 = (*C.GstGLDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gst_gl_window_new(_arg1)
	runtime.KeepAlive(display)

	var _glWindow *GLWindow // out

	_glWindow = wrapGLWindow(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glWindow
}

// ControlsViewport checks if window controls the GL viewport.
//
// The function returns the following values:
//
//   - ok: TRUE if window controls the GL viewport, otherwise FALSE.
func (window *GLWindow) ControlsViewport() bool {
	var _arg0 *C.GstGLWindow // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gst_gl_window_controls_viewport(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Draw: redraw the window contents. Implementations should invoke the draw
// callback.
func (window *GLWindow) Draw() {
	var _arg0 *C.GstGLWindow // out

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gst_gl_window_draw(_arg0)
	runtime.KeepAlive(window)
}

// The function returns the following values:
//
//   - glContext associated with this window.
func (window *GLWindow) Context() GLContexter {
	var _arg0 *C.GstGLWindow  // out
	var _cret *C.GstGLContext // in

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gst_gl_window_get_context(_arg0)
	runtime.KeepAlive(window)

	var _glContext GLContexter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gstgl.GLContexter is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(GLContexter)
			return ok
		})
		rv, ok := casted.(GLContexter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstgl.GLContexter")
		}
		_glContext = rv
	}

	return _glContext
}

// The function returns the following values:
//
//   - guintptr: windowing system display handle for this window.
func (window *GLWindow) Display() uintptr {
	var _arg0 *C.GstGLWindow // out
	var _cret C.guintptr     // in

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gst_gl_window_get_display(_arg0)
	runtime.KeepAlive(window)

	var _guintptr uintptr // out

	_guintptr = uintptr(_cret)

	return _guintptr
}

// The function returns the following values:
//
//   - width: resulting surface width.
//   - height: resulting surface height.
func (window *GLWindow) SurfaceDimensions() (width, height uint) {
	var _arg0 *C.GstGLWindow // out
	var _arg1 C.guint        // in
	var _arg2 C.guint        // in

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gst_gl_window_get_surface_dimensions(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(window)

	var _width uint  // out
	var _height uint // out

	_width = uint(_arg1)
	_height = uint(_arg2)

	return _width, _height
}

// The function returns the following values:
//
//   - guintptr: window handle we are currently rendering into.
func (window *GLWindow) WindowHandle() uintptr {
	var _arg0 *C.GstGLWindow // out
	var _cret C.guintptr     // in

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gst_gl_window_get_window_handle(_arg0)
	runtime.KeepAlive(window)

	var _guintptr uintptr // out

	_guintptr = uintptr(_cret)

	return _guintptr
}

// HandleEvents: tell a window that it should handle events from the window
// system. These events are forwarded upstream as navigation events. In some
// window systems events are not propagated in the window hierarchy if a client
// is listening for them. This method allows you to disable events handling
// completely from the window.
//
// The function takes the following parameters:
//
//   - handleEvents indicating if events should be handled or not.
func (window *GLWindow) HandleEvents(handleEvents bool) {
	var _arg0 *C.GstGLWindow // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if handleEvents {
		_arg1 = C.TRUE
	}

	C.gst_gl_window_handle_events(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(handleEvents)
}

// HasOutputSurface: query whether window has output surface or not.
//
// The function returns the following values:
//
//   - ok: TRUE if window has useable output surface.
func (window *GLWindow) HasOutputSurface() bool {
	var _arg0 *C.GstGLWindow // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gst_gl_window_has_output_surface(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QueueResize: queue resizing of window.
func (window *GLWindow) QueueResize() {
	var _arg0 *C.GstGLWindow // out

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gst_gl_window_queue_resize(_arg0)
	runtime.KeepAlive(window)
}

// Quit the runloop's execution.
func (window *GLWindow) Quit() {
	var _arg0 *C.GstGLWindow // out

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gst_gl_window_quit(_arg0)
	runtime.KeepAlive(window)
}

// Resize window to the given width and height.
//
// The function takes the following parameters:
//
//   - width: new width.
//   - height: new height.
func (window *GLWindow) Resize(width, height uint) {
	var _arg0 *C.GstGLWindow // out
	var _arg1 C.guint        // out
	var _arg2 C.guint        // out

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.guint(width)
	_arg2 = C.guint(height)

	C.gst_gl_window_resize(_arg0, _arg1, _arg2)
	runtime.KeepAlive(window)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// Run: start the execution of the runloop.
func (window *GLWindow) Run() {
	var _arg0 *C.GstGLWindow // out

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gst_gl_window_run(_arg0)
	runtime.KeepAlive(window)
}

// The function takes the following parameters:
//
//   - eventType
//   - keyStr
func (window *GLWindow) SendKeyEvent(eventType, keyStr string) {
	var _arg0 *C.GstGLWindow // out
	var _arg1 *C.char        // out
	var _arg2 *C.char        // out

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(eventType)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(keyStr)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gst_gl_window_send_key_event(_arg0, _arg1, _arg2)
	runtime.KeepAlive(window)
	runtime.KeepAlive(eventType)
	runtime.KeepAlive(keyStr)
}

// The function takes the following parameters:
//
//   - eventType
//   - button
//   - posx
//   - posy
func (window *GLWindow) SendMouseEvent(eventType string, button int, posx, posy float64) {
	var _arg0 *C.GstGLWindow // out
	var _arg1 *C.char        // out
	var _arg2 C.int          // out
	var _arg3 C.double       // out
	var _arg4 C.double       // out

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(eventType)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(button)
	_arg3 = C.double(posx)
	_arg4 = C.double(posy)

	C.gst_gl_window_send_mouse_event(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(window)
	runtime.KeepAlive(eventType)
	runtime.KeepAlive(button)
	runtime.KeepAlive(posx)
	runtime.KeepAlive(posy)
}

// SendScrollEvent: notify a window about a scroll event. A scroll signal
// holding the event coordinates will be emitted.
//
// The function takes the following parameters:
//
//   - posx: x position of the mouse cursor.
//   - posy: y position of the mouse cursor.
//   - deltaX: x offset of the scroll event.
//   - deltaY: y offset of the scroll event.
func (window *GLWindow) SendScrollEvent(posx, posy, deltaX, deltaY float64) {
	var _arg0 *C.GstGLWindow // out
	var _arg1 C.double       // out
	var _arg2 C.double       // out
	var _arg3 C.double       // out
	var _arg4 C.double       // out

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.double(posx)
	_arg2 = C.double(posy)
	_arg3 = C.double(deltaX)
	_arg4 = C.double(deltaY)

	C.gst_gl_window_send_scroll_event(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(window)
	runtime.KeepAlive(posx)
	runtime.KeepAlive(posy)
	runtime.KeepAlive(deltaX)
	runtime.KeepAlive(deltaY)
}

// SetPreferredSize: set the preferred width and height of the window.
// Implementations are free to ignore this information.
//
// The function takes the following parameters:
//
//   - width: new preferred width.
//   - height: new preferred height.
func (window *GLWindow) SetPreferredSize(width, height int) {
	var _arg0 *C.GstGLWindow // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.gint(width)
	_arg2 = C.gint(height)

	C.gst_gl_window_set_preferred_size(_arg0, _arg1, _arg2)
	runtime.KeepAlive(window)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// SetRenderRectangle: tell a window that it should render into a specific
// region of the window according to the VideoOverlay interface.
//
// The function takes the following parameters:
//
//   - x position.
//   - y position.
//   - width: width.
//   - height: height.
//
// The function returns the following values:
//
//   - ok: whether the specified region could be set.
func (window *GLWindow) SetRenderRectangle(x, y, width, height int) bool {
	var _arg0 *C.GstGLWindow // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _arg3 C.gint         // out
	var _arg4 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.gint(x)
	_arg2 = C.gint(y)
	_arg3 = C.gint(width)
	_arg4 = C.gint(height)

	_cret = C.gst_gl_window_set_render_rectangle(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(window)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetWindowHandle sets the window that this window should render into. Some
// implementations require this to be called with a valid handle before drawing
// can commence.
//
// The function takes the following parameters:
//
//   - handle to the window.
func (window *GLWindow) SetWindowHandle(handle uintptr) {
	var _arg0 *C.GstGLWindow // out
	var _arg1 C.guintptr     // out

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.guintptr(handle)

	C.gst_gl_window_set_window_handle(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(handle)
}

// Show: present the window to the screen.
func (window *GLWindow) Show() {
	var _arg0 *C.GstGLWindow // out

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gst_gl_window_show(_arg0)
	runtime.KeepAlive(window)
}

// Close the connection to the display.
func (window *GLWindow) close() {
	gclass := (*C.GstGLWindowClass)(coreglib.PeekParentClass(window))
	fnarg := gclass.close

	var _arg0 *C.GstGLWindow // out

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C._gotk4_gstgl1_GLWindow_virtual_close(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(window)
}

// controlsViewport checks if window controls the GL viewport.
//
// The function returns the following values:
//
//   - ok: TRUE if window controls the GL viewport, otherwise FALSE.
func (window *GLWindow) controlsViewport() bool {
	gclass := (*C.GstGLWindowClass)(coreglib.PeekParentClass(window))
	fnarg := gclass.controls_viewport

	var _arg0 *C.GstGLWindow // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C._gotk4_gstgl1_GLWindow_virtual_controls_viewport(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Draw the window contents. Implementations should invoke the draw callback.
func (window *GLWindow) draw() {
	gclass := (*C.GstGLWindowClass)(coreglib.PeekParentClass(window))
	fnarg := gclass.draw

	var _arg0 *C.GstGLWindow // out

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C._gotk4_gstgl1_GLWindow_virtual_draw(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(window)
}

// Display gets the current windowing system display connection.
//
// The function returns the following values:
//
//   - guintptr: windowing system display handle for this window.
func (window *GLWindow) display() uintptr {
	gclass := (*C.GstGLWindowClass)(coreglib.PeekParentClass(window))
	fnarg := gclass.get_display

	var _arg0 *C.GstGLWindow // out
	var _cret C.guintptr     // in

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C._gotk4_gstgl1_GLWindow_virtual_get_display(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(window)

	var _guintptr uintptr // out

	_guintptr = uintptr(_cret)

	return _guintptr
}

// windowHandle gets the current window handle that this GLWindow is
// rendering into. This may return a different value to what is passed into
// set_window_handle.
//
// The function returns the following values:
//
//   - guintptr: window handle we are currently rendering into.
func (window *GLWindow) windowHandle() uintptr {
	gclass := (*C.GstGLWindowClass)(coreglib.PeekParentClass(window))
	fnarg := gclass.get_window_handle

	var _arg0 *C.GstGLWindow // out
	var _cret C.guintptr     // in

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C._gotk4_gstgl1_GLWindow_virtual_get_window_handle(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(window)

	var _guintptr uintptr // out

	_guintptr = uintptr(_cret)

	return _guintptr
}

// handleEvents: tell a window that it should handle events from the window
// system. These events are forwarded upstream as navigation events. In some
// window systems events are not propagated in the window hierarchy if a client
// is listening for them. This method allows you to disable events handling
// completely from the window.
//
// The function takes the following parameters:
//
//   - handleEvents indicating if events should be handled or not.
func (window *GLWindow) handleEvents(handleEvents bool) {
	gclass := (*C.GstGLWindowClass)(coreglib.PeekParentClass(window))
	fnarg := gclass.handle_events

	var _arg0 *C.GstGLWindow // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if handleEvents {
		_arg1 = C.TRUE
	}

	C._gotk4_gstgl1_GLWindow_virtual_handle_events(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(handleEvents)
}

// hasOutputSurface: query whether window has output surface or not.
//
// The function returns the following values:
//
//   - ok: TRUE if window has useable output surface.
func (window *GLWindow) hasOutputSurface() bool {
	gclass := (*C.GstGLWindowClass)(coreglib.PeekParentClass(window))
	fnarg := gclass.has_output_surface

	var _arg0 *C.GstGLWindow // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C._gotk4_gstgl1_GLWindow_virtual_has_output_surface(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Open the connection to the display.
func (window *GLWindow) open() error {
	gclass := (*C.GstGLWindowClass)(coreglib.PeekParentClass(window))
	fnarg := gclass.open

	var _arg0 *C.GstGLWindow // out
	var _cerr *C.GError      // in

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C._gotk4_gstgl1_GLWindow_virtual_open(unsafe.Pointer(fnarg), _arg0, &_cerr)
	runtime.KeepAlive(window)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// queueResize: queue resizing of window.
func (window *GLWindow) queueResize() {
	gclass := (*C.GstGLWindowClass)(coreglib.PeekParentClass(window))
	fnarg := gclass.queue_resize

	var _arg0 *C.GstGLWindow // out

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C._gotk4_gstgl1_GLWindow_virtual_queue_resize(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(window)
}

// Quit: quit the runloop's execution.
func (window *GLWindow) quit() {
	gclass := (*C.GstGLWindowClass)(coreglib.PeekParentClass(window))
	fnarg := gclass.quit

	var _arg0 *C.GstGLWindow // out

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C._gotk4_gstgl1_GLWindow_virtual_quit(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(window)
}

// Run: start the execution of the runloop.
func (window *GLWindow) run() {
	gclass := (*C.GstGLWindowClass)(coreglib.PeekParentClass(window))
	fnarg := gclass.run

	var _arg0 *C.GstGLWindow // out

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C._gotk4_gstgl1_GLWindow_virtual_run(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(window)
}

// setPreferredSize: set the preferred width and height of the window.
// Implementations are free to ignore this information.
//
// The function takes the following parameters:
//
//   - width: new preferred width.
//   - height: new preferred height.
func (window *GLWindow) setPreferredSize(width, height int) {
	gclass := (*C.GstGLWindowClass)(coreglib.PeekParentClass(window))
	fnarg := gclass.set_preferred_size

	var _arg0 *C.GstGLWindow // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.gint(width)
	_arg2 = C.gint(height)

	C._gotk4_gstgl1_GLWindow_virtual_set_preferred_size(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(window)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// setRenderRectangle: tell a window that it should render into a specific
// region of the window according to the VideoOverlay interface.
//
// The function takes the following parameters:
//
//   - x position.
//   - y position.
//   - width: width.
//   - height: height.
//
// The function returns the following values:
//
//   - ok: whether the specified region could be set.
func (window *GLWindow) setRenderRectangle(x, y, width, height int) bool {
	gclass := (*C.GstGLWindowClass)(coreglib.PeekParentClass(window))
	fnarg := gclass.set_render_rectangle

	var _arg0 *C.GstGLWindow // out
	var _arg1 C.gint         // out
	var _arg2 C.gint         // out
	var _arg3 C.gint         // out
	var _arg4 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.gint(x)
	_arg2 = C.gint(y)
	_arg3 = C.gint(width)
	_arg4 = C.gint(height)

	_cret = C._gotk4_gstgl1_GLWindow_virtual_set_render_rectangle(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(window)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// setWindowHandle sets the window that this window should render into. Some
// implementations require this to be called with a valid handle before drawing
// can commence.
//
// The function takes the following parameters:
//
//   - handle to the window.
func (window *GLWindow) setWindowHandle(handle uintptr) {
	gclass := (*C.GstGLWindowClass)(coreglib.PeekParentClass(window))
	fnarg := gclass.set_window_handle

	var _arg0 *C.GstGLWindow // out
	var _arg1 C.guintptr     // out

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.guintptr(handle)

	C._gotk4_gstgl1_GLWindow_virtual_set_window_handle(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(handle)
}

// Show: present the window to the screen.
func (window *GLWindow) show() {
	gclass := (*C.GstGLWindowClass)(coreglib.PeekParentClass(window))
	fnarg := gclass.show

	var _arg0 *C.GstGLWindow // out

	_arg0 = (*C.GstGLWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C._gotk4_gstgl1_GLWindow_virtual_show(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(window)
}

// GLAllocationParams: instance of this type is always passed by reference.
type GLAllocationParams struct {
	*glAllocationParams
}

// glAllocationParams is the struct that's finalized.
type glAllocationParams struct {
	native *C.GstGLAllocationParams
}

func marshalGLAllocationParams(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &GLAllocationParams{&glAllocationParams{(*C.GstGLAllocationParams)(b)}}, nil
}

// The function returns the following values:
//
//   - glAllocationParams: copy of the GLAllocationParams specified by src.
func (src *GLAllocationParams) Copy() *GLAllocationParams {
	var _arg0 *C.GstGLAllocationParams // out
	var _cret *C.GstGLAllocationParams // in

	_arg0 = (*C.GstGLAllocationParams)(gextras.StructNative(unsafe.Pointer(src)))

	_cret = C.gst_gl_allocation_params_copy(_arg0)
	runtime.KeepAlive(src)

	var _glAllocationParams *GLAllocationParams // out

	_glAllocationParams = (*GLAllocationParams)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_glAllocationParams)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_gl_allocation_params_free((*C.GstGLAllocationParams)(intern.C))
		},
	)

	return _glAllocationParams
}

// CopyData copies the dynamically allocated data from src to dest. Direct
// subclasses should call this function in their own overridden copy function.
//
// The function takes the following parameters:
//
//   - dest: destination GLAllocationParams.
func (src *GLAllocationParams) CopyData(dest *GLAllocationParams) {
	var _arg0 *C.GstGLAllocationParams // out
	var _arg1 *C.GstGLAllocationParams // out

	_arg0 = (*C.GstGLAllocationParams)(gextras.StructNative(unsafe.Pointer(src)))
	_arg1 = (*C.GstGLAllocationParams)(gextras.StructNative(unsafe.Pointer(dest)))

	C.gst_gl_allocation_params_copy_data(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(dest)
}

// FreeData frees the dynamically allocated data in params. Direct subclasses
// should call this function in their own overridden free function.
func (params *GLAllocationParams) FreeData() {
	var _arg0 *C.GstGLAllocationParams // out

	_arg0 = (*C.GstGLAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))

	C.gst_gl_allocation_params_free_data(_arg0)
	runtime.KeepAlive(params)
}

// GLAsyncDebug an opaque structure and should only be accessed through the
// provided API.
//
// An instance of this type is always passed by reference.
type GLAsyncDebug struct {
	*glAsyncDebug
}

// glAsyncDebug is the struct that's finalized.
type glAsyncDebug struct {
	native *C.GstGLAsyncDebug
}

// Freeze: freeze the debug output. While frozen, any call to
// gst_gl_async_debug_output_log_msg() will not output any messages but
// subsequent calls to gst_gl_async_debug_store_log_msg() will overwrite
// previous messages.
func (ad *GLAsyncDebug) Freeze() {
	var _arg0 *C.GstGLAsyncDebug // out

	_arg0 = (*C.GstGLAsyncDebug)(gextras.StructNative(unsafe.Pointer(ad)))

	C.gst_gl_async_debug_freeze(_arg0)
	runtime.KeepAlive(ad)
}

// Init: initialize ad. Intended for use with GLAsyncDebug's that are embedded
// in other structs.
func (ad *GLAsyncDebug) Init() {
	var _arg0 *C.GstGLAsyncDebug // out

	_arg0 = (*C.GstGLAsyncDebug)(gextras.StructNative(unsafe.Pointer(ad)))

	C.gst_gl_async_debug_init(_arg0)
	runtime.KeepAlive(ad)
}

// OutputLogMsg outputs a previously stored debug message.
func (ad *GLAsyncDebug) OutputLogMsg() {
	var _arg0 *C.GstGLAsyncDebug // out

	_arg0 = (*C.GstGLAsyncDebug)(gextras.StructNative(unsafe.Pointer(ad)))

	C.gst_gl_async_debug_output_log_msg(_arg0)
	runtime.KeepAlive(ad)
}

// Thaw: unfreeze the debug output. See gst_gl_async_debug_freeze() for what
// freezing means.
func (ad *GLAsyncDebug) Thaw() {
	var _arg0 *C.GstGLAsyncDebug // out

	_arg0 = (*C.GstGLAsyncDebug)(gextras.StructNative(unsafe.Pointer(ad)))

	C.gst_gl_async_debug_thaw(_arg0)
	runtime.KeepAlive(ad)
}

// Unset any dynamically allocated data. Intended for use with GLAsyncDebug's
// that are embedded in other structs.
func (ad *GLAsyncDebug) Unset() {
	var _arg0 *C.GstGLAsyncDebug // out

	_arg0 = (*C.GstGLAsyncDebug)(gextras.StructNative(unsafe.Pointer(ad)))

	C.gst_gl_async_debug_unset(_arg0)
	runtime.KeepAlive(ad)
}

// GLBaseFilterClass: base class for GStreamer GL Filter.
//
// An instance of this type is always passed by reference.
type GLBaseFilterClass struct {
	*glBaseFilterClass
}

// glBaseFilterClass is the struct that's finalized.
type glBaseFilterClass struct {
	native *C.GstGLBaseFilterClass
}

func (g *GLBaseFilterClass) ParentClass() *gstbase.BaseTransformClass {
	valptr := &g.native.parent_class
	var _v *gstbase.BaseTransformClass // out
	_v = (*gstbase.BaseTransformClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// SupportedGLApi: logical-OR of GLAPI's supported by this element.
func (g *GLBaseFilterClass) SupportedGLApi() GLAPI {
	valptr := &g.native.supported_gl_api
	var _v GLAPI // out
	_v = GLAPI(*valptr)
	return _v
}

// GLBaseMemory is a Memory subclass providing the basis of support for the
// mapping of GL buffers.
//
// Data is uploaded or downloaded from the GPU as is necessary.
//
// An instance of this type is always passed by reference.
type GLBaseMemory struct {
	*glBaseMemory
}

// glBaseMemory is the struct that's finalized.
type glBaseMemory struct {
	native *C.GstGLBaseMemory
}

func marshalGLBaseMemory(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &GLBaseMemory{&glBaseMemory{(*C.GstGLBaseMemory)(b)}}, nil
}

// Mem: parent object.
func (g *GLBaseMemory) Mem() *gst.Memory {
	valptr := &g.native.mem
	var _v *gst.Memory // out
	_v = (*gst.Memory)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_v)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})
	return _v
}

// Context to use for GL operations.
func (g *GLBaseMemory) Context() GLContexter {
	valptr := &g.native.context
	var _v GLContexter // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gstgl.GLContexter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(GLContexter)
			return ok
		})
		rv, ok := casted.(GLContexter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstgl.GLContexter")
		}
		_v = rv
	}
	return _v
}

func (g *GLBaseMemory) MapFlags() gst.MapFlags {
	valptr := &g.native.map_flags
	var _v gst.MapFlags // out
	_v = gst.MapFlags(*valptr)
	return _v
}

func (g *GLBaseMemory) MapCount() int {
	valptr := &g.native.map_count
	var _v int // out
	_v = int(*valptr)
	return _v
}

func (g *GLBaseMemory) GLMapCount() int {
	valptr := &g.native.gl_map_count
	var _v int // out
	_v = int(*valptr)
	return _v
}

func (g *GLBaseMemory) Data() unsafe.Pointer {
	valptr := &g.native.data
	var _v unsafe.Pointer // out
	_v = (unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

func (g *GLBaseMemory) Query() *GLQuery {
	valptr := &g.native.query
	var _v *GLQuery // out
	_v = (*GLQuery)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

func (g *GLBaseMemory) SetMapCount(mapCount int) {
	valptr := &g.native.map_count
	*valptr = C.gint(mapCount)
}

func (g *GLBaseMemory) SetGLMapCount(glMapCount int) {
	valptr := &g.native.gl_map_count
	*valptr = C.gint(glMapCount)
}

// AllocData: note: only intended for subclass usage to allocate the system
// memory buffer on demand. If there is already a non-NULL data pointer in
// gl_mem->data, then this function imply returns TRUE.
//
// The function returns the following values:
//
//   - ok: whether the system memory could be allocated.
func (glMem *GLBaseMemory) AllocData() bool {
	var _arg0 *C.GstGLBaseMemory // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstGLBaseMemory)(gextras.StructNative(unsafe.Pointer(glMem)))

	_cret = C.gst_gl_base_memory_alloc_data(_arg0)
	runtime.KeepAlive(glMem)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - dest: destination GLBaseMemory.
//   - offset to start at.
//   - size: number of bytes to copy.
//
// The function returns the following values:
//
//   - ok: whether the copy succeeded.
func (src *GLBaseMemory) Memcpy(dest *GLBaseMemory, offset int, size int) bool {
	var _arg0 *C.GstGLBaseMemory // out
	var _arg1 *C.GstGLBaseMemory // out
	var _arg2 C.gssize           // out
	var _arg3 C.gssize           // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GstGLBaseMemory)(gextras.StructNative(unsafe.Pointer(src)))
	_arg1 = (*C.GstGLBaseMemory)(gextras.StructNative(unsafe.Pointer(dest)))
	_arg2 = C.gssize(offset)
	_arg3 = C.gssize(size)

	_cret = C.gst_gl_base_memory_memcpy(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - allocator: GLBaseMemoryAllocator.
//   - params to allocate the memory with.
//
// The function returns the following values:
//
//   - glBaseMemory (optional): new GLBaseMemory from allocator with the
//     requested params.
func GLBaseMemoryAlloc(allocator GLBaseMemoryAllocatorrer, params *GLAllocationParams) *GLBaseMemory {
	var _arg1 *C.GstGLBaseMemoryAllocator // out
	var _arg2 *C.GstGLAllocationParams    // out
	var _cret *C.GstGLBaseMemory          // in

	_arg1 = (*C.GstGLBaseMemoryAllocator)(unsafe.Pointer(coreglib.InternObject(allocator).Native()))
	_arg2 = (*C.GstGLAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))

	_cret = C.gst_gl_base_memory_alloc(_arg1, _arg2)
	runtime.KeepAlive(allocator)
	runtime.KeepAlive(params)

	var _glBaseMemory *GLBaseMemory // out

	if _cret != nil {
		_glBaseMemory = (*GLBaseMemory)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_glBaseMemory)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _glBaseMemory
}

// GLBaseMemoryInitOnce initializes the GL Base Memory allocator. It is safe
// to call this function multiple times. This must be called before any other
// GstGLBaseMemory operation.
func GLBaseMemoryInitOnce() {
	C.gst_gl_base_memory_init_once()
}

// GLBaseMemoryAllocatorClass: instance of this type is always passed by
// reference.
type GLBaseMemoryAllocatorClass struct {
	*glBaseMemoryAllocatorClass
}

// glBaseMemoryAllocatorClass is the struct that's finalized.
type glBaseMemoryAllocatorClass struct {
	native *C.GstGLBaseMemoryAllocatorClass
}

// GLBaseMixerClass: instance of this type is always passed by reference.
type GLBaseMixerClass struct {
	*glBaseMixerClass
}

// glBaseMixerClass is the struct that's finalized.
type glBaseMixerClass struct {
	native *C.GstGLBaseMixerClass
}

// ParentClass: parent VideoAggregatorClass.
func (g *GLBaseMixerClass) ParentClass() *gstvideo.VideoAggregatorClass {
	valptr := &g.native.parent_class
	var _v *gstvideo.VideoAggregatorClass // out
	_v = (*gstvideo.VideoAggregatorClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// SupportedGLApi: logical-OR of GLAPI's supported by this element.
func (g *GLBaseMixerClass) SupportedGLApi() GLAPI {
	valptr := &g.native.supported_gl_api
	var _v GLAPI // out
	_v = GLAPI(*valptr)
	return _v
}

// GLBaseMixerPadClass: instance of this type is always passed by reference.
type GLBaseMixerPadClass struct {
	*glBaseMixerPadClass
}

// glBaseMixerPadClass is the struct that's finalized.
type glBaseMixerPadClass struct {
	native *C.GstGLBaseMixerPadClass
}

// ParentClass: parent VideoAggregatorPadClass.
func (g *GLBaseMixerPadClass) ParentClass() *gstvideo.VideoAggregatorPadClass {
	valptr := &g.native.parent_class
	var _v *gstvideo.VideoAggregatorPadClass // out
	_v = (*gstvideo.VideoAggregatorPadClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// GLBaseSrcClass: base class for GStreamer GL Video sources.
//
// An instance of this type is always passed by reference.
type GLBaseSrcClass struct {
	*glBaseSrcClass
}

// glBaseSrcClass is the struct that's finalized.
type glBaseSrcClass struct {
	native *C.GstGLBaseSrcClass
}

func (g *GLBaseSrcClass) ParentClass() *gstbase.PushSrcClass {
	valptr := &g.native.parent_class
	var _v *gstbase.PushSrcClass // out
	_v = (*gstbase.PushSrcClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// SupportedGLApi: logical-OR of GLAPI's supported by this element.
func (g *GLBaseSrcClass) SupportedGLApi() GLAPI {
	valptr := &g.native.supported_gl_api
	var _v GLAPI // out
	_v = GLAPI(*valptr)
	return _v
}

// GLBuffer is a Memory subclass providing support for the mapping of GL
// buffers.
//
// Data is uploaded or downloaded from the GPU as is necessary.
//
// An instance of this type is always passed by reference.
type GLBuffer struct {
	*glBuffer
}

// glBuffer is the struct that's finalized.
type glBuffer struct {
	native *C.GstGLBuffer
}

func marshalGLBuffer(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &GLBuffer{&glBuffer{(*C.GstGLBuffer)(b)}}, nil
}

// Mem: parent object.
func (g *GLBuffer) Mem() *GLBaseMemory {
	valptr := &g.native.mem
	var _v *GLBaseMemory // out
	_v = (*GLBaseMemory)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ID: buffer id for this memory.
func (g *GLBuffer) ID() uint {
	valptr := &g.native.id
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Target: openGL target of this texture for binding purposes.
func (g *GLBuffer) Target() uint {
	valptr := &g.native.target
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// UsageHints: openGL usage hints this buffer was created with.
func (g *GLBuffer) UsageHints() uint {
	valptr := &g.native.usage_hints
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// ID: buffer id for this memory.
func (g *GLBuffer) SetID(id uint) {
	valptr := &g.native.id
	*valptr = C.guint(id)
}

// Target: openGL target of this texture for binding purposes.
func (g *GLBuffer) SetTarget(target uint) {
	valptr := &g.native.target
	*valptr = C.guint(target)
}

// UsageHints: openGL usage hints this buffer was created with.
func (g *GLBuffer) SetUsageHints(usageHints uint) {
	valptr := &g.native.usage_hints
	*valptr = C.guint(usageHints)
}

// GLBufferInitOnce initializes the GL Buffer allocator. It is safe to call
// this function multiple times. This must be called before any other GLBuffer
// operation.
func GLBufferInitOnce() {
	C.gst_gl_buffer_init_once()
}

// GLBufferAllocationParams: instance of this type is always passed by
// reference.
type GLBufferAllocationParams struct {
	*glBufferAllocationParams
}

// glBufferAllocationParams is the struct that's finalized.
type glBufferAllocationParams struct {
	native *C.GstGLBufferAllocationParams
}

func marshalGLBufferAllocationParams(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &GLBufferAllocationParams{&glBufferAllocationParams{(*C.GstGLBufferAllocationParams)(b)}}, nil
}

// NewGLBufferAllocationParams constructs a struct GLBufferAllocationParams.
func NewGLBufferAllocationParams(context GLContexter, allocSize uint, allocParams *gst.AllocationParams, glTarget uint, glUsage uint) *GLBufferAllocationParams {
	var _arg1 *C.GstGLContext                // out
	var _arg2 C.gsize                        // out
	var _arg3 *C.GstAllocationParams         // out
	var _arg4 C.guint                        // out
	var _arg5 C.guint                        // out
	var _cret *C.GstGLBufferAllocationParams // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.gsize(allocSize)
	if allocParams != nil {
		_arg3 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(allocParams)))
	}
	_arg4 = C.guint(glTarget)
	_arg5 = C.guint(glUsage)

	_cret = C.gst_gl_buffer_allocation_params_new(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(context)
	runtime.KeepAlive(allocSize)
	runtime.KeepAlive(allocParams)
	runtime.KeepAlive(glTarget)
	runtime.KeepAlive(glUsage)

	var _glBufferAllocationParams *GLBufferAllocationParams // out

	_glBufferAllocationParams = (*GLBufferAllocationParams)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_glBufferAllocationParams)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _glBufferAllocationParams
}

// Parent: parent object.
func (g *GLBufferAllocationParams) Parent() *GLAllocationParams {
	valptr := &g.native.parent
	var _v *GLAllocationParams // out
	_v = (*GLAllocationParams)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// GLTarget: openGL target to bind the buffer to.
func (g *GLBufferAllocationParams) GLTarget() uint {
	valptr := &g.native.gl_target
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// GLUsage: openGL usage hint to create the buffer with.
func (g *GLBufferAllocationParams) GLUsage() uint {
	valptr := &g.native.gl_usage
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// GLTarget: openGL target to bind the buffer to.
func (g *GLBufferAllocationParams) SetGLTarget(glTarget uint) {
	valptr := &g.native.gl_target
	*valptr = C.guint(glTarget)
}

// GLUsage: openGL usage hint to create the buffer with.
func (g *GLBufferAllocationParams) SetGLUsage(glUsage uint) {
	valptr := &g.native.gl_usage
	*valptr = C.guint(glUsage)
}

// GLBufferAllocatorClass only contains private data
//
// An instance of this type is always passed by reference.
type GLBufferAllocatorClass struct {
	*glBufferAllocatorClass
}

// glBufferAllocatorClass is the struct that's finalized.
type glBufferAllocatorClass struct {
	native *C.GstGLBufferAllocatorClass
}

func (g *GLBufferAllocatorClass) ParentClass() *GLBaseMemoryAllocatorClass {
	valptr := &g.native.parent_class
	var _v *GLBaseMemoryAllocatorClass // out
	_v = (*GLBaseMemoryAllocatorClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// GLBufferPoolClass structure contains only private data
//
// An instance of this type is always passed by reference.
type GLBufferPoolClass struct {
	*glBufferPoolClass
}

// glBufferPoolClass is the struct that's finalized.
type glBufferPoolClass struct {
	native *C.GstGLBufferPoolClass
}

func (g *GLBufferPoolClass) ParentClass() *gst.BufferPoolClass {
	valptr := &g.native.parent_class
	var _v *gst.BufferPoolClass // out
	_v = (*gst.BufferPoolClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// GLColorConvertClass struct only contains private data
//
// An instance of this type is always passed by reference.
type GLColorConvertClass struct {
	*glColorConvertClass
}

// glColorConvertClass is the struct that's finalized.
type glColorConvertClass struct {
	native *C.GstGLColorConvertClass
}

// GLContextClass: instance of this type is always passed by reference.
type GLContextClass struct {
	*glContextClass
}

// glContextClass is the struct that's finalized.
type glContextClass struct {
	native *C.GstGLContextClass
}

func (g *GLContextClass) ParentClass() *gst.ObjectClass {
	valptr := &g.native.parent_class
	var _v *gst.ObjectClass // out
	_v = (*gst.ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// GLDisplayClass: instance of this type is always passed by reference.
type GLDisplayClass struct {
	*glDisplayClass
}

// glDisplayClass is the struct that's finalized.
type glDisplayClass struct {
	native *C.GstGLDisplayClass
}

func (g *GLDisplayClass) ObjectClass() *gst.ObjectClass {
	valptr := &g.native.object_class
	var _v *gst.ObjectClass // out
	_v = (*gst.ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// GLFilterClass: instance of this type is always passed by reference.
type GLFilterClass struct {
	*glFilterClass
}

// glFilterClass is the struct that's finalized.
type glFilterClass struct {
	native *C.GstGLFilterClass
}

func (g *GLFilterClass) ParentClass() *GLBaseFilterClass {
	valptr := &g.native.parent_class
	var _v *GLBaseFilterClass // out
	_v = (*GLBaseFilterClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// GLFramebufferClass: opaque GLFramebufferClass struct
//
// An instance of this type is always passed by reference.
type GLFramebufferClass struct {
	*glFramebufferClass
}

// glFramebufferClass is the struct that's finalized.
type glFramebufferClass struct {
	native *C.GstGLFramebufferClass
}

// GLMemory is a GLBaseMemory subclass providing support for the mapping of
// OpenGL textures.
//
// GLMemory is created or wrapped through gst_gl_base_memory_alloc() with
// GLVideoAllocationParams.
//
// Data is uploaded or downloaded from the GPU as is necessary.
//
// The Caps that is used for GLMemory based buffers should contain the
// GST_CAPS_FEATURE_MEMORY_GL_MEMORY as a CapsFeatures and should contain a
// 'texture-target' field with one of the GLTextureTarget values as a string,
// i.e. some combination of 'texture-target=(string){2D, rectangle,
// external-oes}'.
//
// An instance of this type is always passed by reference.
type GLMemory struct {
	*glMemory
}

// glMemory is the struct that's finalized.
type glMemory struct {
	native *C.GstGLMemory
}

func marshalGLMemory(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &GLMemory{&glMemory{(*C.GstGLMemory)(b)}}, nil
}

// Mem: parent GLBaseMemory object.
func (g *GLMemory) Mem() *GLBaseMemory {
	valptr := &g.native.mem
	var _v *GLBaseMemory // out
	_v = (*GLBaseMemory)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// TexID: GL texture id for this memory.
func (g *GLMemory) TexID() uint {
	valptr := &g.native.tex_id
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// TexTarget: GL texture target for this memory.
func (g *GLMemory) TexTarget() GLTextureTarget {
	valptr := &g.native.tex_target
	var _v GLTextureTarget // out
	_v = GLTextureTarget(*valptr)
	return _v
}

// TexFormat: texture type.
func (g *GLMemory) TexFormat() GLFormat {
	valptr := &g.native.tex_format
	var _v GLFormat // out
	_v = GLFormat(*valptr)
	return _v
}

// Info texture's VideoInfo.
func (g *GLMemory) Info() *gstvideo.VideoInfo {
	valptr := &g.native.info
	var _v *gstvideo.VideoInfo // out
	_v = (*gstvideo.VideoInfo)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// VAlign: data alignment for system memory mapping.
func (g *GLMemory) VAlign() *gstvideo.VideoAlignment {
	valptr := &g.native.valign
	var _v *gstvideo.VideoAlignment // out
	_v = (*gstvideo.VideoAlignment)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Plane: data plane in info.
func (g *GLMemory) Plane() uint {
	valptr := &g.native.plane
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// TexScaling: GL shader scaling parameters for valign and/or width/height.
func (g *GLMemory) TexScaling() [2]float32 {
	valptr := &g.native.tex_scaling
	var _v [2]float32 // out
	_v = *(*[2]float32)(unsafe.Pointer(&*valptr))
	return _v
}

func (g *GLMemory) TextureWrapped() bool {
	valptr := &g.native.texture_wrapped
	var _v bool // out
	if *valptr != 0 {
		_v = true
	}
	return _v
}

func (g *GLMemory) UnpackLength() uint {
	valptr := &g.native.unpack_length
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

func (g *GLMemory) TexWidth() uint {
	valptr := &g.native.tex_width
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// TexID: GL texture id for this memory.
func (g *GLMemory) SetTexID(texId uint) {
	valptr := &g.native.tex_id
	*valptr = C.guint(texId)
}

// Plane: data plane in info.
func (g *GLMemory) SetPlane(plane uint) {
	valptr := &g.native.plane
	*valptr = C.guint(plane)
}

func (g *GLMemory) SetTextureWrapped(textureWrapped bool) {
	valptr := &g.native.texture_wrapped
	if textureWrapped {
		*valptr = C.TRUE
	}
}

func (g *GLMemory) SetUnpackLength(unpackLength uint) {
	valptr := &g.native.unpack_length
	*valptr = C.guint(unpackLength)
}

func (g *GLMemory) SetTexWidth(texWidth uint) {
	valptr := &g.native.tex_width
	*valptr = C.guint(texWidth)
}

// CopyInto copies gl_mem into the texture specified by tex_id. The format of
// tex_id is specified by tex_format, width and height.
//
// The function takes the following parameters:
//
//   - texId: openGL texture id.
//   - target: GLTextureTarget.
//   - texFormat: GLFormat.
//   - width of tex_id.
//   - height of tex_id.
//
// The function returns the following values:
//
//   - ok: whether the copy succeeded.
func (glMem *GLMemory) CopyInto(texId uint, target GLTextureTarget, texFormat GLFormat, width int, height int) bool {
	var _arg0 *C.GstGLMemory       // out
	var _arg1 C.guint              // out
	var _arg2 C.GstGLTextureTarget // out
	var _arg3 C.GstGLFormat        // out
	var _arg4 C.gint               // out
	var _arg5 C.gint               // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(glMem)))
	_arg1 = C.guint(texId)
	_arg2 = C.GstGLTextureTarget(target)
	_arg3 = C.GstGLFormat(texFormat)
	_arg4 = C.gint(width)
	_arg5 = C.gint(height)

	_cret = C.gst_gl_memory_copy_into(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(glMem)
	runtime.KeepAlive(texId)
	runtime.KeepAlive(target)
	runtime.KeepAlive(texFormat)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CopyTeximage copies the texture in GLMemory into the texture specified by
// tex_id, out_target, out_tex_format, out_width and out_height.
//
// The function takes the following parameters:
//
//   - texId: destination texture id.
//   - outTarget: destination GLTextureTarget.
//   - outTexFormat: destination GLFormat.
//   - outWidth: destination width.
//   - outHeight: destination height.
//
// The function returns the following values:
//
//   - ok: whether the copy succeeded.
func (src *GLMemory) CopyTeximage(texId uint, outTarget GLTextureTarget, outTexFormat GLFormat, outWidth int, outHeight int) bool {
	var _arg0 *C.GstGLMemory       // out
	var _arg1 C.guint              // out
	var _arg2 C.GstGLTextureTarget // out
	var _arg3 C.GstGLFormat        // out
	var _arg4 C.gint               // out
	var _arg5 C.gint               // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(src)))
	_arg1 = C.guint(texId)
	_arg2 = C.GstGLTextureTarget(outTarget)
	_arg3 = C.GstGLFormat(outTexFormat)
	_arg4 = C.gint(outWidth)
	_arg5 = C.gint(outHeight)

	_cret = C.gst_gl_memory_copy_teximage(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(src)
	runtime.KeepAlive(texId)
	runtime.KeepAlive(outTarget)
	runtime.KeepAlive(outTexFormat)
	runtime.KeepAlive(outWidth)
	runtime.KeepAlive(outHeight)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - glFormat of gl_mem.
func (glMem *GLMemory) TextureFormat() GLFormat {
	var _arg0 *C.GstGLMemory // out
	var _cret C.GstGLFormat  // in

	_arg0 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(glMem)))

	_cret = C.gst_gl_memory_get_texture_format(_arg0)
	runtime.KeepAlive(glMem)

	var _glFormat GLFormat // out

	_glFormat = GLFormat(_cret)

	return _glFormat
}

// The function returns the following values:
//
//   - gint: texture height of gl_mem.
func (glMem *GLMemory) TextureHeight() int {
	var _arg0 *C.GstGLMemory // out
	var _cret C.gint         // in

	_arg0 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(glMem)))

	_cret = C.gst_gl_memory_get_texture_height(_arg0)
	runtime.KeepAlive(glMem)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
//   - guint: openGL texture handle of gl_mem.
func (glMem *GLMemory) TextureID() uint {
	var _arg0 *C.GstGLMemory // out
	var _cret C.guint        // in

	_arg0 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(glMem)))

	_cret = C.gst_gl_memory_get_texture_id(_arg0)
	runtime.KeepAlive(glMem)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - glTextureTarget of gl_mem.
func (glMem *GLMemory) TextureTarget() GLTextureTarget {
	var _arg0 *C.GstGLMemory       // out
	var _cret C.GstGLTextureTarget // in

	_arg0 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(glMem)))

	_cret = C.gst_gl_memory_get_texture_target(_arg0)
	runtime.KeepAlive(glMem)

	var _glTextureTarget GLTextureTarget // out

	_glTextureTarget = GLTextureTarget(_cret)

	return _glTextureTarget
}

// The function returns the following values:
//
//   - gint: texture width of gl_mem.
func (glMem *GLMemory) TextureWidth() int {
	var _arg0 *C.GstGLMemory // out
	var _cret C.gint         // in

	_arg0 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(glMem)))

	_cret = C.gst_gl_memory_get_texture_width(_arg0)
	runtime.KeepAlive(glMem)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ReadPixels reads the texture in GLMemory into write_pointer if no buffer is
// bound to GL_PIXEL_PACK_BUFFER. Otherwise write_pointer is the byte offset
// into the currently bound GL_PIXEL_PACK_BUFFER buffer to store the result of
// glReadPixels. See the OpenGL specification for glReadPixels for more details.
//
// The function takes the following parameters:
//
//   - writePointer (optional): data pointer to pass to glReadPixels.
//
// The function returns the following values:
//
//   - ok: whether theread operation succeeded.
func (glMem *GLMemory) ReadPixels(writePointer unsafe.Pointer) bool {
	var _arg0 *C.GstGLMemory // out
	var _arg1 C.gpointer     // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(glMem)))
	_arg1 = (C.gpointer)(unsafe.Pointer(writePointer))

	_cret = C.gst_gl_memory_read_pixels(_arg0, _arg1)
	runtime.KeepAlive(glMem)
	runtime.KeepAlive(writePointer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Texsubimage reads the texture in read_pointer into gl_mem.
//
// See gst_gl_memory_read_pixels() for what read_pointer signifies.
//
// The function takes the following parameters:
//
//   - readPointer (optional): data pointer to pass to glTexSubImage.
func (glMem *GLMemory) Texsubimage(readPointer unsafe.Pointer) {
	var _arg0 *C.GstGLMemory // out
	var _arg1 C.gpointer     // out

	_arg0 = (*C.GstGLMemory)(gextras.StructNative(unsafe.Pointer(glMem)))
	_arg1 = (C.gpointer)(unsafe.Pointer(readPointer))

	C.gst_gl_memory_texsubimage(_arg0, _arg1)
	runtime.KeepAlive(glMem)
	runtime.KeepAlive(readPointer)
}

// GLMemoryInitOnce initializes the GL Base Texture allocator. It is safe to
// call this function multiple times. This must be called before any other
// GstGLMemory operation.
func GLMemoryInitOnce() {
	C.gst_gl_memory_init_once()
}

// GLMemoryAllocatorClass: instance of this type is always passed by reference.
type GLMemoryAllocatorClass struct {
	*glMemoryAllocatorClass
}

// glMemoryAllocatorClass is the struct that's finalized.
type glMemoryAllocatorClass struct {
	native *C.GstGLMemoryAllocatorClass
}

// GLMemoryPBO is created or wrapped through gst_gl_base_memory_alloc() with
// GLVideoAllocationParams.
//
// Data is uploaded or downloaded from the GPU as is necessary.
//
// An instance of this type is always passed by reference.
type GLMemoryPBO struct {
	*glMemoryPBO
}

// glMemoryPBO is the struct that's finalized.
type glMemoryPBO struct {
	native *C.GstGLMemoryPBO
}

func marshalGLMemoryPBO(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &GLMemoryPBO{&glMemoryPBO{(*C.GstGLMemoryPBO)(b)}}, nil
}

// CopyIntoTexture copies gl_mem into the texture specified by tex_id.
// The format of tex_id is specified by tex_format, width and height.
//
// If respecify is TRUE, then the copy is performed in terms of the texture
// data. This is useful for splitting RGBA textures into RG or R textures or
// vice versa. The requirement for this to succeed is that the backing texture
// data must be the same size, i.e. say a RGBA8 texture is converted into a RG8
// texture, then the RG texture must have twice as many pixels available for
// output as the RGBA texture.
//
// Otherwise, if respecify is FALSE, then the copy is performed per texel using
// glCopyTexImage. See the OpenGL specification for details on the mappings
// between texture formats.
//
// The function takes the following parameters:
//
//   - texId: destination texture id.
//   - target: destination GLTextureTarget.
//   - texFormat: destination GLFormat.
//   - width of tex_id.
//   - height of tex_id.
//   - stride of the backing texture data.
//   - respecify: whether to copy the data or copy per texel.
//
// The function returns the following values:
//
//   - ok: whether the copy succeeded.
func (glMem *GLMemoryPBO) CopyIntoTexture(texId uint, target GLTextureTarget, texFormat GLFormat, width int, height int, stride int, respecify bool) bool {
	var _arg0 *C.GstGLMemoryPBO    // out
	var _arg1 C.guint              // out
	var _arg2 C.GstGLTextureTarget // out
	var _arg3 C.GstGLFormat        // out
	var _arg4 C.gint               // out
	var _arg5 C.gint               // out
	var _arg6 C.gint               // out
	var _arg7 C.gboolean           // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstGLMemoryPBO)(gextras.StructNative(unsafe.Pointer(glMem)))
	_arg1 = C.guint(texId)
	_arg2 = C.GstGLTextureTarget(target)
	_arg3 = C.GstGLFormat(texFormat)
	_arg4 = C.gint(width)
	_arg5 = C.gint(height)
	_arg6 = C.gint(stride)
	if respecify {
		_arg7 = C.TRUE
	}

	_cret = C.gst_gl_memory_pbo_copy_into_texture(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(glMem)
	runtime.KeepAlive(texId)
	runtime.KeepAlive(target)
	runtime.KeepAlive(texFormat)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(stride)
	runtime.KeepAlive(respecify)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DownloadTransfer: transfer the texture data from the texture into the PBO if
// necessary.
func (glMem *GLMemoryPBO) DownloadTransfer() {
	var _arg0 *C.GstGLMemoryPBO // out

	_arg0 = (*C.GstGLMemoryPBO)(gextras.StructNative(unsafe.Pointer(glMem)))

	C.gst_gl_memory_pbo_download_transfer(_arg0)
	runtime.KeepAlive(glMem)
}

// UploadTransfer: transfer the texture data from the PBO into the texture if
// necessary.
func (glMem *GLMemoryPBO) UploadTransfer() {
	var _arg0 *C.GstGLMemoryPBO // out

	_arg0 = (*C.GstGLMemoryPBO)(gextras.StructNative(unsafe.Pointer(glMem)))

	C.gst_gl_memory_pbo_upload_transfer(_arg0)
	runtime.KeepAlive(glMem)
}

func GLMemoryPBOInitOnce() {
	C.gst_gl_memory_pbo_init_once()
}

// GLMemoryPBOAllocatorClass: only contains private data
//
// An instance of this type is always passed by reference.
type GLMemoryPBOAllocatorClass struct {
	*glMemoryPBOAllocatorClass
}

// glMemoryPBOAllocatorClass is the struct that's finalized.
type glMemoryPBOAllocatorClass struct {
	native *C.GstGLMemoryPBOAllocatorClass
}

func (g *GLMemoryPBOAllocatorClass) ParentClass() *GLMemoryAllocatorClass {
	valptr := &g.native.parent_class
	var _v *GLMemoryAllocatorClass // out
	_v = (*GLMemoryAllocatorClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// GLMixerClass: instance of this type is always passed by reference.
type GLMixerClass struct {
	*glMixerClass
}

// glMixerClass is the struct that's finalized.
type glMixerClass struct {
	native *C.GstGLMixerClass
}

func (g *GLMixerClass) ParentClass() *GLBaseMixerClass {
	valptr := &g.native.parent_class
	var _v *GLBaseMixerClass // out
	_v = (*GLBaseMixerClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// AddRGBAPadTemplates adds the default RGBA pad templates to this class.
// If you have any special template requirements like a different pad subclass
// or different supported caps, you should not call this function and add the
// pad templates yourself manually.
func (klass *GLMixerClass) AddRGBAPadTemplates() {
	var _arg0 *C.GstGLMixerClass // out

	_arg0 = (*C.GstGLMixerClass)(gextras.StructNative(unsafe.Pointer(klass)))

	C.gst_gl_mixer_class_add_rgba_pad_templates(_arg0)
	runtime.KeepAlive(klass)
}

// GLMixerPadClass: instance of this type is always passed by reference.
type GLMixerPadClass struct {
	*glMixerPadClass
}

// glMixerPadClass is the struct that's finalized.
type glMixerPadClass struct {
	native *C.GstGLMixerPadClass
}

// ParentClass: parent GLBaseMixerPadClass.
func (g *GLMixerPadClass) ParentClass() *GLBaseMixerPadClass {
	valptr := &g.native.parent_class
	var _v *GLBaseMixerPadClass // out
	_v = (*GLBaseMixerPadClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// GLOverlayCompositorClass: instance of this type is always passed by
// reference.
type GLOverlayCompositorClass struct {
	*glOverlayCompositorClass
}

// glOverlayCompositorClass is the struct that's finalized.
type glOverlayCompositorClass struct {
	native *C.GstGLOverlayCompositorClass
}

func (g *GLOverlayCompositorClass) ObjectClass() *gst.ObjectClass {
	valptr := &g.native.object_class
	var _v *gst.ObjectClass // out
	_v = (*gst.ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// GLQuery represents and holds an OpenGL query object. Various types of queries
// can be run or counters retrieved.
//
// An instance of this type is always passed by reference.
type GLQuery struct {
	*glQuery
}

// glQuery is the struct that's finalized.
type glQuery struct {
	native *C.GstGLQuery
}

// Counter: record the result of a counter.
func (query *GLQuery) Counter() {
	var _arg0 *C.GstGLQuery // out

	_arg0 = (*C.GstGLQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_gl_query_counter(_arg0)
	runtime.KeepAlive(query)
}

// End counting the query.
func (query *GLQuery) End() {
	var _arg0 *C.GstGLQuery // out

	_arg0 = (*C.GstGLQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_gl_query_end(_arg0)
	runtime.KeepAlive(query)
}

// The function takes the following parameters:
//
//   - context: GLContext.
//   - queryType: GLQueryType.
func (query *GLQuery) Init(context GLContexter, queryType GLQueryType) {
	var _arg0 *C.GstGLQuery    // out
	var _arg1 *C.GstGLContext  // out
	var _arg2 C.GstGLQueryType // out

	_arg0 = (*C.GstGLQuery)(gextras.StructNative(unsafe.Pointer(query)))
	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.GstGLQueryType(queryType)

	C.gst_gl_query_init(_arg0, _arg1, _arg2)
	runtime.KeepAlive(query)
	runtime.KeepAlive(context)
	runtime.KeepAlive(queryType)
}

// The function returns the following values:
//
//   - guint64: result of the query.
func (query *GLQuery) Result() uint64 {
	var _arg0 *C.GstGLQuery // out
	var _cret C.guint64     // in

	_arg0 = (*C.GstGLQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C.gst_gl_query_result(_arg0)
	runtime.KeepAlive(query)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// Start counting the query.
func (query *GLQuery) Start() {
	var _arg0 *C.GstGLQuery // out

	_arg0 = (*C.GstGLQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_gl_query_start(_arg0)
	runtime.KeepAlive(query)
}

// Unset: free any dynamically allocated resources.
func (query *GLQuery) Unset() {
	var _arg0 *C.GstGLQuery // out

	_arg0 = (*C.GstGLQuery)(gextras.StructNative(unsafe.Pointer(query)))

	C.gst_gl_query_unset(_arg0)
	runtime.KeepAlive(query)
}

// GLRenderbuffer is a GLBaseMemory subclass providing support for OpenGL
// renderbuffers.
//
// GLRenderbuffer is created or wrapped through gst_gl_base_memory_alloc() with
// GLRenderbufferAllocationParams.
//
// An instance of this type is always passed by reference.
type GLRenderbuffer struct {
	*glRenderbuffer
}

// glRenderbuffer is the struct that's finalized.
type glRenderbuffer struct {
	native *C.GstGLRenderbuffer
}

func marshalGLRenderbuffer(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &GLRenderbuffer{&glRenderbuffer{(*C.GstGLRenderbuffer)(b)}}, nil
}

// RenderbufferID: GL texture id for this memory.
func (g *GLRenderbuffer) RenderbufferID() uint {
	valptr := &g.native.renderbuffer_id
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// RenderbufferFormat: texture type.
func (g *GLRenderbuffer) RenderbufferFormat() GLFormat {
	valptr := &g.native.renderbuffer_format
	var _v GLFormat // out
	_v = GLFormat(*valptr)
	return _v
}

func (g *GLRenderbuffer) RenderbufferWrapped() bool {
	valptr := &g.native.renderbuffer_wrapped
	var _v bool // out
	if *valptr != 0 {
		_v = true
	}
	return _v
}

// RenderbufferID: GL texture id for this memory.
func (g *GLRenderbuffer) SetRenderbufferID(renderbufferId uint) {
	valptr := &g.native.renderbuffer_id
	*valptr = C.guint(renderbufferId)
}

func (g *GLRenderbuffer) SetRenderbufferWrapped(renderbufferWrapped bool) {
	valptr := &g.native.renderbuffer_wrapped
	if renderbufferWrapped {
		*valptr = C.TRUE
	}
}

// The function returns the following values:
//
//   - glFormat of gl_mem.
func (glMem *GLRenderbuffer) Format() GLFormat {
	var _arg0 *C.GstGLRenderbuffer // out
	var _cret C.GstGLFormat        // in

	_arg0 = (*C.GstGLRenderbuffer)(gextras.StructNative(unsafe.Pointer(glMem)))

	_cret = C.gst_gl_renderbuffer_get_format(_arg0)
	runtime.KeepAlive(glMem)

	var _glFormat GLFormat // out

	_glFormat = GLFormat(_cret)

	return _glFormat
}

// The function returns the following values:
//
//   - gint: configured height of gl_mem.
func (glMem *GLRenderbuffer) Height() int {
	var _arg0 *C.GstGLRenderbuffer // out
	var _cret C.gint               // in

	_arg0 = (*C.GstGLRenderbuffer)(gextras.StructNative(unsafe.Pointer(glMem)))

	_cret = C.gst_gl_renderbuffer_get_height(_arg0)
	runtime.KeepAlive(glMem)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
//   - guint: openGL renderbuffer handle of gl_mem.
func (glMem *GLRenderbuffer) ID() uint {
	var _arg0 *C.GstGLRenderbuffer // out
	var _cret C.guint              // in

	_arg0 = (*C.GstGLRenderbuffer)(gextras.StructNative(unsafe.Pointer(glMem)))

	_cret = C.gst_gl_renderbuffer_get_id(_arg0)
	runtime.KeepAlive(glMem)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - gint: configured width of gl_mem.
func (glMem *GLRenderbuffer) Width() int {
	var _arg0 *C.GstGLRenderbuffer // out
	var _cret C.gint               // in

	_arg0 = (*C.GstGLRenderbuffer)(gextras.StructNative(unsafe.Pointer(glMem)))

	_cret = C.gst_gl_renderbuffer_get_width(_arg0)
	runtime.KeepAlive(glMem)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// GLRenderbufferInitOnce initializes the GL Base Texture allocator. It is safe
// to call this function multiple times. This must be called before any other
// GstGLRenderbuffer operation.
func GLRenderbufferInitOnce() {
	C.gst_gl_renderbuffer_init_once()
}

// GLRenderbufferAllocationParams: allocation parameters
//
// An instance of this type is always passed by reference.
type GLRenderbufferAllocationParams struct {
	*glRenderbufferAllocationParams
}

// glRenderbufferAllocationParams is the struct that's finalized.
type glRenderbufferAllocationParams struct {
	native *C.GstGLRenderbufferAllocationParams
}

func marshalGLRenderbufferAllocationParams(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &GLRenderbufferAllocationParams{&glRenderbufferAllocationParams{(*C.GstGLRenderbufferAllocationParams)(b)}}, nil
}

// NewGLRenderbufferAllocationParams constructs a struct GLRenderbufferAllocationParams.
func NewGLRenderbufferAllocationParams(context GLContexter, allocParams *gst.AllocationParams, renderbufferFormat GLFormat, width uint, height uint) *GLRenderbufferAllocationParams {
	var _arg1 *C.GstGLContext                      // out
	var _arg2 *C.GstAllocationParams               // out
	var _arg3 C.GstGLFormat                        // out
	var _arg4 C.guint                              // out
	var _arg5 C.guint                              // out
	var _cret *C.GstGLRenderbufferAllocationParams // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if allocParams != nil {
		_arg2 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(allocParams)))
	}
	_arg3 = C.GstGLFormat(renderbufferFormat)
	_arg4 = C.guint(width)
	_arg5 = C.guint(height)

	_cret = C.gst_gl_renderbuffer_allocation_params_new(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(context)
	runtime.KeepAlive(allocParams)
	runtime.KeepAlive(renderbufferFormat)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)

	var _glRenderbufferAllocationParams *GLRenderbufferAllocationParams // out

	_glRenderbufferAllocationParams = (*GLRenderbufferAllocationParams)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_glRenderbufferAllocationParams)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _glRenderbufferAllocationParams
}

// RenderbufferFormat: GLFormat.
func (g *GLRenderbufferAllocationParams) RenderbufferFormat() GLFormat {
	valptr := &g.native.renderbuffer_format
	var _v GLFormat // out
	_v = GLFormat(*valptr)
	return _v
}

// Width: width.
func (g *GLRenderbufferAllocationParams) Width() uint {
	valptr := &g.native.width
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Height: height.
func (g *GLRenderbufferAllocationParams) Height() uint {
	valptr := &g.native.height
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Width: width.
func (g *GLRenderbufferAllocationParams) SetWidth(width uint) {
	valptr := &g.native.width
	*valptr = C.guint(width)
}

// Height: height.
func (g *GLRenderbufferAllocationParams) SetHeight(height uint) {
	valptr := &g.native.height
	*valptr = C.guint(height)
}

// GLRenderbufferAllocatorClass only contains private data
//
// An instance of this type is always passed by reference.
type GLRenderbufferAllocatorClass struct {
	*glRenderbufferAllocatorClass
}

// glRenderbufferAllocatorClass is the struct that's finalized.
type glRenderbufferAllocatorClass struct {
	native *C.GstGLRenderbufferAllocatorClass
}

func (g *GLRenderbufferAllocatorClass) ParentClass() *GLBaseMemoryAllocatorClass {
	valptr := &g.native.parent_class
	var _v *GLBaseMemoryAllocatorClass // out
	_v = (*GLBaseMemoryAllocatorClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// GLSLStageClass: opaque GLSLStageClass struct
//
// An instance of this type is always passed by reference.
type GLSLStageClass struct {
	*glslStageClass
}

// glslStageClass is the struct that's finalized.
type glslStageClass struct {
	native *C.GstGLSLStageClass
}

// GLShaderClass: instance of this type is always passed by reference.
type GLShaderClass struct {
	*glShaderClass
}

// glShaderClass is the struct that's finalized.
type glShaderClass struct {
	native *C.GstGLShaderClass
}

// GLSyncMeta provides the ability to synchronize the OpenGL command stream with
// the CPU or with other OpenGL contexts.
//
// An instance of this type is always passed by reference.
type GLSyncMeta struct {
	*glSyncMeta
}

// glSyncMeta is the struct that's finalized.
type glSyncMeta struct {
	native *C.GstGLSyncMeta
}

// Parent: parent Meta.
func (g *GLSyncMeta) Parent() *gst.Meta {
	valptr := &g.native.parent
	var _v *gst.Meta // out
	_v = (*gst.Meta)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Context used to allocate the meta.
func (g *GLSyncMeta) Context() GLContexter {
	valptr := &g.native.context
	var _v GLContexter // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gstgl.GLContexter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(GLContexter)
			return ok
		})
		rv, ok := casted.(GLContexter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstgl.GLContexter")
		}
		_v = rv
	}
	return _v
}

// Data: custom data pointer for the implementation.
func (g *GLSyncMeta) Data() unsafe.Pointer {
	valptr := &g.native.data
	var _v unsafe.Pointer // out
	_v = (unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

// SetSyncPoint: set a sync point to possibly wait on at a later time.
//
// The function takes the following parameters:
//
//   - context: GLContext.
func (syncMeta *GLSyncMeta) SetSyncPoint(context GLContexter) {
	var _arg0 *C.GstGLSyncMeta // out
	var _arg1 *C.GstGLContext  // out

	_arg0 = (*C.GstGLSyncMeta)(gextras.StructNative(unsafe.Pointer(syncMeta)))
	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gst_gl_sync_meta_set_sync_point(_arg0, _arg1)
	runtime.KeepAlive(syncMeta)
	runtime.KeepAlive(context)
}

// Wait: insert a wait into context's command stream ensuring all previous
// OpenGL commands before sync_meta have completed.
//
// The function takes the following parameters:
//
//   - context: GLContext.
func (syncMeta *GLSyncMeta) Wait(context GLContexter) {
	var _arg0 *C.GstGLSyncMeta // out
	var _arg1 *C.GstGLContext  // out

	_arg0 = (*C.GstGLSyncMeta)(gextras.StructNative(unsafe.Pointer(syncMeta)))
	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gst_gl_sync_meta_wait(_arg0, _arg1)
	runtime.KeepAlive(syncMeta)
	runtime.KeepAlive(context)
}

// WaitCpu: perform a wait so that the sync point has passed from the CPU's
// perspective What that means, is that all GL operations changing CPU-visible
// data before the sync point are now visible.
//
// The function takes the following parameters:
//
//   - context: GLContext.
func (syncMeta *GLSyncMeta) WaitCpu(context GLContexter) {
	var _arg0 *C.GstGLSyncMeta // out
	var _arg1 *C.GstGLContext  // out

	_arg0 = (*C.GstGLSyncMeta)(gextras.StructNative(unsafe.Pointer(syncMeta)))
	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gst_gl_sync_meta_wait_cpu(_arg0, _arg1)
	runtime.KeepAlive(syncMeta)
	runtime.KeepAlive(context)
}

func GLSyncMetaGetInfo() *gst.MetaInfo {
	var _cret *C.GstMetaInfo // in

	_cret = C.gst_gl_sync_meta_get_info()

	var _metaInfo *gst.MetaInfo // out

	_metaInfo = (*gst.MetaInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _metaInfo
}

// GLUploadClass struct only contains private data
//
// An instance of this type is always passed by reference.
type GLUploadClass struct {
	*glUploadClass
}

// glUploadClass is the struct that's finalized.
type glUploadClass struct {
	native *C.GstGLUploadClass
}

func (g *GLUploadClass) ObjectClass() *gst.ObjectClass {
	valptr := &g.native.object_class
	var _v *gst.ObjectClass // out
	_v = (*gst.ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// GLVideoAllocationParams: instance of this type is always passed by reference.
type GLVideoAllocationParams struct {
	*glVideoAllocationParams
}

// glVideoAllocationParams is the struct that's finalized.
type glVideoAllocationParams struct {
	native *C.GstGLVideoAllocationParams
}

func marshalGLVideoAllocationParams(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &GLVideoAllocationParams{&glVideoAllocationParams{(*C.GstGLVideoAllocationParams)(b)}}, nil
}

// NewGLVideoAllocationParams constructs a struct GLVideoAllocationParams.
func NewGLVideoAllocationParams(context GLContexter, allocParams *gst.AllocationParams, vInfo *gstvideo.VideoInfo, plane uint, valign *gstvideo.VideoAlignment, target GLTextureTarget, texFormat GLFormat) *GLVideoAllocationParams {
	var _arg1 *C.GstGLContext               // out
	var _arg2 *C.GstAllocationParams        // out
	var _arg3 *C.GstVideoInfo               // out
	var _arg4 C.guint                       // out
	var _arg5 *C.GstVideoAlignment          // out
	var _arg6 C.GstGLTextureTarget          // out
	var _arg7 C.GstGLFormat                 // out
	var _cret *C.GstGLVideoAllocationParams // in

	_arg1 = (*C.GstGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if allocParams != nil {
		_arg2 = (*C.GstAllocationParams)(gextras.StructNative(unsafe.Pointer(allocParams)))
	}
	_arg3 = (*C.GstVideoInfo)(gextras.StructNative(unsafe.Pointer(vInfo)))
	_arg4 = C.guint(plane)
	if valign != nil {
		_arg5 = (*C.GstVideoAlignment)(gextras.StructNative(unsafe.Pointer(valign)))
	}
	_arg6 = C.GstGLTextureTarget(target)
	_arg7 = C.GstGLFormat(texFormat)

	_cret = C.gst_gl_video_allocation_params_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(context)
	runtime.KeepAlive(allocParams)
	runtime.KeepAlive(vInfo)
	runtime.KeepAlive(plane)
	runtime.KeepAlive(valign)
	runtime.KeepAlive(target)
	runtime.KeepAlive(texFormat)

	var _glVideoAllocationParams *GLVideoAllocationParams // out

	_glVideoAllocationParams = (*GLVideoAllocationParams)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_glVideoAllocationParams)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _glVideoAllocationParams
}

// Parent: parent GLAllocationParams structure.
func (g *GLVideoAllocationParams) Parent() *GLAllocationParams {
	valptr := &g.native.parent
	var _v *GLAllocationParams // out
	_v = (*GLAllocationParams)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// VInfo to allocate.
func (g *GLVideoAllocationParams) VInfo() *gstvideo.VideoInfo {
	valptr := &g.native.v_info
	var _v *gstvideo.VideoInfo // out
	_v = (*gstvideo.VideoInfo)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// Plane: video plane index to allocate.
func (g *GLVideoAllocationParams) Plane() uint {
	valptr := &g.native.plane
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// VAlign to align the system representation to (may be NULL for the default).
func (g *GLVideoAllocationParams) VAlign() *gstvideo.VideoAlignment {
	valptr := &g.native.valign
	var _v *gstvideo.VideoAlignment // out
	_v = (*gstvideo.VideoAlignment)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// Target to allocate.
func (g *GLVideoAllocationParams) Target() GLTextureTarget {
	valptr := &g.native.target
	var _v GLTextureTarget // out
	_v = GLTextureTarget(*valptr)
	return _v
}

// TexFormat to allocate.
func (g *GLVideoAllocationParams) TexFormat() GLFormat {
	valptr := &g.native.tex_format
	var _v GLFormat // out
	_v = GLFormat(*valptr)
	return _v
}

// Plane: video plane index to allocate.
func (g *GLVideoAllocationParams) SetPlane(plane uint) {
	valptr := &g.native.plane
	*valptr = C.guint(plane)
}

// CopyData: copy and set any dynamically allocated resources in dest_vid.
// Intended for subclass usage only to chain up at the end of a subclass copy
// function.
//
// The function takes the following parameters:
//
//   - destVid: destination GLVideoAllocationParams to copy into.
func (srcVid *GLVideoAllocationParams) CopyData(destVid *GLVideoAllocationParams) {
	var _arg0 *C.GstGLVideoAllocationParams // out
	var _arg1 *C.GstGLVideoAllocationParams // out

	_arg0 = (*C.GstGLVideoAllocationParams)(gextras.StructNative(unsafe.Pointer(srcVid)))
	_arg1 = (*C.GstGLVideoAllocationParams)(gextras.StructNative(unsafe.Pointer(destVid)))

	C.gst_gl_video_allocation_params_copy_data(_arg0, _arg1)
	runtime.KeepAlive(srcVid)
	runtime.KeepAlive(destVid)
}

// FreeData: unset and free any dynamically allocated resources. Intended for
// subclass usage only to chain up at the end of a subclass free function.
func (params *GLVideoAllocationParams) FreeData() {
	var _arg0 *C.GstGLVideoAllocationParams // out

	_arg0 = (*C.GstGLVideoAllocationParams)(gextras.StructNative(unsafe.Pointer(params)))

	C.gst_gl_video_allocation_params_free_data(_arg0)
	runtime.KeepAlive(params)
}

// GLViewConvertClass: opaque GLViewConvertClass struct
//
// An instance of this type is always passed by reference.
type GLViewConvertClass struct {
	*glViewConvertClass
}

// glViewConvertClass is the struct that's finalized.
type glViewConvertClass struct {
	native *C.GstGLViewConvertClass
}

// GLWindowClass: instance of this type is always passed by reference.
type GLWindowClass struct {
	*glWindowClass
}

// glWindowClass is the struct that's finalized.
type glWindowClass struct {
	native *C.GstGLWindowClass
}

// ParentClass: parent class.
func (g *GLWindowClass) ParentClass() *gst.ObjectClass {
	valptr := &g.native.parent_class
	var _v *gst.ObjectClass // out
	_v = (*gst.ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
