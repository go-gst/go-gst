// Code generated by girgen. DO NOT EDIT.

package gstnet

import (
	"runtime"
	_ "runtime/cgo"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/go-gst/go-gst/pkg/gst"
)

// #cgo pkg-config: gstreamer-net-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/net/net.h>
// extern void callbackDelete(gpointer);
// extern gboolean _gotk4_gstnet1_PtpStatisticsCallback(guint8, GstStructure*, gpointer);
import "C"

// GType values.
var (
	GTypeNetClientClock  = coreglib.Type(C.gst_net_client_clock_get_type())
	GTypeNetTimeProvider = coreglib.Type(C.gst_net_time_provider_get_type())
	GTypeNtpClock        = coreglib.Type(C.gst_ntp_clock_get_type())
	GTypePtpClock        = coreglib.Type(C.gst_ptp_clock_get_type())
	GTypeNetTimePacket   = coreglib.Type(C.gst_net_time_packet_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeNetClientClock, F: marshalNetClientClock},
		coreglib.TypeMarshaler{T: GTypeNetTimeProvider, F: marshalNetTimeProvider},
		coreglib.TypeMarshaler{T: GTypeNtpClock, F: marshalNtpClock},
		coreglib.TypeMarshaler{T: GTypePtpClock, F: marshalPtpClock},
		coreglib.TypeMarshaler{T: GTypeNetTimePacket, F: marshalNetTimePacket},
	})
}

// NET_TIME_PACKET_SIZE (GST_NET_TIME_PACKET_SIZE): size of the packets sent
// between network clocks.
const NET_TIME_PACKET_SIZE = 16

// PTP_CLOCK_ID_NONE (GST_PTP_CLOCK_ID_NONE): PTP clock identification that
// can be passed to gst_ptp_init() to automatically select one based on the MAC
// address of interfaces.
const PTP_CLOCK_ID_NONE = 18446744073709551615
const PTP_STATISTICS_BEST_MASTER_CLOCK_SELECTED = "GstPtpStatisticsBestMasterClockSelected"
const PTP_STATISTICS_NEW_DOMAIN_FOUND = "GstPtpStatisticsNewDomainFound"
const PTP_STATISTICS_PATH_DELAY_MEASURED = "GstPtpStatisticsPathDelayMeasured"
const PTP_STATISTICS_TIME_UPDATED = "GstPtpStatisticsTimeUpdated"

// PtpStatisticsCallback statistics can be the following structures:
//
// GST_PTP_STATISTICS_NEW_DOMAIN_FOUND: "domain" G_TYPE_UINT The domain
// identifier of the domain "clock" GST_TYPE_CLOCK The internal clock that is
// slaved to the PTP domain
//
// GST_PTP_STATISTICS_BEST_MASTER_CLOCK_SELECTED: "domain" G_TYPE_UINT The
// domain identifier of the domain "master-clock-id" G_TYPE_UINT64 PTP clock
// identifier of the selected master clock "master-clock-port" G_TYPE_UINT PTP
// port number of the selected master clock "grandmaster-clock-id" G_TYPE_UINT64
// PTP clock identifier of the grandmaster clock
//
// GST_PTP_STATISTICS_PATH_DELAY_MEASURED: "domain" G_TYPE_UINT The domain
// identifier of the domain "mean-path-delay-avg" GST_TYPE_CLOCK_TIME Average
// mean path delay "mean-path-delay" GST_TYPE_CLOCK_TIME Latest mean path delay
// "delay-request-delay" GST_TYPE_CLOCK_TIME Delay of DELAY_REQ / DELAY_RESP
// messages
//
// GST_PTP_STATISTICS_TIME_UPDATED: "domain" G_TYPE_UINT The domain identifier
// of the domain "mean-path-delay-avg" GST_TYPE_CLOCK_TIME Average mean
// path delay "local-time" GST_TYPE_CLOCK_TIME Local time that corresponds
// to ptp-time "ptp-time" GST_TYPE_CLOCK_TIME Newly measured PTP time at
// local-time "estimated-ptp-time" GST_TYPE_CLOCK_TIME Estimated PTP time
// based on previous measurements "discontinuity" G_TYPE_INT64 Difference
// between estimated and measured PTP time "synced" G_TYPE_BOOLEAN Currently
// synced to the remote clock "r-squared" G_TYPE_DOUBLE RÂ² of clock estimation
// regression "internal-time" GST_TYPE_CLOCK_TIME Internal time clock parameter
// "external-time" GST_TYPE_CLOCK_TIME External time clock parameter "rate-num"
// G_TYPE_UINT64 Internal/external rate numerator "rate-den" G_TYPE_UINT64
// Internal/external rate denominator "rate" G_TYPE_DOUBLE Internal/external
// rate
//
// If FALSE is returned, the callback is removed and never called again.
type PtpStatisticsCallback func(domain byte, stats *gst.Structure) (ok bool)

// BufferAddNetAddressMeta (gst_buffer_add_net_address_meta) attaches addr as
// metadata in a NetAddressMeta to buffer.
//
// The function takes the following parameters:
//
//   - buffer: Buffer.
//   - addr GSocketAddress to connect to buffer.
//
// The function returns the following values:
//
//   - netAddressMeta connected to buffer.
func BufferAddNetAddressMeta(buffer *gst.Buffer, addr gio.SocketAddresser) *NetAddressMeta {
	var _arg1 *C.GstBuffer         // out
	var _arg2 *C.GSocketAddress    // out
	var _cret *C.GstNetAddressMeta // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.BaseObject(addr).Native()))

	_cret = C.gst_buffer_add_net_address_meta(_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(addr)

	var _netAddressMeta *NetAddressMeta // out

	_netAddressMeta = (*NetAddressMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _netAddressMeta
}

// BufferAddNetControlMessageMeta (gst_buffer_add_net_control_message_meta)
// attaches message as metadata in a NetControlMessageMeta to buffer.
//
// The function takes the following parameters:
//
//   - buffer: Buffer.
//   - message: GSocketControlMessage to attach to buffer.
//
// The function returns the following values:
//
//   - netControlMessageMeta connected to buffer.
func BufferAddNetControlMessageMeta(buffer *gst.Buffer, message gio.SocketControlMessager) *NetControlMessageMeta {
	var _arg1 *C.GstBuffer                // out
	var _arg2 *C.GSocketControlMessage    // out
	var _cret *C.GstNetControlMessageMeta // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	_arg2 = (*C.GSocketControlMessage)(unsafe.Pointer(coreglib.BaseObject(message).Native()))

	_cret = C.gst_buffer_add_net_control_message_meta(_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(message)

	var _netControlMessageMeta *NetControlMessageMeta // out

	_netControlMessageMeta = (*NetControlMessageMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _netControlMessageMeta
}

// BufferGetNetAddressMeta (gst_buffer_get_net_address_meta): find the
// NetAddressMeta on buffer.
//
// The function takes the following parameters:
//
//   - buffer: Buffer.
//
// The function returns the following values:
//
//   - netAddressMeta (optional) or NULL when there is no such metadata on
//     buffer.
func BufferGetNetAddressMeta(buffer *gst.Buffer) *NetAddressMeta {
	var _arg1 *C.GstBuffer         // out
	var _cret *C.GstNetAddressMeta // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))

	_cret = C.gst_buffer_get_net_address_meta(_arg1)
	runtime.KeepAlive(buffer)

	var _netAddressMeta *NetAddressMeta // out

	if _cret != nil {
		_netAddressMeta = (*NetAddressMeta)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _netAddressMeta
}

func NetAddressMetaApiGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.gst_net_address_meta_api_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

func NetControlMessageMetaApiGetType() coreglib.Type {
	var _cret C.GType // in

	_cret = C.gst_net_control_message_meta_api_get_type()

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// NetUtilsSetSocketTos (gst_net_utils_set_socket_tos) configures IP_TOS value
// of socket, i.e. sets QoS DSCP.
//
// The function takes the following parameters:
//
//   - socket: socket to configure.
//   - qosDscp: qoS DSCP value.
//
// The function returns the following values:
//
//   - ok: TRUE if successful, FALSE in case an error occurred.
func NetUtilsSetSocketTos(socket *gio.Socket, qosDscp int) bool {
	var _arg1 *C.GSocket // out
	var _arg2 C.gint     // out
	var _cret C.gboolean // in

	_arg1 = (*C.GSocket)(unsafe.Pointer(coreglib.BaseObject(socket).Native()))
	_arg2 = C.gint(qosDscp)

	_cret = C.gst_net_utils_set_socket_tos(_arg1, _arg2)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(qosDscp)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PtpDeinit (gst_ptp_deinit): deinitialize the GStreamer PTP subsystem and stop
// the PTP clock. If there are any remaining GstPtpClock instances, they won't
// be further synchronized to the PTP network clock.
func PtpDeinit() {
	C.gst_ptp_deinit()
}

// PtpInit (gst_ptp_init): initialize the GStreamer PTP subsystem and create a
// PTP ordinary clock in slave-only mode for all domains on the given interfaces
// with the given clock_id.
//
// If clock_id is GST_PTP_CLOCK_ID_NONE, a clock id is automatically generated
// from the MAC address of the first network interface.
//
// This function is automatically called by gst_ptp_clock_new() with default
// parameters if it wasn't called before.
//
// The function takes the following parameters:
//
//   - clockId: PTP clock id of this process' clock or GST_PTP_CLOCK_ID_NONE.
//   - interfaces (optional): network interfaces to run the clock on.
//
// The function returns the following values:
//
//   - ok: TRUE if the GStreamer PTP clock subsystem could be initialized.
func PtpInit(clockId uint64, interfaces []string) bool {
	var _arg1 C.guint64  // out
	var _arg2 **C.gchar  // out
	var _cret C.gboolean // in

	_arg1 = C.guint64(clockId)
	{
		_arg2 = (**C.gchar)(C.calloc(C.size_t((len(interfaces) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice(_arg2, len(interfaces)+1)
			var zero *C.gchar
			out[len(interfaces)] = zero
			for i := range interfaces {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(interfaces[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.gst_ptp_init(_arg1, _arg2)
	runtime.KeepAlive(clockId)
	runtime.KeepAlive(interfaces)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PtpInitFull (gst_ptp_init_full): initialize the GStreamer PTP subsystem and
// create a PTP ordinary clock in slave-only mode according to the config.
//
// config is a Structure with the following optional fields: * #guint64
// clock-id: The clock ID to use for the local clock. If the clock-id is not
// provided or GST_PTP_CLOCK_ID_NONE is provided, a clock id is automatically
// generated from the MAC address of the first network interface. * #GStrv
// interfaces: The interface names to listen on for PTP packets. If none are
// provided then all compatible interfaces will be used. * #guint ttl: The TTL
// to use for multicast packets sent out by GStreamer. This defaults to 1, i.e.
// packets will not leave the local network.
//
// This function is automatically called by gst_ptp_clock_new() with default
// parameters if it wasn't called before.
//
// The function takes the following parameters:
//
//   - config: configuration for initializing the GStreamer PTP subsystem.
//
// The function returns the following values:
//
//   - ok: TRUE if the GStreamer PTP clock subsystem could be initialized.
func PtpInitFull(config *gst.Structure) bool {
	var _arg1 *C.GstStructure // out
	var _cret C.gboolean      // in

	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(config)))

	_cret = C.gst_ptp_init_full(_arg1)
	runtime.KeepAlive(config)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PtpIsInitialized (gst_ptp_is_initialized): check if the GStreamer PTP clock
// subsystem is initialized.
//
// The function returns the following values:
//
//   - ok: TRUE if the GStreamer PTP clock subsystem is initialized.
func PtpIsInitialized() bool {
	var _cret C.gboolean // in

	_cret = C.gst_ptp_is_initialized()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PtpIsSupported (gst_ptp_is_supported): check if PTP clocks are generally
// supported on this system, and if previous initializations did not fail.
//
// The function returns the following values:
//
//   - ok: TRUE if PTP clocks are generally supported on this system, and
//     previous initializations did not fail.
func PtpIsSupported() bool {
	var _cret C.gboolean // in

	_cret = C.gst_ptp_is_supported()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PtpStatisticsCallbackAdd (gst_ptp_statistics_callback_add) installs
// a new statistics callback for gathering PTP statistics. See
// GstPtpStatisticsCallback for a list of statistics that are provided.
//
// The function takes the following parameters:
//
//   - callback: gstPtpStatisticsCallback to call.
//
// The function returns the following values:
//
//   - gulong: id for the callback that can be passed to
//     gst_ptp_statistics_callback_remove().
func PtpStatisticsCallbackAdd(callback PtpStatisticsCallback) uint32 {
	var _arg1 C.GstPtpStatisticsCallback // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify
	var _cret C.gulong // in

	_arg1 = (*[0]byte)(C._gotk4_gstnet1_PtpStatisticsCallback)
	_arg2 = C.gpointer(gbox.Assign(callback))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.gst_ptp_statistics_callback_add(_arg1, _arg2, _arg3)
	runtime.KeepAlive(callback)

	var _gulong uint32 // out

	_gulong = uint32(_cret)

	return _gulong
}

// PtpStatisticsCallbackRemove (gst_ptp_statistics_callback_remove)
// removes a PTP statistics callback that was previously added with
// gst_ptp_statistics_callback_add().
//
// The function takes the following parameters:
//
//   - id: callback id to remove.
func PtpStatisticsCallbackRemove(id uint32) {
	var _arg1 C.gulong // out

	_arg1 = C.gulong(id)

	C.gst_ptp_statistics_callback_remove(_arg1)
	runtime.KeepAlive(id)
}

// NetClientClockOverrides contains methods that are overridable.
type NetClientClockOverrides struct {
}

func defaultNetClientClockOverrides(v *NetClientClock) NetClientClockOverrides {
	return NetClientClockOverrides{}
}

// NetClientClock (GstNetClientClock) implements a custom Clock that
// synchronizes its time to a remote time provider such as NetTimeProvider.
// NtpClock implements a Clock that synchronizes its time to a remote NTPv4
// server.
//
// A new clock is created with gst_net_client_clock_new() or
// gst_ntp_clock_new(), which takes the address and port of the remote time
// provider along with a name and an initial time.
//
// This clock will poll the time provider and will update its calibration
// parameters based on the local and remote observations.
//
// The "round-trip" property limits the maximum round trip packets can take.
//
// Various parameters of the clock can be configured with the parent Clock
// "timeout", "window-size" and "window-threshold" object properties.
//
// A NetClientClock and NtpClock is typically set on a Pipeline with
// gst_pipeline_use_clock().
//
// If you set a Bus on the clock via the "bus" object property, it will send
// GST_MESSAGE_ELEMENT messages with an attached Structure containing statistics
// about clock accuracy and network traffic.
type NetClientClock struct {
	_ [0]func() // equal guard
	gst.SystemClock
}

var (
	_ gst.Clocker = (*NetClientClock)(nil)
)

// NetClientClocker describes types inherited from NetClientClock.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type NetClientClocker interface {
	gst.SystemClocker

	baseNetClientClock() *NetClientClock
}

var _ NetClientClocker = (*NetClientClock)(nil)

func init() {
	coreglib.RegisterClassInfo[*NetClientClock, *NetClientClockClass, NetClientClockOverrides](
		GTypeNetClientClock,
		initNetClientClockClass,
		wrapNetClientClock,
		defaultNetClientClockOverrides,
	)
}

func initNetClientClockClass(gclass unsafe.Pointer, overrides NetClientClockOverrides, classInitFunc func(*NetClientClockClass)) {
	if classInitFunc != nil {
		class := (*NetClientClockClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapNetClientClock(obj *coreglib.Object) *NetClientClock {
	return &NetClientClock{
		SystemClock: gst.SystemClock{
			Clock: gst.Clock{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalNetClientClock(p uintptr) (interface{}, error) {
	return wrapNetClientClock(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *NetClientClock) baseNetClientClock() *NetClientClock {
	return v
}

// BaseNetClientClock returns the underlying base object.
func BaseNetClientClock(obj NetClientClocker) *NetClientClock {
	return obj.baseNetClientClock()
}

// NewNetClientClock (gst_net_client_clock_new): create a new NetClientClock
// that will report the time provided by the NetTimeProvider on remote_address
// and remote_port.
//
// The function takes the following parameters:
//
//   - name (optional) for the clock.
//   - remoteAddress address or hostname of the remote clock provider.
//   - remotePort: port of the remote clock provider.
//   - baseTime: initial time of the clock.
//
// The function returns the following values:
//
//   - netClientClock: new Clock that receives a time from the remote clock.
func NewNetClientClock(name, remoteAddress string, remotePort int, baseTime gst.ClockTime) *NetClientClock {
	var _arg1 *C.gchar       // out
	var _arg2 *C.gchar       // out
	var _arg3 C.gint         // out
	var _arg4 C.GstClockTime // out
	var _cret *C.GstClock    // in

	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(remoteAddress)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.gint(remotePort)
	_arg4 = C.GstClockTime(baseTime)

	_cret = C.gst_net_client_clock_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(name)
	runtime.KeepAlive(remoteAddress)
	runtime.KeepAlive(remotePort)
	runtime.KeepAlive(baseTime)

	var _netClientClock *NetClientClock // out

	_netClientClock = wrapNetClientClock(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _netClientClock
}

// NetTimeProviderOverrides contains methods that are overridable.
type NetTimeProviderOverrides struct {
}

func defaultNetTimeProviderOverrides(v *NetTimeProvider) NetTimeProviderOverrides {
	return NetTimeProviderOverrides{}
}

// NetTimeProvider (GstNetTimeProvider): this object exposes the time of a Clock
// on the network.
//
// A NetTimeProvider is created with gst_net_time_provider_new() which takes a
// Clock, an address and a port number as arguments.
//
// After creating the object, a client clock such as NetClientClock can query
// the exposed clock over the network for its values.
//
// The NetTimeProvider typically wraps the clock used by a Pipeline.
type NetTimeProvider struct {
	_ [0]func() // equal guard
	gst.GstObject

	gio.Initable
}

var (
	_ gst.GstObjector = (*NetTimeProvider)(nil)
)

// NetTimeProviderer describes types inherited from NetTimeProvider.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type NetTimeProviderer interface {
	gst.GstObjector
	gio.Initabler

	baseNetTimeProvider() *NetTimeProvider
}

var _ NetTimeProviderer = (*NetTimeProvider)(nil)

func init() {
	coreglib.RegisterClassInfo[*NetTimeProvider, *NetTimeProviderClass, NetTimeProviderOverrides](
		GTypeNetTimeProvider,
		initNetTimeProviderClass,
		wrapNetTimeProvider,
		defaultNetTimeProviderOverrides,
	)
}

func initNetTimeProviderClass(gclass unsafe.Pointer, overrides NetTimeProviderOverrides, classInitFunc func(*NetTimeProviderClass)) {
	if classInitFunc != nil {
		class := (*NetTimeProviderClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapNetTimeProvider(obj *coreglib.Object) *NetTimeProvider {
	return &NetTimeProvider{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
		Initable: gio.Initable{
			Object: obj,
		},
	}
}

func marshalNetTimeProvider(p uintptr) (interface{}, error) {
	return wrapNetTimeProvider(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *NetTimeProvider) baseNetTimeProvider() *NetTimeProvider {
	return v
}

// BaseNetTimeProvider returns the underlying base object.
func BaseNetTimeProvider(obj NetTimeProviderer) *NetTimeProvider {
	return obj.baseNetTimeProvider()
}

// NewNetTimeProvider (gst_net_time_provider_new) allows network clients to get
// the current time of clock.
//
// The function takes the following parameters:
//
//   - clock to export over the network.
//   - address (optional) to bind on as a dotted quad (xxx.xxx.xxx.xxx),
//     IPv6 address, or NULL to bind to all addresses.
//   - port to bind on, or 0 to let the kernel choose.
//
// The function returns the following values:
//
//   - netTimeProvider (optional): new NetTimeProvider, or NULL on error.
func NewNetTimeProvider(clock gst.Clocker, address string, port int) *NetTimeProvider {
	var _arg1 *C.GstClock           // out
	var _arg2 *C.gchar              // out
	var _arg3 C.gint                // out
	var _cret *C.GstNetTimeProvider // in

	_arg1 = (*C.GstClock)(unsafe.Pointer(coreglib.BaseObject(clock).Native()))
	if address != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(address)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = C.gint(port)

	_cret = C.gst_net_time_provider_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(clock)
	runtime.KeepAlive(address)
	runtime.KeepAlive(port)

	var _netTimeProvider *NetTimeProvider // out

	if _cret != nil {
		_netTimeProvider = wrapNetTimeProvider(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _netTimeProvider
}

// NtpClockOverrides contains methods that are overridable.
type NtpClockOverrides struct {
}

func defaultNtpClockOverrides(v *NtpClock) NtpClockOverrides {
	return NtpClockOverrides{}
}

type NtpClock struct {
	_ [0]func() // equal guard
	NetClientClock
}

var (
	_ gst.Clocker = (*NtpClock)(nil)
)

// NtpClocker describes types inherited from NtpClock.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type NtpClocker interface {
	NetClientClocker

	baseNtpClock() *NtpClock
}

var _ NtpClocker = (*NtpClock)(nil)

func init() {
	coreglib.RegisterClassInfo[*NtpClock, *NtpClockClass, NtpClockOverrides](
		GTypeNtpClock,
		initNtpClockClass,
		wrapNtpClock,
		defaultNtpClockOverrides,
	)
}

func initNtpClockClass(gclass unsafe.Pointer, overrides NtpClockOverrides, classInitFunc func(*NtpClockClass)) {
	if classInitFunc != nil {
		class := (*NtpClockClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapNtpClock(obj *coreglib.Object) *NtpClock {
	return &NtpClock{
		NetClientClock: NetClientClock{
			SystemClock: gst.SystemClock{
				Clock: gst.Clock{
					GstObject: gst.GstObject{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
					},
				},
			},
		},
	}
}

func marshalNtpClock(p uintptr) (interface{}, error) {
	return wrapNtpClock(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *NtpClock) baseNtpClock() *NtpClock {
	return v
}

// BaseNtpClock returns the underlying base object.
func BaseNtpClock(obj NtpClocker) *NtpClock {
	return obj.baseNtpClock()
}

// NewNtpClock (gst_ntp_clock_new): create a new NtpClock that will report the
// time provided by the NTPv4 server on remote_address and remote_port.
//
// The function takes the following parameters:
//
//   - name (optional) for the clock.
//   - remoteAddress address or hostname of the remote clock provider.
//   - remotePort: port of the remote clock provider.
//   - baseTime: initial time of the clock.
//
// The function returns the following values:
//
//   - ntpClock: new Clock that receives a time from the remote clock.
func NewNtpClock(name, remoteAddress string, remotePort int, baseTime gst.ClockTime) *NtpClock {
	var _arg1 *C.gchar       // out
	var _arg2 *C.gchar       // out
	var _arg3 C.gint         // out
	var _arg4 C.GstClockTime // out
	var _cret *C.GstClock    // in

	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(remoteAddress)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.gint(remotePort)
	_arg4 = C.GstClockTime(baseTime)

	_cret = C.gst_ntp_clock_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(name)
	runtime.KeepAlive(remoteAddress)
	runtime.KeepAlive(remotePort)
	runtime.KeepAlive(baseTime)

	var _ntpClock *NtpClock // out

	_ntpClock = wrapNtpClock(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ntpClock
}

// PtpClockOverrides contains methods that are overridable.
type PtpClockOverrides struct {
}

func defaultPtpClockOverrides(v *PtpClock) PtpClockOverrides {
	return PtpClockOverrides{}
}

// PtpClock (GstPtpClock) implements a PTP (IEEE1588:2008) ordinary clock in
// slave-only mode, that allows a GStreamer pipeline to synchronize to a PTP
// network clock in some specific domain.
//
// The PTP subsystem can be initialized with gst_ptp_init(), which then starts
// a helper process to do the actual communication via the PTP ports. This is
// required as PTP listens on ports < 1024 and thus requires special privileges.
// Once this helper process is started, the main process will synchronize to all
// PTP domains that are detected on the selected interfaces.
//
// gst_ptp_clock_new() then allows to create a GstClock that provides the PTP
// time from a master clock inside a specific PTP domain. This clock will only
// return valid timestamps once the timestamps in the PTP domain are known.
// To check this, you can use gst_clock_wait_for_sync(), the GstClock::synced
// signal and gst_clock_is_synced().
//
// To gather statistics about the PTP clock synchronization,
// gst_ptp_statistics_callback_add() can be used. This gives the application
// the possibility to collect all kinds of statistics from the clock
// synchronization.
type PtpClock struct {
	_ [0]func() // equal guard
	gst.SystemClock
}

var (
	_ gst.Clocker = (*PtpClock)(nil)
)

// PtpClocker describes types inherited from PtpClock.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type PtpClocker interface {
	gst.SystemClocker

	basePtpClock() *PtpClock
}

var _ PtpClocker = (*PtpClock)(nil)

func init() {
	coreglib.RegisterClassInfo[*PtpClock, *PtpClockClass, PtpClockOverrides](
		GTypePtpClock,
		initPtpClockClass,
		wrapPtpClock,
		defaultPtpClockOverrides,
	)
}

func initPtpClockClass(gclass unsafe.Pointer, overrides PtpClockOverrides, classInitFunc func(*PtpClockClass)) {
	if classInitFunc != nil {
		class := (*PtpClockClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapPtpClock(obj *coreglib.Object) *PtpClock {
	return &PtpClock{
		SystemClock: gst.SystemClock{
			Clock: gst.Clock{
				GstObject: gst.GstObject{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalPtpClock(p uintptr) (interface{}, error) {
	return wrapPtpClock(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *PtpClock) basePtpClock() *PtpClock {
	return v
}

// BasePtpClock returns the underlying base object.
func BasePtpClock(obj PtpClocker) *PtpClock {
	return obj.basePtpClock()
}

// NewPtpClock (gst_ptp_clock_new) creates a new PTP clock instance that exports
// the PTP time of the master clock in domain. This clock can be slaved to other
// clocks as needed.
//
// If gst_ptp_init() was not called before, this will call gst_ptp_init() with
// default parameters.
//
// This clock only returns valid timestamps after it received the first
// times from the PTP master clock on the network. Once this happens the
// GstPtpClock::internal-clock property will become non-NULL. You can check
// this with gst_clock_wait_for_sync(), the GstClock::synced signal and
// gst_clock_is_synced().
//
// The function takes the following parameters:
//
//   - name: name of the clock.
//   - domain: PTP domain.
//
// The function returns the following values:
//
//   - ptpClock: new Clock.
func NewPtpClock(name string, domain uint) *PtpClock {
	var _arg1 *C.gchar    // out
	var _arg2 C.guint     // out
	var _cret *C.GstClock // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(domain)

	_cret = C.gst_ptp_clock_new(_arg1, _arg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(domain)

	var _ptpClock *PtpClock // out

	_ptpClock = wrapPtpClock(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ptpClock
}

// NetAddressMeta (GstNetAddressMeta) can be used to store a network address (a
// Address) in a Buffer so that it network elements can track the to and from
// address of the buffer.
//
// An instance of this type is always passed by reference.
type NetAddressMeta struct {
	*netAddressMeta
}

// netAddressMeta is the struct that's finalized.
type netAddressMeta struct {
	native *C.GstNetAddressMeta
}

// Meta: parent type.
func (n *NetAddressMeta) Meta() *gst.Meta {
	valptr := &n.native.meta
	var _v *gst.Meta // out
	_v = (*gst.Meta)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Addr stored as metadata.
func (n *NetAddressMeta) Addr() gio.SocketAddresser {
	valptr := &n.native.addr
	var _v gio.SocketAddresser // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gio.SocketAddresser is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.SocketAddresser)
			return ok
		})
		rv, ok := casted.(gio.SocketAddresser)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddresser")
		}
		_v = rv
	}
	return _v
}

func NetAddressMetaGetInfo() *gst.MetaInfo {
	var _cret *C.GstMetaInfo // in

	_cret = C.gst_net_address_meta_get_info()

	var _metaInfo *gst.MetaInfo // out

	_metaInfo = (*gst.MetaInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _metaInfo
}

// NetClientClockClass (GstNetClientClockClass): instance of this type is always
// passed by reference.
type NetClientClockClass struct {
	*netClientClockClass
}

// netClientClockClass is the struct that's finalized.
type netClientClockClass struct {
	native *C.GstNetClientClockClass
}

func (n *NetClientClockClass) ParentClass() *gst.SystemClockClass {
	valptr := &n.native.parent_class
	var _v *gst.SystemClockClass // out
	_v = (*gst.SystemClockClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// NetControlMessageMeta (GstNetControlMessageMeta) can be used to store
// control messages (ancillary data) which was received with or is to be sent
// alongside the buffer data. When used with socket sinks and sources which
// understand this meta it allows sending and receiving ancillary data such as
// unix credentials (See CredentialsMessage) and Unix file descriptions (See
// FDMessage).
//
// An instance of this type is always passed by reference.
type NetControlMessageMeta struct {
	*netControlMessageMeta
}

// netControlMessageMeta is the struct that's finalized.
type netControlMessageMeta struct {
	native *C.GstNetControlMessageMeta
}

// Meta: parent type.
func (n *NetControlMessageMeta) Meta() *gst.Meta {
	valptr := &n.native.meta
	var _v *gst.Meta // out
	_v = (*gst.Meta)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Message stored as metadata.
func (n *NetControlMessageMeta) Message() gio.SocketControlMessager {
	valptr := &n.native.message
	var _v gio.SocketControlMessager // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gio.SocketControlMessager is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.SocketControlMessager)
			return ok
		})
		rv, ok := casted.(gio.SocketControlMessager)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketControlMessager")
		}
		_v = rv
	}
	return _v
}

func NetControlMessageMetaGetInfo() *gst.MetaInfo {
	var _cret *C.GstMetaInfo // in

	_cret = C.gst_net_control_message_meta_get_info()

	var _metaInfo *gst.MetaInfo // out

	_metaInfo = (*gst.MetaInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _metaInfo
}

// NetTimePacket (GstNetTimePacket) various functions for receiving, sending an
// serializing NetTimePacket structures.
//
// An instance of this type is always passed by reference.
type NetTimePacket struct {
	*netTimePacket
}

// netTimePacket is the struct that's finalized.
type netTimePacket struct {
	native *C.GstNetTimePacket
}

func marshalNetTimePacket(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &NetTimePacket{&netTimePacket{(*C.GstNetTimePacket)(b)}}, nil
}

// NewNetTimePacket constructs a struct NetTimePacket.
func NewNetTimePacket(buffer [16]byte) *NetTimePacket {
	var _arg1 *C.guint8           // out
	var _cret *C.GstNetTimePacket // in

	_arg1 = (*C.guint8)(unsafe.Pointer(&buffer))

	_cret = C.gst_net_time_packet_new(_arg1)
	runtime.KeepAlive(buffer)

	var _netTimePacket *NetTimePacket // out

	_netTimePacket = (*NetTimePacket)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_netTimePacket)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_net_time_packet_free((*C.GstNetTimePacket)(intern.C))
		},
	)

	return _netTimePacket
}

// LocalTime: local time when this packet was sent.
func (n *NetTimePacket) LocalTime() gst.ClockTime {
	valptr := &n.native.local_time
	var _v gst.ClockTime // out
	_v = gst.ClockTime(*valptr)
	return _v
}

// RemoteTime: remote time observation.
func (n *NetTimePacket) RemoteTime() gst.ClockTime {
	valptr := &n.native.remote_time
	var _v gst.ClockTime // out
	_v = gst.ClockTime(*valptr)
	return _v
}

// Copy (gst_net_time_packet_copy): make a copy of packet.
//
// The function returns the following values:
//
//   - netTimePacket: copy of packet, free with gst_net_time_packet_free().
func (packet *NetTimePacket) Copy() *NetTimePacket {
	var _arg0 *C.GstNetTimePacket // out
	var _cret *C.GstNetTimePacket // in

	_arg0 = (*C.GstNetTimePacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_net_time_packet_copy(_arg0)
	runtime.KeepAlive(packet)

	var _netTimePacket *NetTimePacket // out

	_netTimePacket = (*NetTimePacket)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_netTimePacket)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_net_time_packet_free((*C.GstNetTimePacket)(intern.C))
		},
	)

	return _netTimePacket
}

// Send (gst_net_time_packet_send) sends a NetTimePacket over a socket.
//
// MT safe.
//
// The function takes the following parameters:
//
//   - socket to send the time packet on.
//   - destAddress address to send the time packet to.
func (packet *NetTimePacket) Send(socket *gio.Socket, destAddress gio.SocketAddresser) error {
	var _arg0 *C.GstNetTimePacket // out
	var _arg1 *C.GSocket          // out
	var _arg2 *C.GSocketAddress   // out
	var _cerr *C.GError           // in

	_arg0 = (*C.GstNetTimePacket)(gextras.StructNative(unsafe.Pointer(packet)))
	_arg1 = (*C.GSocket)(unsafe.Pointer(coreglib.BaseObject(socket).Native()))
	_arg2 = (*C.GSocketAddress)(unsafe.Pointer(coreglib.BaseObject(destAddress).Native()))

	C.gst_net_time_packet_send(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(packet)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(destAddress)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Serialize (gst_net_time_packet_serialize): serialized a NetTimePacket into
// a newly-allocated sequence of T_NET_TIME_PACKET_SIZE bytes, in network byte
// order. The value returned is suitable for passing to write(2) or sendto(2)
// for communication over the network.
//
// MT safe. Caller owns return value (g_free to free).
//
// The function returns the following values:
//
//   - guint8s: newly allocated sequence of T_NET_TIME_PACKET_SIZE bytes.
func (packet *NetTimePacket) Serialize() [16]byte {
	var _arg0 *C.GstNetTimePacket // out
	var _cret *C.guint8           // in

	_arg0 = (*C.GstNetTimePacket)(gextras.StructNative(unsafe.Pointer(packet)))

	_cret = C.gst_net_time_packet_serialize(_arg0)
	runtime.KeepAlive(packet)

	var _guint8s [16]byte // out

	_guint8s = *(*[16]byte)(unsafe.Pointer(&_cret))

	return _guint8s
}

// NetTimePacketReceive (gst_net_time_packet_receive) receives a NetTimePacket
// over a socket. Handles interrupted system calls, but otherwise returns NULL
// on error.
//
// The function takes the following parameters:
//
//   - socket to receive the time packet on.
//
// The function returns the following values:
//
//   - srcAddress (optional) address of variable to return sender address.
//   - netTimePacket: new NetTimePacket, or NULL on error. Free with
//     gst_net_time_packet_free() when done.
func NetTimePacketReceive(socket *gio.Socket) (gio.SocketAddresser, *NetTimePacket, error) {
	var _arg1 *C.GSocket          // out
	var _arg2 *C.GSocketAddress   // in
	var _cret *C.GstNetTimePacket // in
	var _cerr *C.GError           // in

	_arg1 = (*C.GSocket)(unsafe.Pointer(coreglib.BaseObject(socket).Native()))

	_cret = C.gst_net_time_packet_receive(_arg1, &_arg2, &_cerr)
	runtime.KeepAlive(socket)

	var _srcAddress gio.SocketAddresser // out
	var _netTimePacket *NetTimePacket   // out
	var _goerr error                    // out

	if _arg2 != nil {
		{
			objptr := unsafe.Pointer(_arg2)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.SocketAddresser)
				return ok
			})
			rv, ok := casted.(gio.SocketAddresser)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddresser")
			}
			_srcAddress = rv
		}
	}
	_netTimePacket = (*NetTimePacket)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_netTimePacket)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_net_time_packet_free((*C.GstNetTimePacket)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _srcAddress, _netTimePacket, _goerr
}

// NetTimeProviderClass (GstNetTimeProviderClass): instance of this type is
// always passed by reference.
type NetTimeProviderClass struct {
	*netTimeProviderClass
}

// netTimeProviderClass is the struct that's finalized.
type netTimeProviderClass struct {
	native *C.GstNetTimeProviderClass
}

func (n *NetTimeProviderClass) ParentClass() *gst.ObjectClass {
	valptr := &n.native.parent_class
	var _v *gst.ObjectClass // out
	_v = (*gst.ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

func (n *NetTimeProviderClass) GstReserved() [4]unsafe.Pointer {
	valptr := &n.native._gst_reserved
	var _v [4]unsafe.Pointer // out
	{
		src := &*valptr
		for i := 0; i < 4; i++ {
			_v[i] = (unsafe.Pointer)(unsafe.Pointer(src[i]))
		}
	}
	return _v
}

// NtpClockClass (GstNtpClockClass): instance of this type is always passed by
// reference.
type NtpClockClass struct {
	*ntpClockClass
}

// ntpClockClass is the struct that's finalized.
type ntpClockClass struct {
	native *C.GstNtpClockClass
}

func (n *NtpClockClass) ParentClass() *gst.SystemClockClass {
	valptr := &n.native.parent_class
	var _v *gst.SystemClockClass // out
	_v = (*gst.SystemClockClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// PtpClockClass (GstPtpClockClass): opaque PtpClockClass structure.
//
// An instance of this type is always passed by reference.
type PtpClockClass struct {
	*ptpClockClass
}

// ptpClockClass is the struct that's finalized.
type ptpClockClass struct {
	native *C.GstPtpClockClass
}

// ParentClass: parented to SystemClockClass.
func (p *PtpClockClass) ParentClass() *gst.SystemClockClass {
	valptr := &p.native.parent_class
	var _v *gst.SystemClockClass // out
	_v = (*gst.SystemClockClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
