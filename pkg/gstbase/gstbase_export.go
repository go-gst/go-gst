// Code generated by girgen. DO NOT EDIT.

package gstbase

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/go-gst/go-gst/pkg/gst"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/base/base.h>
import "C"

//export _gotk4_gstbase1_CollectPadsBufferFunction
func _gotk4_gstbase1_CollectPadsBufferFunction(arg1 *C.GstCollectPads, arg2 *C.GstCollectData, arg3 *C.GstBuffer, arg4 C.gpointer) (cret C.GstFlowReturn) {
	var fn CollectPadsBufferFunction
	{
		v := gbox.Get(uintptr(arg4))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(CollectPadsBufferFunction)
	}

	var _pads *CollectPads  // out
	var _data *CollectData  // out
	var _buffer *gst.Buffer // out

	_pads = wrapCollectPads(coreglib.Take(unsafe.Pointer(arg1)))
	_data = (*CollectData)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	flowReturn := fn(_pads, _data, _buffer)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_CollectPadsClipFunction
func _gotk4_gstbase1_CollectPadsClipFunction(arg1 *C.GstCollectPads, arg2 *C.GstCollectData, arg3 *C.GstBuffer, arg4 **C.GstBuffer, arg5 C.gpointer) (cret C.GstFlowReturn) {
	var fn CollectPadsClipFunction
	{
		v := gbox.Get(uintptr(arg5))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(CollectPadsClipFunction)
	}

	var _pads *CollectPads    // out
	var _data *CollectData    // out
	var _inbuffer *gst.Buffer // out

	_pads = wrapCollectPads(coreglib.Take(unsafe.Pointer(arg1)))
	_data = (*CollectData)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_inbuffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_inbuffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	outbuffer, flowReturn := fn(_pads, _data, _inbuffer)

	var _ *gst.Buffer
	var _ gst.FlowReturn

	*arg4 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(outbuffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(outbuffer)), nil)
	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_CollectPadsCompareFunction
func _gotk4_gstbase1_CollectPadsCompareFunction(arg1 *C.GstCollectPads, arg2 *C.GstCollectData, arg3 C.GstClockTime, arg4 *C.GstCollectData, arg5 C.GstClockTime, arg6 C.gpointer) (cret C.gint) {
	var fn CollectPadsCompareFunction
	{
		v := gbox.Get(uintptr(arg6))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(CollectPadsCompareFunction)
	}

	var _pads *CollectPads        // out
	var _data1 *CollectData       // out
	var _timestamp1 gst.ClockTime // out
	var _data2 *CollectData       // out
	var _timestamp2 gst.ClockTime // out

	_pads = wrapCollectPads(coreglib.Take(unsafe.Pointer(arg1)))
	_data1 = (*CollectData)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_timestamp1 = gst.ClockTime(arg3)
	_data2 = (*CollectData)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_timestamp2 = gst.ClockTime(arg5)

	gint := fn(_pads, _data1, _timestamp1, _data2, _timestamp2)

	var _ int

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gstbase1_CollectPadsEventFunction
func _gotk4_gstbase1_CollectPadsEventFunction(arg1 *C.GstCollectPads, arg2 *C.GstCollectData, arg3 *C.GstEvent, arg4 C.gpointer) (cret C.gboolean) {
	var fn CollectPadsEventFunction
	{
		v := gbox.Get(uintptr(arg4))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(CollectPadsEventFunction)
	}

	var _pads *CollectPads // out
	var _pad *CollectData  // out
	var _event *gst.Event  // out

	_pads = wrapCollectPads(coreglib.Take(unsafe.Pointer(arg1)))
	_pad = (*CollectData)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	ok := fn(_pads, _pad, _event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_CollectPadsFlushFunction
func _gotk4_gstbase1_CollectPadsFlushFunction(arg1 *C.GstCollectPads, arg2 C.gpointer) {
	var fn CollectPadsFlushFunction
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(CollectPadsFlushFunction)
	}

	var _pads *CollectPads // out

	_pads = wrapCollectPads(coreglib.Take(unsafe.Pointer(arg1)))

	fn(_pads)
}

//export _gotk4_gstbase1_CollectPadsFunction
func _gotk4_gstbase1_CollectPadsFunction(arg1 *C.GstCollectPads, arg2 C.gpointer) (cret C.GstFlowReturn) {
	var fn CollectPadsFunction
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(CollectPadsFunction)
	}

	var _pads *CollectPads // out

	_pads = wrapCollectPads(coreglib.Take(unsafe.Pointer(arg1)))

	flowReturn := fn(_pads)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_CollectPadsQueryFunction
func _gotk4_gstbase1_CollectPadsQueryFunction(arg1 *C.GstCollectPads, arg2 *C.GstCollectData, arg3 *C.GstQuery, arg4 C.gpointer) (cret C.gboolean) {
	var fn CollectPadsQueryFunction
	{
		v := gbox.Get(uintptr(arg4))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(CollectPadsQueryFunction)
	}

	var _pads *CollectPads // out
	var _pad *CollectData  // out
	var _query *gst.Query  // out

	_pads = wrapCollectPads(coreglib.Take(unsafe.Pointer(arg1)))
	_pad = (*CollectData)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	ok := fn(_pads, _pad, _query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_AggregatorClass_aggregate
func _gotk4_gstbase1_AggregatorClass_aggregate(arg0 *C.GstAggregator, arg1 C.gboolean) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorOverrides](instance0)
	if overrides.Aggregate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorOverrides.Aggregate, got none")
	}

	var _timeout bool // out

	if arg1 != 0 {
		_timeout = true
	}

	flowReturn := overrides.Aggregate(_timeout)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_AggregatorClass_clip
func _gotk4_gstbase1_AggregatorClass_clip(arg0 *C.GstAggregator, arg1 *C.GstAggregatorPad, arg2 *C.GstBuffer) (cret *C.GstBuffer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorOverrides](instance0)
	if overrides.Clip == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorOverrides.Clip, got none")
	}

	var _aggregatorPad *AggregatorPad // out
	var _buf *gst.Buffer              // out

	_aggregatorPad = wrapAggregatorPad(coreglib.Take(unsafe.Pointer(arg1)))
	_buf = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	buffer := overrides.Clip(_aggregatorPad, _buf)

	var _ *gst.Buffer

	cret = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buffer)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buffer)), nil)

	return cret
}

//export _gotk4_gstbase1_AggregatorClass_decide_allocation
func _gotk4_gstbase1_AggregatorClass_decide_allocation(arg0 *C.GstAggregator, arg1 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorOverrides](instance0)
	if overrides.DecideAllocation == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorOverrides.DecideAllocation, got none")
	}

	var _query *gst.Query // out

	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.DecideAllocation(_query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_AggregatorClass_finish_buffer
func _gotk4_gstbase1_AggregatorClass_finish_buffer(arg0 *C.GstAggregator, arg1 *C.GstBuffer) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorOverrides](instance0)
	if overrides.FinishBuffer == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorOverrides.FinishBuffer, got none")
	}

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_buffer)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	flowReturn := overrides.FinishBuffer(_buffer)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_AggregatorClass_finish_buffer_list
func _gotk4_gstbase1_AggregatorClass_finish_buffer_list(arg0 *C.GstAggregator, arg1 *C.GstBufferList) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorOverrides](instance0)
	if overrides.FinishBufferList == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorOverrides.FinishBufferList, got none")
	}

	var _bufferlist *gst.BufferList // out

	_bufferlist = (*gst.BufferList)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bufferlist)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	flowReturn := overrides.FinishBufferList(_bufferlist)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_AggregatorClass_fixate_src_caps
func _gotk4_gstbase1_AggregatorClass_fixate_src_caps(arg0 *C.GstAggregator, arg1 *C.GstCaps) (cret *C.GstCaps) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorOverrides](instance0)
	if overrides.FixateSrcCaps == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorOverrides.FixateSrcCaps, got none")
	}

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ret := overrides.FixateSrcCaps(_caps)

	var _ *gst.Caps

	cret = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(ret)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(ret)), nil)

	return cret
}

//export _gotk4_gstbase1_AggregatorClass_flush
func _gotk4_gstbase1_AggregatorClass_flush(arg0 *C.GstAggregator) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorOverrides](instance0)
	if overrides.Flush == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorOverrides.Flush, got none")
	}

	flowReturn := overrides.Flush()

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_AggregatorClass_get_next_time
func _gotk4_gstbase1_AggregatorClass_get_next_time(arg0 *C.GstAggregator) (cret C.GstClockTime) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorOverrides](instance0)
	if overrides.NextTime == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorOverrides.NextTime, got none")
	}

	clockTime := overrides.NextTime()

	var _ gst.ClockTime

	cret = C.GstClockTime(clockTime)

	return cret
}

//export _gotk4_gstbase1_AggregatorClass_negotiate
func _gotk4_gstbase1_AggregatorClass_negotiate(arg0 *C.GstAggregator) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorOverrides](instance0)
	if overrides.Negotiate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorOverrides.Negotiate, got none")
	}

	ok := overrides.Negotiate()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_AggregatorClass_negotiated_src_caps
func _gotk4_gstbase1_AggregatorClass_negotiated_src_caps(arg0 *C.GstAggregator, arg1 *C.GstCaps) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorOverrides](instance0)
	if overrides.NegotiatedSrcCaps == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorOverrides.NegotiatedSrcCaps, got none")
	}

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.NegotiatedSrcCaps(_caps)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_AggregatorClass_peek_next_sample
func _gotk4_gstbase1_AggregatorClass_peek_next_sample(arg0 *C.GstAggregator, arg1 *C.GstAggregatorPad) (cret *C.GstSample) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorOverrides](instance0)
	if overrides.PeekNextSample == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorOverrides.PeekNextSample, got none")
	}

	var _aggregatorPad *AggregatorPad // out

	_aggregatorPad = wrapAggregatorPad(coreglib.Take(unsafe.Pointer(arg1)))

	sample := overrides.PeekNextSample(_aggregatorPad)

	var _ *gst.Sample

	if sample != nil {
		cret = (*C.GstSample)(gextras.StructNative(unsafe.Pointer(sample)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(sample)), nil)
	}

	return cret
}

//export _gotk4_gstbase1_AggregatorClass_propose_allocation
func _gotk4_gstbase1_AggregatorClass_propose_allocation(arg0 *C.GstAggregator, arg1 *C.GstAggregatorPad, arg2 *C.GstQuery, arg3 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorOverrides](instance0)
	if overrides.ProposeAllocation == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorOverrides.ProposeAllocation, got none")
	}

	var _pad *AggregatorPad     // out
	var _decideQuery *gst.Query // out
	var _query *gst.Query       // out

	_pad = wrapAggregatorPad(coreglib.Take(unsafe.Pointer(arg1)))
	_decideQuery = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	ok := overrides.ProposeAllocation(_pad, _decideQuery, _query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_AggregatorClass_sink_event
func _gotk4_gstbase1_AggregatorClass_sink_event(arg0 *C.GstAggregator, arg1 *C.GstAggregatorPad, arg2 *C.GstEvent) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorOverrides](instance0)
	if overrides.SinkEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorOverrides.SinkEvent, got none")
	}

	var _aggregatorPad *AggregatorPad // out
	var _event *gst.Event             // out

	_aggregatorPad = wrapAggregatorPad(coreglib.Take(unsafe.Pointer(arg1)))
	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.SinkEvent(_aggregatorPad, _event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_AggregatorClass_sink_event_pre_queue
func _gotk4_gstbase1_AggregatorClass_sink_event_pre_queue(arg0 *C.GstAggregator, arg1 *C.GstAggregatorPad, arg2 *C.GstEvent) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorOverrides](instance0)
	if overrides.SinkEventPreQueue == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorOverrides.SinkEventPreQueue, got none")
	}

	var _aggregatorPad *AggregatorPad // out
	var _event *gst.Event             // out

	_aggregatorPad = wrapAggregatorPad(coreglib.Take(unsafe.Pointer(arg1)))
	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	flowReturn := overrides.SinkEventPreQueue(_aggregatorPad, _event)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_AggregatorClass_sink_query
func _gotk4_gstbase1_AggregatorClass_sink_query(arg0 *C.GstAggregator, arg1 *C.GstAggregatorPad, arg2 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorOverrides](instance0)
	if overrides.SinkQuery == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorOverrides.SinkQuery, got none")
	}

	var _aggregatorPad *AggregatorPad // out
	var _query *gst.Query             // out

	_aggregatorPad = wrapAggregatorPad(coreglib.Take(unsafe.Pointer(arg1)))
	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.SinkQuery(_aggregatorPad, _query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_AggregatorClass_sink_query_pre_queue
func _gotk4_gstbase1_AggregatorClass_sink_query_pre_queue(arg0 *C.GstAggregator, arg1 *C.GstAggregatorPad, arg2 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorOverrides](instance0)
	if overrides.SinkQueryPreQueue == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorOverrides.SinkQueryPreQueue, got none")
	}

	var _aggregatorPad *AggregatorPad // out
	var _query *gst.Query             // out

	_aggregatorPad = wrapAggregatorPad(coreglib.Take(unsafe.Pointer(arg1)))
	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.SinkQueryPreQueue(_aggregatorPad, _query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_AggregatorClass_src_activate
func _gotk4_gstbase1_AggregatorClass_src_activate(arg0 *C.GstAggregator, arg1 C.GstPadMode, arg2 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorOverrides](instance0)
	if overrides.SrcActivate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorOverrides.SrcActivate, got none")
	}

	var _mode gst.PadMode // out
	var _active bool      // out

	_mode = gst.PadMode(arg1)
	if arg2 != 0 {
		_active = true
	}

	ok := overrides.SrcActivate(_mode, _active)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_AggregatorClass_src_event
func _gotk4_gstbase1_AggregatorClass_src_event(arg0 *C.GstAggregator, arg1 *C.GstEvent) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorOverrides](instance0)
	if overrides.SrcEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorOverrides.SrcEvent, got none")
	}

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SrcEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_AggregatorClass_src_query
func _gotk4_gstbase1_AggregatorClass_src_query(arg0 *C.GstAggregator, arg1 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorOverrides](instance0)
	if overrides.SrcQuery == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorOverrides.SrcQuery, got none")
	}

	var _query *gst.Query // out

	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SrcQuery(_query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_AggregatorClass_start
func _gotk4_gstbase1_AggregatorClass_start(arg0 *C.GstAggregator) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorOverrides](instance0)
	if overrides.Start == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorOverrides.Start, got none")
	}

	ok := overrides.Start()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_AggregatorClass_stop
func _gotk4_gstbase1_AggregatorClass_stop(arg0 *C.GstAggregator) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorOverrides](instance0)
	if overrides.Stop == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorOverrides.Stop, got none")
	}

	ok := overrides.Stop()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_AggregatorClass_update_src_caps
func _gotk4_gstbase1_AggregatorClass_update_src_caps(arg0 *C.GstAggregator, arg1 *C.GstCaps, arg2 **C.GstCaps) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorOverrides](instance0)
	if overrides.UpdateSrcCaps == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorOverrides.UpdateSrcCaps, got none")
	}

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ret, flowReturn := overrides.UpdateSrcCaps(_caps)

	var _ *gst.Caps
	var _ gst.FlowReturn

	if ret != nil {
		if ret != nil {
			*arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(ret)))
			runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(ret)), nil)
		}
	}
	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_Aggregator_ConnectSamplesSelected
func _gotk4_gstbase1_Aggregator_ConnectSamplesSelected(arg0 C.gpointer, arg1 *C.GstSegment, arg2 C.guint64, arg3 C.guint64, arg4 C.guint64, arg5 *C.GstStructure, arg6 C.guintptr) {
	var f func(segment *gst.Segment, pts, dts, duration uint64, info *gst.Structure)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg6))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(segment *gst.Segment, pts, dts, duration uint64, info *gst.Structure))
	}

	var _segment *gst.Segment // out
	var _pts uint64           // out
	var _dts uint64           // out
	var _duration uint64      // out
	var _info *gst.Structure  // out

	_segment = (*gst.Segment)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_pts = uint64(arg2)
	_dts = uint64(arg3)
	_duration = uint64(arg4)
	if arg5 != nil {
		_info = (*gst.Structure)(gextras.NewStructNative(unsafe.Pointer(arg5)))
	}

	f(_segment, _pts, _dts, _duration, _info)
}

//export _gotk4_gstbase1_AggregatorPadClass_flush
func _gotk4_gstbase1_AggregatorPadClass_flush(arg0 *C.GstAggregatorPad, arg1 *C.GstAggregator) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorPadOverrides](instance0)
	if overrides.Flush == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorPadOverrides.Flush, got none")
	}

	var _aggregator Aggregatorrer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gstbase.Aggregatorrer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Aggregatorrer)
			return ok
		})
		rv, ok := casted.(Aggregatorrer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstbase.Aggregatorrer")
		}
		_aggregator = rv
	}

	flowReturn := overrides.Flush(_aggregator)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_AggregatorPadClass_skip_buffer
func _gotk4_gstbase1_AggregatorPadClass_skip_buffer(arg0 *C.GstAggregatorPad, arg1 *C.GstAggregator, arg2 *C.GstBuffer) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AggregatorPadOverrides](instance0)
	if overrides.SkipBuffer == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AggregatorPadOverrides.SkipBuffer, got none")
	}

	var _aggregator Aggregatorrer // out
	var _buffer *gst.Buffer       // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gstbase.Aggregatorrer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Aggregatorrer)
			return ok
		})
		rv, ok := casted.(Aggregatorrer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstbase.Aggregatorrer")
		}
		_aggregator = rv
	}
	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.SkipBuffer(_aggregator, _buffer)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_AggregatorPad_ConnectBufferConsumed
func _gotk4_gstbase1_AggregatorPad_ConnectBufferConsumed(arg0 C.gpointer, arg1 *C.GstBuffer, arg2 C.guintptr) {
	var f func(object *gst.Buffer)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object *gst.Buffer))
	}

	var _object *gst.Buffer // out

	_object = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	f(_object)
}

//export _gotk4_gstbase1_BaseParseClass_convert
func _gotk4_gstbase1_BaseParseClass_convert(arg0 *C.GstBaseParse, arg1 C.GstFormat, arg2 C.gint64, arg3 C.GstFormat, arg4 *C.gint64) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseParseOverrides](instance0)
	if overrides.Convert == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseParseOverrides.Convert, got none")
	}

	var _srcFormat gst.Format  // out
	var _srcValue int64        // out
	var _destFormat gst.Format // out
	var _destValue *int64      // out

	_srcFormat = gst.Format(arg1)
	_srcValue = int64(arg2)
	_destFormat = gst.Format(arg3)
	_destValue = (*int64)(unsafe.Pointer(arg4))

	ok := overrides.Convert(_srcFormat, _srcValue, _destFormat, _destValue)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseParseClass_detect
func _gotk4_gstbase1_BaseParseClass_detect(arg0 *C.GstBaseParse, arg1 *C.GstBuffer) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseParseOverrides](instance0)
	if overrides.Detect == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseParseOverrides.Detect, got none")
	}

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	flowReturn := overrides.Detect(_buffer)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_BaseParseClass_get_sink_caps
func _gotk4_gstbase1_BaseParseClass_get_sink_caps(arg0 *C.GstBaseParse, arg1 *C.GstCaps) (cret *C.GstCaps) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseParseOverrides](instance0)
	if overrides.SinkCaps == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseParseOverrides.SinkCaps, got none")
	}

	var _filter *gst.Caps // out

	_filter = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	caps := overrides.SinkCaps(_filter)

	var _ *gst.Caps

	cret = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)

	return cret
}

//export _gotk4_gstbase1_BaseParseClass_handle_frame
func _gotk4_gstbase1_BaseParseClass_handle_frame(arg0 *C.GstBaseParse, arg1 *C.GstBaseParseFrame, arg2 *C.gint) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseParseOverrides](instance0)
	if overrides.HandleFrame == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseParseOverrides.HandleFrame, got none")
	}

	var _frame *BaseParseFrame // out

	_frame = (*BaseParseFrame)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	skipsize, flowReturn := overrides.HandleFrame(_frame)

	var _ int
	var _ gst.FlowReturn

	*arg2 = C.gint(skipsize)
	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_BaseParseClass_pre_push_frame
func _gotk4_gstbase1_BaseParseClass_pre_push_frame(arg0 *C.GstBaseParse, arg1 *C.GstBaseParseFrame) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseParseOverrides](instance0)
	if overrides.PrePushFrame == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseParseOverrides.PrePushFrame, got none")
	}

	var _frame *BaseParseFrame // out

	_frame = (*BaseParseFrame)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	flowReturn := overrides.PrePushFrame(_frame)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_BaseParseClass_set_sink_caps
func _gotk4_gstbase1_BaseParseClass_set_sink_caps(arg0 *C.GstBaseParse, arg1 *C.GstCaps) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseParseOverrides](instance0)
	if overrides.SetSinkCaps == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseParseOverrides.SetSinkCaps, got none")
	}

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SetSinkCaps(_caps)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseParseClass_sink_event
func _gotk4_gstbase1_BaseParseClass_sink_event(arg0 *C.GstBaseParse, arg1 *C.GstEvent) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseParseOverrides](instance0)
	if overrides.SinkEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseParseOverrides.SinkEvent, got none")
	}

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SinkEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseParseClass_sink_query
func _gotk4_gstbase1_BaseParseClass_sink_query(arg0 *C.GstBaseParse, arg1 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseParseOverrides](instance0)
	if overrides.SinkQuery == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseParseOverrides.SinkQuery, got none")
	}

	var _query *gst.Query // out

	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SinkQuery(_query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseParseClass_src_event
func _gotk4_gstbase1_BaseParseClass_src_event(arg0 *C.GstBaseParse, arg1 *C.GstEvent) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseParseOverrides](instance0)
	if overrides.SrcEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseParseOverrides.SrcEvent, got none")
	}

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SrcEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseParseClass_src_query
func _gotk4_gstbase1_BaseParseClass_src_query(arg0 *C.GstBaseParse, arg1 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseParseOverrides](instance0)
	if overrides.SrcQuery == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseParseOverrides.SrcQuery, got none")
	}

	var _query *gst.Query // out

	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SrcQuery(_query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseParseClass_start
func _gotk4_gstbase1_BaseParseClass_start(arg0 *C.GstBaseParse) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseParseOverrides](instance0)
	if overrides.Start == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseParseOverrides.Start, got none")
	}

	ok := overrides.Start()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseParseClass_stop
func _gotk4_gstbase1_BaseParseClass_stop(arg0 *C.GstBaseParse) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseParseOverrides](instance0)
	if overrides.Stop == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseParseOverrides.Stop, got none")
	}

	ok := overrides.Stop()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseSinkClass_activate_pull
func _gotk4_gstbase1_BaseSinkClass_activate_pull(arg0 *C.GstBaseSink, arg1 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSinkOverrides](instance0)
	if overrides.ActivatePull == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSinkOverrides.ActivatePull, got none")
	}

	var _active bool // out

	if arg1 != 0 {
		_active = true
	}

	ok := overrides.ActivatePull(_active)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseSinkClass_event
func _gotk4_gstbase1_BaseSinkClass_event(arg0 *C.GstBaseSink, arg1 *C.GstEvent) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSinkOverrides](instance0)
	if overrides.Event == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSinkOverrides.Event, got none")
	}

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.Event(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseSinkClass_fixate
func _gotk4_gstbase1_BaseSinkClass_fixate(arg0 *C.GstBaseSink, arg1 *C.GstCaps) (cret *C.GstCaps) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSinkOverrides](instance0)
	if overrides.Fixate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSinkOverrides.Fixate, got none")
	}

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ret := overrides.Fixate(_caps)

	var _ *gst.Caps

	cret = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(ret)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(ret)), nil)

	return cret
}

//export _gotk4_gstbase1_BaseSinkClass_get_caps
func _gotk4_gstbase1_BaseSinkClass_get_caps(arg0 *C.GstBaseSink, arg1 *C.GstCaps) (cret *C.GstCaps) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSinkOverrides](instance0)
	if overrides.Caps == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSinkOverrides.Caps, got none")
	}

	var _filter *gst.Caps // out

	if arg1 != nil {
		_filter = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	}

	caps := overrides.Caps(_filter)

	var _ *gst.Caps

	cret = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)

	return cret
}

//export _gotk4_gstbase1_BaseSinkClass_get_times
func _gotk4_gstbase1_BaseSinkClass_get_times(arg0 *C.GstBaseSink, arg1 *C.GstBuffer, arg2 *C.GstClockTime, arg3 *C.GstClockTime) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSinkOverrides](instance0)
	if overrides.Times == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSinkOverrides.Times, got none")
	}

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	start, end := overrides.Times(_buffer)

	var _ gst.ClockTime
	var _ gst.ClockTime

	*arg2 = C.GstClockTime(start)
	*arg3 = C.GstClockTime(end)
}

//export _gotk4_gstbase1_BaseSinkClass_prepare
func _gotk4_gstbase1_BaseSinkClass_prepare(arg0 *C.GstBaseSink, arg1 *C.GstBuffer) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSinkOverrides](instance0)
	if overrides.Prepare == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSinkOverrides.Prepare, got none")
	}

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	flowReturn := overrides.Prepare(_buffer)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_BaseSinkClass_prepare_list
func _gotk4_gstbase1_BaseSinkClass_prepare_list(arg0 *C.GstBaseSink, arg1 *C.GstBufferList) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSinkOverrides](instance0)
	if overrides.PrepareList == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSinkOverrides.PrepareList, got none")
	}

	var _bufferList *gst.BufferList // out

	_bufferList = (*gst.BufferList)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	flowReturn := overrides.PrepareList(_bufferList)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_BaseSinkClass_preroll
func _gotk4_gstbase1_BaseSinkClass_preroll(arg0 *C.GstBaseSink, arg1 *C.GstBuffer) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSinkOverrides](instance0)
	if overrides.Preroll == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSinkOverrides.Preroll, got none")
	}

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	flowReturn := overrides.Preroll(_buffer)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_BaseSinkClass_propose_allocation
func _gotk4_gstbase1_BaseSinkClass_propose_allocation(arg0 *C.GstBaseSink, arg1 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSinkOverrides](instance0)
	if overrides.ProposeAllocation == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSinkOverrides.ProposeAllocation, got none")
	}

	var _query *gst.Query // out

	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.ProposeAllocation(_query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseSinkClass_query
func _gotk4_gstbase1_BaseSinkClass_query(arg0 *C.GstBaseSink, arg1 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSinkOverrides](instance0)
	if overrides.Query == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSinkOverrides.Query, got none")
	}

	var _query *gst.Query // out

	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.Query(_query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseSinkClass_render
func _gotk4_gstbase1_BaseSinkClass_render(arg0 *C.GstBaseSink, arg1 *C.GstBuffer) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSinkOverrides](instance0)
	if overrides.Render == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSinkOverrides.Render, got none")
	}

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	flowReturn := overrides.Render(_buffer)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_BaseSinkClass_render_list
func _gotk4_gstbase1_BaseSinkClass_render_list(arg0 *C.GstBaseSink, arg1 *C.GstBufferList) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSinkOverrides](instance0)
	if overrides.RenderList == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSinkOverrides.RenderList, got none")
	}

	var _bufferList *gst.BufferList // out

	_bufferList = (*gst.BufferList)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	flowReturn := overrides.RenderList(_bufferList)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_BaseSinkClass_set_caps
func _gotk4_gstbase1_BaseSinkClass_set_caps(arg0 *C.GstBaseSink, arg1 *C.GstCaps) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSinkOverrides](instance0)
	if overrides.SetCaps == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSinkOverrides.SetCaps, got none")
	}

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SetCaps(_caps)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseSinkClass_start
func _gotk4_gstbase1_BaseSinkClass_start(arg0 *C.GstBaseSink) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSinkOverrides](instance0)
	if overrides.Start == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSinkOverrides.Start, got none")
	}

	ok := overrides.Start()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseSinkClass_stop
func _gotk4_gstbase1_BaseSinkClass_stop(arg0 *C.GstBaseSink) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSinkOverrides](instance0)
	if overrides.Stop == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSinkOverrides.Stop, got none")
	}

	ok := overrides.Stop()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseSinkClass_unlock
func _gotk4_gstbase1_BaseSinkClass_unlock(arg0 *C.GstBaseSink) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSinkOverrides](instance0)
	if overrides.Unlock == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSinkOverrides.Unlock, got none")
	}

	ok := overrides.Unlock()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseSinkClass_unlock_stop
func _gotk4_gstbase1_BaseSinkClass_unlock_stop(arg0 *C.GstBaseSink) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSinkOverrides](instance0)
	if overrides.UnlockStop == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSinkOverrides.UnlockStop, got none")
	}

	ok := overrides.UnlockStop()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseSinkClass_wait_event
func _gotk4_gstbase1_BaseSinkClass_wait_event(arg0 *C.GstBaseSink, arg1 *C.GstEvent) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSinkOverrides](instance0)
	if overrides.WaitEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSinkOverrides.WaitEvent, got none")
	}

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	flowReturn := overrides.WaitEvent(_event)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_BaseSrcClass_alloc
func _gotk4_gstbase1_BaseSrcClass_alloc(arg0 *C.GstBaseSrc, arg1 C.guint64, arg2 C.guint, arg3 **C.GstBuffer) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSrcOverrides](instance0)
	if overrides.Alloc == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSrcOverrides.Alloc, got none")
	}

	var _offset uint64 // out
	var _size uint     // out

	_offset = uint64(arg1)
	_size = uint(arg2)

	buf, flowReturn := overrides.Alloc(_offset, _size)

	var _ *gst.Buffer
	var _ gst.FlowReturn

	if buf != nil {
		*arg3 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buf)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buf)), nil)
	}
	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_BaseSrcClass_decide_allocation
func _gotk4_gstbase1_BaseSrcClass_decide_allocation(arg0 *C.GstBaseSrc, arg1 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSrcOverrides](instance0)
	if overrides.DecideAllocation == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSrcOverrides.DecideAllocation, got none")
	}

	var _query *gst.Query // out

	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.DecideAllocation(_query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseSrcClass_do_seek
func _gotk4_gstbase1_BaseSrcClass_do_seek(arg0 *C.GstBaseSrc, arg1 *C.GstSegment) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSrcOverrides](instance0)
	if overrides.DoSeek == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSrcOverrides.DoSeek, got none")
	}

	var _segment *gst.Segment // out

	_segment = (*gst.Segment)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.DoSeek(_segment)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseSrcClass_event
func _gotk4_gstbase1_BaseSrcClass_event(arg0 *C.GstBaseSrc, arg1 *C.GstEvent) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSrcOverrides](instance0)
	if overrides.Event == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSrcOverrides.Event, got none")
	}

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.Event(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseSrcClass_fill
func _gotk4_gstbase1_BaseSrcClass_fill(arg0 *C.GstBaseSrc, arg1 C.guint64, arg2 C.guint, arg3 *C.GstBuffer) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSrcOverrides](instance0)
	if overrides.Fill == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSrcOverrides.Fill, got none")
	}

	var _offset uint64   // out
	var _size uint       // out
	var _buf *gst.Buffer // out

	_offset = uint64(arg1)
	_size = uint(arg2)
	_buf = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	flowReturn := overrides.Fill(_offset, _size, _buf)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_BaseSrcClass_fixate
func _gotk4_gstbase1_BaseSrcClass_fixate(arg0 *C.GstBaseSrc, arg1 *C.GstCaps) (cret *C.GstCaps) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSrcOverrides](instance0)
	if overrides.Fixate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSrcOverrides.Fixate, got none")
	}

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	ret := overrides.Fixate(_caps)

	var _ *gst.Caps

	cret = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(ret)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(ret)), nil)

	return cret
}

//export _gotk4_gstbase1_BaseSrcClass_get_caps
func _gotk4_gstbase1_BaseSrcClass_get_caps(arg0 *C.GstBaseSrc, arg1 *C.GstCaps) (cret *C.GstCaps) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSrcOverrides](instance0)
	if overrides.Caps == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSrcOverrides.Caps, got none")
	}

	var _filter *gst.Caps // out

	if arg1 != nil {
		_filter = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	}

	caps := overrides.Caps(_filter)

	var _ *gst.Caps

	cret = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(caps)), nil)

	return cret
}

//export _gotk4_gstbase1_BaseSrcClass_get_size
func _gotk4_gstbase1_BaseSrcClass_get_size(arg0 *C.GstBaseSrc, arg1 *C.guint64) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSrcOverrides](instance0)
	if overrides.Size == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSrcOverrides.Size, got none")
	}

	size, ok := overrides.Size()

	var _ uint64
	var _ bool

	*arg1 = C.guint64(size)
	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseSrcClass_get_times
func _gotk4_gstbase1_BaseSrcClass_get_times(arg0 *C.GstBaseSrc, arg1 *C.GstBuffer, arg2 *C.GstClockTime, arg3 *C.GstClockTime) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSrcOverrides](instance0)
	if overrides.Times == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSrcOverrides.Times, got none")
	}

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	start, end := overrides.Times(_buffer)

	var _ gst.ClockTime
	var _ gst.ClockTime

	*arg2 = C.GstClockTime(start)
	*arg3 = C.GstClockTime(end)
}

//export _gotk4_gstbase1_BaseSrcClass_is_seekable
func _gotk4_gstbase1_BaseSrcClass_is_seekable(arg0 *C.GstBaseSrc) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSrcOverrides](instance0)
	if overrides.IsSeekable == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSrcOverrides.IsSeekable, got none")
	}

	ok := overrides.IsSeekable()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseSrcClass_negotiate
func _gotk4_gstbase1_BaseSrcClass_negotiate(arg0 *C.GstBaseSrc) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSrcOverrides](instance0)
	if overrides.Negotiate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSrcOverrides.Negotiate, got none")
	}

	ok := overrides.Negotiate()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseSrcClass_prepare_seek_segment
func _gotk4_gstbase1_BaseSrcClass_prepare_seek_segment(arg0 *C.GstBaseSrc, arg1 *C.GstEvent, arg2 *C.GstSegment) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSrcOverrides](instance0)
	if overrides.PrepareSeekSegment == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSrcOverrides.PrepareSeekSegment, got none")
	}

	var _seek *gst.Event      // out
	var _segment *gst.Segment // out

	_seek = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_segment = (*gst.Segment)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.PrepareSeekSegment(_seek, _segment)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseSrcClass_query
func _gotk4_gstbase1_BaseSrcClass_query(arg0 *C.GstBaseSrc, arg1 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSrcOverrides](instance0)
	if overrides.Query == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSrcOverrides.Query, got none")
	}

	var _query *gst.Query // out

	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.Query(_query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseSrcClass_set_caps
func _gotk4_gstbase1_BaseSrcClass_set_caps(arg0 *C.GstBaseSrc, arg1 *C.GstCaps) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSrcOverrides](instance0)
	if overrides.SetCaps == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSrcOverrides.SetCaps, got none")
	}

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.SetCaps(_caps)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseSrcClass_start
func _gotk4_gstbase1_BaseSrcClass_start(arg0 *C.GstBaseSrc) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSrcOverrides](instance0)
	if overrides.Start == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSrcOverrides.Start, got none")
	}

	ok := overrides.Start()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseSrcClass_stop
func _gotk4_gstbase1_BaseSrcClass_stop(arg0 *C.GstBaseSrc) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSrcOverrides](instance0)
	if overrides.Stop == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSrcOverrides.Stop, got none")
	}

	ok := overrides.Stop()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseSrcClass_unlock
func _gotk4_gstbase1_BaseSrcClass_unlock(arg0 *C.GstBaseSrc) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSrcOverrides](instance0)
	if overrides.Unlock == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSrcOverrides.Unlock, got none")
	}

	ok := overrides.Unlock()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseSrcClass_unlock_stop
func _gotk4_gstbase1_BaseSrcClass_unlock_stop(arg0 *C.GstBaseSrc) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseSrcOverrides](instance0)
	if overrides.UnlockStop == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseSrcOverrides.UnlockStop, got none")
	}

	ok := overrides.UnlockStop()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseTransformClass_accept_caps
func _gotk4_gstbase1_BaseTransformClass_accept_caps(arg0 *C.GstBaseTransform, arg1 C.GstPadDirection, arg2 *C.GstCaps) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseTransformOverrides](instance0)
	if overrides.AcceptCaps == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseTransformOverrides.AcceptCaps, got none")
	}

	var _direction gst.PadDirection // out
	var _caps *gst.Caps             // out

	_direction = gst.PadDirection(arg1)
	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.AcceptCaps(_direction, _caps)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseTransformClass_before_transform
func _gotk4_gstbase1_BaseTransformClass_before_transform(arg0 *C.GstBaseTransform, arg1 *C.GstBuffer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseTransformOverrides](instance0)
	if overrides.BeforeTransform == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseTransformOverrides.BeforeTransform, got none")
	}

	var _buffer *gst.Buffer // out

	_buffer = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	overrides.BeforeTransform(_buffer)
}

//export _gotk4_gstbase1_BaseTransformClass_copy_metadata
func _gotk4_gstbase1_BaseTransformClass_copy_metadata(arg0 *C.GstBaseTransform, arg1 *C.GstBuffer, arg2 *C.GstBuffer) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseTransformOverrides](instance0)
	if overrides.CopyMetadata == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseTransformOverrides.CopyMetadata, got none")
	}

	var _input *gst.Buffer  // out
	var _outbuf *gst.Buffer // out

	_input = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_outbuf = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.CopyMetadata(_input, _outbuf)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseTransformClass_decide_allocation
func _gotk4_gstbase1_BaseTransformClass_decide_allocation(arg0 *C.GstBaseTransform, arg1 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseTransformOverrides](instance0)
	if overrides.DecideAllocation == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseTransformOverrides.DecideAllocation, got none")
	}

	var _query *gst.Query // out

	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := overrides.DecideAllocation(_query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseTransformClass_filter_meta
func _gotk4_gstbase1_BaseTransformClass_filter_meta(arg0 *C.GstBaseTransform, arg1 *C.GstQuery, arg2 C.GType, arg3 *C.GstStructure) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseTransformOverrides](instance0)
	if overrides.FilterMeta == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseTransformOverrides.FilterMeta, got none")
	}

	var _query *gst.Query      // out
	var _api coreglib.Type     // out
	var _params *gst.Structure // out

	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_api = coreglib.Type(arg2)
	_params = (*gst.Structure)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	ok := overrides.FilterMeta(_query, _api, _params)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseTransformClass_fixate_caps
func _gotk4_gstbase1_BaseTransformClass_fixate_caps(arg0 *C.GstBaseTransform, arg1 C.GstPadDirection, arg2 *C.GstCaps, arg3 *C.GstCaps) (cret *C.GstCaps) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseTransformOverrides](instance0)
	if overrides.FixateCaps == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseTransformOverrides.FixateCaps, got none")
	}

	var _direction gst.PadDirection // out
	var _caps *gst.Caps             // out
	var _othercaps *gst.Caps        // out

	_direction = gst.PadDirection(arg1)
	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_othercaps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_othercaps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	ret := overrides.FixateCaps(_direction, _caps, _othercaps)

	var _ *gst.Caps

	cret = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(ret)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(ret)), nil)

	return cret
}

//export _gotk4_gstbase1_BaseTransformClass_generate_output
func _gotk4_gstbase1_BaseTransformClass_generate_output(arg0 *C.GstBaseTransform, arg1 **C.GstBuffer) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseTransformOverrides](instance0)
	if overrides.GenerateOutput == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseTransformOverrides.GenerateOutput, got none")
	}

	outbuf, flowReturn := overrides.GenerateOutput()

	var _ *gst.Buffer
	var _ gst.FlowReturn

	*arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(outbuf)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(outbuf)), nil)
	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_BaseTransformClass_get_unit_size
func _gotk4_gstbase1_BaseTransformClass_get_unit_size(arg0 *C.GstBaseTransform, arg1 *C.GstCaps, arg2 *C.gsize) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseTransformOverrides](instance0)
	if overrides.UnitSize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseTransformOverrides.UnitSize, got none")
	}

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	size, ok := overrides.UnitSize(_caps)

	var _ uint
	var _ bool

	*arg2 = C.gsize(size)
	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseTransformClass_prepare_output_buffer
func _gotk4_gstbase1_BaseTransformClass_prepare_output_buffer(arg0 *C.GstBaseTransform, arg1 *C.GstBuffer, arg2 **C.GstBuffer) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseTransformOverrides](instance0)
	if overrides.PrepareOutputBuffer == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseTransformOverrides.PrepareOutputBuffer, got none")
	}

	var _input *gst.Buffer // out

	_input = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	outbuf, flowReturn := overrides.PrepareOutputBuffer(_input)

	var _ *gst.Buffer
	var _ gst.FlowReturn

	*arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(outbuf)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(outbuf)), nil)
	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_BaseTransformClass_propose_allocation
func _gotk4_gstbase1_BaseTransformClass_propose_allocation(arg0 *C.GstBaseTransform, arg1 *C.GstQuery, arg2 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseTransformOverrides](instance0)
	if overrides.ProposeAllocation == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseTransformOverrides.ProposeAllocation, got none")
	}

	var _decideQuery *gst.Query // out
	var _query *gst.Query       // out

	_decideQuery = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.ProposeAllocation(_decideQuery, _query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseTransformClass_query
func _gotk4_gstbase1_BaseTransformClass_query(arg0 *C.GstBaseTransform, arg1 C.GstPadDirection, arg2 *C.GstQuery) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseTransformOverrides](instance0)
	if overrides.Query == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseTransformOverrides.Query, got none")
	}

	var _direction gst.PadDirection // out
	var _query *gst.Query           // out

	_direction = gst.PadDirection(arg1)
	_query = (*gst.Query)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.Query(_direction, _query)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseTransformClass_set_caps
func _gotk4_gstbase1_BaseTransformClass_set_caps(arg0 *C.GstBaseTransform, arg1 *C.GstCaps, arg2 *C.GstCaps) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseTransformOverrides](instance0)
	if overrides.SetCaps == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseTransformOverrides.SetCaps, got none")
	}

	var _incaps *gst.Caps  // out
	var _outcaps *gst.Caps // out

	_incaps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_outcaps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.SetCaps(_incaps, _outcaps)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseTransformClass_sink_event
func _gotk4_gstbase1_BaseTransformClass_sink_event(arg0 *C.GstBaseTransform, arg1 *C.GstEvent) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseTransformOverrides](instance0)
	if overrides.SinkEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseTransformOverrides.SinkEvent, got none")
	}

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	ok := overrides.SinkEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseTransformClass_src_event
func _gotk4_gstbase1_BaseTransformClass_src_event(arg0 *C.GstBaseTransform, arg1 *C.GstEvent) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseTransformOverrides](instance0)
	if overrides.SrcEvent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseTransformOverrides.SrcEvent, got none")
	}

	var _event *gst.Event // out

	_event = (*gst.Event)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_event)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	ok := overrides.SrcEvent(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseTransformClass_start
func _gotk4_gstbase1_BaseTransformClass_start(arg0 *C.GstBaseTransform) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseTransformOverrides](instance0)
	if overrides.Start == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseTransformOverrides.Start, got none")
	}

	ok := overrides.Start()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseTransformClass_stop
func _gotk4_gstbase1_BaseTransformClass_stop(arg0 *C.GstBaseTransform) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseTransformOverrides](instance0)
	if overrides.Stop == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseTransformOverrides.Stop, got none")
	}

	ok := overrides.Stop()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseTransformClass_submit_input_buffer
func _gotk4_gstbase1_BaseTransformClass_submit_input_buffer(arg0 *C.GstBaseTransform, arg1 C.gboolean, arg2 *C.GstBuffer) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseTransformOverrides](instance0)
	if overrides.SubmitInputBuffer == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseTransformOverrides.SubmitInputBuffer, got none")
	}

	var _isDiscont bool    // out
	var _input *gst.Buffer // out

	if arg1 != 0 {
		_isDiscont = true
	}
	_input = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	flowReturn := overrides.SubmitInputBuffer(_isDiscont, _input)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_BaseTransformClass_transform
func _gotk4_gstbase1_BaseTransformClass_transform(arg0 *C.GstBaseTransform, arg1 *C.GstBuffer, arg2 *C.GstBuffer) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseTransformOverrides](instance0)
	if overrides.Transform == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseTransformOverrides.Transform, got none")
	}

	var _inbuf *gst.Buffer  // out
	var _outbuf *gst.Buffer // out

	_inbuf = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_outbuf = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	flowReturn := overrides.Transform(_inbuf, _outbuf)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_BaseTransformClass_transform_caps
func _gotk4_gstbase1_BaseTransformClass_transform_caps(arg0 *C.GstBaseTransform, arg1 C.GstPadDirection, arg2 *C.GstCaps, arg3 *C.GstCaps) (cret *C.GstCaps) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseTransformOverrides](instance0)
	if overrides.TransformCaps == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseTransformOverrides.TransformCaps, got none")
	}

	var _direction gst.PadDirection // out
	var _caps *gst.Caps             // out
	var _filter *gst.Caps           // out

	_direction = gst.PadDirection(arg1)
	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_filter = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	ret := overrides.TransformCaps(_direction, _caps, _filter)

	var _ *gst.Caps

	cret = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(ret)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(ret)), nil)

	return cret
}

//export _gotk4_gstbase1_BaseTransformClass_transform_ip
func _gotk4_gstbase1_BaseTransformClass_transform_ip(arg0 *C.GstBaseTransform, arg1 *C.GstBuffer) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseTransformOverrides](instance0)
	if overrides.TransformIP == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseTransformOverrides.TransformIP, got none")
	}

	var _buf *gst.Buffer // out

	_buf = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	flowReturn := overrides.TransformIP(_buf)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_BaseTransformClass_transform_meta
func _gotk4_gstbase1_BaseTransformClass_transform_meta(arg0 *C.GstBaseTransform, arg1 *C.GstBuffer, arg2 *C.GstMeta, arg3 *C.GstBuffer) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseTransformOverrides](instance0)
	if overrides.TransformMeta == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseTransformOverrides.TransformMeta, got none")
	}

	var _outbuf *gst.Buffer // out
	var _meta *gst.Meta     // out
	var _inbuf *gst.Buffer  // out

	_outbuf = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_meta = (*gst.Meta)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_inbuf = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	ok := overrides.TransformMeta(_outbuf, _meta, _inbuf)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_BaseTransformClass_transform_size
func _gotk4_gstbase1_BaseTransformClass_transform_size(arg0 *C.GstBaseTransform, arg1 C.GstPadDirection, arg2 *C.GstCaps, arg3 C.gsize, arg4 *C.GstCaps, arg5 *C.gsize) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[BaseTransformOverrides](instance0)
	if overrides.TransformSize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected BaseTransformOverrides.TransformSize, got none")
	}

	var _direction gst.PadDirection // out
	var _caps *gst.Caps             // out
	var _size uint                  // out
	var _othercaps *gst.Caps        // out

	_direction = gst.PadDirection(arg1)
	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_size = uint(arg3)
	_othercaps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(arg4)))

	othersize, ok := overrides.TransformSize(_direction, _caps, _size, _othercaps)

	var _ uint
	var _ bool

	*arg5 = C.gsize(othersize)
	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gstbase1_DataQueueClass_empty
func _gotk4_gstbase1_DataQueueClass_empty(arg0 *C.GstDataQueue) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[DataQueueOverrides](instance0)
	if overrides.Empty == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected DataQueueOverrides.Empty, got none")
	}

	overrides.Empty()
}

//export _gotk4_gstbase1_DataQueueClass_full
func _gotk4_gstbase1_DataQueueClass_full(arg0 *C.GstDataQueue) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[DataQueueOverrides](instance0)
	if overrides.Full == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected DataQueueOverrides.Full, got none")
	}

	overrides.Full()
}

//export _gotk4_gstbase1_DataQueue_ConnectEmpty
func _gotk4_gstbase1_DataQueue_ConnectEmpty(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gstbase1_DataQueue_ConnectFull
func _gotk4_gstbase1_DataQueue_ConnectFull(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gstbase1_PushSrcClass_alloc
func _gotk4_gstbase1_PushSrcClass_alloc(arg0 *C.GstPushSrc, arg1 **C.GstBuffer) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PushSrcOverrides](instance0)
	if overrides.Alloc == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PushSrcOverrides.Alloc, got none")
	}

	buf, flowReturn := overrides.Alloc()

	var _ *gst.Buffer
	var _ gst.FlowReturn

	if buf != nil {
		*arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(buf)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(buf)), nil)
	}
	cret = C.GstFlowReturn(flowReturn)

	return cret
}

//export _gotk4_gstbase1_PushSrcClass_fill
func _gotk4_gstbase1_PushSrcClass_fill(arg0 *C.GstPushSrc, arg1 *C.GstBuffer) (cret C.GstFlowReturn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PushSrcOverrides](instance0)
	if overrides.Fill == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PushSrcOverrides.Fill, got none")
	}

	var _buf *gst.Buffer // out

	_buf = (*gst.Buffer)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	flowReturn := overrides.Fill(_buf)

	var _ gst.FlowReturn

	cret = C.GstFlowReturn(flowReturn)

	return cret
}
