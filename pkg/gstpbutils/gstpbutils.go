// Code generated by girgen. DO NOT EDIT.

package gstpbutils

import (
	"fmt"
	"runtime"
	_ "runtime/cgo"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/go-gst/go-gst/pkg/gst"
	"github.com/go-gst/go-gst/pkg/gstvideo"
)

// #cgo pkg-config: gstreamer-pbutils-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/pbutils/pbutils.h>
// extern void _gotk4_gstpbutils1_InstallPluginsResultFunc(GstInstallPluginsReturn, gpointer);
// extern void _gotk4_gstpbutils1_Discoverer_ConnectStarting(gpointer, guintptr);
// extern void _gotk4_gstpbutils1_Discoverer_ConnectSourceSetup(gpointer, GstElement*, guintptr);
// extern void _gotk4_gstpbutils1_Discoverer_ConnectFinished(gpointer, guintptr);
// extern void _gotk4_gstpbutils1_Discoverer_ConnectDiscovered(gpointer, GstDiscovererInfo*, GError*, guintptr);
// extern void _gotk4_gstpbutils1_DiscovererClass_starting(GstDiscoverer*);
// extern void _gotk4_gstpbutils1_DiscovererClass_source_setup(GstDiscoverer*, GstElement*);
// extern void _gotk4_gstpbutils1_DiscovererClass_finished(GstDiscoverer*);
// extern void _gotk4_gstpbutils1_DiscovererClass_discovered(GstDiscoverer*, GstDiscovererInfo*, GError*);
// extern gboolean _gotk4_gstpbutils1_AudioVisualizerClass_setup(GstAudioVisualizer*);
// extern gboolean _gotk4_gstpbutils1_AudioVisualizerClass_render(GstAudioVisualizer*, GstBuffer*, GstVideoFrame*);
// extern gboolean _gotk4_gstpbutils1_AudioVisualizerClass_decide_allocation(GstAudioVisualizer*, GstQuery*);
// extern GstDiscovererInfo* _gotk4_gstpbutils1_Discoverer_ConnectLoadSerializedInfo(gpointer, gchar*, guintptr);
// extern GstDiscovererInfo* _gotk4_gstpbutils1_DiscovererClass_load_serialize_info(GstDiscoverer*, gchar*);
// GstDiscovererInfo* _gotk4_gstpbutils1_Discoverer_virtual_load_serialize_info(void* fnptr, GstDiscoverer* arg0, gchar* arg1) {
//   return ((GstDiscovererInfo* (*)(GstDiscoverer*, gchar*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstpbutils1_AudioVisualizer_virtual_decide_allocation(void* fnptr, GstAudioVisualizer* arg0, GstQuery* arg1) {
//   return ((gboolean (*)(GstAudioVisualizer*, GstQuery*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstpbutils1_AudioVisualizer_virtual_render(void* fnptr, GstAudioVisualizer* arg0, GstBuffer* arg1, GstVideoFrame* arg2) {
//   return ((gboolean (*)(GstAudioVisualizer*, GstBuffer*, GstVideoFrame*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gstpbutils1_AudioVisualizer_virtual_setup(void* fnptr, GstAudioVisualizer* arg0) {
//   return ((gboolean (*)(GstAudioVisualizer*))(fnptr))(arg0);
// };
// void _gotk4_gstpbutils1_Discoverer_virtual_discovered(void* fnptr, GstDiscoverer* arg0, GstDiscovererInfo* arg1, GError* arg2) {
//   ((void (*)(GstDiscoverer*, GstDiscovererInfo*, GError*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gstpbutils1_Discoverer_virtual_finished(void* fnptr, GstDiscoverer* arg0) {
//   ((void (*)(GstDiscoverer*))(fnptr))(arg0);
// };
// void _gotk4_gstpbutils1_Discoverer_virtual_source_setup(void* fnptr, GstDiscoverer* arg0, GstElement* arg1) {
//   ((void (*)(GstDiscoverer*, GstElement*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gstpbutils1_Discoverer_virtual_starting(void* fnptr, GstDiscoverer* arg0) {
//   ((void (*)(GstDiscoverer*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeAudioVisualizerShader       = coreglib.Type(C.gst_audio_visualizer_shader_get_type())
	GTypeDiscovererResult            = coreglib.Type(C.gst_discoverer_result_get_type())
	GTypeInstallPluginsReturn        = coreglib.Type(C.gst_install_plugins_return_get_type())
	GTypeDiscovererSerializeFlags    = coreglib.Type(C.gst_discoverer_serialize_flags_get_type())
	GTypePbUtilsCapsDescriptionFlags = coreglib.Type(C.gst_pb_utils_caps_description_flags_get_type())
	GTypeAudioVisualizer             = coreglib.Type(C.gst_audio_visualizer_get_type())
	GTypeDiscoverer                  = coreglib.Type(C.gst_discoverer_get_type())
	GTypeDiscovererAudioInfo         = coreglib.Type(C.gst_discoverer_audio_info_get_type())
	GTypeDiscovererContainerInfo     = coreglib.Type(C.gst_discoverer_container_info_get_type())
	GTypeDiscovererInfo              = coreglib.Type(C.gst_discoverer_info_get_type())
	GTypeDiscovererStreamInfo        = coreglib.Type(C.gst_discoverer_stream_info_get_type())
	GTypeDiscovererSubtitleInfo      = coreglib.Type(C.gst_discoverer_subtitle_info_get_type())
	GTypeDiscovererVideoInfo         = coreglib.Type(C.gst_discoverer_video_info_get_type())
	GTypeEncodingAudioProfile        = coreglib.Type(C.gst_encoding_audio_profile_get_type())
	GTypeEncodingContainerProfile    = coreglib.Type(C.gst_encoding_container_profile_get_type())
	GTypeEncodingProfile             = coreglib.Type(C.gst_encoding_profile_get_type())
	GTypeEncodingTarget              = coreglib.Type(C.gst_encoding_target_get_type())
	GTypeEncodingVideoProfile        = coreglib.Type(C.gst_encoding_video_profile_get_type())
	GTypeInstallPluginsContext       = coreglib.Type(C.gst_install_plugins_context_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAudioVisualizerShader, F: marshalAudioVisualizerShader},
		coreglib.TypeMarshaler{T: GTypeDiscovererResult, F: marshalDiscovererResult},
		coreglib.TypeMarshaler{T: GTypeInstallPluginsReturn, F: marshalInstallPluginsReturn},
		coreglib.TypeMarshaler{T: GTypeDiscovererSerializeFlags, F: marshalDiscovererSerializeFlags},
		coreglib.TypeMarshaler{T: GTypePbUtilsCapsDescriptionFlags, F: marshalPbUtilsCapsDescriptionFlags},
		coreglib.TypeMarshaler{T: GTypeAudioVisualizer, F: marshalAudioVisualizer},
		coreglib.TypeMarshaler{T: GTypeDiscoverer, F: marshalDiscoverer},
		coreglib.TypeMarshaler{T: GTypeDiscovererAudioInfo, F: marshalDiscovererAudioInfo},
		coreglib.TypeMarshaler{T: GTypeDiscovererContainerInfo, F: marshalDiscovererContainerInfo},
		coreglib.TypeMarshaler{T: GTypeDiscovererInfo, F: marshalDiscovererInfo},
		coreglib.TypeMarshaler{T: GTypeDiscovererStreamInfo, F: marshalDiscovererStreamInfo},
		coreglib.TypeMarshaler{T: GTypeDiscovererSubtitleInfo, F: marshalDiscovererSubtitleInfo},
		coreglib.TypeMarshaler{T: GTypeDiscovererVideoInfo, F: marshalDiscovererVideoInfo},
		coreglib.TypeMarshaler{T: GTypeEncodingAudioProfile, F: marshalEncodingAudioProfile},
		coreglib.TypeMarshaler{T: GTypeEncodingContainerProfile, F: marshalEncodingContainerProfile},
		coreglib.TypeMarshaler{T: GTypeEncodingProfile, F: marshalEncodingProfile},
		coreglib.TypeMarshaler{T: GTypeEncodingTarget, F: marshalEncodingTarget},
		coreglib.TypeMarshaler{T: GTypeEncodingVideoProfile, F: marshalEncodingVideoProfile},
		coreglib.TypeMarshaler{T: GTypeInstallPluginsContext, F: marshalInstallPluginsContext},
	})
}

// ENCODING_CATEGORY_CAPTURE category for recording and capture. Targets within
// this category are optimized for low latency encoding.
const ENCODING_CATEGORY_CAPTURE = "capture"

// ENCODING_CATEGORY_DEVICE category for device-specific targets. The name of
// the target will usually be the constructor and model of the device, and that
// target will contain EncodingProfiles suitable for that device.
const ENCODING_CATEGORY_DEVICE = "device"

// ENCODING_CATEGORY_FILE_EXTENSION category for file extensions. The name of
// the target will be the name of the file extensions possible for a particular
// target. Those targets are defining like 'default' formats usually used for a
// particular file extension.
const ENCODING_CATEGORY_FILE_EXTENSION = "file-extension"

// ENCODING_CATEGORY_ONLINE_SERVICE category for online-services. The name of
// the target will usually be the name of the online service and that target
// will contain EncodingProfiles suitable for that online service.
const ENCODING_CATEGORY_ONLINE_SERVICE = "online-service"

// ENCODING_CATEGORY_STORAGE_EDITING category for storage, archiving and editing
// targets. Those targets can be lossless and/or provide very fast random access
// content. The name of the target will usually be the container type or editing
// target, and that target will contain EncodingProfiles suitable for editing or
// storage.
const ENCODING_CATEGORY_STORAGE_EDITING = "storage-editing"

// PLUGINS_BASE_VERSION_MAJOR: major version of GStreamer's gst-plugins-base
// libraries at compile time.
const PLUGINS_BASE_VERSION_MAJOR = 1

// PLUGINS_BASE_VERSION_MICRO: micro version of GStreamer's gst-plugins-base
// libraries at compile time.
const PLUGINS_BASE_VERSION_MICRO = 10

// PLUGINS_BASE_VERSION_MINOR: minor version of GStreamer's gst-plugins-base
// libraries at compile time.
const PLUGINS_BASE_VERSION_MINOR = 24

// PLUGINS_BASE_VERSION_NANO: nano version of GStreamer's gst-plugins-base
// libraries at compile time. Actual releases have 0, GIT versions have 1,
// prerelease versions have 2-...
const PLUGINS_BASE_VERSION_NANO = 0

// AudioVisualizerShader: different types of supported background shading
// functions.
type AudioVisualizerShader C.gint

const (
	// AudioVisualizerShaderNone: no shading.
	AudioVisualizerShaderNone AudioVisualizerShader = iota
	// AudioVisualizerShaderFade: plain fading.
	AudioVisualizerShaderFade
	// AudioVisualizerShaderFadeAndMoveUp: fade and move up.
	AudioVisualizerShaderFadeAndMoveUp
	// AudioVisualizerShaderFadeAndMoveDown: fade and move down.
	AudioVisualizerShaderFadeAndMoveDown
	// AudioVisualizerShaderFadeAndMoveLeft: fade and move left.
	AudioVisualizerShaderFadeAndMoveLeft
	// AudioVisualizerShaderFadeAndMoveRight: fade and move right.
	AudioVisualizerShaderFadeAndMoveRight
	// AudioVisualizerShaderFadeAndMoveHorizOut: fade and move horizontally out.
	AudioVisualizerShaderFadeAndMoveHorizOut
	// AudioVisualizerShaderFadeAndMoveHorizIn: fade and move horizontally in.
	AudioVisualizerShaderFadeAndMoveHorizIn
	// AudioVisualizerShaderFadeAndMoveVertOut: fade and move vertically out.
	AudioVisualizerShaderFadeAndMoveVertOut
	// AudioVisualizerShaderFadeAndMoveVertIn: fade and move vertically in.
	AudioVisualizerShaderFadeAndMoveVertIn
)

func marshalAudioVisualizerShader(p uintptr) (interface{}, error) {
	return AudioVisualizerShader(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AudioVisualizerShader.
func (a AudioVisualizerShader) String() string {
	switch a {
	case AudioVisualizerShaderNone:
		return "None"
	case AudioVisualizerShaderFade:
		return "Fade"
	case AudioVisualizerShaderFadeAndMoveUp:
		return "FadeAndMoveUp"
	case AudioVisualizerShaderFadeAndMoveDown:
		return "FadeAndMoveDown"
	case AudioVisualizerShaderFadeAndMoveLeft:
		return "FadeAndMoveLeft"
	case AudioVisualizerShaderFadeAndMoveRight:
		return "FadeAndMoveRight"
	case AudioVisualizerShaderFadeAndMoveHorizOut:
		return "FadeAndMoveHorizOut"
	case AudioVisualizerShaderFadeAndMoveHorizIn:
		return "FadeAndMoveHorizIn"
	case AudioVisualizerShaderFadeAndMoveVertOut:
		return "FadeAndMoveVertOut"
	case AudioVisualizerShaderFadeAndMoveVertIn:
		return "FadeAndMoveVertIn"
	default:
		return fmt.Sprintf("AudioVisualizerShader(%d)", a)
	}
}

// DiscovererResult: result values for the discovery process.
type DiscovererResult C.gint

const (
	// DiscovererOK: discovery was successful.
	DiscovererOK DiscovererResult = iota
	// DiscovererURIInvalid: URI is invalid.
	DiscovererURIInvalid
	// DiscovererError: error happened and the GError is set.
	DiscovererError
	// DiscovererTimeout: discovery timed-out.
	DiscovererTimeout
	// DiscovererBusy: discoverer was already discovering a file.
	DiscovererBusy
	// DiscovererMissingPlugins: some plugins are missing for full discovery.
	DiscovererMissingPlugins
)

func marshalDiscovererResult(p uintptr) (interface{}, error) {
	return DiscovererResult(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DiscovererResult.
func (d DiscovererResult) String() string {
	switch d {
	case DiscovererOK:
		return "OK"
	case DiscovererURIInvalid:
		return "URIInvalid"
	case DiscovererError:
		return "Error"
	case DiscovererTimeout:
		return "Timeout"
	case DiscovererBusy:
		return "Busy"
	case DiscovererMissingPlugins:
		return "MissingPlugins"
	default:
		return fmt.Sprintf("DiscovererResult(%d)", d)
	}
}

// InstallPluginsReturn: result codes returned by gst_install_plugins_async()
// and gst_install_plugins_sync(), and also the result code passed to the
// InstallPluginsResultFunc specified with gst_install_plugins_async().
//
// These codes indicate success or failure of starting an external installer
// program and to what extent the requested plugins could be installed.
type InstallPluginsReturn C.gint

const (
	// InstallPluginsSuccess: all of the requested plugins could be installed.
	InstallPluginsSuccess InstallPluginsReturn = 0
	// InstallPluginsNotFound: no appropriate installation candidate for any
	// of the requested plugins could be found. Only return this if nothing has
	// been installed. Return T_INSTALL_PLUGINS_PARTIAL_SUCCESS if some (but not
	// all) of the requested plugins could be installed.
	InstallPluginsNotFound InstallPluginsReturn = 1
	// InstallPluginsError: error occurred during the installation. If this
	// happens, the user has already seen an error message and another one
	// should not be displayed.
	InstallPluginsError InstallPluginsReturn = 2
	// InstallPluginsPartialSuccess: some of the requested plugins could be
	// installed, but not all.
	InstallPluginsPartialSuccess InstallPluginsReturn = 3
	// InstallPluginsUserAbort: user has aborted the installation.
	InstallPluginsUserAbort InstallPluginsReturn = 4
	// InstallPluginsCrashed: installer had an unclean exit code (ie. death by
	// signal).
	InstallPluginsCrashed InstallPluginsReturn = 100
	// InstallPluginsInvalid: helper returned an invalid status code.
	InstallPluginsInvalid InstallPluginsReturn = 101
	// InstallPluginsStartedOK: returned by gst_install_plugins_async() to
	// indicate that everything went fine so far and the provided callback will
	// be called with the result of the installation later.
	InstallPluginsStartedOK InstallPluginsReturn = 200
	// InstallPluginsInternalFailure: some internal failure has occurred when
	// trying to start the installer.
	InstallPluginsInternalFailure InstallPluginsReturn = 201
	// InstallPluginsHelperMissing: helper script to call the actual installer
	// is not installed.
	InstallPluginsHelperMissing InstallPluginsReturn = 202
	// InstallPluginsInstallInProgress: previously-started plugin installation
	// is still in progress, try again later.
	InstallPluginsInstallInProgress InstallPluginsReturn = 203
)

func marshalInstallPluginsReturn(p uintptr) (interface{}, error) {
	return InstallPluginsReturn(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for InstallPluginsReturn.
func (i InstallPluginsReturn) String() string {
	switch i {
	case InstallPluginsSuccess:
		return "Success"
	case InstallPluginsNotFound:
		return "NotFound"
	case InstallPluginsError:
		return "Error"
	case InstallPluginsPartialSuccess:
		return "PartialSuccess"
	case InstallPluginsUserAbort:
		return "UserAbort"
	case InstallPluginsCrashed:
		return "Crashed"
	case InstallPluginsInvalid:
		return "Invalid"
	case InstallPluginsStartedOK:
		return "StartedOK"
	case InstallPluginsInternalFailure:
		return "InternalFailure"
	case InstallPluginsHelperMissing:
		return "HelperMissing"
	case InstallPluginsInstallInProgress:
		return "InstallInProgress"
	default:
		return fmt.Sprintf("InstallPluginsReturn(%d)", i)
	}
}

// InstallPluginsReturnGetName: convenience function to return the descriptive
// string associated with a status code. This function returns English strings
// and should not be used for user messages. It is here only to assist in
// debugging.
//
// The function takes the following parameters:
//
//   - ret: return status code.
//
// The function returns the following values:
//
//   - utf8: descriptive string for the status code in ret.
func InstallPluginsReturnGetName(ret InstallPluginsReturn) string {
	var _arg1 C.GstInstallPluginsReturn // out
	var _cret *C.gchar                  // in

	_arg1 = C.GstInstallPluginsReturn(ret)

	_cret = C.gst_install_plugins_return_get_name(_arg1)
	runtime.KeepAlive(ret)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// DiscovererSerializeFlags: you can use these flags to control what is
// serialized by gst_discoverer_info_to_variant().
type DiscovererSerializeFlags C.guint

const (
	// DiscovererSerializeBasic: serialize only basic information, excluding
	// caps, tags and miscellaneous information.
	DiscovererSerializeBasic DiscovererSerializeFlags = 0b0
	// DiscovererSerializeCaps: serialize the caps for each stream.
	DiscovererSerializeCaps DiscovererSerializeFlags = 0b1
	// DiscovererSerializeTags: serialize the tags for each stream.
	DiscovererSerializeTags DiscovererSerializeFlags = 0b10
	// DiscovererSerializeMisc: serialize miscellaneous information for each
	// stream.
	DiscovererSerializeMisc DiscovererSerializeFlags = 0b100
	// DiscovererSerializeAll: serialize all the available info, including caps,
	// tags and miscellaneous information.
	DiscovererSerializeAll DiscovererSerializeFlags = 0b111
)

func marshalDiscovererSerializeFlags(p uintptr) (interface{}, error) {
	return DiscovererSerializeFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DiscovererSerializeFlags.
func (d DiscovererSerializeFlags) String() string {
	if d == 0 {
		return "DiscovererSerializeFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(119)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DiscovererSerializeBasic:
			builder.WriteString("Basic|")
		case DiscovererSerializeCaps:
			builder.WriteString("Caps|")
		case DiscovererSerializeTags:
			builder.WriteString("Tags|")
		case DiscovererSerializeMisc:
			builder.WriteString("Misc|")
		case DiscovererSerializeAll:
			builder.WriteString("All|")
		default:
			builder.WriteString(fmt.Sprintf("DiscovererSerializeFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DiscovererSerializeFlags) Has(other DiscovererSerializeFlags) bool {
	return (d & other) == other
}

// PbUtilsCapsDescriptionFlags flags that are returned by
// gst_pb_utils_get_caps_description_flags() and describe the format of the
// caps.
type PbUtilsCapsDescriptionFlags C.guint

const (
	// PbutilsCapsDescriptionFlagContainer caps describe a container format.
	PbutilsCapsDescriptionFlagContainer PbUtilsCapsDescriptionFlags = 0b1
	// PbutilsCapsDescriptionFlagAudio caps describe an audio format, or a
	// container format that can store audio.
	PbutilsCapsDescriptionFlagAudio PbUtilsCapsDescriptionFlags = 0b10
	// PbutilsCapsDescriptionFlagVideo caps describe an video format, or a
	// container format that can store video.
	PbutilsCapsDescriptionFlagVideo PbUtilsCapsDescriptionFlags = 0b100
	// PbutilsCapsDescriptionFlagImage caps describe an image format, or a
	// container format that can store image.
	PbutilsCapsDescriptionFlagImage PbUtilsCapsDescriptionFlags = 0b1000
	// PbutilsCapsDescriptionFlagSubtitle caps describe an subtitle format,
	// or a container format that can store subtitles.
	PbutilsCapsDescriptionFlagSubtitle PbUtilsCapsDescriptionFlags = 0b10000
	// PbutilsCapsDescriptionFlagTag: container format is a tags container.
	PbutilsCapsDescriptionFlagTag PbUtilsCapsDescriptionFlags = 0b100000
	// PbutilsCapsDescriptionFlagGeneric: container format can store any kind of
	// stream type.
	PbutilsCapsDescriptionFlagGeneric PbUtilsCapsDescriptionFlags = 0b1000000
	// PbutilsCapsDescriptionFlagMetadata caps describe a metadata format,
	// or a container format that can store metadata.
	PbutilsCapsDescriptionFlagMetadata PbUtilsCapsDescriptionFlags = 0b10000000
)

func marshalPbUtilsCapsDescriptionFlags(p uintptr) (interface{}, error) {
	return PbUtilsCapsDescriptionFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PbUtilsCapsDescriptionFlags.
func (p PbUtilsCapsDescriptionFlags) String() string {
	if p == 0 {
		return "PbUtilsCapsDescriptionFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PbutilsCapsDescriptionFlagContainer:
			builder.WriteString("Container|")
		case PbutilsCapsDescriptionFlagAudio:
			builder.WriteString("Audio|")
		case PbutilsCapsDescriptionFlagVideo:
			builder.WriteString("Video|")
		case PbutilsCapsDescriptionFlagImage:
			builder.WriteString("Image|")
		case PbutilsCapsDescriptionFlagSubtitle:
			builder.WriteString("Subtitle|")
		case PbutilsCapsDescriptionFlagTag:
			builder.WriteString("Tag|")
		case PbutilsCapsDescriptionFlagGeneric:
			builder.WriteString("Generic|")
		case PbutilsCapsDescriptionFlagMetadata:
			builder.WriteString("Metadata|")
		default:
			builder.WriteString(fmt.Sprintf("PbUtilsCapsDescriptionFlags(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PbUtilsCapsDescriptionFlags) Has(other PbUtilsCapsDescriptionFlags) bool {
	return (p & other) == other
}

// InstallPluginsResultFunc: prototype of the callback function that will be
// called once the external plugin installer program has returned. You only need
// to provide a callback function if you are using the asynchronous interface.
type InstallPluginsResultFunc func(result InstallPluginsReturn)

// CodecUtilsAacCapsSetLevelAndProfile sets the level and profile on caps if
// it can be determined from audio_config. See gst_codec_utils_aac_get_level()
// and gst_codec_utils_aac_get_profile() for more details on the parameters.
// caps must be audio/mpeg caps with an "mpegversion" field of either 2 or 4.
// If mpegversion is 4, the "base-profile" field is also set in caps.
//
// The function takes the following parameters:
//
//   - caps to which level and profile fields are to be added.
//   - audioConfig: pointer to the AudioSpecificConfig as specified in the
//     Elementary Stream Descriptor (esds) in ISO/IEC 14496-1. (See below for
//     more details).
//
// The function returns the following values:
//
//   - ok: TRUE if the level and profile could be set, FALSE otherwise.
func CodecUtilsAacCapsSetLevelAndProfile(caps *gst.Caps, audioConfig []byte) bool {
	var _arg1 *C.GstCaps // out
	var _arg2 *C.guint8  // out
	var _arg3 C.guint
	var _cret C.gboolean // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg3 = (C.guint)(len(audioConfig))
	if len(audioConfig) > 0 {
		_arg2 = (*C.guint8)(unsafe.Pointer(&audioConfig[0]))
	}

	_cret = C.gst_codec_utils_aac_caps_set_level_and_profile(_arg1, _arg2, _arg3)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(audioConfig)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CodecUtilsAacGetChannels returns the channels of the given AAC stream.
//
// The function takes the following parameters:
//
//   - audioConfig: pointer to the AudioSpecificConfig as specified in the
//     Elementary Stream Descriptor (esds) in ISO/IEC 14496-1.
//
// The function returns the following values:
//
//   - guint channels or 0 if the channel could not be determined.
func CodecUtilsAacGetChannels(audioConfig []byte) uint {
	var _arg1 *C.guint8 // out
	var _arg2 C.guint
	var _cret C.guint // in

	_arg2 = (C.guint)(len(audioConfig))
	if len(audioConfig) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&audioConfig[0]))
	}

	_cret = C.gst_codec_utils_aac_get_channels(_arg1, _arg2)
	runtime.KeepAlive(audioConfig)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// CodecUtilsAacGetIndexFromSampleRate translates the sample rate to the index
// corresponding to it in AAC spec.
//
// The function takes the following parameters:
//
//   - rate: sample rate.
//
// The function returns the following values:
//
//   - gint: AAC index for this sample rate, -1 if the rate is not a valid AAC
//     sample rate.
func CodecUtilsAacGetIndexFromSampleRate(rate uint) int {
	var _arg1 C.guint // out
	var _cret C.gint  // in

	_arg1 = C.guint(rate)

	_cret = C.gst_codec_utils_aac_get_index_from_sample_rate(_arg1)
	runtime.KeepAlive(rate)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// CodecUtilsAacGetLevel determines the level of a stream as defined in ISO/IEC
// 14496-3. For AAC LC streams, the constraints from the AAC audio profile are
// applied. For AAC Main, LTP, SSR and others, the Main profile is used.
//
// The audio_config parameter follows the following format, starting from the
// most significant bit of the first byte:
//
//   - Bit 0:4 contains the AudioObjectType (if this is 0x5, then the real
//     AudioObjectType is carried after the rate and channel data)
//   - Bit 5:8 contains the sample frequency index (if this is 0xf, then the
//     next 24 bits define the actual sample frequency, and subsequent fields
//     are appropriately shifted).
//   - Bit 9:12 contains the channel configuration.
//
// The function takes the following parameters:
//
//   - audioConfig: pointer to the AudioSpecificConfig as specified in the
//     Elementary Stream Descriptor (esds) in ISO/IEC 14496-1.
//
// The function returns the following values:
//
//   - utf8 (optional): level as a const string and NULL if the level could not
//     be determined.
func CodecUtilsAacGetLevel(audioConfig []byte) string {
	var _arg1 *C.guint8 // out
	var _arg2 C.guint
	var _cret *C.gchar // in

	_arg2 = (C.guint)(len(audioConfig))
	if len(audioConfig) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&audioConfig[0]))
	}

	_cret = C.gst_codec_utils_aac_get_level(_arg1, _arg2)
	runtime.KeepAlive(audioConfig)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// CodecUtilsAacGetProfile returns the profile of the given AAC stream as a
// string. The profile is normally determined using the AudioObjectType field
// which is in the first 5 bits of audio_config.
//
// The function takes the following parameters:
//
//   - audioConfig: pointer to the AudioSpecificConfig as specified in the
//     Elementary Stream Descriptor (esds) in ISO/IEC 14496-1.
//
// The function returns the following values:
//
//   - utf8 (optional): profile as a const string and NULL if the profile could
//     not be determined.
func CodecUtilsAacGetProfile(audioConfig []byte) string {
	var _arg1 *C.guint8 // out
	var _arg2 C.guint
	var _cret *C.gchar // in

	_arg2 = (C.guint)(len(audioConfig))
	if len(audioConfig) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&audioConfig[0]))
	}

	_cret = C.gst_codec_utils_aac_get_profile(_arg1, _arg2)
	runtime.KeepAlive(audioConfig)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// CodecUtilsAacGetSampleRate translates the sample rate index found in AAC
// headers to the actual sample rate.
//
// The function takes the following parameters:
//
//   - audioConfig: pointer to the AudioSpecificConfig as specified in the
//     Elementary Stream Descriptor (esds) in ISO/IEC 14496-1.
//
// The function returns the following values:
//
//   - guint: sample rate if sr_idx is valid, 0 otherwise.
func CodecUtilsAacGetSampleRate(audioConfig []byte) uint {
	var _arg1 *C.guint8 // out
	var _arg2 C.guint
	var _cret C.guint // in

	_arg2 = (C.guint)(len(audioConfig))
	if len(audioConfig) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&audioConfig[0]))
	}

	_cret = C.gst_codec_utils_aac_get_sample_rate(_arg1, _arg2)
	runtime.KeepAlive(audioConfig)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// CodecUtilsAacGetSampleRateFromIndex translates the sample rate index found in
// AAC headers to the actual sample rate.
//
// The function takes the following parameters:
//
//   - srIdx: sample rate index as from the AudioSpecificConfig (MPEG-4
//     container) or ADTS frame header.
//
// The function returns the following values:
//
//   - guint: sample rate if sr_idx is valid, 0 otherwise.
func CodecUtilsAacGetSampleRateFromIndex(srIdx uint) uint {
	var _arg1 C.guint // out
	var _cret C.guint // in

	_arg1 = C.guint(srIdx)

	_cret = C.gst_codec_utils_aac_get_sample_rate_from_index(_arg1)
	runtime.KeepAlive(srIdx)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// CodecUtilsCapsFromMIMECodec converts a RFC 6381 compatible codec string to
// Caps. More than one codec string can be present (separated by ,).
//
// Registered codecs can be found at http://mp4ra.org/#/codecs.
//
// The function takes the following parameters:
//
//   - codecsField: mime codec string field.
//
// The function returns the following values:
//
//   - caps (optional): corresponding Caps or NULL.
func CodecUtilsCapsFromMIMECodec(codecsField string) *gst.Caps {
	var _arg1 *C.gchar   // out
	var _cret *C.GstCaps // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(codecsField)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_codec_utils_caps_from_mime_codec(_arg1)
	runtime.KeepAlive(codecsField)

	var _caps *gst.Caps // out

	if _cret != nil {
		_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_caps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _caps
}

// CodecUtilsCapsGetMIMECodec converts caps to a RFC 6381 compatible codec
// string if possible.
//
// Useful for providing the 'codecs' field inside the 'Content-Type' HTTP header
// for containerized formats, such as mp4 or matroska.
//
// Registered codecs can be found at http://mp4ra.org/#/codecs.
//
// The function takes the following parameters:
//
//   - caps to convert to mime codec.
//
// The function returns the following values:
//
//   - utf8 (optional): RFC 6381 compatible codec string or NULL.
func CodecUtilsCapsGetMIMECodec(caps *gst.Caps) string {
	var _arg1 *C.GstCaps // out
	var _cret *C.gchar   // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_codec_utils_caps_get_mime_codec(_arg1)
	runtime.KeepAlive(caps)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// CodecUtilsH264CapsSetLevelAndProfile sets the level and profile in caps
// if it can be determined from sps. See gst_codec_utils_h264_get_level() and
// gst_codec_utils_h264_get_profile() for more details on the parameters.
//
// The function takes the following parameters:
//
//   - caps to which the level and profile are to be added.
//   - sps: pointer to the sequence parameter set for the stream.
//
// The function returns the following values:
//
//   - ok: TRUE if the level and profile could be set, FALSE otherwise.
func CodecUtilsH264CapsSetLevelAndProfile(caps *gst.Caps, sps []byte) bool {
	var _arg1 *C.GstCaps // out
	var _arg2 *C.guint8  // out
	var _arg3 C.guint
	var _cret C.gboolean // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg3 = (C.guint)(len(sps))
	if len(sps) > 0 {
		_arg2 = (*C.guint8)(unsafe.Pointer(&sps[0]))
	}

	_cret = C.gst_codec_utils_h264_caps_set_level_and_profile(_arg1, _arg2, _arg3)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(sps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CodecUtilsH264GetLevel converts the level indication (level_idc) in the
// stream's sequence parameter set into a string. The SPS is expected to have
// the same format as for gst_codec_utils_h264_get_profile().
//
// The function takes the following parameters:
//
//   - sps: pointer to the sequence parameter set for the stream.
//
// The function returns the following values:
//
//   - utf8 (optional): level as a const string, or NULL if there is an error.
func CodecUtilsH264GetLevel(sps []byte) string {
	var _arg1 *C.guint8 // out
	var _arg2 C.guint
	var _cret *C.gchar // in

	_arg2 = (C.guint)(len(sps))
	if len(sps) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&sps[0]))
	}

	_cret = C.gst_codec_utils_h264_get_level(_arg1, _arg2)
	runtime.KeepAlive(sps)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// CodecUtilsH264GetLevelIdc: transform a level string from the caps into the
// level_idc.
//
// The function takes the following parameters:
//
//   - level string from caps.
//
// The function returns the following values:
//
//   - guint8: level_idc or 0 if the level is unknown.
func CodecUtilsH264GetLevelIdc(level string) byte {
	var _arg1 *C.gchar // out
	var _cret C.guint8 // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(level)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_codec_utils_h264_get_level_idc(_arg1)
	runtime.KeepAlive(level)

	var _guint8 byte // out

	_guint8 = byte(_cret)

	return _guint8
}

// CodecUtilsH264GetProfile converts the profile indication (profile_idc) in
// the stream's sequence parameter set into a string. The SPS is expected to
// have the following format, as defined in the H.264 specification. The SPS is
// viewed as a bitstream here, with bit 0 being the most significant bit of the
// first byte.
//
// * Bit 0:7 - Profile indication * Bit 8 - constraint_set0_flag * Bit
// 9 - constraint_set1_flag * Bit 10 - constraint_set2_flag * Bit 11 -
// constraint_set3_flag * Bit 12 - constraint_set3_flag * Bit 13:15 - Reserved *
// Bit 16:24 - Level indication.
//
// The function takes the following parameters:
//
//   - sps: pointer to the sequence parameter set for the stream.
//
// The function returns the following values:
//
//   - utf8 (optional): profile as a const string, or NULL if there is an error.
func CodecUtilsH264GetProfile(sps []byte) string {
	var _arg1 *C.guint8 // out
	var _arg2 C.guint
	var _cret *C.gchar // in

	_arg2 = (C.guint)(len(sps))
	if len(sps) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&sps[0]))
	}

	_cret = C.gst_codec_utils_h264_get_profile(_arg1, _arg2)
	runtime.KeepAlive(sps)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// CodecUtilsH264GetProfileFlagsLevel parses profile, flags, and level from a
// H264 AVCC extradata/sequence_header. These are most commonly retrieved from a
// video/x-h264 caps with a codec_data buffer.
//
// The format of H264 AVCC extradata/sequence_header is documented in the ITU-T
// H.264 specification section 7.3.2.1.1 as well as in ISO/IEC 14496-15 section
// 5.3.3.1.2.
//
// The function takes the following parameters:
//
//   - codecData: h264 AVCC extradata.
//
// The function returns the following values:
//
//   - profile (optional): return location for h264 profile_idc or NULL.
//   - flags (optional): return location for h264 constraint set flags or NULL.
//   - level (optional): return location h264 level_idc or NULL.
//   - ok: TRUE on success, FALSE on failure.
func CodecUtilsH264GetProfileFlagsLevel(codecData []byte) (profile, flags, level byte, ok bool) {
	var _arg1 *C.guint8 // out
	var _arg2 C.guint
	var _arg3 C.guint8   // in
	var _arg4 C.guint8   // in
	var _arg5 C.guint8   // in
	var _cret C.gboolean // in

	_arg2 = (C.guint)(len(codecData))
	if len(codecData) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&codecData[0]))
	}

	_cret = C.gst_codec_utils_h264_get_profile_flags_level(_arg1, _arg2, &_arg3, &_arg4, &_arg5)
	runtime.KeepAlive(codecData)

	var _profile byte // out
	var _flags byte   // out
	var _level byte   // out
	var _ok bool      // out

	_profile = byte(_arg3)
	_flags = byte(_arg4)
	_level = byte(_arg5)
	if _cret != 0 {
		_ok = true
	}

	return _profile, _flags, _level, _ok
}

// CodecUtilsH265CapsSetLevelTierAndProfile sets the level, tier and
// profile in caps if it can be determined from profile_tier_level.
// See gst_codec_utils_h265_get_level(), gst_codec_utils_h265_get_tier() and
// gst_codec_utils_h265_get_profile() for more details on the parameters.
//
// The function takes the following parameters:
//
//   - caps to which the level, tier and profile are to be added.
//   - profileTierLevel: pointer to the profile_tier_level struct.
//
// The function returns the following values:
//
//   - ok: TRUE if the level, tier, profile could be set, FALSE otherwise.
func CodecUtilsH265CapsSetLevelTierAndProfile(caps *gst.Caps, profileTierLevel []byte) bool {
	var _arg1 *C.GstCaps // out
	var _arg2 *C.guint8  // out
	var _arg3 C.guint
	var _cret C.gboolean // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg3 = (C.guint)(len(profileTierLevel))
	if len(profileTierLevel) > 0 {
		_arg2 = (*C.guint8)(unsafe.Pointer(&profileTierLevel[0]))
	}

	_cret = C.gst_codec_utils_h265_caps_set_level_tier_and_profile(_arg1, _arg2, _arg3)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(profileTierLevel)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CodecUtilsH265GetLevel converts the level indication (general_level_idc)
// in the stream's profile_tier_level structure into a string.
// The profiel_tier_level is expected to have the same format as for
// gst_codec_utils_h264_get_profile().
//
// The function takes the following parameters:
//
//   - profileTierLevel: pointer to the profile_tier_level for the stream.
//
// The function returns the following values:
//
//   - utf8 (optional): level as a const string, or NULL if there is an error.
func CodecUtilsH265GetLevel(profileTierLevel []byte) string {
	var _arg1 *C.guint8 // out
	var _arg2 C.guint
	var _cret *C.gchar // in

	_arg2 = (C.guint)(len(profileTierLevel))
	if len(profileTierLevel) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&profileTierLevel[0]))
	}

	_cret = C.gst_codec_utils_h265_get_level(_arg1, _arg2)
	runtime.KeepAlive(profileTierLevel)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// CodecUtilsH265GetLevelIdc: transform a level string from the caps into the
// level_idc.
//
// The function takes the following parameters:
//
//   - level string from caps.
//
// The function returns the following values:
//
//   - guint8: level_idc or 0 if the level is unknown.
func CodecUtilsH265GetLevelIdc(level string) byte {
	var _arg1 *C.gchar // out
	var _cret C.guint8 // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(level)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_codec_utils_h265_get_level_idc(_arg1)
	runtime.KeepAlive(level)

	var _guint8 byte // out

	_guint8 = byte(_cret)

	return _guint8
}

// CodecUtilsH265GetProfile converts the profile indication
// (general_profile_idc) in the stream's profile_level_tier structure into a
// string. The profile_tier_level is expected to have the following format,
// as defined in the H.265 specification. The profile_tier_level is viewed as a
// bitstream here, with bit 0 being the most significant bit of the first byte.
//
// * Bit 0:1 - general_profile_space * Bit 2 - general_tier_flag * Bit 3:7 -
// general_profile_idc * Bit 8:39 - gernal_profile_compatibility_flags * Bit 40
// - general_progressive_source_flag * Bit 41 - general_interlaced_source_flag
// * Bit 42 - general_non_packed_constraint_flag * Bit 43 -
// general_frame_only_constraint_flag * Bit 44:87 - See below * Bit 88:95 -
// general_level_idc.
//
// The function takes the following parameters:
//
//   - profileTierLevel: pointer to the profile_tier_level structure for the
//     stream.
//
// The function returns the following values:
//
//   - utf8 (optional): profile as a const string, or NULL if there is an error.
func CodecUtilsH265GetProfile(profileTierLevel []byte) string {
	var _arg1 *C.guint8 // out
	var _arg2 C.guint
	var _cret *C.gchar // in

	_arg2 = (C.guint)(len(profileTierLevel))
	if len(profileTierLevel) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&profileTierLevel[0]))
	}

	_cret = C.gst_codec_utils_h265_get_profile(_arg1, _arg2)
	runtime.KeepAlive(profileTierLevel)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// CodecUtilsH265GetTier converts the tier indication (general_tier_flag)
// in the stream's profile_tier_level structure into a string.
// The profile_tier_level is expected to have the same format as for
// gst_codec_utils_h264_get_profile().
//
// The function takes the following parameters:
//
//   - profileTierLevel: pointer to the profile_tier_level for the stream.
//
// The function returns the following values:
//
//   - utf8 (optional): tier as a const string, or NULL if there is an error.
func CodecUtilsH265GetTier(profileTierLevel []byte) string {
	var _arg1 *C.guint8 // out
	var _arg2 C.guint
	var _cret *C.gchar // in

	_arg2 = (C.guint)(len(profileTierLevel))
	if len(profileTierLevel) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&profileTierLevel[0]))
	}

	_cret = C.gst_codec_utils_h265_get_tier(_arg1, _arg2)
	runtime.KeepAlive(profileTierLevel)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// CodecUtilsMpeg4VideoCapsSetLevelAndProfile sets the
// level and profile in caps if it can be determined from
// vis_obj_seq. See gst_codec_utils_mpeg4video_get_level() and
// gst_codec_utils_mpeg4video_get_profile() for more details on the parameters.
//
// The function takes the following parameters:
//
//   - caps to which the level and profile are to be added.
//   - visObjSeq: pointer to the visual object sequence for the stream.
//
// The function returns the following values:
//
//   - ok: TRUE if the level and profile could be set, FALSE otherwise.
func CodecUtilsMpeg4VideoCapsSetLevelAndProfile(caps *gst.Caps, visObjSeq []byte) bool {
	var _arg1 *C.GstCaps // out
	var _arg2 *C.guint8  // out
	var _arg3 C.guint
	var _cret C.gboolean // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))
	_arg3 = (C.guint)(len(visObjSeq))
	if len(visObjSeq) > 0 {
		_arg2 = (*C.guint8)(unsafe.Pointer(&visObjSeq[0]))
	}

	_cret = C.gst_codec_utils_mpeg4video_caps_set_level_and_profile(_arg1, _arg2, _arg3)
	runtime.KeepAlive(caps)
	runtime.KeepAlive(visObjSeq)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CodecUtilsMpeg4VideoGetLevel converts the level indication in the stream's
// visual object sequence into a string. vis_obj_seq is expected to be the
// data following the visual object sequence start code. Only the first byte
// (profile_and_level_indication) is used.
//
// The function takes the following parameters:
//
//   - visObjSeq: pointer to the visual object sequence for the stream.
//
// The function returns the following values:
//
//   - utf8 (optional): level as a const string, or NULL if there is an error.
func CodecUtilsMpeg4VideoGetLevel(visObjSeq []byte) string {
	var _arg1 *C.guint8 // out
	var _arg2 C.guint
	var _cret *C.gchar // in

	_arg2 = (C.guint)(len(visObjSeq))
	if len(visObjSeq) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&visObjSeq[0]))
	}

	_cret = C.gst_codec_utils_mpeg4video_get_level(_arg1, _arg2)
	runtime.KeepAlive(visObjSeq)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// CodecUtilsMpeg4VideoGetProfile converts the profile indication in the
// stream's visual object sequence into a string. vis_obj_seq is expected to be
// the data following the visual object sequence start code. Only the first byte
// (profile_and_level_indication) is used.
//
// The function takes the following parameters:
//
//   - visObjSeq: pointer to the visual object sequence for the stream.
//
// The function returns the following values:
//
//   - utf8 (optional): profile as a const string, or NULL if there is an error.
func CodecUtilsMpeg4VideoGetProfile(visObjSeq []byte) string {
	var _arg1 *C.guint8 // out
	var _arg2 C.guint
	var _cret *C.gchar // in

	_arg2 = (C.guint)(len(visObjSeq))
	if len(visObjSeq) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&visObjSeq[0]))
	}

	_cret = C.gst_codec_utils_mpeg4video_get_profile(_arg1, _arg2)
	runtime.KeepAlive(visObjSeq)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// CodecUtilsOpusCreateCapsFromHeader creates Opus caps from the given OpusHead
// header and comment header comments.
//
// The function takes the following parameters:
//
//   - header: opusHead header.
//   - comments (optional): comment header or NULL.
//
// The function returns the following values:
//
//   - caps (optional): Caps.
func CodecUtilsOpusCreateCapsFromHeader(header, comments *gst.Buffer) *gst.Caps {
	var _arg1 *C.GstBuffer // out
	var _arg2 *C.GstBuffer // out
	var _cret *C.GstCaps   // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(header)))
	if comments != nil {
		_arg2 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(comments)))
	}

	_cret = C.gst_codec_utils_opus_create_caps_from_header(_arg1, _arg2)
	runtime.KeepAlive(header)
	runtime.KeepAlive(comments)

	var _caps *gst.Caps // out

	if _cret != nil {
		_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_caps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _caps
}

// CodecUtilsOpusParseCaps parses Opus caps and fills the different fields with
// defaults if possible.
//
// The function takes the following parameters:
//
//   - caps to parse the data from.
//
// The function returns the following values:
//
//   - rate (optional): sample rate.
//   - channels (optional): number of channels.
//   - channelMappingFamily (optional): channel mapping family.
//   - streamCount (optional): number of independent streams.
//   - coupledCount (optional): number of stereo streams.
//   - channelMapping (optional): mapping between the streams.
//   - ok: TRUE if parsing was successful, FALSE otherwise.
func CodecUtilsOpusParseCaps(caps *gst.Caps) (rate uint32, channels, channelMappingFamily, streamCount, coupledCount byte, channelMapping [256]byte, ok bool) {
	var _arg1 *C.GstCaps    // out
	var _arg2 C.guint32     // in
	var _arg3 C.guint8      // in
	var _arg4 C.guint8      // in
	var _arg5 C.guint8      // in
	var _arg6 C.guint8      // in
	var _arg7 [256]C.guint8 // in
	var _cret C.gboolean    // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_codec_utils_opus_parse_caps(_arg1, &_arg2, &_arg3, &_arg4, &_arg5, &_arg6, &_arg7[0])
	runtime.KeepAlive(caps)

	var _rate uint32               // out
	var _channels byte             // out
	var _channelMappingFamily byte // out
	var _streamCount byte          // out
	var _coupledCount byte         // out
	var _channelMapping [256]byte  // out
	var _ok bool                   // out

	_rate = uint32(_arg2)
	_channels = byte(_arg3)
	_channelMappingFamily = byte(_arg4)
	_streamCount = byte(_arg5)
	_coupledCount = byte(_arg6)
	_channelMapping = *(*[256]byte)(unsafe.Pointer(&_arg7))
	if _cret != 0 {
		_ok = true
	}

	return _rate, _channels, _channelMappingFamily, _streamCount, _coupledCount, _channelMapping, _ok
}

// CodecUtilsOpusParseHeader parses the OpusHead header.
//
// The function takes the following parameters:
//
//   - header: opusHead Buffer.
//
// The function returns the following values:
//
//   - rate (optional): sample rate.
//   - channels (optional): number of channels.
//   - channelMappingFamily (optional): channel mapping family.
//   - streamCount (optional): number of independent streams.
//   - coupledCount (optional): number of stereo streams.
//   - channelMapping (optional): mapping between the streams.
//   - preSkip (optional): pre-skip in 48kHz samples or 0.
//   - outputGain (optional): output gain or 0.
//   - ok: TRUE if parsing was successful, FALSE otherwise.
func CodecUtilsOpusParseHeader(header *gst.Buffer) (rate uint32, channels, channelMappingFamily, streamCount, coupledCount byte, channelMapping [256]byte, preSkip uint16, outputGain int16, ok bool) {
	var _arg1 *C.GstBuffer  // out
	var _arg2 C.guint32     // in
	var _arg3 C.guint8      // in
	var _arg4 C.guint8      // in
	var _arg5 C.guint8      // in
	var _arg6 C.guint8      // in
	var _arg7 [256]C.guint8 // in
	var _arg8 C.guint16     // in
	var _arg9 C.gint16      // in
	var _cret C.gboolean    // in

	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(header)))

	_cret = C.gst_codec_utils_opus_parse_header(_arg1, &_arg2, &_arg3, &_arg4, &_arg5, &_arg6, &_arg7[0], &_arg8, &_arg9)
	runtime.KeepAlive(header)

	var _rate uint32               // out
	var _channels byte             // out
	var _channelMappingFamily byte // out
	var _streamCount byte          // out
	var _coupledCount byte         // out
	var _channelMapping [256]byte  // out
	var _preSkip uint16            // out
	var _outputGain int16          // out
	var _ok bool                   // out

	_rate = uint32(_arg2)
	_channels = byte(_arg3)
	_channelMappingFamily = byte(_arg4)
	_streamCount = byte(_arg5)
	_coupledCount = byte(_arg6)
	_channelMapping = *(*[256]byte)(unsafe.Pointer(&_arg7))
	_preSkip = uint16(_arg8)
	_outputGain = int16(_arg9)
	if _cret != 0 {
		_ok = true
	}

	return _rate, _channels, _channelMappingFamily, _streamCount, _coupledCount, _channelMapping, _preSkip, _outputGain, _ok
}

// EncodingListAllTargets: list all available EncodingTarget for the specified
// category, or all categories if categoryname is NULL.
//
// The function takes the following parameters:
//
//   - categoryname (optional): category, for ex: T_ENCODING_CATEGORY_DEVICE.
//     Can be NULL.
//
// The function returns the following values:
//
//   - list of EncodingTarget.
func EncodingListAllTargets(categoryname string) []*EncodingTarget {
	var _arg1 *C.gchar // out
	var _cret *C.GList // in

	if categoryname != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(categoryname)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gst_encoding_list_all_targets(_arg1)
	runtime.KeepAlive(categoryname)

	var _list []*EncodingTarget // out

	_list = make([]*EncodingTarget, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstEncodingTarget)(v)
		var dst *EncodingTarget // out
		dst = wrapEncodingTarget(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// EncodingListAvailableCategories lists all EncodingTarget categories present
// on disk.
//
// The function returns the following values:
//
//   - list: list of EncodingTarget categories.
func EncodingListAvailableCategories() []string {
	var _cret *C.GList // in

	_cret = C.gst_encoding_list_available_categories()

	var _list []string // out

	_list = make([]string, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.gchar)(v)
		var dst string // out
		dst = C.GoString((*C.gchar)(unsafe.Pointer(src)))
		defer C.free(unsafe.Pointer(src))
		_list = append(_list, dst)
	})

	return _list
}

// InstallPluginsAsync requests plugin installation without blocking. Once the
// plugins have been installed or installation has failed, func will be called
// with the result of the installation and your provided user_data pointer.
//
// This function requires a running GLib/Gtk main loop. If you are
// not running a GLib/Gtk main loop, make sure to regularly call
// g_main_context_iteration(NULL,FALSE).
//
// The installer strings that make up detail are typically obtained by calling
// gst_missing_plugin_message_get_installer_detail() on missing-plugin messages
// that have been caught on a pipeline's bus or created by the application via
// the provided API, such as gst_missing_element_message_new().
//
// It is possible to request the installation of multiple missing plugins in one
// go (as might be required if there is a demuxer for a certain format installed
// but no suitable video decoder and no suitable audio decoder).
//
// The function takes the following parameters:
//
//   - details: NULL-terminated array of installer string details (see below).
//   - ctx (optional) or NULL.
//   - fn: function to call when the installer program returns.
//
// The function returns the following values:
//
//   - installPluginsReturn: result code whether an external installer could be
//     started.
func InstallPluginsAsync(details []string, ctx *InstallPluginsContext, fn InstallPluginsResultFunc) InstallPluginsReturn {
	var _arg1 **C.gchar                     // out
	var _arg2 *C.GstInstallPluginsContext   // out
	var _arg3 C.GstInstallPluginsResultFunc // out
	var _arg4 C.gpointer
	var _cret C.GstInstallPluginsReturn // in

	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(details) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(details)+1)
			var zero *C.gchar
			out[len(details)] = zero
			for i := range details {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(details[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	if ctx != nil {
		_arg2 = (*C.GstInstallPluginsContext)(gextras.StructNative(unsafe.Pointer(ctx)))
	}
	_arg3 = (*[0]byte)(C._gotk4_gstpbutils1_InstallPluginsResultFunc)
	_arg4 = C.gpointer(gbox.AssignOnce(fn))

	_cret = C.gst_install_plugins_async(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(details)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(fn)

	var _installPluginsReturn InstallPluginsReturn // out

	_installPluginsReturn = InstallPluginsReturn(_cret)

	return _installPluginsReturn
}

// InstallPluginsInstallationInProgress checks whether plugin installation
// (initiated by this application only) is currently in progress.
//
// The function returns the following values:
//
//   - ok: TRUE if plugin installation is in progress, otherwise FALSE.
func InstallPluginsInstallationInProgress() bool {
	var _cret C.gboolean // in

	_cret = C.gst_install_plugins_installation_in_progress()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InstallPluginsSupported checks whether plugin installation is likely to be
// supported by the current environment. This currently only checks whether the
// helper script that is to be provided by the distribution or operating system
// vendor exists.
//
// The function returns the following values:
//
//   - ok: TRUE if plugin installation is likely to be supported.
func InstallPluginsSupported() bool {
	var _cret C.gboolean // in

	_cret = C.gst_install_plugins_supported()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InstallPluginsSync requests plugin installation and block until the plugins
// have been installed or installation has failed.
//
// This function should almost never be used, it only exists for cases
// where a non-GLib main loop is running and the user wants to run it in a
// separate thread and marshal the result back asynchronously into the main
// thread using the other non-GLib main loop. You should almost always use
// gst_install_plugins_async() instead of this function.
//
// The function takes the following parameters:
//
//   - details: NULL-terminated array of installer string details.
//   - ctx (optional) or NULL.
//
// The function returns the following values:
//
//   - installPluginsReturn: result of the installation.
func InstallPluginsSync(details []string, ctx *InstallPluginsContext) InstallPluginsReturn {
	var _arg1 **C.gchar                   // out
	var _arg2 *C.GstInstallPluginsContext // out
	var _cret C.GstInstallPluginsReturn   // in

	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(details) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(details)+1)
			var zero *C.gchar
			out[len(details)] = zero
			for i := range details {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(details[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	if ctx != nil {
		_arg2 = (*C.GstInstallPluginsContext)(gextras.StructNative(unsafe.Pointer(ctx)))
	}

	_cret = C.gst_install_plugins_sync(_arg1, _arg2)
	runtime.KeepAlive(details)
	runtime.KeepAlive(ctx)

	var _installPluginsReturn InstallPluginsReturn // out

	_installPluginsReturn = InstallPluginsReturn(_cret)

	return _installPluginsReturn
}

// IsMissingPluginMessage checks whether msg is a missing plugins message.
//
// The function takes the following parameters:
//
//   - msg: Message.
//
// The function returns the following values:
//
//   - ok: TRUE if msg is a missing-plugins message, otherwise FALSE.
func IsMissingPluginMessage(msg *gst.Message) bool {
	var _arg1 *C.GstMessage // out
	var _cret C.gboolean    // in

	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(msg)))

	_cret = C.gst_is_missing_plugin_message(_arg1)
	runtime.KeepAlive(msg)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NewMissingDecoderInstallerDetail returns an opaque string containing all
// the details about the missing element to be passed to an external installer
// called via gst_install_plugins_async() or gst_install_plugins_sync().
//
// This function is mainly for applications that call external plugin
// installation mechanisms using one of the two above-mentioned functions in the
// case where the application knows exactly what kind of plugin it is missing.
//
// The function takes the following parameters:
//
//   - decodeCaps: (fixed) caps for which a decoder element is needed.
//
// The function returns the following values:
//
//   - utf8: newly-allocated detail string. Free string with g_free() when not
//     needed any longer.
func NewMissingDecoderInstallerDetail(decodeCaps *gst.Caps) string {
	var _arg1 *C.GstCaps // out
	var _cret *C.gchar   // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(decodeCaps)))

	_cret = C.gst_missing_decoder_installer_detail_new(_arg1)
	runtime.KeepAlive(decodeCaps)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// NewMissingDecoderMessage creates a missing-plugin message for element to
// notify the application that a decoder element for a particular set of (fixed)
// caps is missing. This function is mainly for use in plugins.
//
// The function takes the following parameters:
//
//   - element posting the message.
//   - decodeCaps: (fixed) caps for which a decoder element is needed.
//
// The function returns the following values:
//
//   - message: new Message.
func NewMissingDecoderMessage(element gst.Elementer, decodeCaps *gst.Caps) *gst.Message {
	var _arg1 *C.GstElement // out
	var _arg2 *C.GstCaps    // out
	var _cret *C.GstMessage // in

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(element).Native()))
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(decodeCaps)))

	_cret = C.gst_missing_decoder_message_new(_arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(decodeCaps)

	var _message *gst.Message // out

	_message = (*gst.Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _message
}

// NewMissingElementInstallerDetail returns an opaque string containing all
// the details about the missing element to be passed to an external installer
// called via gst_install_plugins_async() or gst_install_plugins_sync().
//
// This function is mainly for applications that call external plugin
// installation mechanisms using one of the two above-mentioned functions in the
// case where the application knows exactly what kind of plugin it is missing.
//
// The function takes the following parameters:
//
//   - factoryName: name of the missing element (element factory), e.g.
//     "videoscale" or "cdparanoiasrc".
//
// The function returns the following values:
//
//   - utf8: newly-allocated detail string. Free string with g_free() when not
//     needed any longer.
func NewMissingElementInstallerDetail(factoryName string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(factoryName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_missing_element_installer_detail_new(_arg1)
	runtime.KeepAlive(factoryName)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// NewMissingElementMessage creates a missing-plugin message for element to
// notify the application that a certain required element is missing. This
// function is mainly for use in plugins.
//
// The function takes the following parameters:
//
//   - element posting the message.
//   - factoryName: name of the missing element (element factory), e.g.
//     "videoscale" or "cdparanoiasrc".
//
// The function returns the following values:
//
//   - message: new Message.
func NewMissingElementMessage(element gst.Elementer, factoryName string) *gst.Message {
	var _arg1 *C.GstElement // out
	var _arg2 *C.gchar      // out
	var _cret *C.GstMessage // in

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(element).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(factoryName)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_missing_element_message_new(_arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(factoryName)

	var _message *gst.Message // out

	_message = (*gst.Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _message
}

// NewMissingEncoderInstallerDetail returns an opaque string containing all
// the details about the missing element to be passed to an external installer
// called via gst_install_plugins_async() or gst_install_plugins_sync().
//
// This function is mainly for applications that call external plugin
// installation mechanisms using one of the two above-mentioned functions in the
// case where the application knows exactly what kind of plugin it is missing.
//
// The function takes the following parameters:
//
//   - encodeCaps: (fixed) caps for which an encoder element is needed.
//
// The function returns the following values:
//
//   - utf8: newly-allocated detail string. Free string with g_free() when not
//     needed any longer.
func NewMissingEncoderInstallerDetail(encodeCaps *gst.Caps) string {
	var _arg1 *C.GstCaps // out
	var _cret *C.gchar   // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(encodeCaps)))

	_cret = C.gst_missing_encoder_installer_detail_new(_arg1)
	runtime.KeepAlive(encodeCaps)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// NewMissingEncoderMessage creates a missing-plugin message for element to
// notify the application that an encoder element for a particular set of
// (fixed) caps is missing. This function is mainly for use in plugins.
//
// The function takes the following parameters:
//
//   - element posting the message.
//   - encodeCaps: (fixed) caps for which an encoder element is needed.
//
// The function returns the following values:
//
//   - message: new Message.
func NewMissingEncoderMessage(element gst.Elementer, encodeCaps *gst.Caps) *gst.Message {
	var _arg1 *C.GstElement // out
	var _arg2 *C.GstCaps    // out
	var _cret *C.GstMessage // in

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(element).Native()))
	_arg2 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(encodeCaps)))

	_cret = C.gst_missing_encoder_message_new(_arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(encodeCaps)

	var _message *gst.Message // out

	_message = (*gst.Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _message
}

// MissingPluginMessageGetDescription returns a localised string describing the
// missing feature, for use in error dialogs and the like. Should never return
// NULL unless msg is not a valid missing-plugin message.
//
// This function is mainly for applications that need a human-readable string
// describing a missing plugin, given a previously collected missing-plugin
// message.
//
// The function takes the following parameters:
//
//   - msg: missing-plugin Message of type T_MESSAGE_ELEMENT.
//
// The function returns the following values:
//
//   - utf8: newly-allocated description string. Free string with g_free() when
//     not needed any longer.
func MissingPluginMessageGetDescription(msg *gst.Message) string {
	var _arg1 *C.GstMessage // out
	var _cret *C.gchar      // in

	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(msg)))

	_cret = C.gst_missing_plugin_message_get_description(_arg1)
	runtime.KeepAlive(msg)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// MissingPluginMessageGetInstallerDetail returns an opaque string
// containing all the details about the missing element to be passed
// to an external installer called via gst_install_plugins_async() or
// gst_install_plugins_sync().
//
// This function is mainly for applications that call external plugin
// installation mechanisms using one of the two above-mentioned functions.
//
// The function takes the following parameters:
//
//   - msg: missing-plugin Message of type T_MESSAGE_ELEMENT.
//
// The function returns the following values:
//
//   - utf8 (optional): newly-allocated detail string, or NULL on error.
//     Free string with g_free() when not needed any longer.
func MissingPluginMessageGetInstallerDetail(msg *gst.Message) string {
	var _arg1 *C.GstMessage // out
	var _cret *C.gchar      // in

	_arg1 = (*C.GstMessage)(gextras.StructNative(unsafe.Pointer(msg)))

	_cret = C.gst_missing_plugin_message_get_installer_detail(_arg1)
	runtime.KeepAlive(msg)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// NewMissingURISinkInstallerDetail returns an opaque string containing all
// the details about the missing element to be passed to an external installer
// called via gst_install_plugins_async() or gst_install_plugins_sync().
//
// This function is mainly for applications that call external plugin
// installation mechanisms using one of the two above-mentioned functions in the
// case where the application knows exactly what kind of plugin it is missing.
//
// The function takes the following parameters:
//
//   - protocol: URI protocol the missing source needs to implement, e.g.
//     "http" or "mms".
//
// The function returns the following values:
//
//   - utf8: newly-allocated detail string. Free string with g_free() when not
//     needed any longer.
func NewMissingURISinkInstallerDetail(protocol string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_missing_uri_sink_installer_detail_new(_arg1)
	runtime.KeepAlive(protocol)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// NewMissingURISinkMessage creates a missing-plugin message for element to
// notify the application that a sink element for a particular URI protocol is
// missing. This function is mainly for use in plugins.
//
// The function takes the following parameters:
//
//   - element posting the message.
//   - protocol: URI protocol the missing sink needs to implement, e.g. "http"
//     or "smb".
//
// The function returns the following values:
//
//   - message: new Message.
func NewMissingURISinkMessage(element gst.Elementer, protocol string) *gst.Message {
	var _arg1 *C.GstElement // out
	var _arg2 *C.gchar      // out
	var _cret *C.GstMessage // in

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(element).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_missing_uri_sink_message_new(_arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(protocol)

	var _message *gst.Message // out

	_message = (*gst.Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _message
}

// NewMissingURISourceInstallerDetail returns an opaque string containing all
// the details about the missing element to be passed to an external installer
// called via gst_install_plugins_async() or gst_install_plugins_sync().
//
// This function is mainly for applications that call external plugin
// installation mechanisms using one of the two above-mentioned functions in the
// case where the application knows exactly what kind of plugin it is missing.
//
// The function takes the following parameters:
//
//   - protocol: URI protocol the missing source needs to implement, e.g.
//     "http" or "mms".
//
// The function returns the following values:
//
//   - utf8: newly-allocated detail string. Free string with g_free() when not
//     needed any longer.
func NewMissingURISourceInstallerDetail(protocol string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_missing_uri_source_installer_detail_new(_arg1)
	runtime.KeepAlive(protocol)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// NewMissingURISourceMessage creates a missing-plugin message for element to
// notify the application that a source element for a particular URI protocol is
// missing. This function is mainly for use in plugins.
//
// The function takes the following parameters:
//
//   - element posting the message.
//   - protocol: URI protocol the missing source needs to implement, e.g.
//     "http" or "mms".
//
// The function returns the following values:
//
//   - message: new Message.
func NewMissingURISourceMessage(element gst.Elementer, protocol string) *gst.Message {
	var _arg1 *C.GstElement // out
	var _arg2 *C.gchar      // out
	var _cret *C.GstMessage // in

	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(element).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gst_missing_uri_source_message_new(_arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(protocol)

	var _message *gst.Message // out

	_message = (*gst.Message)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_message)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _message
}

// PbUtilsAddCodecDescriptionToTagList adds a codec tag describing the format
// specified by caps to taglist.
//
// The function takes the following parameters:
//
//   - taglist: TagList.
//   - codecTag (optional): GStreamer codec tag such as T_TAG_AUDIO_CODEC,
//     T_TAG_VIDEO_CODEC or T_TAG_CODEC. If none is specified, the function will
//     attempt to detect the appropriate category.
//   - caps: (fixed) Caps for which a codec tag should be added.
//
// The function returns the following values:
//
//   - ok: TRUE if a codec tag was added, FALSE otherwise.
func PbUtilsAddCodecDescriptionToTagList(taglist *gst.TagList, codecTag string, caps *gst.Caps) bool {
	var _arg1 *C.GstTagList // out
	var _arg2 *C.gchar      // out
	var _arg3 *C.GstCaps    // out
	var _cret C.gboolean    // in

	_arg1 = (*C.GstTagList)(gextras.StructNative(unsafe.Pointer(taglist)))
	if codecTag != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(codecTag)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_pb_utils_add_codec_description_to_tag_list(_arg1, _arg2, _arg3)
	runtime.KeepAlive(taglist)
	runtime.KeepAlive(codecTag)
	runtime.KeepAlive(caps)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PbUtilsGetCapsDescriptionFlags returns flags that describe the format of the
// caps if known. No flags are set for unknown caps.
//
// The function takes the following parameters:
//
//   - caps: (fixed) Caps for which flags are requested.
//
// The function returns the following values:
//
//   - pbUtilsCapsDescriptionFlags that describe caps, or no flags if the caps
//     are unknown.
func PbUtilsGetCapsDescriptionFlags(caps *gst.Caps) PbUtilsCapsDescriptionFlags {
	var _arg1 *C.GstCaps                       // out
	var _cret C.GstPbUtilsCapsDescriptionFlags // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_pb_utils_get_caps_description_flags(_arg1)
	runtime.KeepAlive(caps)

	var _pbUtilsCapsDescriptionFlags PbUtilsCapsDescriptionFlags // out

	_pbUtilsCapsDescriptionFlags = PbUtilsCapsDescriptionFlags(_cret)

	return _pbUtilsCapsDescriptionFlags
}

// PbUtilsGetCodecDescription returns a localised (as far as this is possible)
// string describing the media format specified in caps, for use in error
// dialogs or other messages to be seen by the user. Should never return NULL
// unless caps is invalid.
//
// Also see the convenience function
// gst_pb_utils_add_codec_description_to_tag_list().
//
// The function takes the following parameters:
//
//   - caps: (fixed) Caps for which an format description is needed.
//
// The function returns the following values:
//
//   - utf8 (optional): newly-allocated description string, or NULL on error.
//     Free string with g_free() when not needed any longer.
func PbUtilsGetCodecDescription(caps *gst.Caps) string {
	var _arg1 *C.GstCaps // out
	var _cret *C.gchar   // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_pb_utils_get_codec_description(_arg1)
	runtime.KeepAlive(caps)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// PbUtilsGetDecoderDescription returns a localised string describing an decoder
// for the format specified in caps, for use in error dialogs or other messages
// to be seen by the user.
//
// This function is mainly for internal use, applications would typically
// use gst_missing_plugin_message_get_description() to get a description of a
// missing feature from a missing-plugin message.
//
// The function takes the following parameters:
//
//   - caps: (fixed) Caps for which an decoder description is needed.
//
// The function returns the following values:
//
//   - utf8: newly-allocated description string. Free string with g_free() when
//     not needed any longer.
func PbUtilsGetDecoderDescription(caps *gst.Caps) string {
	var _arg1 *C.GstCaps // out
	var _cret *C.gchar   // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_pb_utils_get_decoder_description(_arg1)
	runtime.KeepAlive(caps)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// PbUtilsGetElementDescription returns a localised string describing the given
// element, for use in error dialogs or other messages to be seen by the user.
//
// This function is mainly for internal use, applications would typically
// use gst_missing_plugin_message_get_description() to get a description of a
// missing feature from a missing-plugin message.
//
// The function takes the following parameters:
//
//   - factoryName: name of the element, e.g. "giosrc".
//
// The function returns the following values:
//
//   - utf8: newly-allocated description string. Free string with g_free() when
//     not needed any longer.
func PbUtilsGetElementDescription(factoryName string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(factoryName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_pb_utils_get_element_description(_arg1)
	runtime.KeepAlive(factoryName)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// PbUtilsGetEncoderDescription returns a localised string describing an encoder
// for the format specified in caps, for use in error dialogs or other messages
// to be seen by the user.
//
// This function is mainly for internal use, applications would typically
// use gst_missing_plugin_message_get_description() to get a description of a
// missing feature from a missing-plugin message.
//
// The function takes the following parameters:
//
//   - caps: (fixed) Caps for which an encoder description is needed.
//
// The function returns the following values:
//
//   - utf8: newly-allocated description string. Free string with g_free() when
//     not needed any longer.
func PbUtilsGetEncoderDescription(caps *gst.Caps) string {
	var _arg1 *C.GstCaps // out
	var _cret *C.gchar   // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_pb_utils_get_encoder_description(_arg1)
	runtime.KeepAlive(caps)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// PbUtilsGetFileExtensionFromCaps returns a possible file extension for the
// given caps, if known.
//
// The function takes the following parameters:
//
//   - caps: (fixed) Caps for which a file extension is needed.
//
// The function returns the following values:
//
//   - utf8 (optional): newly-allocated file extension string, or NULL on error.
//     Free string with g_free() when not needed any longer.
func PbUtilsGetFileExtensionFromCaps(caps *gst.Caps) string {
	var _arg1 *C.GstCaps // out
	var _cret *C.gchar   // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(caps)))

	_cret = C.gst_pb_utils_get_file_extension_from_caps(_arg1)
	runtime.KeepAlive(caps)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// PbUtilsGetSinkDescription returns a localised string describing a sink
// element handling the protocol specified in protocol, for use in error dialogs
// or other messages to be seen by the user.
//
// This function is mainly for internal use, applications would typically
// use gst_missing_plugin_message_get_description() to get a description of a
// missing feature from a missing-plugin message.
//
// The function takes the following parameters:
//
//   - protocol the sink element needs to handle, e.g. "http".
//
// The function returns the following values:
//
//   - utf8: newly-allocated description string. Free string with g_free() when
//     not needed any longer.
func PbUtilsGetSinkDescription(protocol string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_pb_utils_get_sink_description(_arg1)
	runtime.KeepAlive(protocol)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// PbUtilsGetSourceDescription returns a localised string describing a source
// element handling the protocol specified in protocol, for use in error dialogs
// or other messages to be seen by the user.
//
// This function is mainly for internal use, applications would typically
// use gst_missing_plugin_message_get_description() to get a description of a
// missing feature from a missing-plugin message.
//
// The function takes the following parameters:
//
//   - protocol the source element needs to handle, e.g. "http".
//
// The function returns the following values:
//
//   - utf8: newly-allocated description string. Free string with g_free() when
//     not needed any longer.
func PbUtilsGetSourceDescription(protocol string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_pb_utils_get_source_description(_arg1)
	runtime.KeepAlive(protocol)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// PbUtilsInit initialises the base utils support library. This function is not
// thread-safe. Applications should call it after calling gst_init(), plugins
// should call it from their plugin_init function.
//
// This function may be called multiple times. It will do nothing if the library
// has already been initialised.
func PbUtilsInit() {
	C.gst_pb_utils_init()
}

// PluginsBaseVersion gets the version number of the GStreamer Plugins Base
// libraries.
//
// The function returns the following values:
//
//   - major: pointer to a guint to store the major version number, or NULL.
//   - minor: pointer to a guint to store the minor version number, or NULL.
//   - micro: pointer to a guint to store the micro version number, or NULL.
//   - nano: pointer to a guint to store the nano version number, or NULL.
func PluginsBaseVersion() (major, minor, micro, nano uint) {
	var _arg1 C.guint // in
	var _arg2 C.guint // in
	var _arg3 C.guint // in
	var _arg4 C.guint // in

	C.gst_plugins_base_version(&_arg1, &_arg2, &_arg3, &_arg4)

	var _major uint // out
	var _minor uint // out
	var _micro uint // out
	var _nano uint  // out

	_major = uint(_arg1)
	_minor = uint(_arg2)
	_micro = uint(_arg3)
	_nano = uint(_arg4)

	return _major, _minor, _micro, _nano
}

// PluginsBaseVersionString: this function returns a string that is useful for
// describing this version of GStreamer's gst-plugins-base libraries to the
// outside world: user agent strings, logging, about dialogs ...
//
// The function returns the following values:
//
//   - utf8: newly allocated string describing this version of gst-plugins-base.
func PluginsBaseVersionString() string {
	var _cret *C.gchar // in

	_cret = C.gst_plugins_base_version_string()

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// AudioVisualizerOverrides contains methods that are overridable.
type AudioVisualizerOverrides struct {
	DecideAllocation func(query *gst.Query) bool
	// The function takes the following parameters:
	//
	//   - audio
	//   - video
	Render func(audio *gst.Buffer, video *gstvideo.VideoFrame) bool
	Setup  func() bool
}

func defaultAudioVisualizerOverrides(v *AudioVisualizer) AudioVisualizerOverrides {
	return AudioVisualizerOverrides{
		DecideAllocation: v.decideAllocation,
		Render:           v.render,
		Setup:            v.setup,
	}
}

// AudioVisualizer baseclass for scopes (visualizers). It takes care of
// re-fitting the audio-rate to video-rate and handles renegotiation (downstream
// video size changes).
//
// It also provides several background shading effects. These effects are
// applied to a previous picture before the render() implementation can draw a
// new frame.
type AudioVisualizer struct {
	_ [0]func() // equal guard
	gst.Element
}

var (
	_ gst.Elementer = (*AudioVisualizer)(nil)
)

// AudioVisualizerer describes types inherited from class AudioVisualizer.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type AudioVisualizerer interface {
	coreglib.Objector
	baseAudioVisualizer() *AudioVisualizer
}

var _ AudioVisualizerer = (*AudioVisualizer)(nil)

func init() {
	coreglib.RegisterClassInfo[*AudioVisualizer, *AudioVisualizerClass, AudioVisualizerOverrides](
		GTypeAudioVisualizer,
		initAudioVisualizerClass,
		wrapAudioVisualizer,
		defaultAudioVisualizerOverrides,
	)
}

func initAudioVisualizerClass(gclass unsafe.Pointer, overrides AudioVisualizerOverrides, classInitFunc func(*AudioVisualizerClass)) {
	pclass := (*C.GstAudioVisualizerClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAudioVisualizer))))

	if overrides.DecideAllocation != nil {
		pclass.decide_allocation = (*[0]byte)(C._gotk4_gstpbutils1_AudioVisualizerClass_decide_allocation)
	}

	if overrides.Render != nil {
		pclass.render = (*[0]byte)(C._gotk4_gstpbutils1_AudioVisualizerClass_render)
	}

	if overrides.Setup != nil {
		pclass.setup = (*[0]byte)(C._gotk4_gstpbutils1_AudioVisualizerClass_setup)
	}

	if classInitFunc != nil {
		class := (*AudioVisualizerClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAudioVisualizer(obj *coreglib.Object) *AudioVisualizer {
	return &AudioVisualizer{
		Element: gst.Element{
			GstObject: gst.GstObject{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalAudioVisualizer(p uintptr) (interface{}, error) {
	return wrapAudioVisualizer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *AudioVisualizer) baseAudioVisualizer() *AudioVisualizer {
	return v
}

// BaseAudioVisualizer returns the underlying base object.
func BaseAudioVisualizer(obj AudioVisualizerer) *AudioVisualizer {
	return obj.baseAudioVisualizer()
}

func (scope *AudioVisualizer) decideAllocation(query *gst.Query) bool {
	gclass := (*C.GstAudioVisualizerClass)(coreglib.PeekParentClass(scope))
	fnarg := gclass.decide_allocation

	var _arg0 *C.GstAudioVisualizer // out
	var _arg1 *C.GstQuery           // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioVisualizer)(unsafe.Pointer(coreglib.BaseObject(scope).Native()))
	_arg1 = (*C.GstQuery)(gextras.StructNative(unsafe.Pointer(query)))

	_cret = C._gotk4_gstpbutils1_AudioVisualizer_virtual_decide_allocation(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(scope)
	runtime.KeepAlive(query)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - audio
//   - video
func (scope *AudioVisualizer) render(audio *gst.Buffer, video *gstvideo.VideoFrame) bool {
	gclass := (*C.GstAudioVisualizerClass)(coreglib.PeekParentClass(scope))
	fnarg := gclass.render

	var _arg0 *C.GstAudioVisualizer // out
	var _arg1 *C.GstBuffer          // out
	var _arg2 *C.GstVideoFrame      // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioVisualizer)(unsafe.Pointer(coreglib.BaseObject(scope).Native()))
	_arg1 = (*C.GstBuffer)(gextras.StructNative(unsafe.Pointer(audio)))
	_arg2 = (*C.GstVideoFrame)(gextras.StructNative(unsafe.Pointer(video)))

	_cret = C._gotk4_gstpbutils1_AudioVisualizer_virtual_render(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(scope)
	runtime.KeepAlive(audio)
	runtime.KeepAlive(video)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (scope *AudioVisualizer) setup() bool {
	gclass := (*C.GstAudioVisualizerClass)(coreglib.PeekParentClass(scope))
	fnarg := gclass.setup

	var _arg0 *C.GstAudioVisualizer // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstAudioVisualizer)(unsafe.Pointer(coreglib.BaseObject(scope).Native()))

	_cret = C._gotk4_gstpbutils1_AudioVisualizer_virtual_setup(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(scope)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DiscovererOverrides contains methods that are overridable.
type DiscovererOverrides struct {
	// The function takes the following parameters:
	//
	//   - info
	//   - err
	Discovered func(info *DiscovererInfo, err error)
	Finished   func()
	// LoadSerializeInfo loads the serialized info from the given uri.
	//
	// The function takes the following parameters:
	//
	//   - uri to load the info from.
	//
	// The function returns the following values:
	//
	//   - discovererInfo or NULL if it could not be loaded.
	LoadSerializeInfo func(uri string) *DiscovererInfo
	SourceSetup       func(source gst.Elementer)
	Starting          func()
}

func defaultDiscovererOverrides(v *Discoverer) DiscovererOverrides {
	return DiscovererOverrides{
		Discovered:        v.discovered,
		Finished:          v.finished,
		LoadSerializeInfo: v.loadSerializeInfo,
		SourceSetup:       v.sourceSetup,
		Starting:          v.starting,
	}
}

// Discoverer is a utility object which allows to get as much information as
// possible from one or many URIs.
//
// It provides two APIs, allowing usage in blocking or non-blocking mode.
//
// The blocking mode just requires calling gst_discoverer_discover_uri() with
// the URI one wishes to discover.
//
// The non-blocking mode requires a running Loop iterating a Context,
// where one connects to the various signals, appends the URIs to be processed
// (through gst_discoverer_discover_uri_async()) and then asks for the
// discovery to begin (through gst_discoverer_start()). By default this will
// use the GLib default main context unless you have set a custom context using
// g_main_context_push_thread_default().
//
// All the information is returned in a DiscovererInfo structure.
type Discoverer struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Discoverer)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Discoverer, *DiscovererClass, DiscovererOverrides](
		GTypeDiscoverer,
		initDiscovererClass,
		wrapDiscoverer,
		defaultDiscovererOverrides,
	)
}

func initDiscovererClass(gclass unsafe.Pointer, overrides DiscovererOverrides, classInitFunc func(*DiscovererClass)) {
	pclass := (*C.GstDiscovererClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeDiscoverer))))

	if overrides.Discovered != nil {
		pclass.discovered = (*[0]byte)(C._gotk4_gstpbutils1_DiscovererClass_discovered)
	}

	if overrides.Finished != nil {
		pclass.finished = (*[0]byte)(C._gotk4_gstpbutils1_DiscovererClass_finished)
	}

	if overrides.LoadSerializeInfo != nil {
		pclass.load_serialize_info = (*[0]byte)(C._gotk4_gstpbutils1_DiscovererClass_load_serialize_info)
	}

	if overrides.SourceSetup != nil {
		pclass.source_setup = (*[0]byte)(C._gotk4_gstpbutils1_DiscovererClass_source_setup)
	}

	if overrides.Starting != nil {
		pclass.starting = (*[0]byte)(C._gotk4_gstpbutils1_DiscovererClass_starting)
	}

	if classInitFunc != nil {
		class := (*DiscovererClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDiscoverer(obj *coreglib.Object) *Discoverer {
	return &Discoverer{
		Object: obj,
	}
}

func marshalDiscoverer(p uintptr) (interface{}, error) {
	return wrapDiscoverer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectDiscovered will be emitted in async mode when all information on a URI
// could be discovered, or an error occurred.
//
// When an error occurs, info might still contain some partial information,
// depending on the circumstances of the error.
func (discoverer *Discoverer) ConnectDiscovered(f func(info *DiscovererInfo, err error)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(discoverer, "discovered", false, unsafe.Pointer(C._gotk4_gstpbutils1_Discoverer_ConnectDiscovered), f)
}

// ConnectFinished will be emitted in async mode when all pending URIs have been
// processed.
func (discoverer *Discoverer) ConnectFinished(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(discoverer, "finished", false, unsafe.Pointer(C._gotk4_gstpbutils1_Discoverer_ConnectFinished), f)
}

// ConnectLoadSerializedInfo retrieves information about a URI from and external
// source of information, like a cache file. This is used by the discoverer to
// speed up the discovery.
func (discoverer *Discoverer) ConnectLoadSerializedInfo(f func(uri string) (discovererInfo *DiscovererInfo)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(discoverer, "load-serialized-info", false, unsafe.Pointer(C._gotk4_gstpbutils1_Discoverer_ConnectLoadSerializedInfo), f)
}

// ConnectSourceSetup: this signal is emitted after the source element has
// been created for, so the URI being discovered, so it can be configured by
// setting additional properties (e.g. set a proxy server for an http source,
// or set the device and read speed for an audio cd source).
//
// This signal is usually emitted from the context of a GStreamer streaming
// thread.
func (discoverer *Discoverer) ConnectSourceSetup(f func(source gst.Elementer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(discoverer, "source-setup", false, unsafe.Pointer(C._gotk4_gstpbutils1_Discoverer_ConnectSourceSetup), f)
}

// ConnectStarting will be emitted when the discover starts analyzing the
// pending URIs.
func (discoverer *Discoverer) ConnectStarting(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(discoverer, "starting", false, unsafe.Pointer(C._gotk4_gstpbutils1_Discoverer_ConnectStarting), f)
}

// NewDiscoverer creates a new Discoverer with the provided timeout.
//
// The function takes the following parameters:
//
//   - timeout per file, in nanoseconds. Allowed are values between one second
//     (T_SECOND) and one hour (3600 * T_SECOND).
//
// The function returns the following values:
//
//   - discoverer: new Discoverer. If an error occurred when creating the
//     discoverer, err will be set accordingly and NULL will be returned.
//     If err is set, the caller must free it when no longer needed using
//     g_error_free().
func NewDiscoverer(timeout gst.ClockTime) (*Discoverer, error) {
	var _arg1 C.GstClockTime   // out
	var _cret *C.GstDiscoverer // in
	var _cerr *C.GError        // in

	_arg1 = C.GstClockTime(timeout)

	_cret = C.gst_discoverer_new(_arg1, &_cerr)
	runtime.KeepAlive(timeout)

	var _discoverer *Discoverer // out
	var _goerr error            // out

	_discoverer = wrapDiscoverer(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _discoverer, _goerr
}

// DiscoverURI: synchronously discovers the given uri.
//
// A copy of uri will be made internally, so the caller can safely g_free()
// afterwards.
//
// The function takes the following parameters:
//
//   - uri: URI to run on.
//
// The function returns the following values:
//
//   - discovererInfo: result of the scanning. Can be NULL if an error occurred.
func (discoverer *Discoverer) DiscoverURI(uri string) (*DiscovererInfo, error) {
	var _arg0 *C.GstDiscoverer     // out
	var _arg1 *C.gchar             // out
	var _cret *C.GstDiscovererInfo // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GstDiscoverer)(unsafe.Pointer(coreglib.BaseObject(discoverer).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_discoverer_discover_uri(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(discoverer)
	runtime.KeepAlive(uri)

	var _discovererInfo *DiscovererInfo // out
	var _goerr error                    // out

	_discovererInfo = wrapDiscovererInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _discovererInfo, _goerr
}

// DiscoverURIAsync appends the given uri to the list of URIs to discoverer. The
// actual discovery of the uri will only take place if gst_discoverer_start()
// has been called.
//
// A copy of uri will be made internally, so the caller can safely g_free()
// afterwards.
//
// The function takes the following parameters:
//
//   - uri: URI to add.
//
// The function returns the following values:
//
//   - ok: TRUE if the uri was successfully appended to the list of pending
//     uris, else FALSE.
func (discoverer *Discoverer) DiscoverURIAsync(uri string) bool {
	var _arg0 *C.GstDiscoverer // out
	var _arg1 *C.gchar         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GstDiscoverer)(unsafe.Pointer(coreglib.BaseObject(discoverer).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_discoverer_discover_uri_async(_arg0, _arg1)
	runtime.KeepAlive(discoverer)
	runtime.KeepAlive(uri)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Start: allow asynchronous discovering of URIs to take place. A Loop must be
// available for Discoverer to properly work in asynchronous mode.
func (discoverer *Discoverer) Start() {
	var _arg0 *C.GstDiscoverer // out

	_arg0 = (*C.GstDiscoverer)(unsafe.Pointer(coreglib.BaseObject(discoverer).Native()))

	C.gst_discoverer_start(_arg0)
	runtime.KeepAlive(discoverer)
}

// Stop the discovery of any pending URIs and clears the list of pending URIS
// (if any).
func (discoverer *Discoverer) Stop() {
	var _arg0 *C.GstDiscoverer // out

	_arg0 = (*C.GstDiscoverer)(unsafe.Pointer(coreglib.BaseObject(discoverer).Native()))

	C.gst_discoverer_stop(_arg0)
	runtime.KeepAlive(discoverer)
}

// The function takes the following parameters:
//
//   - info
//   - err
func (discoverer *Discoverer) discovered(info *DiscovererInfo, err error) {
	gclass := (*C.GstDiscovererClass)(coreglib.PeekParentClass(discoverer))
	fnarg := gclass.discovered

	var _arg0 *C.GstDiscoverer     // out
	var _arg1 *C.GstDiscovererInfo // out
	var _arg2 *C.GError            // out

	_arg0 = (*C.GstDiscoverer)(unsafe.Pointer(coreglib.BaseObject(discoverer).Native()))
	_arg1 = (*C.GstDiscovererInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))
	if err != nil {
		_arg2 = (*C.GError)(gerror.New(err))
	}

	C._gotk4_gstpbutils1_Discoverer_virtual_discovered(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(discoverer)
	runtime.KeepAlive(info)
	runtime.KeepAlive(err)
}

func (discoverer *Discoverer) finished() {
	gclass := (*C.GstDiscovererClass)(coreglib.PeekParentClass(discoverer))
	fnarg := gclass.finished

	var _arg0 *C.GstDiscoverer // out

	_arg0 = (*C.GstDiscoverer)(unsafe.Pointer(coreglib.BaseObject(discoverer).Native()))

	C._gotk4_gstpbutils1_Discoverer_virtual_finished(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(discoverer)
}

// loadSerializeInfo loads the serialized info from the given uri.
//
// The function takes the following parameters:
//
//   - uri to load the info from.
//
// The function returns the following values:
//
//   - discovererInfo or NULL if it could not be loaded.
func (dc *Discoverer) loadSerializeInfo(uri string) *DiscovererInfo {
	gclass := (*C.GstDiscovererClass)(coreglib.PeekParentClass(dc))
	fnarg := gclass.load_serialize_info

	var _arg0 *C.GstDiscoverer     // out
	var _arg1 *C.gchar             // out
	var _cret *C.GstDiscovererInfo // in

	_arg0 = (*C.GstDiscoverer)(unsafe.Pointer(coreglib.BaseObject(dc).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gstpbutils1_Discoverer_virtual_load_serialize_info(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(dc)
	runtime.KeepAlive(uri)

	var _discovererInfo *DiscovererInfo // out

	_discovererInfo = wrapDiscovererInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _discovererInfo
}

func (discoverer *Discoverer) sourceSetup(source gst.Elementer) {
	gclass := (*C.GstDiscovererClass)(coreglib.PeekParentClass(discoverer))
	fnarg := gclass.source_setup

	var _arg0 *C.GstDiscoverer // out
	var _arg1 *C.GstElement    // out

	_arg0 = (*C.GstDiscoverer)(unsafe.Pointer(coreglib.BaseObject(discoverer).Native()))
	_arg1 = (*C.GstElement)(unsafe.Pointer(coreglib.BaseObject(source).Native()))

	C._gotk4_gstpbutils1_Discoverer_virtual_source_setup(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(discoverer)
	runtime.KeepAlive(source)
}

func (discoverer *Discoverer) starting() {
	gclass := (*C.GstDiscovererClass)(coreglib.PeekParentClass(discoverer))
	fnarg := gclass.starting

	var _arg0 *C.GstDiscoverer // out

	_arg0 = (*C.GstDiscoverer)(unsafe.Pointer(coreglib.BaseObject(discoverer).Native()))

	C._gotk4_gstpbutils1_Discoverer_virtual_starting(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(discoverer)
}

// DiscovererAudioInfo specific to audio streams.
type DiscovererAudioInfo struct {
	_ [0]func() // equal guard
	DiscovererStreamInfo
}

var (
	_ coreglib.Objector = (*DiscovererAudioInfo)(nil)
)

func wrapDiscovererAudioInfo(obj *coreglib.Object) *DiscovererAudioInfo {
	return &DiscovererAudioInfo{
		DiscovererStreamInfo: DiscovererStreamInfo{
			Object: obj,
		},
	}
}

func marshalDiscovererAudioInfo(p uintptr) (interface{}, error) {
	return wrapDiscovererAudioInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function returns the following values:
//
//   - guint: average or nominal bitrate of the stream in bits/second.
func (info *DiscovererAudioInfo) Bitrate() uint {
	var _arg0 *C.GstDiscovererAudioInfo // out
	var _cret C.guint                   // in

	_arg0 = (*C.GstDiscovererAudioInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_audio_info_get_bitrate(_arg0)
	runtime.KeepAlive(info)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - guint64: channel-mask of the stream, refer to
//     gst_audio_channel_positions_from_mask() for more information.
func (info *DiscovererAudioInfo) ChannelMask() uint64 {
	var _arg0 *C.GstDiscovererAudioInfo // out
	var _cret C.guint64                 // in

	_arg0 = (*C.GstDiscovererAudioInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_audio_info_get_channel_mask(_arg0)
	runtime.KeepAlive(info)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// The function returns the following values:
//
//   - guint: number of channels in the stream.
func (info *DiscovererAudioInfo) Channels() uint {
	var _arg0 *C.GstDiscovererAudioInfo // out
	var _cret C.guint                   // in

	_arg0 = (*C.GstDiscovererAudioInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_audio_info_get_channels(_arg0)
	runtime.KeepAlive(info)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - guint: number of bits used per sample in each channel.
func (info *DiscovererAudioInfo) Depth() uint {
	var _arg0 *C.GstDiscovererAudioInfo // out
	var _cret C.guint                   // in

	_arg0 = (*C.GstDiscovererAudioInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_audio_info_get_depth(_arg0)
	runtime.KeepAlive(info)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - utf8 (optional): language of the stream, or NULL if unknown.
func (info *DiscovererAudioInfo) Language() string {
	var _arg0 *C.GstDiscovererAudioInfo // out
	var _cret *C.gchar                  // in

	_arg0 = (*C.GstDiscovererAudioInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_audio_info_get_language(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// The function returns the following values:
//
//   - guint: maximum bitrate of the stream in bits/second.
func (info *DiscovererAudioInfo) MaxBitrate() uint {
	var _arg0 *C.GstDiscovererAudioInfo // out
	var _cret C.guint                   // in

	_arg0 = (*C.GstDiscovererAudioInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_audio_info_get_max_bitrate(_arg0)
	runtime.KeepAlive(info)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - guint: sample rate of the stream in Hertz.
func (info *DiscovererAudioInfo) SampleRate() uint {
	var _arg0 *C.GstDiscovererAudioInfo // out
	var _cret C.guint                   // in

	_arg0 = (*C.GstDiscovererAudioInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_audio_info_get_sample_rate(_arg0)
	runtime.KeepAlive(info)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// DiscovererContainerInfo specific to container streams.
type DiscovererContainerInfo struct {
	_ [0]func() // equal guard
	DiscovererStreamInfo
}

var (
	_ coreglib.Objector = (*DiscovererContainerInfo)(nil)
)

func wrapDiscovererContainerInfo(obj *coreglib.Object) *DiscovererContainerInfo {
	return &DiscovererContainerInfo{
		DiscovererStreamInfo: DiscovererStreamInfo{
			Object: obj,
		},
	}
}

func marshalDiscovererContainerInfo(p uintptr) (interface{}, error) {
	return wrapDiscovererContainerInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function returns the following values:
//
//   - list of DiscovererStreamInfo this container stream offers. Free with
//     gst_discoverer_stream_info_list_free() after usage.
func (info *DiscovererContainerInfo) Streams() []*DiscovererStreamInfo {
	var _arg0 *C.GstDiscovererContainerInfo // out
	var _cret *C.GList                      // in

	_arg0 = (*C.GstDiscovererContainerInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_container_info_get_streams(_arg0)
	runtime.KeepAlive(info)

	var _list []*DiscovererStreamInfo // out

	_list = make([]*DiscovererStreamInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstDiscovererStreamInfo)(v)
		var dst *DiscovererStreamInfo // out
		dst = wrapDiscovererStreamInfo(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// The function returns the following values:
//
//   - tagList (optional) tags specific to the given container. If you wish to
//     use the tags after the life-time of info, you will need to copy them.
func (info *DiscovererContainerInfo) Tags() *gst.TagList {
	var _arg0 *C.GstDiscovererContainerInfo // out
	var _cret *C.GstTagList                 // in

	_arg0 = (*C.GstDiscovererContainerInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_container_info_get_tags(_arg0)
	runtime.KeepAlive(info)

	var _tagList *gst.TagList // out

	if _cret != nil {
		_tagList = (*gst.TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _tagList
}

// DiscovererInfo: structure containing the information of a URI analyzed by
// Discoverer.
type DiscovererInfo struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*DiscovererInfo)(nil)
)

func wrapDiscovererInfo(obj *coreglib.Object) *DiscovererInfo {
	return &DiscovererInfo{
		Object: obj,
	}
}

func marshalDiscovererInfo(p uintptr) (interface{}, error) {
	return wrapDiscovererInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function returns the following values:
//
//   - discovererInfo: copy of the DiscovererInfo.
func (ptr *DiscovererInfo) Copy() *DiscovererInfo {
	var _arg0 *C.GstDiscovererInfo // out
	var _cret *C.GstDiscovererInfo // in

	_arg0 = (*C.GstDiscovererInfo)(unsafe.Pointer(coreglib.BaseObject(ptr).Native()))

	_cret = C.gst_discoverer_info_copy(_arg0)
	runtime.KeepAlive(ptr)

	var _discovererInfo *DiscovererInfo // out

	_discovererInfo = wrapDiscovererInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _discovererInfo
}

// AudioStreams finds all the DiscovererAudioInfo contained in info.
//
// The function returns the following values:
//
//   - list of matching DiscovererStreamInfo. The caller should free it with
//     gst_discoverer_stream_info_list_free().
func (info *DiscovererInfo) AudioStreams() []*DiscovererAudioInfo {
	var _arg0 *C.GstDiscovererInfo // out
	var _cret *C.GList             // in

	_arg0 = (*C.GstDiscovererInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_info_get_audio_streams(_arg0)
	runtime.KeepAlive(info)

	var _list []*DiscovererAudioInfo // out

	_list = make([]*DiscovererAudioInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstDiscovererAudioInfo)(v)
		var dst *DiscovererAudioInfo // out
		dst = wrapDiscovererAudioInfo(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// ContainerStreams finds all the DiscovererContainerInfo contained in info.
//
// The function returns the following values:
//
//   - list of matching DiscovererStreamInfo. The caller should free it with
//     gst_discoverer_stream_info_list_free().
func (info *DiscovererInfo) ContainerStreams() []*DiscovererContainerInfo {
	var _arg0 *C.GstDiscovererInfo // out
	var _cret *C.GList             // in

	_arg0 = (*C.GstDiscovererInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_info_get_container_streams(_arg0)
	runtime.KeepAlive(info)

	var _list []*DiscovererContainerInfo // out

	_list = make([]*DiscovererContainerInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstDiscovererContainerInfo)(v)
		var dst *DiscovererContainerInfo // out
		dst = wrapDiscovererContainerInfo(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// The function returns the following values:
//
//   - clockTime: duration of the URI in ClockTime (nanoseconds).
func (info *DiscovererInfo) Duration() gst.ClockTime {
	var _arg0 *C.GstDiscovererInfo // out
	var _cret C.GstClockTime       // in

	_arg0 = (*C.GstDiscovererInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_info_get_duration(_arg0)
	runtime.KeepAlive(info)

	var _clockTime gst.ClockTime // out

	_clockTime = gst.ClockTime(_cret)

	return _clockTime
}

// The function returns the following values:
//
//   - ok: whether the URI is live.
func (info *DiscovererInfo) Live() bool {
	var _arg0 *C.GstDiscovererInfo // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstDiscovererInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_info_get_live(_arg0)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Misc: deprecated: This functions is deprecated since version 1.4, use
// #gst_discoverer_info_get_missing_elements_installer_details.
//
// The function returns the following values:
//
//   - structure (optional) miscellaneous information stored as a Structure
//     (for example: information about missing plugins). If you wish to use the
//     Structure after the life-time of info, you will need to copy it.
func (info *DiscovererInfo) Misc() *gst.Structure {
	var _arg0 *C.GstDiscovererInfo // out
	var _cret *C.GstStructure      // in

	_arg0 = (*C.GstDiscovererInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_info_get_misc(_arg0)
	runtime.KeepAlive(info)

	var _structure *gst.Structure // out

	if _cret != nil {
		_structure = (*gst.Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.gst_mini_object_ref((*C.GstMiniObject)(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_structure)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _structure
}

// MissingElementsInstallerDetails: get the installer details for missing
// elements.
//
// The function returns the following values:
//
//   - utf8s: array of strings containing information about how to install the
//     various missing elements for info to be usable. If you wish to use the
//     strings after the life-time of info, you will need to copy them.
func (info *DiscovererInfo) MissingElementsInstallerDetails() []string {
	var _arg0 *C.GstDiscovererInfo // out
	var _cret **C.gchar            // in

	_arg0 = (*C.GstDiscovererInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_info_get_missing_elements_installer_details(_arg0)
	runtime.KeepAlive(info)

	var _utf8s []string // out

	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// The function returns the following values:
//
//   - discovererResult: result of the discovery as a DiscovererResult.
func (info *DiscovererInfo) Result() DiscovererResult {
	var _arg0 *C.GstDiscovererInfo  // out
	var _cret C.GstDiscovererResult // in

	_arg0 = (*C.GstDiscovererInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_info_get_result(_arg0)
	runtime.KeepAlive(info)

	var _discovererResult DiscovererResult // out

	_discovererResult = DiscovererResult(_cret)

	return _discovererResult
}

// The function returns the following values:
//
//   - ok: whether the URI is seekable.
func (info *DiscovererInfo) Seekable() bool {
	var _arg0 *C.GstDiscovererInfo // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GstDiscovererInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_info_get_seekable(_arg0)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - discovererStreamInfo (optional): structure (or topology) of the URI as a
//     DiscovererStreamInfo. This structure can be traversed to see the original
//     hierarchy. Unref with gst_discoverer_stream_info_unref() after usage.
func (info *DiscovererInfo) StreamInfo() *DiscovererStreamInfo {
	var _arg0 *C.GstDiscovererInfo       // out
	var _cret *C.GstDiscovererStreamInfo // in

	_arg0 = (*C.GstDiscovererInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_info_get_stream_info(_arg0)
	runtime.KeepAlive(info)

	var _discovererStreamInfo *DiscovererStreamInfo // out

	if _cret != nil {
		_discovererStreamInfo = wrapDiscovererStreamInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _discovererStreamInfo
}

// The function returns the following values:
//
//   - list of all streams contained in the #info. Free after usage with
//     gst_discoverer_stream_info_list_free().
func (info *DiscovererInfo) StreamList() []*DiscovererStreamInfo {
	var _arg0 *C.GstDiscovererInfo // out
	var _cret *C.GList             // in

	_arg0 = (*C.GstDiscovererInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_info_get_stream_list(_arg0)
	runtime.KeepAlive(info)

	var _list []*DiscovererStreamInfo // out

	_list = make([]*DiscovererStreamInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstDiscovererStreamInfo)(v)
		var dst *DiscovererStreamInfo // out
		dst = wrapDiscovererStreamInfo(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// Streams finds the DiscovererStreamInfo contained in info that match the given
// streamtype.
//
// The function takes the following parameters:
//
//   - streamtype derived from DiscovererStreamInfo.
//
// The function returns the following values:
//
//   - list of matching DiscovererStreamInfo. The caller should free it with
//     gst_discoverer_stream_info_list_free().
func (info *DiscovererInfo) Streams(streamtype coreglib.Type) []*DiscovererStreamInfo {
	var _arg0 *C.GstDiscovererInfo // out
	var _arg1 C.GType              // out
	var _cret *C.GList             // in

	_arg0 = (*C.GstDiscovererInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))
	_arg1 = C.GType(streamtype)

	_cret = C.gst_discoverer_info_get_streams(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(streamtype)

	var _list []*DiscovererStreamInfo // out

	_list = make([]*DiscovererStreamInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstDiscovererStreamInfo)(v)
		var dst *DiscovererStreamInfo // out
		dst = wrapDiscovererStreamInfo(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// SubtitleStreams finds all the DiscovererSubtitleInfo contained in info.
//
// The function returns the following values:
//
//   - list of matching DiscovererStreamInfo. The caller should free it with
//     gst_discoverer_stream_info_list_free().
func (info *DiscovererInfo) SubtitleStreams() []*DiscovererSubtitleInfo {
	var _arg0 *C.GstDiscovererInfo // out
	var _cret *C.GList             // in

	_arg0 = (*C.GstDiscovererInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_info_get_subtitle_streams(_arg0)
	runtime.KeepAlive(info)

	var _list []*DiscovererSubtitleInfo // out

	_list = make([]*DiscovererSubtitleInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstDiscovererSubtitleInfo)(v)
		var dst *DiscovererSubtitleInfo // out
		dst = wrapDiscovererSubtitleInfo(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// Tags: deprecated: Use gst_discoverer_{container,stream}_info_get_tags()
// instead.
//
// The function returns the following values:
//
//   - tagList (optional): all tags contained in the URI. If you wish to use the
//     tags after the life-time of info, you will need to copy them.
func (info *DiscovererInfo) Tags() *gst.TagList {
	var _arg0 *C.GstDiscovererInfo // out
	var _cret *C.GstTagList        // in

	_arg0 = (*C.GstDiscovererInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_info_get_tags(_arg0)
	runtime.KeepAlive(info)

	var _tagList *gst.TagList // out

	if _cret != nil {
		_tagList = (*gst.TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _tagList
}

// The function returns the following values:
//
//   - toc (optional): TOC contained in the URI. If you wish to use the TOC
//     after the life-time of info, you will need to copy it.
func (info *DiscovererInfo) Toc() *gst.Toc {
	var _arg0 *C.GstDiscovererInfo // out
	var _cret *C.GstToc            // in

	_arg0 = (*C.GstDiscovererInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_info_get_toc(_arg0)
	runtime.KeepAlive(info)

	var _toc *gst.Toc // out

	if _cret != nil {
		_toc = (*gst.Toc)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _toc
}

// The function returns the following values:
//
//   - utf8: URI to which this information corresponds to. Copy it if you wish
//     to use it after the life-time of info.
func (info *DiscovererInfo) URI() string {
	var _arg0 *C.GstDiscovererInfo // out
	var _cret *C.gchar             // in

	_arg0 = (*C.GstDiscovererInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_info_get_uri(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// VideoStreams finds all the DiscovererVideoInfo contained in info.
//
// The function returns the following values:
//
//   - list of matching DiscovererStreamInfo. The caller should free it with
//     gst_discoverer_stream_info_list_free().
func (info *DiscovererInfo) VideoStreams() []*DiscovererVideoInfo {
	var _arg0 *C.GstDiscovererInfo // out
	var _cret *C.GList             // in

	_arg0 = (*C.GstDiscovererInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_info_get_video_streams(_arg0)
	runtime.KeepAlive(info)

	var _list []*DiscovererVideoInfo // out

	_list = make([]*DiscovererVideoInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GstDiscovererVideoInfo)(v)
		var dst *DiscovererVideoInfo // out
		dst = wrapDiscovererVideoInfo(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// ToVariant serializes info to a #GVariant that can be parsed again through
// gst_discoverer_info_from_variant().
//
// Note that any Toc (s) that might have been discovered will not be serialized
// for now.
//
// The function takes the following parameters:
//
//   - flags: combination of DiscovererSerializeFlags to specify what needs to
//     be serialized.
//
// The function returns the following values:
//
//   - variant: newly-allocated #GVariant representing info.
func (info *DiscovererInfo) ToVariant(flags DiscovererSerializeFlags) *glib.Variant {
	var _arg0 *C.GstDiscovererInfo          // out
	var _arg1 C.GstDiscovererSerializeFlags // out
	var _cret *C.GVariant                   // in

	_arg0 = (*C.GstDiscovererInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))
	_arg1 = C.GstDiscovererSerializeFlags(flags)

	_cret = C.gst_discoverer_info_to_variant(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(flags)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// DiscovererInfoFromVariant parses a #GVariant as produced by
// gst_discoverer_info_to_variant() back to a DiscovererInfo.
//
// The function takes the following parameters:
//
//   - variant to deserialize into a DiscovererInfo.
//
// The function returns the following values:
//
//   - discovererInfo: newly-allocated DiscovererInfo.
func DiscovererInfoFromVariant(variant *glib.Variant) *DiscovererInfo {
	var _arg1 *C.GVariant          // out
	var _cret *C.GstDiscovererInfo // in

	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(variant)))

	_cret = C.gst_discoverer_info_from_variant(_arg1)
	runtime.KeepAlive(variant)

	var _discovererInfo *DiscovererInfo // out

	_discovererInfo = wrapDiscovererInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _discovererInfo
}

// DiscovererStreamInfo: base structure for information concerning
// a media stream. Depending on the stream type, one can find more
// media-specific information in DiscovererAudioInfo, DiscovererVideoInfo,
// and DiscovererContainerInfo.
//
// The DiscovererStreamInfo represents the topology of the stream. Siblings
// can be iterated over with gst_discoverer_stream_info_get_next() and
// gst_discoverer_stream_info_get_previous(). Children (sub-streams) of a stream
// can be accessed using the DiscovererContainerInfo API.
//
// As a simple example, if you run Discoverer on an AVI file with one audio and
// one video stream, you will get a DiscovererContainerInfo corresponding to the
// AVI container, which in turn will have a DiscovererAudioInfo sub-stream and a
// DiscovererVideoInfo sub-stream for the audio and video streams respectively.
type DiscovererStreamInfo struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*DiscovererStreamInfo)(nil)
)

func wrapDiscovererStreamInfo(obj *coreglib.Object) *DiscovererStreamInfo {
	return &DiscovererStreamInfo{
		Object: obj,
	}
}

func marshalDiscovererStreamInfo(p uintptr) (interface{}, error) {
	return wrapDiscovererStreamInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function returns the following values:
//
//   - caps (optional) of the stream. Unref with #gst_caps_unref after usage.
func (info *DiscovererStreamInfo) Caps() *gst.Caps {
	var _arg0 *C.GstDiscovererStreamInfo // out
	var _cret *C.GstCaps                 // in

	_arg0 = (*C.GstDiscovererStreamInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_stream_info_get_caps(_arg0)
	runtime.KeepAlive(info)

	var _caps *gst.Caps // out

	if _cret != nil {
		_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_caps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _caps
}

// Misc: deprecated: This functions is deprecated since version 1.4, use
// #gst_discoverer_info_get_missing_elements_installer_details.
//
// The function returns the following values:
//
//   - structure (optional): additional information regarding the stream (for
//     example codec version, profile, etc..). If you wish to use the Structure
//     after the life-time of info you will need to copy it.
func (info *DiscovererStreamInfo) Misc() *gst.Structure {
	var _arg0 *C.GstDiscovererStreamInfo // out
	var _cret *C.GstStructure            // in

	_arg0 = (*C.GstDiscovererStreamInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_stream_info_get_misc(_arg0)
	runtime.KeepAlive(info)

	var _structure *gst.Structure // out

	if _cret != nil {
		_structure = (*gst.Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.gst_mini_object_ref((*C.GstMiniObject)(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_structure)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _structure
}

// The function returns the following values:
//
//   - discovererStreamInfo (optional): next DiscovererStreamInfo in a chain.
//     NULL for final streams. Unref with #gst_discoverer_stream_info_unref
//     after usage.
func (info *DiscovererStreamInfo) Next() *DiscovererStreamInfo {
	var _arg0 *C.GstDiscovererStreamInfo // out
	var _cret *C.GstDiscovererStreamInfo // in

	_arg0 = (*C.GstDiscovererStreamInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_stream_info_get_next(_arg0)
	runtime.KeepAlive(info)

	var _discovererStreamInfo *DiscovererStreamInfo // out

	if _cret != nil {
		_discovererStreamInfo = wrapDiscovererStreamInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _discovererStreamInfo
}

// The function returns the following values:
//
//   - discovererStreamInfo (optional) previous DiscovererStreamInfo in a chain.
//     NULL for starting points. Unref with #gst_discoverer_stream_info_unref
//     after usage.
func (info *DiscovererStreamInfo) Previous() *DiscovererStreamInfo {
	var _arg0 *C.GstDiscovererStreamInfo // out
	var _cret *C.GstDiscovererStreamInfo // in

	_arg0 = (*C.GstDiscovererStreamInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_stream_info_get_previous(_arg0)
	runtime.KeepAlive(info)

	var _discovererStreamInfo *DiscovererStreamInfo // out

	if _cret != nil {
		_discovererStreamInfo = wrapDiscovererStreamInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _discovererStreamInfo
}

// The function returns the following values:
//
//   - utf8 (optional): stream ID of this stream. If you wish to use the stream
//     ID after the life-time of info you will need to copy it.
func (info *DiscovererStreamInfo) StreamID() string {
	var _arg0 *C.GstDiscovererStreamInfo // out
	var _cret *C.gchar                   // in

	_arg0 = (*C.GstDiscovererStreamInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_stream_info_get_stream_id(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// The function returns the following values:
//
//   - gint: stream number, -1 if no index could be determined. This property
//     acts as a unique identifier as a 'int' for the stream.
func (info *DiscovererStreamInfo) StreamNumber() int {
	var _arg0 *C.GstDiscovererStreamInfo // out
	var _cret C.gint                     // in

	_arg0 = (*C.GstDiscovererStreamInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_stream_info_get_stream_number(_arg0)
	runtime.KeepAlive(info)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
//   - utf8: human readable name for the stream type of the given info (ex :
//     "audio", "container",...).
func (info *DiscovererStreamInfo) StreamTypeNick() string {
	var _arg0 *C.GstDiscovererStreamInfo // out
	var _cret *C.gchar                   // in

	_arg0 = (*C.GstDiscovererStreamInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_stream_info_get_stream_type_nick(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
//   - tagList (optional) tags contained in this stream. If you wish to use the
//     tags after the life-time of info you will need to copy them.
func (info *DiscovererStreamInfo) Tags() *gst.TagList {
	var _arg0 *C.GstDiscovererStreamInfo // out
	var _cret *C.GstTagList              // in

	_arg0 = (*C.GstDiscovererStreamInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_stream_info_get_tags(_arg0)
	runtime.KeepAlive(info)

	var _tagList *gst.TagList // out

	if _cret != nil {
		_tagList = (*gst.TagList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _tagList
}

// The function returns the following values:
//
//   - toc (optional): TOC contained in this stream. If you wish to use the TOC
//     after the life-time of info you will need to copy it.
func (info *DiscovererStreamInfo) Toc() *gst.Toc {
	var _arg0 *C.GstDiscovererStreamInfo // out
	var _cret *C.GstToc                  // in

	_arg0 = (*C.GstDiscovererStreamInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_stream_info_get_toc(_arg0)
	runtime.KeepAlive(info)

	var _toc *gst.Toc // out

	if _cret != nil {
		_toc = (*gst.Toc)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _toc
}

// DiscovererSubtitleInfo specific to subtitle streams (this includes text and
// image based ones).
type DiscovererSubtitleInfo struct {
	_ [0]func() // equal guard
	DiscovererStreamInfo
}

var (
	_ coreglib.Objector = (*DiscovererSubtitleInfo)(nil)
)

func wrapDiscovererSubtitleInfo(obj *coreglib.Object) *DiscovererSubtitleInfo {
	return &DiscovererSubtitleInfo{
		DiscovererStreamInfo: DiscovererStreamInfo{
			Object: obj,
		},
	}
}

func marshalDiscovererSubtitleInfo(p uintptr) (interface{}, error) {
	return wrapDiscovererSubtitleInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function returns the following values:
//
//   - utf8 (optional): language of the stream, or NULL if unknown.
func (info *DiscovererSubtitleInfo) Language() string {
	var _arg0 *C.GstDiscovererSubtitleInfo // out
	var _cret *C.gchar                     // in

	_arg0 = (*C.GstDiscovererSubtitleInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_subtitle_info_get_language(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// DiscovererVideoInfo specific to video streams (this includes images).
type DiscovererVideoInfo struct {
	_ [0]func() // equal guard
	DiscovererStreamInfo
}

var (
	_ coreglib.Objector = (*DiscovererVideoInfo)(nil)
)

func wrapDiscovererVideoInfo(obj *coreglib.Object) *DiscovererVideoInfo {
	return &DiscovererVideoInfo{
		DiscovererStreamInfo: DiscovererStreamInfo{
			Object: obj,
		},
	}
}

func marshalDiscovererVideoInfo(p uintptr) (interface{}, error) {
	return wrapDiscovererVideoInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function returns the following values:
//
//   - guint: average or nominal bitrate of the video stream in bits/second.
func (info *DiscovererVideoInfo) Bitrate() uint {
	var _arg0 *C.GstDiscovererVideoInfo // out
	var _cret C.guint                   // in

	_arg0 = (*C.GstDiscovererVideoInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_video_info_get_bitrate(_arg0)
	runtime.KeepAlive(info)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - guint: depth in bits of the video stream.
func (info *DiscovererVideoInfo) Depth() uint {
	var _arg0 *C.GstDiscovererVideoInfo // out
	var _cret C.guint                   // in

	_arg0 = (*C.GstDiscovererVideoInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_video_info_get_depth(_arg0)
	runtime.KeepAlive(info)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - guint: framerate of the video stream (denominator).
func (info *DiscovererVideoInfo) FramerateDenom() uint {
	var _arg0 *C.GstDiscovererVideoInfo // out
	var _cret C.guint                   // in

	_arg0 = (*C.GstDiscovererVideoInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_video_info_get_framerate_denom(_arg0)
	runtime.KeepAlive(info)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - guint: framerate of the video stream (numerator).
func (info *DiscovererVideoInfo) FramerateNum() uint {
	var _arg0 *C.GstDiscovererVideoInfo // out
	var _cret C.guint                   // in

	_arg0 = (*C.GstDiscovererVideoInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_video_info_get_framerate_num(_arg0)
	runtime.KeepAlive(info)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - guint: height of the video stream in pixels.
func (info *DiscovererVideoInfo) Height() uint {
	var _arg0 *C.GstDiscovererVideoInfo // out
	var _cret C.guint                   // in

	_arg0 = (*C.GstDiscovererVideoInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_video_info_get_height(_arg0)
	runtime.KeepAlive(info)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - guint: maximum bitrate of the video stream in bits/second.
func (info *DiscovererVideoInfo) MaxBitrate() uint {
	var _arg0 *C.GstDiscovererVideoInfo // out
	var _cret C.guint                   // in

	_arg0 = (*C.GstDiscovererVideoInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_video_info_get_max_bitrate(_arg0)
	runtime.KeepAlive(info)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - guint: pixel Aspect Ratio (PAR) of the video stream (denominator).
func (info *DiscovererVideoInfo) ParDenom() uint {
	var _arg0 *C.GstDiscovererVideoInfo // out
	var _cret C.guint                   // in

	_arg0 = (*C.GstDiscovererVideoInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_video_info_get_par_denom(_arg0)
	runtime.KeepAlive(info)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - guint: pixel Aspect Ratio (PAR) of the video stream (numerator).
func (info *DiscovererVideoInfo) ParNum() uint {
	var _arg0 *C.GstDiscovererVideoInfo // out
	var _cret C.guint                   // in

	_arg0 = (*C.GstDiscovererVideoInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_video_info_get_par_num(_arg0)
	runtime.KeepAlive(info)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - guint: width of the video stream in pixels.
func (info *DiscovererVideoInfo) Width() uint {
	var _arg0 *C.GstDiscovererVideoInfo // out
	var _cret C.guint                   // in

	_arg0 = (*C.GstDiscovererVideoInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_video_info_get_width(_arg0)
	runtime.KeepAlive(info)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - ok: TRUE if the video stream corresponds to an image (i.e. only contains
//     one frame).
func (info *DiscovererVideoInfo) IsImage() bool {
	var _arg0 *C.GstDiscovererVideoInfo // out
	var _cret C.gboolean                // in

	_arg0 = (*C.GstDiscovererVideoInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_video_info_is_image(_arg0)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - ok: TRUE if the stream is interlaced, else FALSE.
func (info *DiscovererVideoInfo) IsInterlaced() bool {
	var _arg0 *C.GstDiscovererVideoInfo // out
	var _cret C.gboolean                // in

	_arg0 = (*C.GstDiscovererVideoInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_discoverer_video_info_is_interlaced(_arg0)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EncodingAudioProfile: variant of EncodingProfile for audio streams.
type EncodingAudioProfile struct {
	_ [0]func() // equal guard
	EncodingProfile
}

var (
	_ coreglib.Objector = (*EncodingAudioProfile)(nil)
)

func wrapEncodingAudioProfile(obj *coreglib.Object) *EncodingAudioProfile {
	return &EncodingAudioProfile{
		EncodingProfile: EncodingProfile{
			Object: obj,
		},
	}
}

func marshalEncodingAudioProfile(p uintptr) (interface{}, error) {
	return wrapEncodingAudioProfile(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewEncodingAudioProfile creates a new EncodingAudioProfile
//
// All provided allocatable arguments will be internally copied, so can be
// safely freed/unreferenced after calling this method.
//
// The function takes the following parameters:
//
//   - format: Caps.
//   - preset (optional): preset(s) to use on the encoder, can be NULL.
//   - restriction (optional) used to restrict the input to the encoder,
//     can be NULL. See gst_encoding_profile_get_restriction() for more details.
//   - presence: number of time this stream must be used. 0 means any number of
//     times (including never).
//
// The function returns the following values:
//
//   - encodingAudioProfile: newly created EncodingAudioProfile.
func NewEncodingAudioProfile(format *gst.Caps, preset string, restriction *gst.Caps, presence uint) *EncodingAudioProfile {
	var _arg1 *C.GstCaps                 // out
	var _arg2 *C.gchar                   // out
	var _arg3 *C.GstCaps                 // out
	var _arg4 C.guint                    // out
	var _cret *C.GstEncodingAudioProfile // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(format)))
	if preset != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(preset)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if restriction != nil {
		_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(restriction)))
	}
	_arg4 = C.guint(presence)

	_cret = C.gst_encoding_audio_profile_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(format)
	runtime.KeepAlive(preset)
	runtime.KeepAlive(restriction)
	runtime.KeepAlive(presence)

	var _encodingAudioProfile *EncodingAudioProfile // out

	_encodingAudioProfile = wrapEncodingAudioProfile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _encodingAudioProfile
}

// EncodingContainerProfile: encoding profiles for containers. Keeps track of a
// list of EncodingProfile.
type EncodingContainerProfile struct {
	_ [0]func() // equal guard
	EncodingProfile
}

var (
	_ coreglib.Objector = (*EncodingContainerProfile)(nil)
)

func wrapEncodingContainerProfile(obj *coreglib.Object) *EncodingContainerProfile {
	return &EncodingContainerProfile{
		EncodingProfile: EncodingProfile{
			Object: obj,
		},
	}
}

func marshalEncodingContainerProfile(p uintptr) (interface{}, error) {
	return wrapEncodingContainerProfile(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewEncodingContainerProfile creates a new EncodingContainerProfile.
//
// The function takes the following parameters:
//
//   - name (optional) of the container profile, can be NULL.
//   - description (optional) of the container profile, can be NULL.
//   - format to use for this profile.
//   - preset (optional) to use for this profile.
//
// The function returns the following values:
//
//   - encodingContainerProfile: newly created EncodingContainerProfile.
func NewEncodingContainerProfile(name, description string, format *gst.Caps, preset string) *EncodingContainerProfile {
	var _arg1 *C.gchar                       // out
	var _arg2 *C.gchar                       // out
	var _arg3 *C.GstCaps                     // out
	var _arg4 *C.gchar                       // out
	var _cret *C.GstEncodingContainerProfile // in

	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if description != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(format)))
	if preset != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(preset)))
		defer C.free(unsafe.Pointer(_arg4))
	}

	_cret = C.gst_encoding_container_profile_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(name)
	runtime.KeepAlive(description)
	runtime.KeepAlive(format)
	runtime.KeepAlive(preset)

	var _encodingContainerProfile *EncodingContainerProfile // out

	_encodingContainerProfile = wrapEncodingContainerProfile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _encodingContainerProfile
}

// AddProfile: add a EncodingProfile to the list of profiles handled by
// container.
//
// No copy of profile will be made, if you wish to use it elsewhere after this
// method you should increment its reference count.
//
// The function takes the following parameters:
//
//   - profile to add.
//
// The function returns the following values:
//
//   - ok: TRUE if the stream was properly added, else FALSE.
func (container *EncodingContainerProfile) AddProfile(profile *EncodingProfile) bool {
	var _arg0 *C.GstEncodingContainerProfile // out
	var _arg1 *C.GstEncodingProfile          // out
	var _cret C.gboolean                     // in

	_arg0 = (*C.GstEncodingContainerProfile)(unsafe.Pointer(coreglib.BaseObject(container).Native()))
	_arg1 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))
	C.g_object_ref(C.gpointer(coreglib.BaseObject(profile).Native()))

	_cret = C.gst_encoding_container_profile_add_profile(_arg0, _arg1)
	runtime.KeepAlive(container)
	runtime.KeepAlive(profile)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ContainsProfile checks if container contains a EncodingProfile identical to
// profile.
//
// The function takes the following parameters:
//
//   - profile: EncodingProfile.
//
// The function returns the following values:
//
//   - ok: TRUE if container contains a EncodingProfile identical to profile,
//     else FALSE.
func (container *EncodingContainerProfile) ContainsProfile(profile *EncodingProfile) bool {
	var _arg0 *C.GstEncodingContainerProfile // out
	var _arg1 *C.GstEncodingProfile          // out
	var _cret C.gboolean                     // in

	_arg0 = (*C.GstEncodingContainerProfile)(unsafe.Pointer(coreglib.BaseObject(container).Native()))
	_arg1 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))

	_cret = C.gst_encoding_container_profile_contains_profile(_arg0, _arg1)
	runtime.KeepAlive(container)
	runtime.KeepAlive(profile)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - list: the list of contained EncodingProfile.
func (profile *EncodingContainerProfile) Profiles() []*EncodingProfile {
	var _arg0 *C.GstEncodingContainerProfile // out
	var _cret *C.GList                       // in

	_arg0 = (*C.GstEncodingContainerProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))

	_cret = C.gst_encoding_container_profile_get_profiles(_arg0)
	runtime.KeepAlive(profile)

	var _list []*EncodingProfile // out

	_list = make([]*EncodingProfile, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstEncodingProfile)(v)
		var dst *EncodingProfile // out
		dst = wrapEncodingProfile(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// EncodingProfile: opaque base class object for all encoding profiles. This
// contains generic information like name, description, format and preset.
type EncodingProfile struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*EncodingProfile)(nil)
)

func wrapEncodingProfile(obj *coreglib.Object) *EncodingProfile {
	return &EncodingProfile{
		Object: obj,
	}
}

func marshalEncodingProfile(p uintptr) (interface{}, error) {
	return wrapEncodingProfile(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Copy makes a deep copy of self.
//
// The function returns the following values:
//
//   - encodingProfile: copy of self.
func (self *EncodingProfile) Copy() *EncodingProfile {
	var _arg0 *C.GstEncodingProfile // out
	var _cret *C.GstEncodingProfile // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(self).Native()))

	_cret = C.gst_encoding_profile_copy(_arg0)
	runtime.KeepAlive(self)

	var _encodingProfile *EncodingProfile // out

	_encodingProfile = wrapEncodingProfile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _encodingProfile
}

// AllowDynamicOutput: get whether the format that has been negotiated in at
// some point can be renegotiated later during the encoding.
func (profile *EncodingProfile) AllowDynamicOutput() bool {
	var _arg0 *C.GstEncodingProfile // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_allow_dynamic_output(_arg0)
	runtime.KeepAlive(profile)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - utf8 (optional): description of the profile, can be NULL.
func (profile *EncodingProfile) Description() string {
	var _arg0 *C.GstEncodingProfile // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_description(_arg0)
	runtime.KeepAlive(profile)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// The function returns the following values:
//
//   - structure (optional) properties that are going to be set on the
//     underlying element.
func (self *EncodingProfile) ElementProperties() *gst.Structure {
	var _arg0 *C.GstEncodingProfile // out
	var _cret *C.GstStructure       // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(self).Native()))

	_cret = C.gst_encoding_profile_get_element_properties(_arg0)
	runtime.KeepAlive(self)

	var _structure *gst.Structure // out

	if _cret != nil {
		_structure = (*gst.Structure)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_structure)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _structure
}

// The function returns the following values:
//
//   - utf8 (optional): suitable file extension for profile, or NULL.
func (profile *EncodingProfile) FileExtension() string {
	var _arg0 *C.GstEncodingProfile // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_file_extension(_arg0)
	runtime.KeepAlive(profile)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// The function returns the following values:
//
//   - caps: (nullable): the Caps corresponding to the media format used in the
//     profile. Unref after usage.
func (profile *EncodingProfile) Format() *gst.Caps {
	var _arg0 *C.GstEncodingProfile // out
	var _cret *C.GstCaps            // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_format(_arg0)
	runtime.KeepAlive(profile)

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _caps
}

// InputCaps computes the full output caps that this profile will be able to
// consume.
//
// The function returns the following values:
//
//   - caps: full caps the given profile can consume. Call gst_caps_unref() when
//     you are done with the caps.
func (profile *EncodingProfile) InputCaps() *gst.Caps {
	var _arg0 *C.GstEncodingProfile // out
	var _cret *C.GstCaps            // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_input_caps(_arg0)
	runtime.KeepAlive(profile)

	var _caps *gst.Caps // out

	_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_caps)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
		})

	return _caps
}

// The function returns the following values:
//
//   - utf8 (optional): name of the profile, can be NULL.
func (profile *EncodingProfile) Name() string {
	var _arg0 *C.GstEncodingProfile // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_name(_arg0)
	runtime.KeepAlive(profile)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// The function returns the following values:
//
//   - guint: number of times the profile is used in its parent container
//     profile. If 0, it is not a mandatory stream.
func (profile *EncodingProfile) Presence() uint {
	var _arg0 *C.GstEncodingProfile // out
	var _cret C.guint               // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_presence(_arg0)
	runtime.KeepAlive(profile)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function returns the following values:
//
//   - utf8 (optional): name of the Preset to be used in the profile. This is
//     the name that has been set when saving the preset.
func (profile *EncodingProfile) Preset() string {
	var _arg0 *C.GstEncodingProfile // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_preset(_arg0)
	runtime.KeepAlive(profile)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// The function returns the following values:
//
//   - utf8 (optional): name of the Preset factory to be used in the profile.
func (profile *EncodingProfile) PresetName() string {
	var _arg0 *C.GstEncodingProfile // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_preset_name(_arg0)
	runtime.KeepAlive(profile)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// The function returns the following values:
//
//   - caps (optional): restriction Caps to apply before the encoder that
//     will be used in the profile. The fields present in restriction caps are
//     properties of the raw stream (that is before encoding), such as height
//     and width for video and depth and sampling rate for audio. Does not apply
//     to EncodingContainerProfile (since there is no corresponding raw stream).
//     Can be NULL. Unref after usage.
func (profile *EncodingProfile) Restriction() *gst.Caps {
	var _arg0 *C.GstEncodingProfile // out
	var _cret *C.GstCaps            // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_restriction(_arg0)
	runtime.KeepAlive(profile)

	var _caps *gst.Caps // out

	if _cret != nil {
		_caps = (*gst.Caps)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_caps)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gst_mini_object_unref((*C.GstMiniObject)(intern.C))
			})
	}

	return _caps
}

// The function returns the following values:
//
//   - ok if the stream represented by profile should use a single segment
//     before the encoder, LSE otherwise. This means that buffers will be
//     retimestamped and segments will be eat so as to appear as one segment.
func (profile *EncodingProfile) SingleSegment() bool {
	var _arg0 *C.GstEncodingProfile // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_single_segment(_arg0)
	runtime.KeepAlive(profile)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - utf8: human-readable name of the type of profile.
func (profile *EncodingProfile) TypeNick() string {
	var _arg0 *C.GstEncodingProfile // out
	var _cret *C.gchar              // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))

	_cret = C.gst_encoding_profile_get_type_nick(_arg0)
	runtime.KeepAlive(profile)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

func (profile *EncodingProfile) IsEnabled() bool {
	var _arg0 *C.GstEncodingProfile // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))

	_cret = C.gst_encoding_profile_is_enabled(_arg0)
	runtime.KeepAlive(profile)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEqual checks whether the two EncodingProfile are equal.
//
// The function takes the following parameters:
//
//   - b: EncodingProfile.
//
// The function returns the following values:
//
//   - ok: TRUE if a and b are equal, else FALSE.
func (a *EncodingProfile) IsEqual(b *EncodingProfile) bool {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 *C.GstEncodingProfile // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(a).Native()))
	_arg1 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(b).Native()))

	_cret = C.gst_encoding_profile_is_equal(_arg0, _arg1)
	runtime.KeepAlive(a)
	runtime.KeepAlive(b)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAllowDynamicOutput sets whether the format that has been negotiated in at
// some point can be renegotiated later during the encoding.
//
// The function takes the following parameters:
//
//   - allowDynamicOutput: whether the format that has been negotiated first can
//     be renegotiated during the encoding.
func (profile *EncodingProfile) SetAllowDynamicOutput(allowDynamicOutput bool) {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))
	if allowDynamicOutput {
		_arg1 = C.TRUE
	}

	C.gst_encoding_profile_set_allow_dynamic_output(_arg0, _arg1)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(allowDynamicOutput)
}

// SetDescription: set description as the given description for the profile.
// A copy of description will be made internally.
//
// The function takes the following parameters:
//
//   - description (optional) to set on the profile.
func (profile *EncodingProfile) SetDescription(description string) {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 *C.gchar              // out

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))
	if description != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gst_encoding_profile_set_description(_arg0, _arg1)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(description)
}

// SetElementProperties: this allows setting the muxing/encoding element
// properties.
//
// **Set properties generically**
//
// ` properties [element-properties, boolean-prop=true, string-prop="hi"]
//
//	  **Mapping properties with well known element factories**
//
//
//
//	properties
//
//	element-properties-map, map = {
//	     [openh264enc, gop-size=32, ],
//	     [x264enc, key-int-max=32, tune=zerolatency],
//	 }.
//
// `
//
// The function takes the following parameters:
//
//   - elementProperties defining the properties to be set to the element the
//     profile represents.
func (self *EncodingProfile) SetElementProperties(elementProperties *gst.Structure) {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 *C.GstStructure       // out

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(self).Native()))
	_arg1 = (*C.GstStructure)(gextras.StructNative(unsafe.Pointer(elementProperties)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(elementProperties)), nil)

	C.gst_encoding_profile_set_element_properties(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(elementProperties)
}

// SetEnabled: set whether the profile should be used or not.
//
// The function takes the following parameters:
//
//   - enabled: FALSE to disable profile, TRUE to enable it.
func (profile *EncodingProfile) SetEnabled(enabled bool) {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gst_encoding_profile_set_enabled(_arg0, _arg1)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(enabled)
}

// SetFormat sets the media format used in the profile.
//
// The function takes the following parameters:
//
//   - format: media format to use in the profile.
func (profile *EncodingProfile) SetFormat(format *gst.Caps) {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 *C.GstCaps            // out

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))
	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(format)))

	C.gst_encoding_profile_set_format(_arg0, _arg1)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(format)
}

// SetName: set name as the given name for the profile. A copy of name will be
// made internally.
//
// The function takes the following parameters:
//
//   - name (optional) to set on the profile.
func (profile *EncodingProfile) SetName(name string) {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 *C.gchar              // out

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))
	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gst_encoding_profile_set_name(_arg0, _arg1)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(name)
}

// SetPresence: set the number of time the profile is used in its parent
// container profile. If 0, it is not a mandatory stream.
//
// The function takes the following parameters:
//
//   - presence: number of time the profile can be used.
func (profile *EncodingProfile) SetPresence(presence uint) {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 C.guint               // out

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))
	_arg1 = C.guint(presence)

	C.gst_encoding_profile_set_presence(_arg0, _arg1)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(presence)
}

// SetPreset sets the name of the Element that implements the Preset interface
// to use for the profile. This is the name that has been set when saving the
// preset.
//
// The function takes the following parameters:
//
//   - preset (optional): element preset to use.
func (profile *EncodingProfile) SetPreset(preset string) {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 *C.gchar              // out

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))
	if preset != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(preset)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gst_encoding_profile_set_preset(_arg0, _arg1)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(preset)
}

// SetPresetName sets the name of the Preset's factory to be used in the
// profile.
//
// The function takes the following parameters:
//
//   - presetName (optional): name of the preset to use in this profile.
func (profile *EncodingProfile) SetPresetName(presetName string) {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 *C.gchar              // out

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))
	if presetName != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(presetName)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gst_encoding_profile_set_preset_name(_arg0, _arg1)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(presetName)
}

// SetRestriction: set the restriction Caps to apply before the encoder that
// will be used in the profile. See gst_encoding_profile_get_restriction() for
// more about restrictions. Does not apply to EncodingContainerProfile.
//
// The function takes the following parameters:
//
//   - restriction (optional) to apply.
func (profile *EncodingProfile) SetRestriction(restriction *gst.Caps) {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 *C.GstCaps            // out

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))
	if restriction != nil {
		_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(restriction)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(restriction)), nil)
	}

	C.gst_encoding_profile_set_restriction(_arg0, _arg1)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(restriction)
}

// SetSingleSegment: if using a single segment, buffers will be retimestamped
// and segments will be eat so as to appear as one segment.
//
// > *NOTE*: Single segment is not property supported when using >
// #encodebin:avoid-reencoding.
//
// The function takes the following parameters:
//
//   - singleSegment if the stream represented by profile should use a single
//     segment before the encoder, LSE otherwise.
func (profile *EncodingProfile) SetSingleSegment(singleSegment bool) {
	var _arg0 *C.GstEncodingProfile // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))
	if singleSegment {
		_arg1 = C.TRUE
	}

	C.gst_encoding_profile_set_single_segment(_arg0, _arg1)
	runtime.KeepAlive(profile)
	runtime.KeepAlive(singleSegment)
}

// EncodingProfileFind: find the EncodingProfile with the specified name and
// category.
//
// The function takes the following parameters:
//
//   - targetname: name of the target.
//   - profilename (optional): name of the profile, if NULL provided, it will
//     default to the encoding profile called default.
//   - category (optional): target category. Can be NULL.
//
// The function returns the following values:
//
//   - encodingProfile (optional): matching EncodingProfile or NULL.
func EncodingProfileFind(targetname, profilename, category string) *EncodingProfile {
	var _arg1 *C.gchar              // out
	var _arg2 *C.gchar              // out
	var _arg3 *C.gchar              // out
	var _cret *C.GstEncodingProfile // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(targetname)))
	defer C.free(unsafe.Pointer(_arg1))
	if profilename != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(profilename)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if category != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(category)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	_cret = C.gst_encoding_profile_find(_arg1, _arg2, _arg3)
	runtime.KeepAlive(targetname)
	runtime.KeepAlive(profilename)
	runtime.KeepAlive(category)

	var _encodingProfile *EncodingProfile // out

	if _cret != nil {
		_encodingProfile = wrapEncodingProfile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _encodingProfile
}

// EncodingProfileFromDiscoverer creates a EncodingProfile matching the formats
// from the given DiscovererInfo. Streams other than audio or video (eg,
// subtitles), are currently ignored.
//
// The function takes the following parameters:
//
//   - info to read from.
//
// The function returns the following values:
//
//   - encodingProfile (optional): new EncodingProfile or NULL.
func EncodingProfileFromDiscoverer(info *DiscovererInfo) *EncodingProfile {
	var _arg1 *C.GstDiscovererInfo  // out
	var _cret *C.GstEncodingProfile // in

	_arg1 = (*C.GstDiscovererInfo)(unsafe.Pointer(coreglib.BaseObject(info).Native()))

	_cret = C.gst_encoding_profile_from_discoverer(_arg1)
	runtime.KeepAlive(info)

	var _encodingProfile *EncodingProfile // out

	if _cret != nil {
		_encodingProfile = wrapEncodingProfile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _encodingProfile
}

// EncodingTarget: collection of EncodingProfile for a specific target or
// use-case.
//
// When being stored/loaded, targets come from a specific category, like
// T_ENCODING_CATEGORY_DEVICE.
type EncodingTarget struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*EncodingTarget)(nil)
)

func wrapEncodingTarget(obj *coreglib.Object) *EncodingTarget {
	return &EncodingTarget{
		Object: obj,
	}
}

func marshalEncodingTarget(p uintptr) (interface{}, error) {
	return wrapEncodingTarget(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewEncodingTarget creates a new EncodingTarget.
//
// The name and category can only consist of lowercase ASCII letters for the
// first character, followed by either lowercase ASCII letters, digits or
// hyphens ('-').
//
// The category *should* be one of the existing well-defined categories, like
// T_ENCODING_CATEGORY_DEVICE, but it *can* be a application or user specific
// category if needed.
//
// The function takes the following parameters:
//
//   - name of the target.
//   - category: name of the category to which this target belongs. For example:
//     T_ENCODING_CATEGORY_DEVICE.
//   - description of EncodingTarget in the current locale.
//   - profiles: #GList of EncodingProfile.
//
// The function returns the following values:
//
//   - encodingTarget (optional): newly created EncodingTarget or NULL if there
//     was an error.
func NewEncodingTarget(name, category, description string, profiles []*EncodingProfile) *EncodingTarget {
	var _arg1 *C.gchar             // out
	var _arg2 *C.gchar             // out
	var _arg3 *C.gchar             // out
	var _arg4 *C.GList             // out
	var _cret *C.GstEncodingTarget // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(category)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(_arg3))
	for i := len(profiles) - 1; i >= 0; i-- {
		src := profiles[i]
		var dst *C.GstEncodingProfile // out
		dst = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(src).Native()))
		_arg4 = C.g_list_prepend(_arg4, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg4)

	_cret = C.gst_encoding_target_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(name)
	runtime.KeepAlive(category)
	runtime.KeepAlive(description)
	runtime.KeepAlive(profiles)

	var _encodingTarget *EncodingTarget // out

	if _cret != nil {
		_encodingTarget = wrapEncodingTarget(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _encodingTarget
}

// AddProfile adds the given profile to the target. Each added profile must have
// a unique name within the profile.
//
// The target will steal a reference to the profile. If you wish to use the
// profile after calling this method, you should increase its reference count.
//
// The function takes the following parameters:
//
//   - profile to add.
//
// The function returns the following values:
//
//   - ok: TRUE if the profile was added, else FALSE.
func (target *EncodingTarget) AddProfile(profile *EncodingProfile) bool {
	var _arg0 *C.GstEncodingTarget  // out
	var _arg1 *C.GstEncodingProfile // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstEncodingTarget)(unsafe.Pointer(coreglib.BaseObject(target).Native()))
	_arg1 = (*C.GstEncodingProfile)(unsafe.Pointer(coreglib.BaseObject(profile).Native()))
	C.g_object_ref(C.gpointer(coreglib.BaseObject(profile).Native()))

	_cret = C.gst_encoding_target_add_profile(_arg0, _arg1)
	runtime.KeepAlive(target)
	runtime.KeepAlive(profile)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - utf8: category of the target. For example: T_ENCODING_CATEGORY_DEVICE.
func (target *EncodingTarget) Category() string {
	var _arg0 *C.GstEncodingTarget // out
	var _cret *C.gchar             // in

	_arg0 = (*C.GstEncodingTarget)(unsafe.Pointer(coreglib.BaseObject(target).Native()))

	_cret = C.gst_encoding_target_get_category(_arg0)
	runtime.KeepAlive(target)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
//   - utf8: description of the target.
func (target *EncodingTarget) Description() string {
	var _arg0 *C.GstEncodingTarget // out
	var _cret *C.gchar             // in

	_arg0 = (*C.GstEncodingTarget)(unsafe.Pointer(coreglib.BaseObject(target).Native()))

	_cret = C.gst_encoding_target_get_description(_arg0)
	runtime.KeepAlive(target)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
//   - utf8: name of the target.
func (target *EncodingTarget) Name() string {
	var _arg0 *C.GstEncodingTarget // out
	var _cret *C.gchar             // in

	_arg0 = (*C.GstEncodingTarget)(unsafe.Pointer(coreglib.BaseObject(target).Native()))

	_cret = C.gst_encoding_target_get_name(_arg0)
	runtime.KeepAlive(target)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// The function returns the following values:
//
//   - filename (optional): path to the target file.
func (target *EncodingTarget) Path() string {
	var _arg0 *C.GstEncodingTarget // out
	var _cret *C.gchar             // in

	_arg0 = (*C.GstEncodingTarget)(unsafe.Pointer(coreglib.BaseObject(target).Native()))

	_cret = C.gst_encoding_target_get_path(_arg0)
	runtime.KeepAlive(target)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _filename
}

// The function takes the following parameters:
//
//   - name of the profile to retrieve.
//
// The function returns the following values:
//
//   - encodingProfile (optional): matching EncodingProfile, or NULL.
func (target *EncodingTarget) Profile(name string) *EncodingProfile {
	var _arg0 *C.GstEncodingTarget  // out
	var _arg1 *C.gchar              // out
	var _cret *C.GstEncodingProfile // in

	_arg0 = (*C.GstEncodingTarget)(unsafe.Pointer(coreglib.BaseObject(target).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_encoding_target_get_profile(_arg0, _arg1)
	runtime.KeepAlive(target)
	runtime.KeepAlive(name)

	var _encodingProfile *EncodingProfile // out

	if _cret != nil {
		_encodingProfile = wrapEncodingProfile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _encodingProfile
}

// The function returns the following values:
//
//   - list of EncodingProfile(s) this target handles.
func (target *EncodingTarget) Profiles() []*EncodingProfile {
	var _arg0 *C.GstEncodingTarget // out
	var _cret *C.GList             // in

	_arg0 = (*C.GstEncodingTarget)(unsafe.Pointer(coreglib.BaseObject(target).Native()))

	_cret = C.gst_encoding_target_get_profiles(_arg0)
	runtime.KeepAlive(target)

	var _list []*EncodingProfile // out

	_list = make([]*EncodingProfile, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GstEncodingProfile)(v)
		var dst *EncodingProfile // out
		dst = wrapEncodingProfile(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// Save saves the target to a default user-local directory.
func (target *EncodingTarget) Save() error {
	var _arg0 *C.GstEncodingTarget // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GstEncodingTarget)(unsafe.Pointer(coreglib.BaseObject(target).Native()))

	C.gst_encoding_target_save(_arg0, &_cerr)
	runtime.KeepAlive(target)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SaveToFile saves the target to the provided file location.
//
// The function takes the following parameters:
//
//   - filepath: location to store the target at.
func (target *EncodingTarget) SaveToFile(filepath string) error {
	var _arg0 *C.GstEncodingTarget // out
	var _arg1 *C.gchar             // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GstEncodingTarget)(unsafe.Pointer(coreglib.BaseObject(target).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filepath)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_encoding_target_save_to_file(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(target)
	runtime.KeepAlive(filepath)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// EncodingTargetLoad searches for the EncodingTarget with the given name,
// loads it and returns it.
//
// If the category name is specified only targets from that category will be
// searched for.
//
// The function takes the following parameters:
//
//   - name of the EncodingTarget to load (automatically converted to lower case
//     internally as capital letters are not valid for target names).
//   - category (optional): name of the target category, like
//     T_ENCODING_CATEGORY_DEVICE. Can be NULL.
//
// The function returns the following values:
//
//   - encodingTarget if available, else NULL.
func EncodingTargetLoad(name, category string) (*EncodingTarget, error) {
	var _arg1 *C.gchar             // out
	var _arg2 *C.gchar             // out
	var _cret *C.GstEncodingTarget // in
	var _cerr *C.GError            // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	if category != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(category)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gst_encoding_target_load(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(name)
	runtime.KeepAlive(category)

	var _encodingTarget *EncodingTarget // out
	var _goerr error                    // out

	_encodingTarget = wrapEncodingTarget(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _encodingTarget, _goerr
}

// EncodingTargetLoadFromFile opens the provided file and returns the contained
// EncodingTarget.
//
// The function takes the following parameters:
//
//   - filepath: file location to load the EncodingTarget from.
//
// The function returns the following values:
//
//   - encodingTarget contained in the file, else NULL.
func EncodingTargetLoadFromFile(filepath string) (*EncodingTarget, error) {
	var _arg1 *C.gchar             // out
	var _cret *C.GstEncodingTarget // in
	var _cerr *C.GError            // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filepath)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_encoding_target_load_from_file(_arg1, &_cerr)
	runtime.KeepAlive(filepath)

	var _encodingTarget *EncodingTarget // out
	var _goerr error                    // out

	_encodingTarget = wrapEncodingTarget(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _encodingTarget, _goerr
}

// EncodingVideoProfile: variant of EncodingProfile for video streams, allows
// specifying the pass.
type EncodingVideoProfile struct {
	_ [0]func() // equal guard
	EncodingProfile
}

var (
	_ coreglib.Objector = (*EncodingVideoProfile)(nil)
)

func wrapEncodingVideoProfile(obj *coreglib.Object) *EncodingVideoProfile {
	return &EncodingVideoProfile{
		EncodingProfile: EncodingProfile{
			Object: obj,
		},
	}
}

func marshalEncodingVideoProfile(p uintptr) (interface{}, error) {
	return wrapEncodingVideoProfile(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewEncodingVideoProfile creates a new EncodingVideoProfile
//
// All provided allocatable arguments will be internally copied, so can be
// safely freed/unreferenced after calling this method.
//
// If you wish to control the pass number (in case of multi-pass scenarios),
// please refer to the gst_encoding_video_profile_set_pass() documentation.
//
// If you wish to use/force a constant framerate please refer to the
// gst_encoding_video_profile_set_variableframerate() documentation.
//
// The function takes the following parameters:
//
//   - format: Caps.
//   - preset (optional): preset(s) to use on the encoder, can be NULL.
//   - restriction (optional) used to restrict the input to the encoder,
//     can be NULL. See gst_encoding_profile_get_restriction() for more details.
//   - presence: number of time this stream must be used. 0 means any number of
//     times (including never).
//
// The function returns the following values:
//
//   - encodingVideoProfile: newly created EncodingVideoProfile.
func NewEncodingVideoProfile(format *gst.Caps, preset string, restriction *gst.Caps, presence uint) *EncodingVideoProfile {
	var _arg1 *C.GstCaps                 // out
	var _arg2 *C.gchar                   // out
	var _arg3 *C.GstCaps                 // out
	var _arg4 C.guint                    // out
	var _cret *C.GstEncodingVideoProfile // in

	_arg1 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(format)))
	if preset != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(preset)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if restriction != nil {
		_arg3 = (*C.GstCaps)(gextras.StructNative(unsafe.Pointer(restriction)))
	}
	_arg4 = C.guint(presence)

	_cret = C.gst_encoding_video_profile_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(format)
	runtime.KeepAlive(preset)
	runtime.KeepAlive(restriction)
	runtime.KeepAlive(presence)

	var _encodingVideoProfile *EncodingVideoProfile // out

	_encodingVideoProfile = wrapEncodingVideoProfile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _encodingVideoProfile
}

// Pass: get the pass number if this is part of a multi-pass profile.
//
// The function returns the following values:
//
//   - guint pass number. Starts at 1 for multi-pass. 0 if this is not a
//     multi-pass profile.
func (prof *EncodingVideoProfile) Pass() uint {
	var _arg0 *C.GstEncodingVideoProfile // out
	var _cret C.guint                    // in

	_arg0 = (*C.GstEncodingVideoProfile)(unsafe.Pointer(coreglib.BaseObject(prof).Native()))

	_cret = C.gst_encoding_video_profile_get_pass(_arg0)
	runtime.KeepAlive(prof)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Variableframerate: > *NOTE*: Fixed framerate won't be enforced when
// #encodebin:avoid-reencoding > is set.
//
// The function returns the following values:
//
//   - ok: whether non-constant video framerate is allowed for encoding.
func (prof *EncodingVideoProfile) Variableframerate() bool {
	var _arg0 *C.GstEncodingVideoProfile // out
	var _cret C.gboolean                 // in

	_arg0 = (*C.GstEncodingVideoProfile)(unsafe.Pointer(coreglib.BaseObject(prof).Native()))

	_cret = C.gst_encoding_video_profile_get_variableframerate(_arg0)
	runtime.KeepAlive(prof)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetPass sets the pass number of this video profile. The first pass profile
// should have this value set to 1. If this video profile isn't part of a
// multi-pass profile, you may set it to 0 (the default value).
//
// The function takes the following parameters:
//
//   - pass number for this profile.
func (prof *EncodingVideoProfile) SetPass(pass uint) {
	var _arg0 *C.GstEncodingVideoProfile // out
	var _arg1 C.guint                    // out

	_arg0 = (*C.GstEncodingVideoProfile)(unsafe.Pointer(coreglib.BaseObject(prof).Native()))
	_arg1 = C.guint(pass)

	C.gst_encoding_video_profile_set_pass(_arg0, _arg1)
	runtime.KeepAlive(prof)
	runtime.KeepAlive(pass)
}

// SetVariableframerate: if set to TRUE, then the incoming stream will be
// allowed to have non-constant framerate. If set to FALSE (default value),
// then the incoming stream will be normalized by dropping/duplicating frames in
// order to produce a constance framerate.
//
// The function takes the following parameters:
//
//   - variableframerate: boolean.
func (prof *EncodingVideoProfile) SetVariableframerate(variableframerate bool) {
	var _arg0 *C.GstEncodingVideoProfile // out
	var _arg1 C.gboolean                 // out

	_arg0 = (*C.GstEncodingVideoProfile)(unsafe.Pointer(coreglib.BaseObject(prof).Native()))
	if variableframerate {
		_arg1 = C.TRUE
	}

	C.gst_encoding_video_profile_set_variableframerate(_arg0, _arg1)
	runtime.KeepAlive(prof)
	runtime.KeepAlive(variableframerate)
}

// AudioVisualizerClass: instance of this type is always passed by reference.
type AudioVisualizerClass struct {
	*audioVisualizerClass
}

// audioVisualizerClass is the struct that's finalized.
type audioVisualizerClass struct {
	native *C.GstAudioVisualizerClass
}

// DiscovererClass: instance of this type is always passed by reference.
type DiscovererClass struct {
	*discovererClass
}

// discovererClass is the struct that's finalized.
type discovererClass struct {
	native *C.GstDiscovererClass
}

func (d *DiscovererClass) Reserved() [3]unsafe.Pointer {
	valptr := &d.native._reserved
	var _v [3]unsafe.Pointer // out
	{
		src := &*valptr
		for i := 0; i < 3; i++ {
			_v[i] = (unsafe.Pointer)(unsafe.Pointer(src[i]))
		}
	}
	return _v
}

// InstallPluginsContext: opaque context structure for the plugin installation.
// Use the provided API to set details on it.
//
// An instance of this type is always passed by reference.
type InstallPluginsContext struct {
	*installPluginsContext
}

// installPluginsContext is the struct that's finalized.
type installPluginsContext struct {
	native *C.GstInstallPluginsContext
}

func marshalInstallPluginsContext(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &InstallPluginsContext{&installPluginsContext{(*C.GstInstallPluginsContext)(b)}}, nil
}

// NewInstallPluginsContext constructs a struct InstallPluginsContext.
func NewInstallPluginsContext() *InstallPluginsContext {
	var _cret *C.GstInstallPluginsContext // in

	_cret = C.gst_install_plugins_context_new()

	var _installPluginsContext *InstallPluginsContext // out

	_installPluginsContext = (*InstallPluginsContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_installPluginsContext)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_install_plugins_context_free((*C.GstInstallPluginsContext)(intern.C))
		},
	)

	return _installPluginsContext
}

// Copy copies a InstallPluginsContext.
//
// The function returns the following values:
//
//   - installPluginsContext: copy of ctx.
func (ctx *InstallPluginsContext) Copy() *InstallPluginsContext {
	var _arg0 *C.GstInstallPluginsContext // out
	var _cret *C.GstInstallPluginsContext // in

	_arg0 = (*C.GstInstallPluginsContext)(gextras.StructNative(unsafe.Pointer(ctx)))

	_cret = C.gst_install_plugins_context_copy(_arg0)
	runtime.KeepAlive(ctx)

	var _installPluginsContext *InstallPluginsContext // out

	_installPluginsContext = (*InstallPluginsContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_installPluginsContext)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_install_plugins_context_free((*C.GstInstallPluginsContext)(intern.C))
		},
	)

	return _installPluginsContext
}

// SetConfirmSearch: this function is used to tell the external installer
// process whether it should ask for confirmation or not before searching for
// missing plugins.
//
// If set, this option will be passed to the installer via a
// --interaction=[show-confirm-search|hide-confirm-search] command line option.
//
// The function takes the following parameters:
//
//   - confirmSearch: whether to ask for confirmation before searching for
//     plugins.
func (ctx *InstallPluginsContext) SetConfirmSearch(confirmSearch bool) {
	var _arg0 *C.GstInstallPluginsContext // out
	var _arg1 C.gboolean                  // out

	_arg0 = (*C.GstInstallPluginsContext)(gextras.StructNative(unsafe.Pointer(ctx)))
	if confirmSearch {
		_arg1 = C.TRUE
	}

	C.gst_install_plugins_context_set_confirm_search(_arg0, _arg1)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(confirmSearch)
}

// SetDesktopID: this function is used to pass the calling application's desktop
// file ID to the external installer process.
//
// A desktop file ID is the basename of the desktop file, including the .desktop
// extension.
//
// If set, the desktop file ID will be passed to the installer via a
// --desktop-id= command line option.
//
// The function takes the following parameters:
//
//   - desktopId: desktop file ID of the calling application.
func (ctx *InstallPluginsContext) SetDesktopID(desktopId string) {
	var _arg0 *C.GstInstallPluginsContext // out
	var _arg1 *C.gchar                    // out

	_arg0 = (*C.GstInstallPluginsContext)(gextras.StructNative(unsafe.Pointer(ctx)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(desktopId)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_install_plugins_context_set_desktop_id(_arg0, _arg1)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(desktopId)
}

// SetStartupNotificationID sets the startup notification ID for the launched
// process.
//
// This is typically used to to pass the current X11 event timestamp to the
// external installer process.
//
// Startup notification IDs are defined in the
// FreeDesktop.Org Startup Notifications standard
// (http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
//
// If set, the ID will be passed to the installer via a
// --startup-notification-id= command line option.
//
// GTK+/GNOME applications should be able to create a startup notification ID
// like this:
//
//	  timestamp = gtk_get_current_event_time ();
//	  startup_id = g_strdup_printf ("_TIMEu", timestamp);
//	...
//
// The function takes the following parameters:
//
//   - startupId: startup notification ID.
func (ctx *InstallPluginsContext) SetStartupNotificationID(startupId string) {
	var _arg0 *C.GstInstallPluginsContext // out
	var _arg1 *C.gchar                    // out

	_arg0 = (*C.GstInstallPluginsContext)(gextras.StructNative(unsafe.Pointer(ctx)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(startupId)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_install_plugins_context_set_startup_notification_id(_arg0, _arg1)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(startupId)
}

// SetXid: this function is for X11-based applications (such as most Gtk/Qt
// applications on linux/unix) only. You can use it to tell the external
// installer the XID of your main application window. That way the installer
// can make its own window transient to your application window during the
// installation.
//
// If set, the XID will be passed to the installer via a --transient-for=XID
// command line option.
//
// Gtk+/Gnome application should be able to obtain the XID of the top-level
// window like this:
//
//	##include <gtk/gtk.h>
//	##ifdef GDK_WINDOWING_X11
//	##include <gdk/gdkx.h>
//	##endif
//	...
//	##ifdef GDK_WINDOWING_X11
//	  xid = GDK_WINDOW_XWINDOW (GTK_WIDGET (application_window)->window);
//	##endif
//	...
//
// The function takes the following parameters:
//
//   - xid: XWindow ID (XID) of the top-level application.
func (ctx *InstallPluginsContext) SetXid(xid uint) {
	var _arg0 *C.GstInstallPluginsContext // out
	var _arg1 C.guint                     // out

	_arg0 = (*C.GstInstallPluginsContext)(gextras.StructNative(unsafe.Pointer(ctx)))
	_arg1 = C.guint(xid)

	C.gst_install_plugins_context_set_xid(_arg0, _arg1)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(xid)
}
