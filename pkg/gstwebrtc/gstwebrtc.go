// Code generated by girgen. DO NOT EDIT.

package gstwebrtc

import (
	"fmt"
	"runtime"
	_ "runtime/cgo"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/go-gst/go-gst/pkg/gst"
	"github.com/go-gst/go-gst/pkg/gstsdp"
)

// #cgo pkg-config: gstreamer-webrtc-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <gst/webrtc/webrtc.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_gstwebrtc1_WebRTCICETransport_ConnectOnSelectedCandidatePairChange(gpointer, guintptr);
// extern void _gotk4_gstwebrtc1_WebRTCICETransport_ConnectOnNewCandidate(gpointer, gchar*, guintptr);
// extern void _gotk4_gstwebrtc1_WebRTCICEOnCandidateFunc(GstWebRTCICE*, guint, gchar*, gpointer);
// extern void _gotk4_gstwebrtc1_WebRTCICEClass_set_turn_server(GstWebRTCICE*, gchar*);
// extern void _gotk4_gstwebrtc1_WebRTCICEClass_set_tos(GstWebRTCICE*, GstWebRTCICEStream*, guint);
// extern void _gotk4_gstwebrtc1_WebRTCICEClass_set_stun_server(GstWebRTCICE*, gchar*);
// extern void _gotk4_gstwebrtc1_WebRTCICEClass_set_is_controller(GstWebRTCICE*, gboolean);
// extern void _gotk4_gstwebrtc1_WebRTCICEClass_set_http_proxy(GstWebRTCICE*, gchar*);
// extern void _gotk4_gstwebrtc1_WebRTCICEClass_set_force_relay(GstWebRTCICE*, gboolean);
// extern void _gotk4_gstwebrtc1_WebRTCICEClass_add_candidate(GstWebRTCICE*, GstWebRTCICEStream*, gchar*, GstPromise*);
// extern void _gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnOpen(gpointer, guintptr);
// extern void _gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnMessageString(gpointer, gchar*, guintptr);
// extern void _gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnMessageData(gpointer, GBytes*, guintptr);
// extern void _gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnError(gpointer, GError*, guintptr);
// extern void _gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnClose(gpointer, guintptr);
// extern void _gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnBufferedAmountLow(gpointer, guintptr);
// extern gchar* _gotk4_gstwebrtc1_WebRTCICEClass_get_turn_server(GstWebRTCICE*);
// extern gchar* _gotk4_gstwebrtc1_WebRTCICEClass_get_stun_server(GstWebRTCICE*);
// extern gchar* _gotk4_gstwebrtc1_WebRTCICEClass_get_http_proxy(GstWebRTCICE*);
// extern gboolean _gotk4_gstwebrtc1_WebRTCICETransportClass_gather_candidates(GstWebRTCICETransport*);
// extern gboolean _gotk4_gstwebrtc1_WebRTCICEStreamClass_gather_candidates(GstWebRTCICEStream*);
// extern gboolean _gotk4_gstwebrtc1_WebRTCICEClass_set_remote_credentials(GstWebRTCICE*, GstWebRTCICEStream*, gchar*, gchar*);
// extern gboolean _gotk4_gstwebrtc1_WebRTCICEClass_set_local_credentials(GstWebRTCICE*, GstWebRTCICEStream*, gchar*, gchar*);
// extern gboolean _gotk4_gstwebrtc1_WebRTCICEClass_get_selected_pair(GstWebRTCICE*, GstWebRTCICEStream*, GstWebRTCICECandidateStats**, GstWebRTCICECandidateStats**);
// extern gboolean _gotk4_gstwebrtc1_WebRTCICEClass_get_is_controller(GstWebRTCICE*);
// extern gboolean _gotk4_gstwebrtc1_WebRTCICEClass_gather_candidates(GstWebRTCICE*, GstWebRTCICEStream*);
// extern gboolean _gotk4_gstwebrtc1_WebRTCICEClass_add_turn_server(GstWebRTCICE*, gchar*);
// extern GstWebRTCICETransport* _gotk4_gstwebrtc1_WebRTCICEStreamClass_find_transport(GstWebRTCICEStream*, GstWebRTCICEComponent);
// extern GstWebRTCICETransport* _gotk4_gstwebrtc1_WebRTCICEClass_find_transport(GstWebRTCICE*, GstWebRTCICEStream*, GstWebRTCICEComponent);
// extern GstWebRTCICEStream* _gotk4_gstwebrtc1_WebRTCICEClass_add_stream(GstWebRTCICE*, guint);
// GstWebRTCICECandidateStats** _gotk4_gstwebrtc1_WebRTCICE_virtual_get_local_candidates(void* fnptr, GstWebRTCICE* arg0, GstWebRTCICEStream* arg1) {
//   return ((GstWebRTCICECandidateStats** (*)(GstWebRTCICE*, GstWebRTCICEStream*))(fnptr))(arg0, arg1);
// };
// GstWebRTCICECandidateStats** _gotk4_gstwebrtc1_WebRTCICE_virtual_get_remote_candidates(void* fnptr, GstWebRTCICE* arg0, GstWebRTCICEStream* arg1) {
//   return ((GstWebRTCICECandidateStats** (*)(GstWebRTCICE*, GstWebRTCICEStream*))(fnptr))(arg0, arg1);
// };
// GstWebRTCICEStream* _gotk4_gstwebrtc1_WebRTCICE_virtual_add_stream(void* fnptr, GstWebRTCICE* arg0, guint arg1) {
//   return ((GstWebRTCICEStream* (*)(GstWebRTCICE*, guint))(fnptr))(arg0, arg1);
// };
// GstWebRTCICETransport* _gotk4_gstwebrtc1_WebRTCICEStream_virtual_find_transport(void* fnptr, GstWebRTCICEStream* arg0, GstWebRTCICEComponent arg1) {
//   return ((GstWebRTCICETransport* (*)(GstWebRTCICEStream*, GstWebRTCICEComponent))(fnptr))(arg0, arg1);
// };
// GstWebRTCICETransport* _gotk4_gstwebrtc1_WebRTCICE_virtual_find_transport(void* fnptr, GstWebRTCICE* arg0, GstWebRTCICEStream* arg1, GstWebRTCICEComponent arg2) {
//   return ((GstWebRTCICETransport* (*)(GstWebRTCICE*, GstWebRTCICEStream*, GstWebRTCICEComponent))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gstwebrtc1_WebRTCICEStream_virtual_gather_candidates(void* fnptr, GstWebRTCICEStream* arg0) {
//   return ((gboolean (*)(GstWebRTCICEStream*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstwebrtc1_WebRTCICETransport_virtual_gather_candidates(void* fnptr, GstWebRTCICETransport* arg0) {
//   return ((gboolean (*)(GstWebRTCICETransport*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstwebrtc1_WebRTCICE_virtual_add_turn_server(void* fnptr, GstWebRTCICE* arg0, gchar* arg1) {
//   return ((gboolean (*)(GstWebRTCICE*, gchar*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstwebrtc1_WebRTCICE_virtual_gather_candidates(void* fnptr, GstWebRTCICE* arg0, GstWebRTCICEStream* arg1) {
//   return ((gboolean (*)(GstWebRTCICE*, GstWebRTCICEStream*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gstwebrtc1_WebRTCICE_virtual_get_is_controller(void* fnptr, GstWebRTCICE* arg0) {
//   return ((gboolean (*)(GstWebRTCICE*))(fnptr))(arg0);
// };
// gboolean _gotk4_gstwebrtc1_WebRTCICE_virtual_get_selected_pair(void* fnptr, GstWebRTCICE* arg0, GstWebRTCICEStream* arg1, GstWebRTCICECandidateStats** arg2, GstWebRTCICECandidateStats** arg3) {
//   return ((gboolean (*)(GstWebRTCICE*, GstWebRTCICEStream*, GstWebRTCICECandidateStats**, GstWebRTCICECandidateStats**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gstwebrtc1_WebRTCICE_virtual_set_local_credentials(void* fnptr, GstWebRTCICE* arg0, GstWebRTCICEStream* arg1, gchar* arg2, gchar* arg3) {
//   return ((gboolean (*)(GstWebRTCICE*, GstWebRTCICEStream*, gchar*, gchar*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gstwebrtc1_WebRTCICE_virtual_set_remote_credentials(void* fnptr, GstWebRTCICE* arg0, GstWebRTCICEStream* arg1, gchar* arg2, gchar* arg3) {
//   return ((gboolean (*)(GstWebRTCICE*, GstWebRTCICEStream*, gchar*, gchar*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gchar* _gotk4_gstwebrtc1_WebRTCICE_virtual_get_http_proxy(void* fnptr, GstWebRTCICE* arg0) {
//   return ((gchar* (*)(GstWebRTCICE*))(fnptr))(arg0);
// };
// gchar* _gotk4_gstwebrtc1_WebRTCICE_virtual_get_stun_server(void* fnptr, GstWebRTCICE* arg0) {
//   return ((gchar* (*)(GstWebRTCICE*))(fnptr))(arg0);
// };
// gchar* _gotk4_gstwebrtc1_WebRTCICE_virtual_get_turn_server(void* fnptr, GstWebRTCICE* arg0) {
//   return ((gchar* (*)(GstWebRTCICE*))(fnptr))(arg0);
// };
// void _gotk4_gstwebrtc1_WebRTCICE_virtual_add_candidate(void* fnptr, GstWebRTCICE* arg0, GstWebRTCICEStream* arg1, gchar* arg2, GstPromise* arg3) {
//   ((void (*)(GstWebRTCICE*, GstWebRTCICEStream*, gchar*, GstPromise*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gstwebrtc1_WebRTCICE_virtual_set_force_relay(void* fnptr, GstWebRTCICE* arg0, gboolean arg1) {
//   ((void (*)(GstWebRTCICE*, gboolean))(fnptr))(arg0, arg1);
// };
// void _gotk4_gstwebrtc1_WebRTCICE_virtual_set_http_proxy(void* fnptr, GstWebRTCICE* arg0, gchar* arg1) {
//   ((void (*)(GstWebRTCICE*, gchar*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gstwebrtc1_WebRTCICE_virtual_set_is_controller(void* fnptr, GstWebRTCICE* arg0, gboolean arg1) {
//   ((void (*)(GstWebRTCICE*, gboolean))(fnptr))(arg0, arg1);
// };
// void _gotk4_gstwebrtc1_WebRTCICE_virtual_set_on_ice_candidate(void* fnptr, GstWebRTCICE* arg0, GstWebRTCICEOnCandidateFunc arg1, gpointer arg2, GDestroyNotify arg3) {
//   ((void (*)(GstWebRTCICE*, GstWebRTCICEOnCandidateFunc, gpointer, GDestroyNotify))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gstwebrtc1_WebRTCICE_virtual_set_stun_server(void* fnptr, GstWebRTCICE* arg0, gchar* arg1) {
//   ((void (*)(GstWebRTCICE*, gchar*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gstwebrtc1_WebRTCICE_virtual_set_tos(void* fnptr, GstWebRTCICE* arg0, GstWebRTCICEStream* arg1, guint arg2) {
//   ((void (*)(GstWebRTCICE*, GstWebRTCICEStream*, guint))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gstwebrtc1_WebRTCICE_virtual_set_turn_server(void* fnptr, GstWebRTCICE* arg0, gchar* arg1) {
//   ((void (*)(GstWebRTCICE*, gchar*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeWebRTCBundlePolicy            = coreglib.Type(C.gst_webrtc_bundle_policy_get_type())
	GTypeWebRTCDTLSSetup               = coreglib.Type(C.gst_webrtc_dtls_setup_get_type())
	GTypeWebRTCDTLSTransportState      = coreglib.Type(C.gst_webrtc_dtls_transport_state_get_type())
	GTypeWebRTCDataChannelState        = coreglib.Type(C.gst_webrtc_data_channel_state_get_type())
	GTypeWebRTCError                   = coreglib.Type(C.gst_webrtc_error_get_type())
	GTypeWebRTCFECType                 = coreglib.Type(C.gst_webrtc_fec_type_get_type())
	GTypeWebRTCICEComponent            = coreglib.Type(C.gst_webrtc_ice_component_get_type())
	GTypeWebRTCICEConnectionState      = coreglib.Type(C.gst_webrtc_ice_connection_state_get_type())
	GTypeWebRTCICEGatheringState       = coreglib.Type(C.gst_webrtc_ice_gathering_state_get_type())
	GTypeWebRTCICERole                 = coreglib.Type(C.gst_webrtc_ice_role_get_type())
	GTypeWebRTCICETransportPolicy      = coreglib.Type(C.gst_webrtc_ice_transport_policy_get_type())
	GTypeWebRTCKind                    = coreglib.Type(C.gst_webrtc_kind_get_type())
	GTypeWebRTCPeerConnectionState     = coreglib.Type(C.gst_webrtc_peer_connection_state_get_type())
	GTypeWebRTCPriorityType            = coreglib.Type(C.gst_webrtc_priority_type_get_type())
	GTypeWebRTCRTPTransceiverDirection = coreglib.Type(C.gst_webrtc_rtp_transceiver_direction_get_type())
	GTypeWebRTCSCTPTransportState      = coreglib.Type(C.gst_webrtc_sctp_transport_state_get_type())
	GTypeWebRTCSDPType                 = coreglib.Type(C.gst_webrtc_sdp_type_get_type())
	GTypeWebRTCSignalingState          = coreglib.Type(C.gst_webrtc_signaling_state_get_type())
	GTypeWebRTCStatsType               = coreglib.Type(C.gst_webrtc_stats_type_get_type())
	GTypeWebRTCDTLSTransport           = coreglib.Type(C.gst_webrtc_dtls_transport_get_type())
	GTypeWebRTCDataChannel             = coreglib.Type(C.gst_webrtc_data_channel_get_type())
	GTypeWebRTCICE                     = coreglib.Type(C.gst_webrtc_ice_get_type())
	GTypeWebRTCICEStream               = coreglib.Type(C.gst_webrtc_ice_stream_get_type())
	GTypeWebRTCICETransport            = coreglib.Type(C.gst_webrtc_ice_transport_get_type())
	GTypeWebRTCRTPReceiver             = coreglib.Type(C.gst_webrtc_rtp_receiver_get_type())
	GTypeWebRTCRTPSender               = coreglib.Type(C.gst_webrtc_rtp_sender_get_type())
	GTypeWebRTCRTPTransceiver          = coreglib.Type(C.gst_webrtc_rtp_transceiver_get_type())
	GTypeWebRTCSCTPTransport           = coreglib.Type(C.gst_webrtc_sctp_transport_get_type())
	GTypeWebRTCICECandidateStats       = coreglib.Type(C.gst_webrtc_ice_candidate_stats_get_type())
	GTypeWebRTCSessionDescription      = coreglib.Type(C.gst_webrtc_session_description_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeWebRTCBundlePolicy, F: marshalWebRTCBundlePolicy},
		coreglib.TypeMarshaler{T: GTypeWebRTCDTLSSetup, F: marshalWebRTCDTLSSetup},
		coreglib.TypeMarshaler{T: GTypeWebRTCDTLSTransportState, F: marshalWebRTCDTLSTransportState},
		coreglib.TypeMarshaler{T: GTypeWebRTCDataChannelState, F: marshalWebRTCDataChannelState},
		coreglib.TypeMarshaler{T: GTypeWebRTCError, F: marshalWebRTCError},
		coreglib.TypeMarshaler{T: GTypeWebRTCFECType, F: marshalWebRTCFECType},
		coreglib.TypeMarshaler{T: GTypeWebRTCICEComponent, F: marshalWebRTCICEComponent},
		coreglib.TypeMarshaler{T: GTypeWebRTCICEConnectionState, F: marshalWebRTCICEConnectionState},
		coreglib.TypeMarshaler{T: GTypeWebRTCICEGatheringState, F: marshalWebRTCICEGatheringState},
		coreglib.TypeMarshaler{T: GTypeWebRTCICERole, F: marshalWebRTCICERole},
		coreglib.TypeMarshaler{T: GTypeWebRTCICETransportPolicy, F: marshalWebRTCICETransportPolicy},
		coreglib.TypeMarshaler{T: GTypeWebRTCKind, F: marshalWebRTCKind},
		coreglib.TypeMarshaler{T: GTypeWebRTCPeerConnectionState, F: marshalWebRTCPeerConnectionState},
		coreglib.TypeMarshaler{T: GTypeWebRTCPriorityType, F: marshalWebRTCPriorityType},
		coreglib.TypeMarshaler{T: GTypeWebRTCRTPTransceiverDirection, F: marshalWebRTCRTPTransceiverDirection},
		coreglib.TypeMarshaler{T: GTypeWebRTCSCTPTransportState, F: marshalWebRTCSCTPTransportState},
		coreglib.TypeMarshaler{T: GTypeWebRTCSDPType, F: marshalWebRTCSDPType},
		coreglib.TypeMarshaler{T: GTypeWebRTCSignalingState, F: marshalWebRTCSignalingState},
		coreglib.TypeMarshaler{T: GTypeWebRTCStatsType, F: marshalWebRTCStatsType},
		coreglib.TypeMarshaler{T: GTypeWebRTCDTLSTransport, F: marshalWebRTCDTLSTransport},
		coreglib.TypeMarshaler{T: GTypeWebRTCDataChannel, F: marshalWebRTCDataChannel},
		coreglib.TypeMarshaler{T: GTypeWebRTCICE, F: marshalWebRTCICE},
		coreglib.TypeMarshaler{T: GTypeWebRTCICEStream, F: marshalWebRTCICEStream},
		coreglib.TypeMarshaler{T: GTypeWebRTCICETransport, F: marshalWebRTCICETransport},
		coreglib.TypeMarshaler{T: GTypeWebRTCRTPReceiver, F: marshalWebRTCRTPReceiver},
		coreglib.TypeMarshaler{T: GTypeWebRTCRTPSender, F: marshalWebRTCRTPSender},
		coreglib.TypeMarshaler{T: GTypeWebRTCRTPTransceiver, F: marshalWebRTCRTPTransceiver},
		coreglib.TypeMarshaler{T: GTypeWebRTCSCTPTransport, F: marshalWebRTCSCTPTransport},
		coreglib.TypeMarshaler{T: GTypeWebRTCICECandidateStats, F: marshalWebRTCICECandidateStats},
		coreglib.TypeMarshaler{T: GTypeWebRTCSessionDescription, F: marshalWebRTCSessionDescription},
	})
}

// WebRTCBundlePolicy: see
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-24#section-4.1.1 for more
// information.
type WebRTCBundlePolicy C.gint

const (
	// WebrtcBundlePolicyNone: none.
	WebrtcBundlePolicyNone WebRTCBundlePolicy = iota
	// WebrtcBundlePolicyBalanced: balanced.
	WebrtcBundlePolicyBalanced
	// WebrtcBundlePolicyMaxCompat: max-compat.
	WebrtcBundlePolicyMaxCompat
	// WebrtcBundlePolicyMaxBundle: max-bundle.
	WebrtcBundlePolicyMaxBundle
)

func marshalWebRTCBundlePolicy(p uintptr) (interface{}, error) {
	return WebRTCBundlePolicy(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WebRTCBundlePolicy.
func (w WebRTCBundlePolicy) String() string {
	switch w {
	case WebrtcBundlePolicyNone:
		return "None"
	case WebrtcBundlePolicyBalanced:
		return "Balanced"
	case WebrtcBundlePolicyMaxCompat:
		return "MaxCompat"
	case WebrtcBundlePolicyMaxBundle:
		return "MaxBundle"
	default:
		return fmt.Sprintf("WebRTCBundlePolicy(%d)", w)
	}
}

type WebRTCDTLSSetup C.gint

const (
	// WebrtcDTLSSetupNone: none.
	WebrtcDTLSSetupNone WebRTCDTLSSetup = iota
	// WebrtcDTLSSetupActpass: actpass.
	WebrtcDTLSSetupActpass
	// WebrtcDTLSSetupActive: sendonly.
	WebrtcDTLSSetupActive
	// WebrtcDTLSSetupPassive: recvonly.
	WebrtcDTLSSetupPassive
)

func marshalWebRTCDTLSSetup(p uintptr) (interface{}, error) {
	return WebRTCDTLSSetup(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WebRTCDTLSSetup.
func (w WebRTCDTLSSetup) String() string {
	switch w {
	case WebrtcDTLSSetupNone:
		return "None"
	case WebrtcDTLSSetupActpass:
		return "Actpass"
	case WebrtcDTLSSetupActive:
		return "Active"
	case WebrtcDTLSSetupPassive:
		return "Passive"
	default:
		return fmt.Sprintf("WebRTCDTLSSetup(%d)", w)
	}
}

type WebRTCDTLSTransportState C.gint

const (
	// NewWebrtcDTLSTransportState: new.
	NewWebrtcDTLSTransportState WebRTCDTLSTransportState = iota
	// WebrtcDTLSTransportStateClosed: closed.
	WebrtcDTLSTransportStateClosed
	// WebrtcDTLSTransportStateFailed: failed.
	WebrtcDTLSTransportStateFailed
	// WebrtcDTLSTransportStateConnecting: connecting.
	WebrtcDTLSTransportStateConnecting
	// WebrtcDTLSTransportStateConnected: connected.
	WebrtcDTLSTransportStateConnected
)

func marshalWebRTCDTLSTransportState(p uintptr) (interface{}, error) {
	return WebRTCDTLSTransportState(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WebRTCDTLSTransportState.
func (w WebRTCDTLSTransportState) String() string {
	switch w {
	case NewWebrtcDTLSTransportState:
		return "New"
	case WebrtcDTLSTransportStateClosed:
		return "Closed"
	case WebrtcDTLSTransportStateFailed:
		return "Failed"
	case WebrtcDTLSTransportStateConnecting:
		return "Connecting"
	case WebrtcDTLSTransportStateConnected:
		return "Connected"
	default:
		return fmt.Sprintf("WebRTCDTLSTransportState(%d)", w)
	}
}

// WebRTCDataChannelState: see
// <http://w3c.github.io/webrtc-pc/#dom-rtcdatachannelstate>.
type WebRTCDataChannelState C.gint

const (
	// WebrtcDataChannelStateConnecting: connecting.
	WebrtcDataChannelStateConnecting WebRTCDataChannelState = 1
	// WebrtcDataChannelStateOpen: open.
	WebrtcDataChannelStateOpen WebRTCDataChannelState = 2
	// WebrtcDataChannelStateClosing: closing.
	WebrtcDataChannelStateClosing WebRTCDataChannelState = 3
	// WebrtcDataChannelStateClosed: closed.
	WebrtcDataChannelStateClosed WebRTCDataChannelState = 4
)

func marshalWebRTCDataChannelState(p uintptr) (interface{}, error) {
	return WebRTCDataChannelState(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WebRTCDataChannelState.
func (w WebRTCDataChannelState) String() string {
	switch w {
	case WebrtcDataChannelStateConnecting:
		return "Connecting"
	case WebrtcDataChannelStateOpen:
		return "Open"
	case WebrtcDataChannelStateClosing:
		return "Closing"
	case WebrtcDataChannelStateClosed:
		return "Closed"
	default:
		return fmt.Sprintf("WebRTCDataChannelState(%d)", w)
	}
}

// WebRTCError: see <https://www.w3.org/TR/webrtc/#dom-rtcerrordetailtype> for
// more information.
type WebRTCError C.gint

const (
	// WebrtcErrorDataChannelFailure: data-channel-failure.
	WebrtcErrorDataChannelFailure WebRTCError = iota
	// WebrtcErrorDTLSFailure: dtls-failure.
	WebrtcErrorDTLSFailure
	// WebrtcErrorFingerprintFailure: fingerprint-failure.
	WebrtcErrorFingerprintFailure
	// WebrtcErrorSCTPFailure: sctp-failure.
	WebrtcErrorSCTPFailure
	// WebrtcErrorSdpSyntaxError: sdp-syntax-error.
	WebrtcErrorSdpSyntaxError
	// WebrtcErrorHardwareEncoderNotAvailable: hardware-encoder-not-available.
	WebrtcErrorHardwareEncoderNotAvailable
	// WebrtcErrorEncoderError: encoder-error.
	WebrtcErrorEncoderError
	// WebrtcErrorInvalidState: invalid-state (part of WebIDL specification).
	WebrtcErrorInvalidState
	// WebrtcErrorInternalFailure: GStreamer-specific failure, not matching any
	// other value from the specification.
	WebrtcErrorInternalFailure
	// WebrtcErrorInvalidModification: invalid-modification (part of WebIDL
	// specification).
	WebrtcErrorInvalidModification
	// WebrtcErrorTypeError: type-error (maps to JavaScript TypeError).
	WebrtcErrorTypeError
)

func marshalWebRTCError(p uintptr) (interface{}, error) {
	return WebRTCError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WebRTCError.
func (w WebRTCError) String() string {
	switch w {
	case WebrtcErrorDataChannelFailure:
		return "DataChannelFailure"
	case WebrtcErrorDTLSFailure:
		return "DTLSFailure"
	case WebrtcErrorFingerprintFailure:
		return "FingerprintFailure"
	case WebrtcErrorSCTPFailure:
		return "SCTPFailure"
	case WebrtcErrorSdpSyntaxError:
		return "SdpSyntaxError"
	case WebrtcErrorHardwareEncoderNotAvailable:
		return "HardwareEncoderNotAvailable"
	case WebrtcErrorEncoderError:
		return "EncoderError"
	case WebrtcErrorInvalidState:
		return "InvalidState"
	case WebrtcErrorInternalFailure:
		return "InternalFailure"
	case WebrtcErrorInvalidModification:
		return "InvalidModification"
	case WebrtcErrorTypeError:
		return "TypeError"
	default:
		return fmt.Sprintf("WebRTCError(%d)", w)
	}
}

func WebRTCErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gst_webrtc_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

type WebRTCFECType C.gint

const (
	// WebrtcFecTypeNone: none.
	WebrtcFecTypeNone WebRTCFECType = iota
	// WebrtcFecTypeUlpRed: ulpfec + red.
	WebrtcFecTypeUlpRed
)

func marshalWebRTCFECType(p uintptr) (interface{}, error) {
	return WebRTCFECType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WebRTCFECType.
func (w WebRTCFECType) String() string {
	switch w {
	case WebrtcFecTypeNone:
		return "None"
	case WebrtcFecTypeUlpRed:
		return "UlpRed"
	default:
		return fmt.Sprintf("WebRTCFECType(%d)", w)
	}
}

type WebRTCICEComponent C.gint

const (
	// WebrtcIceComponentRtp: RTP component.
	WebrtcIceComponentRtp WebRTCICEComponent = iota
	// WebrtcIceComponentRtcp: RTCP component.
	WebrtcIceComponentRtcp
)

func marshalWebRTCICEComponent(p uintptr) (interface{}, error) {
	return WebRTCICEComponent(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WebRTCICEComponent.
func (w WebRTCICEComponent) String() string {
	switch w {
	case WebrtcIceComponentRtp:
		return "Rtp"
	case WebrtcIceComponentRtcp:
		return "Rtcp"
	default:
		return fmt.Sprintf("WebRTCICEComponent(%d)", w)
	}
}

// WebRTCICEConnectionState: see
// <http://w3c.github.io/webrtc-pc/#dom-rtciceconnectionstate>.
type WebRTCICEConnectionState C.gint

const (
	// NewWebrtcIceConnectionState: new.
	NewWebrtcIceConnectionState WebRTCICEConnectionState = iota
	// WebrtcIceConnectionStateChecking: checking.
	WebrtcIceConnectionStateChecking
	// WebrtcIceConnectionStateConnected: connected.
	WebrtcIceConnectionStateConnected
	// WebrtcIceConnectionStateCompleted: completed.
	WebrtcIceConnectionStateCompleted
	// WebrtcIceConnectionStateFailed: failed.
	WebrtcIceConnectionStateFailed
	// WebrtcIceConnectionStateDisconnected: disconnected.
	WebrtcIceConnectionStateDisconnected
	// WebrtcIceConnectionStateClosed: closed.
	WebrtcIceConnectionStateClosed
)

func marshalWebRTCICEConnectionState(p uintptr) (interface{}, error) {
	return WebRTCICEConnectionState(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WebRTCICEConnectionState.
func (w WebRTCICEConnectionState) String() string {
	switch w {
	case NewWebrtcIceConnectionState:
		return "New"
	case WebrtcIceConnectionStateChecking:
		return "Checking"
	case WebrtcIceConnectionStateConnected:
		return "Connected"
	case WebrtcIceConnectionStateCompleted:
		return "Completed"
	case WebrtcIceConnectionStateFailed:
		return "Failed"
	case WebrtcIceConnectionStateDisconnected:
		return "Disconnected"
	case WebrtcIceConnectionStateClosed:
		return "Closed"
	default:
		return fmt.Sprintf("WebRTCICEConnectionState(%d)", w)
	}
}

// WebRTCICEGatheringState: see
// <http://w3c.github.io/webrtc-pc/#dom-rtcicegatheringstate>.
type WebRTCICEGatheringState C.gint

const (
	// NewWebrtcIceGatheringState: new.
	NewWebrtcIceGatheringState WebRTCICEGatheringState = iota
	// WebrtcIceGatheringStateGathering: gathering.
	WebrtcIceGatheringStateGathering
	// WebrtcIceGatheringStateComplete: complete.
	WebrtcIceGatheringStateComplete
)

func marshalWebRTCICEGatheringState(p uintptr) (interface{}, error) {
	return WebRTCICEGatheringState(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WebRTCICEGatheringState.
func (w WebRTCICEGatheringState) String() string {
	switch w {
	case NewWebrtcIceGatheringState:
		return "New"
	case WebrtcIceGatheringStateGathering:
		return "Gathering"
	case WebrtcIceGatheringStateComplete:
		return "Complete"
	default:
		return fmt.Sprintf("WebRTCICEGatheringState(%d)", w)
	}
}

type WebRTCICERole C.gint

const (
	// WebrtcIceRoleControlled: controlled.
	WebrtcIceRoleControlled WebRTCICERole = iota
	// WebrtcIceRoleControlling: controlling.
	WebrtcIceRoleControlling
)

func marshalWebRTCICERole(p uintptr) (interface{}, error) {
	return WebRTCICERole(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WebRTCICERole.
func (w WebRTCICERole) String() string {
	switch w {
	case WebrtcIceRoleControlled:
		return "Controlled"
	case WebrtcIceRoleControlling:
		return "Controlling"
	default:
		return fmt.Sprintf("WebRTCICERole(%d)", w)
	}
}

// WebRTCICETransportPolicy: see
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-24#section-4.1.1 for more
// information.
type WebRTCICETransportPolicy C.gint

const (
	// WebrtcIceTransportPolicyAll: all.
	WebrtcIceTransportPolicyAll WebRTCICETransportPolicy = iota
	// WebrtcIceTransportPolicyRelay: relay.
	WebrtcIceTransportPolicyRelay
)

func marshalWebRTCICETransportPolicy(p uintptr) (interface{}, error) {
	return WebRTCICETransportPolicy(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WebRTCICETransportPolicy.
func (w WebRTCICETransportPolicy) String() string {
	switch w {
	case WebrtcIceTransportPolicyAll:
		return "All"
	case WebrtcIceTransportPolicyRelay:
		return "Relay"
	default:
		return fmt.Sprintf("WebRTCICETransportPolicy(%d)", w)
	}
}

// WebRTCKind:
// https://w3c.github.io/mediacapture-main/#dom-mediastreamtrack-kind.
type WebRTCKind C.gint

const (
	// WebrtcKindUnknown: kind has not yet been set.
	WebrtcKindUnknown WebRTCKind = iota
	// WebrtcKindAudio: kind is audio.
	WebrtcKindAudio
	// WebrtcKindVideo: kind is audio.
	WebrtcKindVideo
)

func marshalWebRTCKind(p uintptr) (interface{}, error) {
	return WebRTCKind(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WebRTCKind.
func (w WebRTCKind) String() string {
	switch w {
	case WebrtcKindUnknown:
		return "Unknown"
	case WebrtcKindAudio:
		return "Audio"
	case WebrtcKindVideo:
		return "Video"
	default:
		return fmt.Sprintf("WebRTCKind(%d)", w)
	}
}

// WebRTCPeerConnectionState: see
// <http://w3c.github.io/webrtc-pc/#dom-rtcpeerconnectionstate>.
type WebRTCPeerConnectionState C.gint

const (
	// NewWebrtcPeerConnectionState: new.
	NewWebrtcPeerConnectionState WebRTCPeerConnectionState = iota
	// WebrtcPeerConnectionStateConnecting: connecting.
	WebrtcPeerConnectionStateConnecting
	// WebrtcPeerConnectionStateConnected: connected.
	WebrtcPeerConnectionStateConnected
	// WebrtcPeerConnectionStateDisconnected: disconnected.
	WebrtcPeerConnectionStateDisconnected
	// WebrtcPeerConnectionStateFailed: failed.
	WebrtcPeerConnectionStateFailed
	// WebrtcPeerConnectionStateClosed: closed.
	WebrtcPeerConnectionStateClosed
)

func marshalWebRTCPeerConnectionState(p uintptr) (interface{}, error) {
	return WebRTCPeerConnectionState(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WebRTCPeerConnectionState.
func (w WebRTCPeerConnectionState) String() string {
	switch w {
	case NewWebrtcPeerConnectionState:
		return "New"
	case WebrtcPeerConnectionStateConnecting:
		return "Connecting"
	case WebrtcPeerConnectionStateConnected:
		return "Connected"
	case WebrtcPeerConnectionStateDisconnected:
		return "Disconnected"
	case WebrtcPeerConnectionStateFailed:
		return "Failed"
	case WebrtcPeerConnectionStateClosed:
		return "Closed"
	default:
		return fmt.Sprintf("WebRTCPeerConnectionState(%d)", w)
	}
}

// WebRTCPriorityType: see
// <http://w3c.github.io/webrtc-pc/#dom-rtcprioritytype>.
type WebRTCPriorityType C.gint

const (
	// WebrtcPriorityTypeVeryLow: very-low.
	WebrtcPriorityTypeVeryLow WebRTCPriorityType = 1
	// WebrtcPriorityTypeLow: low.
	WebrtcPriorityTypeLow WebRTCPriorityType = 2
	// WebrtcPriorityTypeMedium: medium.
	WebrtcPriorityTypeMedium WebRTCPriorityType = 3
	// WebrtcPriorityTypeHigh: high.
	WebrtcPriorityTypeHigh WebRTCPriorityType = 4
)

func marshalWebRTCPriorityType(p uintptr) (interface{}, error) {
	return WebRTCPriorityType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WebRTCPriorityType.
func (w WebRTCPriorityType) String() string {
	switch w {
	case WebrtcPriorityTypeVeryLow:
		return "VeryLow"
	case WebrtcPriorityTypeLow:
		return "Low"
	case WebrtcPriorityTypeMedium:
		return "Medium"
	case WebrtcPriorityTypeHigh:
		return "High"
	default:
		return fmt.Sprintf("WebRTCPriorityType(%d)", w)
	}
}

type WebRTCRTPTransceiverDirection C.gint

const (
	// WebrtcRtpTransceiverDirectionNone: none.
	WebrtcRtpTransceiverDirectionNone WebRTCRTPTransceiverDirection = iota
	// WebrtcRtpTransceiverDirectionInactive: inactive.
	WebrtcRtpTransceiverDirectionInactive
	// WebrtcRtpTransceiverDirectionSendonly: sendonly.
	WebrtcRtpTransceiverDirectionSendonly
	// WebrtcRtpTransceiverDirectionRecvonly: recvonly.
	WebrtcRtpTransceiverDirectionRecvonly
	// WebrtcRtpTransceiverDirectionSendrecv: sendrecv.
	WebrtcRtpTransceiverDirectionSendrecv
)

func marshalWebRTCRTPTransceiverDirection(p uintptr) (interface{}, error) {
	return WebRTCRTPTransceiverDirection(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WebRTCRTPTransceiverDirection.
func (w WebRTCRTPTransceiverDirection) String() string {
	switch w {
	case WebrtcRtpTransceiverDirectionNone:
		return "None"
	case WebrtcRtpTransceiverDirectionInactive:
		return "Inactive"
	case WebrtcRtpTransceiverDirectionSendonly:
		return "Sendonly"
	case WebrtcRtpTransceiverDirectionRecvonly:
		return "Recvonly"
	case WebrtcRtpTransceiverDirectionSendrecv:
		return "Sendrecv"
	default:
		return fmt.Sprintf("WebRTCRTPTransceiverDirection(%d)", w)
	}
}

// WebRTCSCTPTransportState: see
// <http://w3c.github.io/webrtc-pc/#dom-rtcsctptransportstate>.
type WebRTCSCTPTransportState C.gint

const (
	// NewWebrtcSCTPTransportState: new.
	NewWebrtcSCTPTransportState WebRTCSCTPTransportState = iota
	// WebrtcSCTPTransportStateConnecting: connecting.
	WebrtcSCTPTransportStateConnecting
	// WebrtcSCTPTransportStateConnected: connected.
	WebrtcSCTPTransportStateConnected
	// WebrtcSCTPTransportStateClosed: closed.
	WebrtcSCTPTransportStateClosed
)

func marshalWebRTCSCTPTransportState(p uintptr) (interface{}, error) {
	return WebRTCSCTPTransportState(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WebRTCSCTPTransportState.
func (w WebRTCSCTPTransportState) String() string {
	switch w {
	case NewWebrtcSCTPTransportState:
		return "New"
	case WebrtcSCTPTransportStateConnecting:
		return "Connecting"
	case WebrtcSCTPTransportStateConnected:
		return "Connected"
	case WebrtcSCTPTransportStateClosed:
		return "Closed"
	default:
		return fmt.Sprintf("WebRTCSCTPTransportState(%d)", w)
	}
}

// WebRTCSDPType: see <http://w3c.github.io/webrtc-pc/#rtcsdptype>.
type WebRTCSDPType C.gint

const (
	// WebrtcSdpTypeOffer: offer.
	WebrtcSdpTypeOffer WebRTCSDPType = 1
	// WebrtcSdpTypePranswer: pranswer.
	WebrtcSdpTypePranswer WebRTCSDPType = 2
	// WebrtcSdpTypeAnswer: answer.
	WebrtcSdpTypeAnswer WebRTCSDPType = 3
	// WebrtcSdpTypeRollback: rollback.
	WebrtcSdpTypeRollback WebRTCSDPType = 4
)

func marshalWebRTCSDPType(p uintptr) (interface{}, error) {
	return WebRTCSDPType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WebRTCSDPType.
func (w WebRTCSDPType) String() string {
	switch w {
	case WebrtcSdpTypeOffer:
		return "Offer"
	case WebrtcSdpTypePranswer:
		return "Pranswer"
	case WebrtcSdpTypeAnswer:
		return "Answer"
	case WebrtcSdpTypeRollback:
		return "Rollback"
	default:
		return fmt.Sprintf("WebRTCSDPType(%d)", w)
	}
}

// The function takes the following parameters:
//
//   - typ: WebRTCSDPType.
//
// The function returns the following values:
//
//   - utf8: string representation of type or "unknown" when type is not
//     recognized.
func WebRTCSDPTypeToString(typ WebRTCSDPType) string {
	var _arg1 C.GstWebRTCSDPType // out
	var _cret *C.gchar           // in

	_arg1 = C.GstWebRTCSDPType(typ)

	_cret = C.gst_webrtc_sdp_type_to_string(_arg1)
	runtime.KeepAlive(typ)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// WebRTCSignalingState: see
// <http://w3c.github.io/webrtc-pc/#dom-rtcsignalingstate>.
type WebRTCSignalingState C.gint

const (
	// WebrtcSignalingStateStable: stable.
	WebrtcSignalingStateStable WebRTCSignalingState = iota
	// WebrtcSignalingStateClosed: closed.
	WebrtcSignalingStateClosed
	// WebrtcSignalingStateHaveLocalOffer: have-local-offer.
	WebrtcSignalingStateHaveLocalOffer
	// WebrtcSignalingStateHaveRemoteOffer: have-remote-offer.
	WebrtcSignalingStateHaveRemoteOffer
	// WebrtcSignalingStateHaveLocalPranswer: have-local-pranswer.
	WebrtcSignalingStateHaveLocalPranswer
	// WebrtcSignalingStateHaveRemotePranswer: have-remote-pranswer.
	WebrtcSignalingStateHaveRemotePranswer
)

func marshalWebRTCSignalingState(p uintptr) (interface{}, error) {
	return WebRTCSignalingState(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WebRTCSignalingState.
func (w WebRTCSignalingState) String() string {
	switch w {
	case WebrtcSignalingStateStable:
		return "Stable"
	case WebrtcSignalingStateClosed:
		return "Closed"
	case WebrtcSignalingStateHaveLocalOffer:
		return "HaveLocalOffer"
	case WebrtcSignalingStateHaveRemoteOffer:
		return "HaveRemoteOffer"
	case WebrtcSignalingStateHaveLocalPranswer:
		return "HaveLocalPranswer"
	case WebrtcSignalingStateHaveRemotePranswer:
		return "HaveRemotePranswer"
	default:
		return fmt.Sprintf("WebRTCSignalingState(%d)", w)
	}
}

// WebRTCStatsType: see <https://w3c.github.io/webrtc-stats/#dom-rtcstatstype>.
type WebRTCStatsType C.gint

const (
	// WebrtcStatsCodec: codec.
	WebrtcStatsCodec WebRTCStatsType = 1
	// WebrtcStatsInboundRtp: inbound-rtp.
	WebrtcStatsInboundRtp WebRTCStatsType = 2
	// WebrtcStatsOutboundRtp: outbound-rtp.
	WebrtcStatsOutboundRtp WebRTCStatsType = 3
	// WebrtcStatsRemoteInboundRtp: remote-inbound-rtp.
	WebrtcStatsRemoteInboundRtp WebRTCStatsType = 4
	// WebrtcStatsRemoteOutboundRtp: remote-outbound-rtp.
	WebrtcStatsRemoteOutboundRtp WebRTCStatsType = 5
	// WebrtcStatsCsrc: csrc.
	WebrtcStatsCsrc WebRTCStatsType = 6
	// WebrtcStatsPeerConnection: peer-connection.
	WebrtcStatsPeerConnection WebRTCStatsType = 7
	// WebrtcStatsDataChannel: data-channel.
	WebrtcStatsDataChannel WebRTCStatsType = 8
	// WebrtcStatsStream: stream.
	WebrtcStatsStream WebRTCStatsType = 9
	// WebrtcStatsTransport: transport.
	WebrtcStatsTransport WebRTCStatsType = 10
	// WebrtcStatsCandidatePair: candidate-pair.
	WebrtcStatsCandidatePair WebRTCStatsType = 11
	// WebrtcStatsLocalCandidate: local-candidate.
	WebrtcStatsLocalCandidate WebRTCStatsType = 12
	// WebrtcStatsRemoteCandidate: remote-candidate.
	WebrtcStatsRemoteCandidate WebRTCStatsType = 13
	// WebrtcStatsCertificate: certificate.
	WebrtcStatsCertificate WebRTCStatsType = 14
)

func marshalWebRTCStatsType(p uintptr) (interface{}, error) {
	return WebRTCStatsType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WebRTCStatsType.
func (w WebRTCStatsType) String() string {
	switch w {
	case WebrtcStatsCodec:
		return "Codec"
	case WebrtcStatsInboundRtp:
		return "InboundRtp"
	case WebrtcStatsOutboundRtp:
		return "OutboundRtp"
	case WebrtcStatsRemoteInboundRtp:
		return "RemoteInboundRtp"
	case WebrtcStatsRemoteOutboundRtp:
		return "RemoteOutboundRtp"
	case WebrtcStatsCsrc:
		return "Csrc"
	case WebrtcStatsPeerConnection:
		return "PeerConnection"
	case WebrtcStatsDataChannel:
		return "DataChannel"
	case WebrtcStatsStream:
		return "Stream"
	case WebrtcStatsTransport:
		return "Transport"
	case WebrtcStatsCandidatePair:
		return "CandidatePair"
	case WebrtcStatsLocalCandidate:
		return "LocalCandidate"
	case WebrtcStatsRemoteCandidate:
		return "RemoteCandidate"
	case WebrtcStatsCertificate:
		return "Certificate"
	default:
		return fmt.Sprintf("WebRTCStatsType(%d)", w)
	}
}

// WebRTCICEOnCandidateFunc: callback function to be triggered on discovery of a
// new candidate.
type WebRTCICEOnCandidateFunc func(ice WebRTCICEer, streamId uint, candidate string)

type WebRTCDTLSTransport struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*WebRTCDTLSTransport)(nil)
)

func wrapWebRTCDTLSTransport(obj *coreglib.Object) *WebRTCDTLSTransport {
	return &WebRTCDTLSTransport{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalWebRTCDTLSTransport(p uintptr) (interface{}, error) {
	return wrapWebRTCDTLSTransport(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

type WebRTCDataChannel struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*WebRTCDataChannel)(nil)
)

// WebRTCDataChanneller describes types inherited from class WebRTCDataChannel.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type WebRTCDataChanneller interface {
	coreglib.Objector
	baseWebRTCDataChannel() *WebRTCDataChannel
}

var _ WebRTCDataChanneller = (*WebRTCDataChannel)(nil)

func wrapWebRTCDataChannel(obj *coreglib.Object) *WebRTCDataChannel {
	return &WebRTCDataChannel{
		Object: obj,
	}
}

func marshalWebRTCDataChannel(p uintptr) (interface{}, error) {
	return wrapWebRTCDataChannel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (channel *WebRTCDataChannel) baseWebRTCDataChannel() *WebRTCDataChannel {
	return channel
}

// BaseWebRTCDataChannel returns the underlying base object.
func BaseWebRTCDataChannel(obj WebRTCDataChanneller) *WebRTCDataChannel {
	return obj.baseWebRTCDataChannel()
}

func (channel *WebRTCDataChannel) ConnectOnBufferedAmountLow(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(channel, "on-buffered-amount-low", false, unsafe.Pointer(C._gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnBufferedAmountLow), f)
}

func (channel *WebRTCDataChannel) ConnectOnClose(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(channel, "on-close", false, unsafe.Pointer(C._gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnClose), f)
}

func (channel *WebRTCDataChannel) ConnectOnError(f func(err error)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(channel, "on-error", false, unsafe.Pointer(C._gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnError), f)
}

func (channel *WebRTCDataChannel) ConnectOnMessageData(f func(data *glib.Bytes)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(channel, "on-message-data", false, unsafe.Pointer(C._gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnMessageData), f)
}

func (channel *WebRTCDataChannel) ConnectOnMessageString(f func(data string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(channel, "on-message-string", false, unsafe.Pointer(C._gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnMessageString), f)
}

func (channel *WebRTCDataChannel) ConnectOnOpen(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(channel, "on-open", false, unsafe.Pointer(C._gotk4_gstwebrtc1_WebRTCDataChannel_ConnectOnOpen), f)
}

// Close the channel.
func (channel *WebRTCDataChannel) Close() {
	var _arg0 *C.GstWebRTCDataChannel // out

	_arg0 = (*C.GstWebRTCDataChannel)(unsafe.Pointer(coreglib.InternObject(channel).Native()))

	C.gst_webrtc_data_channel_close(_arg0)
	runtime.KeepAlive(channel)
}

// SendData: send data as a data message over channel.
//
// The function takes the following parameters:
//
//   - data (optional) or NULL.
func (channel *WebRTCDataChannel) SendData(data *glib.Bytes) {
	var _arg0 *C.GstWebRTCDataChannel // out
	var _arg1 *C.GBytes               // out

	_arg0 = (*C.GstWebRTCDataChannel)(unsafe.Pointer(coreglib.InternObject(channel).Native()))
	if data != nil {
		_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(data)))
	}

	C.gst_webrtc_data_channel_send_data(_arg0, _arg1)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(data)
}

// SendDataFull: send data as a data message over channel.
//
// The function takes the following parameters:
//
//   - data (optional) or NULL.
func (channel *WebRTCDataChannel) SendDataFull(data *glib.Bytes) error {
	var _arg0 *C.GstWebRTCDataChannel // out
	var _arg1 *C.GBytes               // out
	var _cerr *C.GError               // in

	_arg0 = (*C.GstWebRTCDataChannel)(unsafe.Pointer(coreglib.InternObject(channel).Native()))
	if data != nil {
		_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(data)))
	}

	C.gst_webrtc_data_channel_send_data_full(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(data)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SendString: send str as a string message over channel.
//
// The function takes the following parameters:
//
//   - str (optional): string or NULL.
func (channel *WebRTCDataChannel) SendString(str string) {
	var _arg0 *C.GstWebRTCDataChannel // out
	var _arg1 *C.gchar                // out

	_arg0 = (*C.GstWebRTCDataChannel)(unsafe.Pointer(coreglib.InternObject(channel).Native()))
	if str != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gst_webrtc_data_channel_send_string(_arg0, _arg1)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(str)
}

// SendStringFull: send str as a string message over channel.
//
// The function takes the following parameters:
//
//   - str (optional): string or NULL.
func (channel *WebRTCDataChannel) SendStringFull(str string) error {
	var _arg0 *C.GstWebRTCDataChannel // out
	var _arg1 *C.gchar                // out
	var _cerr *C.GError               // in

	_arg0 = (*C.GstWebRTCDataChannel)(unsafe.Pointer(coreglib.InternObject(channel).Native()))
	if str != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gst_webrtc_data_channel_send_string_full(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(channel)
	runtime.KeepAlive(str)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// WebRTCICEOverrides contains methods that are overridable.
type WebRTCICEOverrides struct {
	// The function takes the following parameters:
	//
	//   - stream: WebRTCICEStream.
	//   - candidate: ICE candidate.
	//   - promise (optional) for task notifications (Since: 1.24).
	AddCandidate func(stream WebRTCICEStreamer, candidate string, promise *gst.Promise)
	// The function takes the following parameters:
	//
	//   - sessionId: session id.
	//
	// The function returns the following values:
	//
	//   - webRTCICEStream (optional) or NULL.
	AddStream func(sessionId uint) WebRTCICEStreamer
	// The function takes the following parameters:
	//
	//   - uri: URI of the TURN server.
	//
	// The function returns the following values:
	//
	//   - ok: FALSE on error, TRUE otherwise.
	AddTurnServer func(uri string) bool
	// The function takes the following parameters:
	//
	//   - stream: WebRTCICEStream.
	//   - component: WebRTCICEComponent.
	//
	// The function returns the following values:
	//
	//   - webRTCICETransport (optional) or NULL.
	FindTransport func(stream WebRTCICEStreamer, component WebRTCICEComponent) WebRTCICETransporter
	// The function takes the following parameters:
	//
	//   - stream: WebRTCICEStream.
	//
	// The function returns the following values:
	//
	//   - ok: FALSE on error, TRUE otherwise.
	GatherCandidates func(stream WebRTCICEStreamer) bool
	// HTTPProxy: get HTTP Proxy to be used when connecting to TURN server.
	//
	// The function returns the following values:
	//
	//   - utf8: URI of the HTTP proxy of the form
	//     http://[username:password@]hostname[:port][?alpn=<alpn>]
	//
	//     Get HTTP Proxy to be used when connecting to TURN server.
	HTTPProxy func() string
	// The function returns the following values:
	//
	//   - ok: TRUE if set as controller, FALSE otherwise.
	IsController func() bool
	// The function takes the following parameters:
	//
	//   - stream: WebRTCICEStream.
	//
	// The function returns the following values:
	//
	//   - localStats: pointer to WebRTCICECandidateStats for local candidate.
	//   - remoteStats: pointer to WebRTCICECandidateStats for remote candidate.
	//   - ok: FALSE on failure, otherwise local_stats remote_stats will be set.
	SelectedPair func(stream WebRTCICEStreamer) (localStats, remoteStats *WebRTCICECandidateStats, ok bool)
	// The function returns the following values:
	//
	//   - utf8 (optional): URI of the STUN sever.
	StunServer func() string
	// The function returns the following values:
	//
	//   - utf8 (optional): URI of the TURN sever.
	TurnServer func() string
	// The function takes the following parameters:
	//
	//   - forceRelay: TRUE to enable force relay.
	SetForceRelay func(forceRelay bool)
	// SetHTTPProxy: set HTTP Proxy to be used when connecting to TURN server.
	//
	// The function takes the following parameters:
	//
	//   - uri: URI of the HTTP proxy of the form
	//     http://[username:password@]hostname[:port][?alpn=<alpn>].
	SetHTTPProxy func(uri string)
	// The function takes the following parameters:
	//
	//   - controller: TRUE to set as controller.
	SetIsController func(controller bool)
	// The function takes the following parameters:
	//
	//   - stream: WebRTCICEStream.
	//   - ufrag: ICE username.
	//   - pwd: ICE password.
	//
	// The function returns the following values:
	//
	//   - ok: FALSE on error, TRUE otherwise.
	SetLocalCredentials func(stream WebRTCICEStreamer, ufrag, pwd string) bool
	// The function takes the following parameters:
	//
	//   - stream: WebRTCICEStream.
	//   - ufrag: ICE username.
	//   - pwd: ICE password.
	//
	// The function returns the following values:
	//
	//   - ok: FALSE on error, TRUE otherwise.
	SetRemoteCredentials func(stream WebRTCICEStreamer, ufrag, pwd string) bool
	// The function takes the following parameters:
	//
	//   - uri (optional): URI of the STUN server.
	SetStunServer func(uri string)
	// The function takes the following parameters:
	//
	//   - stream: WebRTCICEStream.
	//   - tos: toS to be set.
	SetTos func(stream WebRTCICEStreamer, tos uint)
	// The function takes the following parameters:
	//
	//   - uri (optional): URI of the TURN sever.
	SetTurnServer func(uri string)
}

func defaultWebRTCICEOverrides(v *WebRTCICE) WebRTCICEOverrides {
	return WebRTCICEOverrides{
		AddCandidate:         v.addCandidate,
		AddStream:            v.addStream,
		AddTurnServer:        v.addTurnServer,
		FindTransport:        v.findTransport,
		GatherCandidates:     v.gatherCandidates,
		HTTPProxy:            v.httpProxy,
		IsController:         v.isController,
		SelectedPair:         v.selectedPair,
		StunServer:           v.stunServer,
		TurnServer:           v.turnServer,
		SetForceRelay:        v.setForceRelay,
		SetHTTPProxy:         v.setHTTPProxy,
		SetIsController:      v.setIsController,
		SetLocalCredentials:  v.setLocalCredentials,
		SetRemoteCredentials: v.setRemoteCredentials,
		SetStunServer:        v.setStunServer,
		SetTos:               v.setTos,
		SetTurnServer:        v.setTurnServer,
	}
}

type WebRTCICE struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*WebRTCICE)(nil)
)

// WebRTCICEer describes types inherited from class WebRTCICE.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type WebRTCICEer interface {
	coreglib.Objector
	baseWebRTCICE() *WebRTCICE
}

var _ WebRTCICEer = (*WebRTCICE)(nil)

func init() {
	coreglib.RegisterClassInfo[*WebRTCICE, *WebRTCICEClass, WebRTCICEOverrides](
		GTypeWebRTCICE,
		initWebRTCICEClass,
		wrapWebRTCICE,
		defaultWebRTCICEOverrides,
	)
}

func initWebRTCICEClass(gclass unsafe.Pointer, overrides WebRTCICEOverrides, classInitFunc func(*WebRTCICEClass)) {
	pclass := (*C.GstWebRTCICEClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeWebRTCICE))))

	if overrides.AddCandidate != nil {
		pclass.add_candidate = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICEClass_add_candidate)
	}

	if overrides.AddStream != nil {
		pclass.add_stream = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICEClass_add_stream)
	}

	if overrides.AddTurnServer != nil {
		pclass.add_turn_server = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICEClass_add_turn_server)
	}

	if overrides.FindTransport != nil {
		pclass.find_transport = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICEClass_find_transport)
	}

	if overrides.GatherCandidates != nil {
		pclass.gather_candidates = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICEClass_gather_candidates)
	}

	if overrides.HTTPProxy != nil {
		pclass.get_http_proxy = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICEClass_get_http_proxy)
	}

	if overrides.IsController != nil {
		pclass.get_is_controller = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICEClass_get_is_controller)
	}

	if overrides.SelectedPair != nil {
		pclass.get_selected_pair = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICEClass_get_selected_pair)
	}

	if overrides.StunServer != nil {
		pclass.get_stun_server = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICEClass_get_stun_server)
	}

	if overrides.TurnServer != nil {
		pclass.get_turn_server = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICEClass_get_turn_server)
	}

	if overrides.SetForceRelay != nil {
		pclass.set_force_relay = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICEClass_set_force_relay)
	}

	if overrides.SetHTTPProxy != nil {
		pclass.set_http_proxy = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICEClass_set_http_proxy)
	}

	if overrides.SetIsController != nil {
		pclass.set_is_controller = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICEClass_set_is_controller)
	}

	if overrides.SetLocalCredentials != nil {
		pclass.set_local_credentials = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICEClass_set_local_credentials)
	}

	if overrides.SetRemoteCredentials != nil {
		pclass.set_remote_credentials = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICEClass_set_remote_credentials)
	}

	if overrides.SetStunServer != nil {
		pclass.set_stun_server = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICEClass_set_stun_server)
	}

	if overrides.SetTos != nil {
		pclass.set_tos = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICEClass_set_tos)
	}

	if overrides.SetTurnServer != nil {
		pclass.set_turn_server = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICEClass_set_turn_server)
	}

	if classInitFunc != nil {
		class := (*WebRTCICEClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapWebRTCICE(obj *coreglib.Object) *WebRTCICE {
	return &WebRTCICE{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalWebRTCICE(p uintptr) (interface{}, error) {
	return wrapWebRTCICE(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (ice *WebRTCICE) baseWebRTCICE() *WebRTCICE {
	return ice
}

// BaseWebRTCICE returns the underlying base object.
func BaseWebRTCICE(obj WebRTCICEer) *WebRTCICE {
	return obj.baseWebRTCICE()
}

// The function takes the following parameters:
//
//   - stream: WebRTCICEStream.
//   - candidate: ICE candidate.
//   - promise (optional) for task notifications (Since: 1.24).
func (ice *WebRTCICE) AddCandidate(stream WebRTCICEStreamer, candidate string, promise *gst.Promise) {
	var _arg0 *C.GstWebRTCICE       // out
	var _arg1 *C.GstWebRTCICEStream // out
	var _arg2 *C.gchar              // out
	var _arg3 *C.GstPromise         // out

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(candidate)))
	defer C.free(unsafe.Pointer(_arg2))
	if promise != nil {
		_arg3 = (*C.GstPromise)(gextras.StructNative(unsafe.Pointer(promise)))
	}

	C.gst_webrtc_ice_add_candidate(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(candidate)
	runtime.KeepAlive(promise)
}

// The function takes the following parameters:
//
//   - sessionId: session id.
//
// The function returns the following values:
//
//   - webRTCICEStream (optional) or NULL.
func (ice *WebRTCICE) AddStream(sessionId uint) WebRTCICEStreamer {
	var _arg0 *C.GstWebRTCICE       // out
	var _arg1 C.guint               // out
	var _cret *C.GstWebRTCICEStream // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = C.guint(sessionId)

	_cret = C.gst_webrtc_ice_add_stream(_arg0, _arg1)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(sessionId)

	var _webRTCICEStream WebRTCICEStreamer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(WebRTCICEStreamer)
				return ok
			})
			rv, ok := casted.(WebRTCICEStreamer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstwebrtc.WebRTCICEStreamer")
			}
			_webRTCICEStream = rv
		}
	}

	return _webRTCICEStream
}

// The function takes the following parameters:
//
//   - uri: URI of the TURN server.
//
// The function returns the following values:
//
//   - ok: FALSE on error, TRUE otherwise.
func (ice *WebRTCICE) AddTurnServer(uri string) bool {
	var _arg0 *C.GstWebRTCICE // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gst_webrtc_ice_add_turn_server(_arg0, _arg1)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(uri)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - stream: WebRTCICEStream.
//   - component: WebRTCICEComponent.
//
// The function returns the following values:
//
//   - webRTCICETransport (optional) or NULL.
func (ice *WebRTCICE) FindTransport(stream WebRTCICEStreamer, component WebRTCICEComponent) WebRTCICETransporter {
	var _arg0 *C.GstWebRTCICE          // out
	var _arg1 *C.GstWebRTCICEStream    // out
	var _arg2 C.GstWebRTCICEComponent  // out
	var _cret *C.GstWebRTCICETransport // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg2 = C.GstWebRTCICEComponent(component)

	_cret = C.gst_webrtc_ice_find_transport(_arg0, _arg1, _arg2)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(component)

	var _webRTCICETransport WebRTCICETransporter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(WebRTCICETransporter)
				return ok
			})
			rv, ok := casted.(WebRTCICETransporter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstwebrtc.WebRTCICETransporter")
			}
			_webRTCICETransport = rv
		}
	}

	return _webRTCICETransport
}

// The function takes the following parameters:
//
//   - stream: WebRTCICEStream.
//
// The function returns the following values:
//
//   - ok: FALSE on error, TRUE otherwise.
func (ice *WebRTCICE) GatherCandidates(stream WebRTCICEStreamer) bool {
	var _arg0 *C.GstWebRTCICE       // out
	var _arg1 *C.GstWebRTCICEStream // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.gst_webrtc_ice_gather_candidates(_arg0, _arg1)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function returns the following values:
//
//   - utf8: URI of the HTTP proxy of the form
//     http://[username:password@]hostname[:port][?alpn=<alpn>]
//
//     Get HTTP Proxy to be used when connecting to TURN server.
func (ice *WebRTCICE) HTTPProxy() string {
	var _arg0 *C.GstWebRTCICE // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))

	_cret = C.gst_webrtc_ice_get_http_proxy(_arg0)
	runtime.KeepAlive(ice)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// The function returns the following values:
//
//   - ok: TRUE if set as controller, FALSE otherwise.
func (ice *WebRTCICE) IsController() bool {
	var _arg0 *C.GstWebRTCICE // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))

	_cret = C.gst_webrtc_ice_get_is_controller(_arg0)
	runtime.KeepAlive(ice)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - stream: WebRTCICEStream.
//
// The function returns the following values:
//
//   - webRTCICECandidateStats: list of local candidates.
func (ice *WebRTCICE) LocalCandidates(stream WebRTCICEStreamer) []*WebRTCICECandidateStats {
	var _arg0 *C.GstWebRTCICE                // out
	var _arg1 *C.GstWebRTCICEStream          // out
	var _cret **C.GstWebRTCICECandidateStats // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.gst_webrtc_ice_get_local_candidates(_arg0, _arg1)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(stream)

	var _webRTCICECandidateStats []*WebRTCICECandidateStats // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.GstWebRTCICECandidateStats
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_webRTCICECandidateStats = make([]*WebRTCICECandidateStats, i)
		for i := range src {
			_webRTCICECandidateStats[i] = (*WebRTCICECandidateStats)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_webRTCICECandidateStats[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.gst_webrtc_ice_candidate_stats_free((*C.GstWebRTCICECandidateStats)(intern.C))
				},
			)
		}
	}

	return _webRTCICECandidateStats
}

// The function takes the following parameters:
//
//   - stream: WebRTCICEStream.
//
// The function returns the following values:
//
//   - webRTCICECandidateStats: list of remote candidates.
func (ice *WebRTCICE) RemoteCandidates(stream WebRTCICEStreamer) []*WebRTCICECandidateStats {
	var _arg0 *C.GstWebRTCICE                // out
	var _arg1 *C.GstWebRTCICEStream          // out
	var _cret **C.GstWebRTCICECandidateStats // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.gst_webrtc_ice_get_remote_candidates(_arg0, _arg1)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(stream)

	var _webRTCICECandidateStats []*WebRTCICECandidateStats // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.GstWebRTCICECandidateStats
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_webRTCICECandidateStats = make([]*WebRTCICECandidateStats, i)
		for i := range src {
			_webRTCICECandidateStats[i] = (*WebRTCICECandidateStats)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(_webRTCICECandidateStats[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.gst_webrtc_ice_candidate_stats_free((*C.GstWebRTCICECandidateStats)(intern.C))
				},
			)
		}
	}

	return _webRTCICECandidateStats
}

// The function takes the following parameters:
//
//   - stream: WebRTCICEStream.
//
// The function returns the following values:
//
//   - localStats: pointer to WebRTCICECandidateStats for local candidate.
//   - remoteStats: pointer to WebRTCICECandidateStats for remote candidate.
//   - ok: FALSE on failure, otherwise local_stats remote_stats will be set.
func (ice *WebRTCICE) SelectedPair(stream WebRTCICEStreamer) (localStats, remoteStats *WebRTCICECandidateStats, ok bool) {
	var _arg0 *C.GstWebRTCICE               // out
	var _arg1 *C.GstWebRTCICEStream         // out
	var _arg2 *C.GstWebRTCICECandidateStats // in
	var _arg3 *C.GstWebRTCICECandidateStats // in
	var _cret C.gboolean                    // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.gst_webrtc_ice_get_selected_pair(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(stream)

	var _localStats *WebRTCICECandidateStats  // out
	var _remoteStats *WebRTCICECandidateStats // out
	var _ok bool                              // out

	_localStats = (*WebRTCICECandidateStats)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_localStats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_webrtc_ice_candidate_stats_free((*C.GstWebRTCICECandidateStats)(intern.C))
		},
	)
	_remoteStats = (*WebRTCICECandidateStats)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_remoteStats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_webrtc_ice_candidate_stats_free((*C.GstWebRTCICECandidateStats)(intern.C))
		},
	)
	if _cret != 0 {
		_ok = true
	}

	return _localStats, _remoteStats, _ok
}

// The function returns the following values:
//
//   - utf8 (optional): URI of the STUN sever.
func (ice *WebRTCICE) StunServer() string {
	var _arg0 *C.GstWebRTCICE // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))

	_cret = C.gst_webrtc_ice_get_stun_server(_arg0)
	runtime.KeepAlive(ice)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// The function returns the following values:
//
//   - utf8 (optional): URI of the TURN sever.
func (ice *WebRTCICE) TurnServer() string {
	var _arg0 *C.GstWebRTCICE // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))

	_cret = C.gst_webrtc_ice_get_turn_server(_arg0)
	runtime.KeepAlive(ice)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// The function takes the following parameters:
//
//   - forceRelay: TRUE to enable force relay.
func (ice *WebRTCICE) SetForceRelay(forceRelay bool) {
	var _arg0 *C.GstWebRTCICE // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	if forceRelay {
		_arg1 = C.TRUE
	}

	C.gst_webrtc_ice_set_force_relay(_arg0, _arg1)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(forceRelay)
}

// SetHTTPProxy: set HTTP Proxy to be used when connecting to TURN server.
//
// The function takes the following parameters:
//
//   - uri: URI of the HTTP proxy of the form
//     http://[username:password@]hostname[:port][?alpn=<alpn>].
func (ice *WebRTCICE) SetHTTPProxy(uri string) {
	var _arg0 *C.GstWebRTCICE // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gst_webrtc_ice_set_http_proxy(_arg0, _arg1)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(uri)
}

// The function takes the following parameters:
//
//   - controller: TRUE to set as controller.
func (ice *WebRTCICE) SetIsController(controller bool) {
	var _arg0 *C.GstWebRTCICE // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	if controller {
		_arg1 = C.TRUE
	}

	C.gst_webrtc_ice_set_is_controller(_arg0, _arg1)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(controller)
}

// The function takes the following parameters:
//
//   - stream: WebRTCICEStream.
//   - ufrag: ICE username.
//   - pwd: ICE password.
//
// The function returns the following values:
//
//   - ok: FALSE on error, TRUE otherwise.
func (ice *WebRTCICE) SetLocalCredentials(stream WebRTCICEStreamer, ufrag, pwd string) bool {
	var _arg0 *C.GstWebRTCICE       // out
	var _arg1 *C.GstWebRTCICEStream // out
	var _arg2 *C.gchar              // out
	var _arg3 *C.gchar              // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(ufrag)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(pwd)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gst_webrtc_ice_set_local_credentials(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ufrag)
	runtime.KeepAlive(pwd)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - fn callback function.
func (ice *WebRTCICE) SetOnIceCandidate(fn WebRTCICEOnCandidateFunc) {
	var _arg0 *C.GstWebRTCICE               // out
	var _arg1 C.GstWebRTCICEOnCandidateFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICEOnCandidateFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.gst_webrtc_ice_set_on_ice_candidate(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(fn)
}

// The function takes the following parameters:
//
//   - stream: WebRTCICEStream.
//   - ufrag: ICE username.
//   - pwd: ICE password.
//
// The function returns the following values:
//
//   - ok: FALSE on error, TRUE otherwise.
func (ice *WebRTCICE) SetRemoteCredentials(stream WebRTCICEStreamer, ufrag, pwd string) bool {
	var _arg0 *C.GstWebRTCICE       // out
	var _arg1 *C.GstWebRTCICEStream // out
	var _arg2 *C.gchar              // out
	var _arg3 *C.gchar              // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(ufrag)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(pwd)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gst_webrtc_ice_set_remote_credentials(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ufrag)
	runtime.KeepAlive(pwd)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - uri (optional): URI of the STUN server.
func (ice *WebRTCICE) SetStunServer(uri string) {
	var _arg0 *C.GstWebRTCICE // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	if uri != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gst_webrtc_ice_set_stun_server(_arg0, _arg1)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(uri)
}

// The function takes the following parameters:
//
//   - stream: WebRTCICEStream.
//   - tos: toS to be set.
func (ice *WebRTCICE) SetTos(stream WebRTCICEStreamer, tos uint) {
	var _arg0 *C.GstWebRTCICE       // out
	var _arg1 *C.GstWebRTCICEStream // out
	var _arg2 C.guint               // out

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg2 = C.guint(tos)

	C.gst_webrtc_ice_set_tos(_arg0, _arg1, _arg2)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(tos)
}

// The function takes the following parameters:
//
//   - uri (optional): URI of the TURN sever.
func (ice *WebRTCICE) SetTurnServer(uri string) {
	var _arg0 *C.GstWebRTCICE // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	if uri != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gst_webrtc_ice_set_turn_server(_arg0, _arg1)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(uri)
}

// The function takes the following parameters:
//
//   - stream: WebRTCICEStream.
//   - candidate: ICE candidate.
//   - promise (optional) for task notifications (Since: 1.24).
func (ice *WebRTCICE) addCandidate(stream WebRTCICEStreamer, candidate string, promise *gst.Promise) {
	gclass := (*C.GstWebRTCICEClass)(coreglib.PeekParentClass(ice))
	fnarg := gclass.add_candidate

	var _arg0 *C.GstWebRTCICE       // out
	var _arg1 *C.GstWebRTCICEStream // out
	var _arg2 *C.gchar              // out
	var _arg3 *C.GstPromise         // out

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(candidate)))
	defer C.free(unsafe.Pointer(_arg2))
	if promise != nil {
		_arg3 = (*C.GstPromise)(gextras.StructNative(unsafe.Pointer(promise)))
	}

	C._gotk4_gstwebrtc1_WebRTCICE_virtual_add_candidate(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(candidate)
	runtime.KeepAlive(promise)
}

// The function takes the following parameters:
//
//   - sessionId: session id.
//
// The function returns the following values:
//
//   - webRTCICEStream (optional) or NULL.
func (ice *WebRTCICE) addStream(sessionId uint) WebRTCICEStreamer {
	gclass := (*C.GstWebRTCICEClass)(coreglib.PeekParentClass(ice))
	fnarg := gclass.add_stream

	var _arg0 *C.GstWebRTCICE       // out
	var _arg1 C.guint               // out
	var _cret *C.GstWebRTCICEStream // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = C.guint(sessionId)

	_cret = C._gotk4_gstwebrtc1_WebRTCICE_virtual_add_stream(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(sessionId)

	var _webRTCICEStream WebRTCICEStreamer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(WebRTCICEStreamer)
				return ok
			})
			rv, ok := casted.(WebRTCICEStreamer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstwebrtc.WebRTCICEStreamer")
			}
			_webRTCICEStream = rv
		}
	}

	return _webRTCICEStream
}

// The function takes the following parameters:
//
//   - uri: URI of the TURN server.
//
// The function returns the following values:
//
//   - ok: FALSE on error, TRUE otherwise.
func (ice *WebRTCICE) addTurnServer(uri string) bool {
	gclass := (*C.GstWebRTCICEClass)(coreglib.PeekParentClass(ice))
	fnarg := gclass.add_turn_server

	var _arg0 *C.GstWebRTCICE // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gstwebrtc1_WebRTCICE_virtual_add_turn_server(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(uri)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - stream: WebRTCICEStream.
//   - component: WebRTCICEComponent.
//
// The function returns the following values:
//
//   - webRTCICETransport (optional) or NULL.
func (ice *WebRTCICE) findTransport(stream WebRTCICEStreamer, component WebRTCICEComponent) WebRTCICETransporter {
	gclass := (*C.GstWebRTCICEClass)(coreglib.PeekParentClass(ice))
	fnarg := gclass.find_transport

	var _arg0 *C.GstWebRTCICE          // out
	var _arg1 *C.GstWebRTCICEStream    // out
	var _arg2 C.GstWebRTCICEComponent  // out
	var _cret *C.GstWebRTCICETransport // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg2 = C.GstWebRTCICEComponent(component)

	_cret = C._gotk4_gstwebrtc1_WebRTCICE_virtual_find_transport(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(component)

	var _webRTCICETransport WebRTCICETransporter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(WebRTCICETransporter)
				return ok
			})
			rv, ok := casted.(WebRTCICETransporter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstwebrtc.WebRTCICETransporter")
			}
			_webRTCICETransport = rv
		}
	}

	return _webRTCICETransport
}

// The function takes the following parameters:
//
//   - stream: WebRTCICEStream.
//
// The function returns the following values:
//
//   - ok: FALSE on error, TRUE otherwise.
func (ice *WebRTCICE) gatherCandidates(stream WebRTCICEStreamer) bool {
	gclass := (*C.GstWebRTCICEClass)(coreglib.PeekParentClass(ice))
	fnarg := gclass.gather_candidates

	var _arg0 *C.GstWebRTCICE       // out
	var _arg1 *C.GstWebRTCICEStream // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C._gotk4_gstwebrtc1_WebRTCICE_virtual_gather_candidates(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(stream)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// httpProxy: get HTTP Proxy to be used when connecting to TURN server.
//
// The function returns the following values:
//
//   - utf8: URI of the HTTP proxy of the form
//     http://[username:password@]hostname[:port][?alpn=<alpn>]
//
//     Get HTTP Proxy to be used when connecting to TURN server.
func (ice *WebRTCICE) httpProxy() string {
	gclass := (*C.GstWebRTCICEClass)(coreglib.PeekParentClass(ice))
	fnarg := gclass.get_http_proxy

	var _arg0 *C.GstWebRTCICE // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))

	_cret = C._gotk4_gstwebrtc1_WebRTCICE_virtual_get_http_proxy(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(ice)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// The function returns the following values:
//
//   - ok: TRUE if set as controller, FALSE otherwise.
func (ice *WebRTCICE) isController() bool {
	gclass := (*C.GstWebRTCICEClass)(coreglib.PeekParentClass(ice))
	fnarg := gclass.get_is_controller

	var _arg0 *C.GstWebRTCICE // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))

	_cret = C._gotk4_gstwebrtc1_WebRTCICE_virtual_get_is_controller(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(ice)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (ice *WebRTCICE) localCandidates(stream WebRTCICEStreamer) *WebRTCICECandidateStats {
	gclass := (*C.GstWebRTCICEClass)(coreglib.PeekParentClass(ice))
	fnarg := gclass.get_local_candidates

	var _arg0 *C.GstWebRTCICE                // out
	var _arg1 *C.GstWebRTCICEStream          // out
	var _cret **C.GstWebRTCICECandidateStats // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C._gotk4_gstwebrtc1_WebRTCICE_virtual_get_local_candidates(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(stream)

	var _webRTCICECandidateStats *WebRTCICECandidateStats // out

	_webRTCICECandidateStats = (*WebRTCICECandidateStats)(gextras.NewStructNative(unsafe.Pointer((*_cret))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_webRTCICECandidateStats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_webrtc_ice_candidate_stats_free((*C.GstWebRTCICECandidateStats)(intern.C))
		},
	)

	return _webRTCICECandidateStats
}

func (ice *WebRTCICE) remoteCandidates(stream WebRTCICEStreamer) *WebRTCICECandidateStats {
	gclass := (*C.GstWebRTCICEClass)(coreglib.PeekParentClass(ice))
	fnarg := gclass.get_remote_candidates

	var _arg0 *C.GstWebRTCICE                // out
	var _arg1 *C.GstWebRTCICEStream          // out
	var _cret **C.GstWebRTCICECandidateStats // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C._gotk4_gstwebrtc1_WebRTCICE_virtual_get_remote_candidates(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(stream)

	var _webRTCICECandidateStats *WebRTCICECandidateStats // out

	_webRTCICECandidateStats = (*WebRTCICECandidateStats)(gextras.NewStructNative(unsafe.Pointer((*_cret))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_webRTCICECandidateStats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_webrtc_ice_candidate_stats_free((*C.GstWebRTCICECandidateStats)(intern.C))
		},
	)

	return _webRTCICECandidateStats
}

// The function takes the following parameters:
//
//   - stream: WebRTCICEStream.
//
// The function returns the following values:
//
//   - localStats: pointer to WebRTCICECandidateStats for local candidate.
//   - remoteStats: pointer to WebRTCICECandidateStats for remote candidate.
//   - ok: FALSE on failure, otherwise local_stats remote_stats will be set.
func (ice *WebRTCICE) selectedPair(stream WebRTCICEStreamer) (localStats, remoteStats *WebRTCICECandidateStats, ok bool) {
	gclass := (*C.GstWebRTCICEClass)(coreglib.PeekParentClass(ice))
	fnarg := gclass.get_selected_pair

	var _arg0 *C.GstWebRTCICE               // out
	var _arg1 *C.GstWebRTCICEStream         // out
	var _arg2 *C.GstWebRTCICECandidateStats // in
	var _arg3 *C.GstWebRTCICECandidateStats // in
	var _cret C.gboolean                    // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C._gotk4_gstwebrtc1_WebRTCICE_virtual_get_selected_pair(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(stream)

	var _localStats *WebRTCICECandidateStats  // out
	var _remoteStats *WebRTCICECandidateStats // out
	var _ok bool                              // out

	_localStats = (*WebRTCICECandidateStats)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_localStats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_webrtc_ice_candidate_stats_free((*C.GstWebRTCICECandidateStats)(intern.C))
		},
	)
	_remoteStats = (*WebRTCICECandidateStats)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_remoteStats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_webrtc_ice_candidate_stats_free((*C.GstWebRTCICECandidateStats)(intern.C))
		},
	)
	if _cret != 0 {
		_ok = true
	}

	return _localStats, _remoteStats, _ok
}

// The function returns the following values:
//
//   - utf8 (optional): URI of the STUN sever.
func (ice *WebRTCICE) stunServer() string {
	gclass := (*C.GstWebRTCICEClass)(coreglib.PeekParentClass(ice))
	fnarg := gclass.get_stun_server

	var _arg0 *C.GstWebRTCICE // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))

	_cret = C._gotk4_gstwebrtc1_WebRTCICE_virtual_get_stun_server(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(ice)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// The function returns the following values:
//
//   - utf8 (optional): URI of the TURN sever.
func (ice *WebRTCICE) turnServer() string {
	gclass := (*C.GstWebRTCICEClass)(coreglib.PeekParentClass(ice))
	fnarg := gclass.get_turn_server

	var _arg0 *C.GstWebRTCICE // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))

	_cret = C._gotk4_gstwebrtc1_WebRTCICE_virtual_get_turn_server(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(ice)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// The function takes the following parameters:
//
//   - forceRelay: TRUE to enable force relay.
func (ice *WebRTCICE) setForceRelay(forceRelay bool) {
	gclass := (*C.GstWebRTCICEClass)(coreglib.PeekParentClass(ice))
	fnarg := gclass.set_force_relay

	var _arg0 *C.GstWebRTCICE // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	if forceRelay {
		_arg1 = C.TRUE
	}

	C._gotk4_gstwebrtc1_WebRTCICE_virtual_set_force_relay(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(forceRelay)
}

// setHTTPProxy: set HTTP Proxy to be used when connecting to TURN server.
//
// The function takes the following parameters:
//
//   - uri: URI of the HTTP proxy of the form
//     http://[username:password@]hostname[:port][?alpn=<alpn>].
func (ice *WebRTCICE) setHTTPProxy(uri string) {
	gclass := (*C.GstWebRTCICEClass)(coreglib.PeekParentClass(ice))
	fnarg := gclass.set_http_proxy

	var _arg0 *C.GstWebRTCICE // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gstwebrtc1_WebRTCICE_virtual_set_http_proxy(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(uri)
}

// The function takes the following parameters:
//
//   - controller: TRUE to set as controller.
func (ice *WebRTCICE) setIsController(controller bool) {
	gclass := (*C.GstWebRTCICEClass)(coreglib.PeekParentClass(ice))
	fnarg := gclass.set_is_controller

	var _arg0 *C.GstWebRTCICE // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	if controller {
		_arg1 = C.TRUE
	}

	C._gotk4_gstwebrtc1_WebRTCICE_virtual_set_is_controller(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(controller)
}

// The function takes the following parameters:
//
//   - stream: WebRTCICEStream.
//   - ufrag: ICE username.
//   - pwd: ICE password.
//
// The function returns the following values:
//
//   - ok: FALSE on error, TRUE otherwise.
func (ice *WebRTCICE) setLocalCredentials(stream WebRTCICEStreamer, ufrag, pwd string) bool {
	gclass := (*C.GstWebRTCICEClass)(coreglib.PeekParentClass(ice))
	fnarg := gclass.set_local_credentials

	var _arg0 *C.GstWebRTCICE       // out
	var _arg1 *C.GstWebRTCICEStream // out
	var _arg2 *C.gchar              // out
	var _arg3 *C.gchar              // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(ufrag)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(pwd)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C._gotk4_gstwebrtc1_WebRTCICE_virtual_set_local_credentials(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ufrag)
	runtime.KeepAlive(pwd)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - fn callback function.
func (ice *WebRTCICE) setOnIceCandidate(fn WebRTCICEOnCandidateFunc) {
	gclass := (*C.GstWebRTCICEClass)(coreglib.PeekParentClass(ice))
	fnarg := gclass.set_on_ice_candidate

	var _arg0 *C.GstWebRTCICE               // out
	var _arg1 C.GstWebRTCICEOnCandidateFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICEOnCandidateFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C._gotk4_gstwebrtc1_WebRTCICE_virtual_set_on_ice_candidate(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(fn)
}

// The function takes the following parameters:
//
//   - stream: WebRTCICEStream.
//   - ufrag: ICE username.
//   - pwd: ICE password.
//
// The function returns the following values:
//
//   - ok: FALSE on error, TRUE otherwise.
func (ice *WebRTCICE) setRemoteCredentials(stream WebRTCICEStreamer, ufrag, pwd string) bool {
	gclass := (*C.GstWebRTCICEClass)(coreglib.PeekParentClass(ice))
	fnarg := gclass.set_remote_credentials

	var _arg0 *C.GstWebRTCICE       // out
	var _arg1 *C.GstWebRTCICEStream // out
	var _arg2 *C.gchar              // out
	var _arg3 *C.gchar              // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(ufrag)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(pwd)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C._gotk4_gstwebrtc1_WebRTCICE_virtual_set_remote_credentials(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ufrag)
	runtime.KeepAlive(pwd)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - uri (optional): URI of the STUN server.
func (ice *WebRTCICE) setStunServer(uri string) {
	gclass := (*C.GstWebRTCICEClass)(coreglib.PeekParentClass(ice))
	fnarg := gclass.set_stun_server

	var _arg0 *C.GstWebRTCICE // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	if uri != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C._gotk4_gstwebrtc1_WebRTCICE_virtual_set_stun_server(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(uri)
}

// The function takes the following parameters:
//
//   - stream: WebRTCICEStream.
//   - tos: toS to be set.
func (ice *WebRTCICE) setTos(stream WebRTCICEStreamer, tos uint) {
	gclass := (*C.GstWebRTCICEClass)(coreglib.PeekParentClass(ice))
	fnarg := gclass.set_tos

	var _arg0 *C.GstWebRTCICE       // out
	var _arg1 *C.GstWebRTCICEStream // out
	var _arg2 C.guint               // out

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg2 = C.guint(tos)

	C._gotk4_gstwebrtc1_WebRTCICE_virtual_set_tos(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(tos)
}

// The function takes the following parameters:
//
//   - uri (optional): URI of the TURN sever.
func (ice *WebRTCICE) setTurnServer(uri string) {
	gclass := (*C.GstWebRTCICEClass)(coreglib.PeekParentClass(ice))
	fnarg := gclass.set_turn_server

	var _arg0 *C.GstWebRTCICE // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GstWebRTCICE)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	if uri != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C._gotk4_gstwebrtc1_WebRTCICE_virtual_set_turn_server(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(uri)
}

// WebRTCICEStreamOverrides contains methods that are overridable.
type WebRTCICEStreamOverrides struct {
	// The function takes the following parameters:
	//
	//   - component: WebRTCICEComponent.
	//
	// The function returns the following values:
	//
	//   - webRTCICETransport (optional) or NULL.
	FindTransport func(component WebRTCICEComponent) WebRTCICETransporter
	// The function returns the following values:
	//
	//   - ok: FALSE on error, TRUE otherwise.
	GatherCandidates func() bool
}

func defaultWebRTCICEStreamOverrides(v *WebRTCICEStream) WebRTCICEStreamOverrides {
	return WebRTCICEStreamOverrides{
		FindTransport:    v.findTransport,
		GatherCandidates: v.gatherCandidates,
	}
}

type WebRTCICEStream struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*WebRTCICEStream)(nil)
)

// WebRTCICEStreamer describes types inherited from class WebRTCICEStream.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type WebRTCICEStreamer interface {
	coreglib.Objector
	baseWebRTCICEStream() *WebRTCICEStream
}

var _ WebRTCICEStreamer = (*WebRTCICEStream)(nil)

func init() {
	coreglib.RegisterClassInfo[*WebRTCICEStream, *WebRTCICEStreamClass, WebRTCICEStreamOverrides](
		GTypeWebRTCICEStream,
		initWebRTCICEStreamClass,
		wrapWebRTCICEStream,
		defaultWebRTCICEStreamOverrides,
	)
}

func initWebRTCICEStreamClass(gclass unsafe.Pointer, overrides WebRTCICEStreamOverrides, classInitFunc func(*WebRTCICEStreamClass)) {
	pclass := (*C.GstWebRTCICEStreamClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeWebRTCICEStream))))

	if overrides.FindTransport != nil {
		pclass.find_transport = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICEStreamClass_find_transport)
	}

	if overrides.GatherCandidates != nil {
		pclass.gather_candidates = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICEStreamClass_gather_candidates)
	}

	if classInitFunc != nil {
		class := (*WebRTCICEStreamClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapWebRTCICEStream(obj *coreglib.Object) *WebRTCICEStream {
	return &WebRTCICEStream{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalWebRTCICEStream(p uintptr) (interface{}, error) {
	return wrapWebRTCICEStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (stream *WebRTCICEStream) baseWebRTCICEStream() *WebRTCICEStream {
	return stream
}

// BaseWebRTCICEStream returns the underlying base object.
func BaseWebRTCICEStream(obj WebRTCICEStreamer) *WebRTCICEStream {
	return obj.baseWebRTCICEStream()
}

// The function takes the following parameters:
//
//   - component: WebRTCICEComponent.
//
// The function returns the following values:
//
//   - webRTCICETransport (optional) or NULL.
func (stream *WebRTCICEStream) FindTransport(component WebRTCICEComponent) WebRTCICETransporter {
	var _arg0 *C.GstWebRTCICEStream    // out
	var _arg1 C.GstWebRTCICEComponent  // out
	var _cret *C.GstWebRTCICETransport // in

	_arg0 = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = C.GstWebRTCICEComponent(component)

	_cret = C.gst_webrtc_ice_stream_find_transport(_arg0, _arg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(component)

	var _webRTCICETransport WebRTCICETransporter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(WebRTCICETransporter)
				return ok
			})
			rv, ok := casted.(WebRTCICETransporter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstwebrtc.WebRTCICETransporter")
			}
			_webRTCICETransport = rv
		}
	}

	return _webRTCICETransport
}

// The function returns the following values:
//
//   - ok: FALSE on error, TRUE otherwise.
func (ice *WebRTCICEStream) GatherCandidates() bool {
	var _arg0 *C.GstWebRTCICEStream // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.InternObject(ice).Native()))

	_cret = C.gst_webrtc_ice_stream_gather_candidates(_arg0)
	runtime.KeepAlive(ice)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - component: WebRTCICEComponent.
//
// The function returns the following values:
//
//   - webRTCICETransport (optional) or NULL.
func (stream *WebRTCICEStream) findTransport(component WebRTCICEComponent) WebRTCICETransporter {
	gclass := (*C.GstWebRTCICEStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.find_transport

	var _arg0 *C.GstWebRTCICEStream    // out
	var _arg1 C.GstWebRTCICEComponent  // out
	var _cret *C.GstWebRTCICETransport // in

	_arg0 = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = C.GstWebRTCICEComponent(component)

	_cret = C._gotk4_gstwebrtc1_WebRTCICEStream_virtual_find_transport(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(component)

	var _webRTCICETransport WebRTCICETransporter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(WebRTCICETransporter)
				return ok
			})
			rv, ok := casted.(WebRTCICETransporter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gstwebrtc.WebRTCICETransporter")
			}
			_webRTCICETransport = rv
		}
	}

	return _webRTCICETransport
}

// The function returns the following values:
//
//   - ok: FALSE on error, TRUE otherwise.
func (ice *WebRTCICEStream) gatherCandidates() bool {
	gclass := (*C.GstWebRTCICEStreamClass)(coreglib.PeekParentClass(ice))
	fnarg := gclass.gather_candidates

	var _arg0 *C.GstWebRTCICEStream // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GstWebRTCICEStream)(unsafe.Pointer(coreglib.InternObject(ice).Native()))

	_cret = C._gotk4_gstwebrtc1_WebRTCICEStream_virtual_gather_candidates(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(ice)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WebRTCICETransportOverrides contains methods that are overridable.
type WebRTCICETransportOverrides struct {
	GatherCandidates func() bool
}

func defaultWebRTCICETransportOverrides(v *WebRTCICETransport) WebRTCICETransportOverrides {
	return WebRTCICETransportOverrides{
		GatherCandidates: v.gatherCandidates,
	}
}

type WebRTCICETransport struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*WebRTCICETransport)(nil)
)

// WebRTCICETransporter describes types inherited from class WebRTCICETransport.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type WebRTCICETransporter interface {
	coreglib.Objector
	baseWebRTCICETransport() *WebRTCICETransport
}

var _ WebRTCICETransporter = (*WebRTCICETransport)(nil)

func init() {
	coreglib.RegisterClassInfo[*WebRTCICETransport, *WebRTCICETransportClass, WebRTCICETransportOverrides](
		GTypeWebRTCICETransport,
		initWebRTCICETransportClass,
		wrapWebRTCICETransport,
		defaultWebRTCICETransportOverrides,
	)
}

func initWebRTCICETransportClass(gclass unsafe.Pointer, overrides WebRTCICETransportOverrides, classInitFunc func(*WebRTCICETransportClass)) {
	pclass := (*C.GstWebRTCICETransportClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeWebRTCICETransport))))

	if overrides.GatherCandidates != nil {
		pclass.gather_candidates = (*[0]byte)(C._gotk4_gstwebrtc1_WebRTCICETransportClass_gather_candidates)
	}

	if classInitFunc != nil {
		class := (*WebRTCICETransportClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapWebRTCICETransport(obj *coreglib.Object) *WebRTCICETransport {
	return &WebRTCICETransport{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalWebRTCICETransport(p uintptr) (interface{}, error) {
	return wrapWebRTCICETransport(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (ice *WebRTCICETransport) baseWebRTCICETransport() *WebRTCICETransport {
	return ice
}

// BaseWebRTCICETransport returns the underlying base object.
func BaseWebRTCICETransport(obj WebRTCICETransporter) *WebRTCICETransport {
	return obj.baseWebRTCICETransport()
}

func (ice *WebRTCICETransport) ConnectOnNewCandidate(f func(object string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(ice, "on-new-candidate", false, unsafe.Pointer(C._gotk4_gstwebrtc1_WebRTCICETransport_ConnectOnNewCandidate), f)
}

func (ice *WebRTCICETransport) ConnectOnSelectedCandidatePairChange(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(ice, "on-selected-candidate-pair-change", false, unsafe.Pointer(C._gotk4_gstwebrtc1_WebRTCICETransport_ConnectOnSelectedCandidatePairChange), f)
}

func (ice *WebRTCICETransport) ConnectionStateChange(newState WebRTCICEConnectionState) {
	var _arg0 *C.GstWebRTCICETransport      // out
	var _arg1 C.GstWebRTCICEConnectionState // out

	_arg0 = (*C.GstWebRTCICETransport)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = C.GstWebRTCICEConnectionState(newState)

	C.gst_webrtc_ice_transport_connection_state_change(_arg0, _arg1)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(newState)
}

func (ice *WebRTCICETransport) GatheringStateChange(newState WebRTCICEGatheringState) {
	var _arg0 *C.GstWebRTCICETransport     // out
	var _arg1 C.GstWebRTCICEGatheringState // out

	_arg0 = (*C.GstWebRTCICETransport)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = C.GstWebRTCICEGatheringState(newState)

	C.gst_webrtc_ice_transport_gathering_state_change(_arg0, _arg1)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(newState)
}

// The function takes the following parameters:
//
//   - streamId
//   - component
//   - attr
func (ice *WebRTCICETransport) NewCandidate(streamId uint, component WebRTCICEComponent, attr string) {
	var _arg0 *C.GstWebRTCICETransport // out
	var _arg1 C.guint                  // out
	var _arg2 C.GstWebRTCICEComponent  // out
	var _arg3 *C.gchar                 // out

	_arg0 = (*C.GstWebRTCICETransport)(unsafe.Pointer(coreglib.InternObject(ice).Native()))
	_arg1 = C.guint(streamId)
	_arg2 = C.GstWebRTCICEComponent(component)
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(attr)))
	defer C.free(unsafe.Pointer(_arg3))

	C.gst_webrtc_ice_transport_new_candidate(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(ice)
	runtime.KeepAlive(streamId)
	runtime.KeepAlive(component)
	runtime.KeepAlive(attr)
}

func (ice *WebRTCICETransport) SelectedPairChange() {
	var _arg0 *C.GstWebRTCICETransport // out

	_arg0 = (*C.GstWebRTCICETransport)(unsafe.Pointer(coreglib.InternObject(ice).Native()))

	C.gst_webrtc_ice_transport_selected_pair_change(_arg0)
	runtime.KeepAlive(ice)
}

func (transport *WebRTCICETransport) gatherCandidates() bool {
	gclass := (*C.GstWebRTCICETransportClass)(coreglib.PeekParentClass(transport))
	fnarg := gclass.gather_candidates

	var _arg0 *C.GstWebRTCICETransport // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GstWebRTCICETransport)(unsafe.Pointer(coreglib.InternObject(transport).Native()))

	_cret = C._gotk4_gstwebrtc1_WebRTCICETransport_virtual_gather_candidates(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(transport)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WebRTCRTPReceiver: object to track the receiving aspect of the stream
//
// Mostly matches the WebRTC RTCRtpReceiver interface.
type WebRTCRTPReceiver struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*WebRTCRTPReceiver)(nil)
)

func wrapWebRTCRTPReceiver(obj *coreglib.Object) *WebRTCRTPReceiver {
	return &WebRTCRTPReceiver{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalWebRTCRTPReceiver(p uintptr) (interface{}, error) {
	return wrapWebRTCRTPReceiver(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// WebRTCRTPSender: object to track the sending aspect of the stream
//
// Mostly matches the WebRTC RTCRtpSender interface.
type WebRTCRTPSender struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*WebRTCRTPSender)(nil)
)

func wrapWebRTCRTPSender(obj *coreglib.Object) *WebRTCRTPSender {
	return &WebRTCRTPSender{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalWebRTCRTPSender(p uintptr) (interface{}, error) {
	return wrapWebRTCRTPSender(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// SetPriority sets the content of the IPv4 Type of Service (ToS), also known as
// DSCP (Differentiated Services Code Point). This also sets the Traffic Class
// field of IPv6.
//
// The function takes the following parameters:
//
//   - priority of this sender.
func (sender *WebRTCRTPSender) SetPriority(priority WebRTCPriorityType) {
	var _arg0 *C.GstWebRTCRTPSender   // out
	var _arg1 C.GstWebRTCPriorityType // out

	_arg0 = (*C.GstWebRTCRTPSender)(unsafe.Pointer(coreglib.InternObject(sender).Native()))
	_arg1 = C.GstWebRTCPriorityType(priority)

	C.gst_webrtc_rtp_sender_set_priority(_arg0, _arg1)
	runtime.KeepAlive(sender)
	runtime.KeepAlive(priority)
}

// WebRTCRTPTransceiver: mostly matches the WebRTC RTCRtpTransceiver interface.
type WebRTCRTPTransceiver struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*WebRTCRTPTransceiver)(nil)
)

// WebRTCRTPTransceiverer describes types inherited from class WebRTCRTPTransceiver.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type WebRTCRTPTransceiverer interface {
	coreglib.Objector
	baseWebRTCRTPTransceiver() *WebRTCRTPTransceiver
}

var _ WebRTCRTPTransceiverer = (*WebRTCRTPTransceiver)(nil)

func wrapWebRTCRTPTransceiver(obj *coreglib.Object) *WebRTCRTPTransceiver {
	return &WebRTCRTPTransceiver{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalWebRTCRTPTransceiver(p uintptr) (interface{}, error) {
	return wrapWebRTCRTPTransceiver(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *WebRTCRTPTransceiver) baseWebRTCRTPTransceiver() *WebRTCRTPTransceiver {
	return v
}

// BaseWebRTCRTPTransceiver returns the underlying base object.
func BaseWebRTCRTPTransceiver(obj WebRTCRTPTransceiverer) *WebRTCRTPTransceiver {
	return obj.baseWebRTCRTPTransceiver()
}

type WebRTCSCTPTransport struct {
	_ [0]func() // equal guard
	gst.GstObject
}

var (
	_ gst.GstObjector = (*WebRTCSCTPTransport)(nil)
)

// WebRTCSCTPTransporter describes types inherited from class WebRTCSCTPTransport.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type WebRTCSCTPTransporter interface {
	coreglib.Objector
	baseWebRTCSCTPTransport() *WebRTCSCTPTransport
}

var _ WebRTCSCTPTransporter = (*WebRTCSCTPTransport)(nil)

func wrapWebRTCSCTPTransport(obj *coreglib.Object) *WebRTCSCTPTransport {
	return &WebRTCSCTPTransport{
		GstObject: gst.GstObject{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalWebRTCSCTPTransport(p uintptr) (interface{}, error) {
	return wrapWebRTCSCTPTransport(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *WebRTCSCTPTransport) baseWebRTCSCTPTransport() *WebRTCSCTPTransport {
	return v
}

// BaseWebRTCSCTPTransport returns the underlying base object.
func BaseWebRTCSCTPTransport(obj WebRTCSCTPTransporter) *WebRTCSCTPTransport {
	return obj.baseWebRTCSCTPTransport()
}

// WebRTCICECandidateStats: instance of this type is always passed by reference.
type WebRTCICECandidateStats struct {
	*webRTCICECandidateStats
}

// webRTCICECandidateStats is the struct that's finalized.
type webRTCICECandidateStats struct {
	native *C.GstWebRTCICECandidateStats
}

func marshalWebRTCICECandidateStats(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &WebRTCICECandidateStats{&webRTCICECandidateStats{(*C.GstWebRTCICECandidateStats)(b)}}, nil
}

func (w *WebRTCICECandidateStats) Ipaddr() string {
	valptr := &w.native.ipaddr
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

func (w *WebRTCICECandidateStats) Port() uint {
	valptr := &w.native.port
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

func (w *WebRTCICECandidateStats) StreamID() uint {
	valptr := &w.native.stream_id
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

func (w *WebRTCICECandidateStats) Type() string {
	valptr := &w.native._type
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

func (w *WebRTCICECandidateStats) Proto() string {
	valptr := &w.native.proto
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

func (w *WebRTCICECandidateStats) RelayProto() string {
	valptr := &w.native.relay_proto
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

func (w *WebRTCICECandidateStats) Prio() uint {
	valptr := &w.native.prio
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

func (w *WebRTCICECandidateStats) URL() string {
	valptr := &w.native.url
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

func (w *WebRTCICECandidateStats) GstReserved() [20]unsafe.Pointer {
	valptr := &w.native._gst_reserved
	var _v [20]unsafe.Pointer // out
	{
		src := &*valptr
		for i := 0; i < 20; i++ {
			_v[i] = (unsafe.Pointer)(unsafe.Pointer(src[i]))
		}
	}
	return _v
}

func (w *WebRTCICECandidateStats) SetPort(port uint) {
	valptr := &w.native.port
	*valptr = C.guint(port)
}

func (w *WebRTCICECandidateStats) SetStreamID(streamId uint) {
	valptr := &w.native.stream_id
	*valptr = C.guint(streamId)
}

func (w *WebRTCICECandidateStats) SetPrio(prio uint) {
	valptr := &w.native.prio
	*valptr = C.guint(prio)
}

// The function returns the following values:
//
//   - webRTCICECandidateStats: copy of stats.
func (stats *WebRTCICECandidateStats) Copy() *WebRTCICECandidateStats {
	var _arg0 *C.GstWebRTCICECandidateStats // out
	var _cret *C.GstWebRTCICECandidateStats // in

	_arg0 = (*C.GstWebRTCICECandidateStats)(gextras.StructNative(unsafe.Pointer(stats)))

	_cret = C.gst_webrtc_ice_candidate_stats_copy(_arg0)
	runtime.KeepAlive(stats)

	var _webRTCICECandidateStats *WebRTCICECandidateStats // out

	_webRTCICECandidateStats = (*WebRTCICECandidateStats)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_webRTCICECandidateStats)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_webrtc_ice_candidate_stats_free((*C.GstWebRTCICECandidateStats)(intern.C))
		},
	)

	return _webRTCICECandidateStats
}

// WebRTCICEClass: instance of this type is always passed by reference.
type WebRTCICEClass struct {
	*webRTCICEClass
}

// webRTCICEClass is the struct that's finalized.
type webRTCICEClass struct {
	native *C.GstWebRTCICEClass
}

func (w *WebRTCICEClass) ParentClass() *gst.ObjectClass {
	valptr := &w.native.parent_class
	var _v *gst.ObjectClass // out
	_v = (*gst.ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

func (w *WebRTCICEClass) GstReserved() [4]unsafe.Pointer {
	valptr := &w.native._gst_reserved
	var _v [4]unsafe.Pointer // out
	{
		src := &*valptr
		for i := 0; i < 4; i++ {
			_v[i] = (unsafe.Pointer)(unsafe.Pointer(src[i]))
		}
	}
	return _v
}

// WebRTCICEStreamClass: instance of this type is always passed by reference.
type WebRTCICEStreamClass struct {
	*webRTCICEStreamClass
}

// webRTCICEStreamClass is the struct that's finalized.
type webRTCICEStreamClass struct {
	native *C.GstWebRTCICEStreamClass
}

func (w *WebRTCICEStreamClass) ParentClass() *gst.ObjectClass {
	valptr := &w.native.parent_class
	var _v *gst.ObjectClass // out
	_v = (*gst.ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// WebRTCICETransportClass: instance of this type is always passed by reference.
type WebRTCICETransportClass struct {
	*webRTCICETransportClass
}

// webRTCICETransportClass is the struct that's finalized.
type webRTCICETransportClass struct {
	native *C.GstWebRTCICETransportClass
}

func (w *WebRTCICETransportClass) ParentClass() *gst.ObjectClass {
	valptr := &w.native.parent_class
	var _v *gst.ObjectClass // out
	_v = (*gst.ObjectClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

func (w *WebRTCICETransportClass) Padding() [4]unsafe.Pointer {
	valptr := &w.native._padding
	var _v [4]unsafe.Pointer // out
	{
		src := &*valptr
		for i := 0; i < 4; i++ {
			_v[i] = (unsafe.Pointer)(unsafe.Pointer(src[i]))
		}
	}
	return _v
}

// WebRTCSessionDescription: see
// <https://www.w3.org/TR/webrtc/#rtcsessiondescription-class>
//
// An instance of this type is always passed by reference.
type WebRTCSessionDescription struct {
	*webRTCSessionDescription
}

// webRTCSessionDescription is the struct that's finalized.
type webRTCSessionDescription struct {
	native *C.GstWebRTCSessionDescription
}

func marshalWebRTCSessionDescription(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &WebRTCSessionDescription{&webRTCSessionDescription{(*C.GstWebRTCSessionDescription)(b)}}, nil
}

// NewWebRTCSessionDescription constructs a struct WebRTCSessionDescription.
func NewWebRTCSessionDescription(typ WebRTCSDPType, sdp *gstsdp.SDPMessage) *WebRTCSessionDescription {
	var _arg1 C.GstWebRTCSDPType             // out
	var _arg2 *C.GstSDPMessage               // out
	var _cret *C.GstWebRTCSessionDescription // in

	_arg1 = C.GstWebRTCSDPType(typ)
	_arg2 = (*C.GstSDPMessage)(gextras.StructNative(unsafe.Pointer(sdp)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(sdp)), nil)

	_cret = C.gst_webrtc_session_description_new(_arg1, _arg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(sdp)

	var _webRTCSessionDescription *WebRTCSessionDescription // out

	_webRTCSessionDescription = (*WebRTCSessionDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_webRTCSessionDescription)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_webrtc_session_description_free((*C.GstWebRTCSessionDescription)(intern.C))
		},
	)

	return _webRTCSessionDescription
}

// Type of the description.
func (w *WebRTCSessionDescription) Type() WebRTCSDPType {
	valptr := &w.native._type
	var _v WebRTCSDPType // out
	_v = WebRTCSDPType(*valptr)
	return _v
}

// Sdp of the description.
func (w *WebRTCSessionDescription) Sdp() *gstsdp.SDPMessage {
	valptr := &w.native.sdp
	var _v *gstsdp.SDPMessage // out
	_v = (*gstsdp.SDPMessage)(gextras.NewStructNative(unsafe.Pointer(*valptr)))
	return _v
}

// The function returns the following values:
//
//   - webRTCSessionDescription: new copy of src.
func (src *WebRTCSessionDescription) Copy() *WebRTCSessionDescription {
	var _arg0 *C.GstWebRTCSessionDescription // out
	var _cret *C.GstWebRTCSessionDescription // in

	_arg0 = (*C.GstWebRTCSessionDescription)(gextras.StructNative(unsafe.Pointer(src)))

	_cret = C.gst_webrtc_session_description_copy(_arg0)
	runtime.KeepAlive(src)

	var _webRTCSessionDescription *WebRTCSessionDescription // out

	_webRTCSessionDescription = (*WebRTCSessionDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_webRTCSessionDescription)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gst_webrtc_session_description_free((*C.GstWebRTCSessionDescription)(intern.C))
		},
	)

	return _webRTCSessionDescription
}
